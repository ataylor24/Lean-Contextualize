[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":51},{"state":[],"start":52},{"state":[],"start":56},{"state":[],"start":111},{"state":[],"start":112},{"state":[],"start":208},{"state":[],"start":296},{"state":[],"start":391},{"state":[],"start":494},{"state":[],"start":495},{"state":[],"start":543},{"state":[],"start":544},{"state":[],"start":616},{"state":[],"start":672},{"state":[],"start":673},{"state":[],"start":697},{"state":[],"start":698},{"state":[],"start":842},{"state":[],"start":843},{"state":[],"start":860},{"state":[],"start":861},{"state":[],"start":864},{"state":[],"start":865},{"state":[],"start":866},{"state":[],"start":931},{"state":[],"start":995},{"state":[],"start":996},{"state":[],"start":1068},{"state":[],"start":1111},{"state":[],"start":1112},{"state":[],"start":1131},{"state":[],"start":1132},{"state":[],"start":1179},{"state":[],"start":1230},{"state":[],"start":1326},{"state":[],"start":1327},{"state":[],"start":1348},{"state":[],"start":1417},{"state":[],"start":1477},{"state":[],"start":1478},{"state":[],"start":1499},{"state":[],"start":1569},{"state":[],"start":1581},{"state":[],"start":1582},{"state":[],"start":1603},{"state":[],"start":1681},{"state":[],"start":1693},{"state":[],"start":1694},{"state":[],"start":1750},{"state":[],"start":1808},{"state":[],"start":1890},{"state":[],"start":1891},{"state":[],"start":1947},{"state":[],"start":2008},{"state":[],"start":2113},{"state":[],"start":2114},{"state":[],"start":2135},{"state":[],"start":2218},{"state":[],"start":2283},{"state":[],"start":2284},{"state":[],"start":2371},{"state":[],"start":2436},{"state":[],"start":2437},{"state":[],"start":2525},{"state":[],"start":2590},{"state":[],"start":2591},{"state":[],"start":2638},{"state":[],"start":2689},{"state":[],"start":2754},{"state":[],"start":2755},{"state":[],"start":2802},{"state":[],"start":2848},{"state":[],"start":2946},{"state":[],"start":2947},{"state":[],"start":2994},{"state":[{"type":"Equiv a b ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - b n| ≤ ε","tag":[],"mvarId":["_uniq",4307],"isProp":true,"context":[{"type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",4305],"binderInfo":"default"},{"type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",4306],"binderInfo":"default"}]}],"start":3111},{"state":[],"start":3119},{"state":[],"start":3120},{"state":[],"start":3145},{"state":[],"start":3176},{"state":[],"start":3266},{"state":[],"start":3325},{"state":[{"type":"Equiv (fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)) fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","tag":[],"mvarId":["_uniq",4797],"isProp":true,"context":[]}],"start":3419},{"state":[{"type":"Equiv a fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","tag":[],"mvarId":["_uniq",5107],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]}]}],"start":3468},{"state":[{"type":"Equiv a b","tag":[],"mvarId":["_uniq",5328],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]}]}],"start":3517},{"state":[{"type":"∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - b n| ≤ ε","tag":[],"mvarId":["_uniq",5359],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]}]}],"start":3534},{"state":[{"type":"∃ N, ∀ n ≥ N, |a n - b n| ≤ ε","tag":[],"mvarId":["_uniq",5370],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"}]}],"start":3549},{"state":[{"type":"∃ N, ∀ n ≥ N, |a n - b n| ≤ ε","tag":[],"mvarId":["_uniq",6551],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]}]}],"start":3614},{"state":[{"type":"∃ N, ∀ n ≥ N, |a n - b n| ≤ ε","tag":[],"mvarId":["_uniq",6551],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]}]}],"start":3701},{"state":[],"start":3751},{"state":[{"type":"∃ N, ∀ n ≥ N, |a n - b n| ≤ ε","tag":[],"mvarId":["_uniq",6551],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]}]}],"start":3794},{"state":[{"type":"∀ n ≥ N, |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","tag":[],"mvarId":["_uniq",12520],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",12148],"binderInfo":"default"}]}],"start":3872},{"state":[{"type":"∃ N, ∀ n ≥ N, |a n - b n| ≤ ε","tag":[],"mvarId":["_uniq",12526],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]}]}],"start":3917},{"state":[{"type":"∃ N, 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ ε","tag":[],"mvarId":["_uniq",19757],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]}]}],"start":3980},{"state":[{"type":"∃ N, 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ ε","tag":[],"mvarId":["_uniq",20400],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"value":"fun N =>\n  Trans.trans\n    (Eq.mpr\n      (id\n        (eq_div_iff._simp_1\n          (ne_of_gt\n            (pow_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                (Eq.refl (Nat.ble 1 10)))\n              (N + 1)))))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (HMul.hMul (2 * 10 ^ (-(↑N : ℤ) - 1)))\n                  (Eq.trans (equiv_example._simp_1 10 (N + 1))\n                    (congrArg (HPow.hPow 10)\n                      (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℤ)) Nat.cast_one)))))\n                (mul_assoc 2 (10 ^ (-(↑N : ℤ) - 1)) (10 ^ ((↑N : ℤ) + 1))))\n              (Eq.trans\n                (congrArg (HMul.hMul 2)\n                  (Eq.trans\n                    ((fun m n =>\n                        Eq.symm\n                          (zpow_add₀\n                            (have this :=\n                              Mathlib.Meta.NormNum.isNat_eq_false (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0)) (Eq.refl false);\n                            this)\n                            m n))\n                      (-(↑N : ℤ) - 1) ((↑N : ℤ) + 1))\n                    (Eq.trans\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans (sub_add_add_cancel (-(↑N : ℤ)) (↑N : ℤ) 1) (neg_add_cancel (↑N : ℤ))))\n                      (zpow_zero 10))))\n                (mul_one 2))))\n          (eq_self 2))))\n    (div_le_div₀\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n      (le_refl 2)\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n      (le_trans\n        (Eq.mpr\n          (eq_of_heq\n            ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n                Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n                  (fun h =>\n                    Eq.ndrec (motive := fun self' =>\n                      ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                      (fun e_2 h =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                              (fun e_3 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                      (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                                  (Eq.refl a'_1) (HEq.refl e'_4))\n                              (Eq.symm h) e'_3)\n                          (Eq.refl a') (HEq.refl e'_3))\n                      (Eq.symm h) e'_2)\n                  (Eq.refl self') (HEq.refl e'_2))\n              ℚ Rat.instPreorder.toLE Rat.instPartialOrder.toLE (Eq.refl Rat.instPreorder.toLE) ((↑N : ℚ) + 1)\n              (↑(N + 1) : ℚ)\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (Eq ((↑N : ℚ) + 1))\n                    (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℚ)) Nat.cast_one)))\n                  (eq_self ((↑N : ℚ) + 1))))\n              (2 ^ (N + 1)) (↑(2 ^ (N + 1)) : ℚ)\n              (of_eq_true (Eq.trans (congrArg (Eq (2 ^ (N + 1))) (Nat.cast_pow 2 (N + 1))) (eq_self (2 ^ (N + 1)))))))\n          (Nat.cast_le.mpr (Section_4_3.two_pow_geq (N + 1))))\n        (pow_le_pow_left₀\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl true);\n          this)\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true);\n          this)\n          (N + 1))))","type":"∀ (N : ℕ), 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ 2 / ((↑N : ℚ) + 1)","name":["hN'"],"isProp":true,"id":["_uniq",20398]}]}],"start":4049},{"state":[{"type":"2 * 10 ^ (-(↑N : ℤ) - 1) = 2 / 10 ^ (N + 1)","tag":[],"mvarId":["_uniq",20316],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",19763],"binderInfo":"default"}]}],"start":4084},{"state":[{"type":"2 * 10 ^ (-(↑N : ℤ) - 1) * 10 ^ (N + 1) = 2","tag":[],"mvarId":["_uniq",21921],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",19763],"binderInfo":"default"}]}],"start":4103},{"state":[],"start":4206},{"state":[{"type":"2 / 10 ^ (N + 1) ≤ 2 / ((↑N : ℚ) + 1)","tag":[],"mvarId":["_uniq",20327],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",19763],"binderInfo":"default"}]}],"start":4226},{"state":[{"type":"(↑N : ℚ) + 1 ≤ 10 ^ (N + 1)","tag":["hdb"],"mvarId":["_uniq",24341],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",19763],"binderInfo":"default"}]}],"start":4241},{"state":[{"type":"(↑N : ℚ) + 1 ≤ 2 ^ (N + 1)","tag":[],"mvarId":["_uniq",27774],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",19763],"binderInfo":"default"}]}],"start":4319},{"state":[{"type":"(↑N : ℚ) + 1 ≤ 2 ^ (N + 1)","tag":[],"mvarId":["_uniq",27774],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",19763],"binderInfo":"default"}]}],"start":4366},{"state":[{"type":"(↑N : ℚ) + 1 = (↑(N + 1) : ℚ)","tag":["h","e'_3"],"mvarId":["_uniq",30745],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",19763],"binderInfo":"default"}]},{"type":"2 ^ (N + 1) = (↑(2 ^ (N + 1)) : ℚ)","tag":["h","e'_4"],"mvarId":["_uniq",30746],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",19763],"binderInfo":"default"}]}],"start":4461},{"state":[{"type":"∃ N, 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ ε","tag":[],"mvarId":["_uniq",20400],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"value":"fun N =>\n  Trans.trans\n    (Eq.mpr\n      (id\n        (eq_div_iff._simp_1\n          (ne_of_gt\n            (pow_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                (Eq.refl (Nat.ble 1 10)))\n              (N + 1)))))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (HMul.hMul (2 * 10 ^ (-(↑N : ℤ) - 1)))\n                  (Eq.trans (equiv_example._simp_1 10 (N + 1))\n                    (congrArg (HPow.hPow 10)\n                      (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℤ)) Nat.cast_one)))))\n                (mul_assoc 2 (10 ^ (-(↑N : ℤ) - 1)) (10 ^ ((↑N : ℤ) + 1))))\n              (Eq.trans\n                (congrArg (HMul.hMul 2)\n                  (Eq.trans\n                    ((fun m n =>\n                        Eq.symm\n                          (zpow_add₀\n                            (have this :=\n                              Mathlib.Meta.NormNum.isNat_eq_false (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0)) (Eq.refl false);\n                            this)\n                            m n))\n                      (-(↑N : ℤ) - 1) ((↑N : ℤ) + 1))\n                    (Eq.trans\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans (sub_add_add_cancel (-(↑N : ℤ)) (↑N : ℤ) 1) (neg_add_cancel (↑N : ℤ))))\n                      (zpow_zero 10))))\n                (mul_one 2))))\n          (eq_self 2))))\n    (div_le_div₀\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n      (le_refl 2)\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n      (le_trans\n        (Eq.mpr\n          (eq_of_heq\n            ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n                Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n                  (fun h =>\n                    Eq.ndrec (motive := fun self' =>\n                      ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                      (fun e_2 h =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                              (fun e_3 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                      (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                                  (Eq.refl a'_1) (HEq.refl e'_4))\n                              (Eq.symm h) e'_3)\n                          (Eq.refl a') (HEq.refl e'_3))\n                      (Eq.symm h) e'_2)\n                  (Eq.refl self') (HEq.refl e'_2))\n              ℚ Rat.instPreorder.toLE Rat.instPartialOrder.toLE (Eq.refl Rat.instPreorder.toLE) ((↑N : ℚ) + 1)\n              (↑(N + 1) : ℚ)\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (Eq ((↑N : ℚ) + 1))\n                    (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℚ)) Nat.cast_one)))\n                  (eq_self ((↑N : ℚ) + 1))))\n              (2 ^ (N + 1)) (↑(2 ^ (N + 1)) : ℚ)\n              (of_eq_true (Eq.trans (congrArg (Eq (2 ^ (N + 1))) (Nat.cast_pow 2 (N + 1))) (eq_self (2 ^ (N + 1)))))))\n          (Nat.cast_le.mpr (Section_4_3.two_pow_geq (N + 1))))\n        (pow_le_pow_left₀\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl true);\n          this)\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true);\n          this)\n          (N + 1))))","type":"∀ (N : ℕ), 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ 2 / ((↑N : ℚ) + 1)","name":["hN'"],"isProp":true,"id":["_uniq",20398]}]}],"start":4484},{"state":[{"type":"∃ N, 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ ε","tag":[],"mvarId":["_uniq",32816],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"value":"fun N =>\n  Trans.trans\n    (Eq.mpr\n      (id\n        (eq_div_iff._simp_1\n          (ne_of_gt\n            (pow_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                (Eq.refl (Nat.ble 1 10)))\n              (N + 1)))))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (HMul.hMul (2 * 10 ^ (-(↑N : ℤ) - 1)))\n                  (Eq.trans (equiv_example._simp_1 10 (N + 1))\n                    (congrArg (HPow.hPow 10)\n                      (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℤ)) Nat.cast_one)))))\n                (mul_assoc 2 (10 ^ (-(↑N : ℤ) - 1)) (10 ^ ((↑N : ℤ) + 1))))\n              (Eq.trans\n                (congrArg (HMul.hMul 2)\n                  (Eq.trans\n                    ((fun m n =>\n                        Eq.symm\n                          (zpow_add₀\n                            (have this :=\n                              Mathlib.Meta.NormNum.isNat_eq_false (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0)) (Eq.refl false);\n                            this)\n                            m n))\n                      (-(↑N : ℤ) - 1) ((↑N : ℤ) + 1))\n                    (Eq.trans\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans (sub_add_add_cancel (-(↑N : ℤ)) (↑N : ℤ) 1) (neg_add_cancel (↑N : ℤ))))\n                      (zpow_zero 10))))\n                (mul_one 2))))\n          (eq_self 2))))\n    (div_le_div₀\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n      (le_refl 2)\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n      (le_trans\n        (Eq.mpr\n          (eq_of_heq\n            ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n                Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n                  (fun h =>\n                    Eq.ndrec (motive := fun self' =>\n                      ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                      (fun e_2 h =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                              (fun e_3 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                      (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                                  (Eq.refl a'_1) (HEq.refl e'_4))\n                              (Eq.symm h) e'_3)\n                          (Eq.refl a') (HEq.refl e'_3))\n                      (Eq.symm h) e'_2)\n                  (Eq.refl self') (HEq.refl e'_2))\n              ℚ Rat.instPreorder.toLE Rat.instPartialOrder.toLE (Eq.refl Rat.instPreorder.toLE) ((↑N : ℚ) + 1)\n              (↑(N + 1) : ℚ)\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (Eq ((↑N : ℚ) + 1))\n                    (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℚ)) Nat.cast_one)))\n                  (eq_self ((↑N : ℚ) + 1))))\n              (2 ^ (N + 1)) (↑(2 ^ (N + 1)) : ℚ)\n              (of_eq_true (Eq.trans (congrArg (Eq (2 ^ (N + 1))) (Nat.cast_pow 2 (N + 1))) (eq_self (2 ^ (N + 1)))))))\n          (Nat.cast_le.mpr (Section_4_3.two_pow_geq (N + 1))))\n        (pow_le_pow_left₀\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl true);\n          this)\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true);\n          this)\n          (N + 1))))","type":"∀ (N : ℕ), 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ 2 / ((↑N : ℚ) + 1)","name":["hN'"],"isProp":true,"id":["_uniq",20398]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",32812],"binderInfo":"default"},{"type":"2 / ε < (↑N : ℚ)","name":["hN"],"isProp":true,"id":["_uniq",32815],"binderInfo":"default"}]}],"start":4529},{"state":[{"type":"2 / ((↑N : ℚ) + 1) ≤ ε","tag":[],"mvarId":["_uniq",32849],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"value":"fun N =>\n  Trans.trans\n    (Eq.mpr\n      (id\n        (eq_div_iff._simp_1\n          (ne_of_gt\n            (pow_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                (Eq.refl (Nat.ble 1 10)))\n              (N + 1)))))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (HMul.hMul (2 * 10 ^ (-(↑N : ℤ) - 1)))\n                  (Eq.trans (equiv_example._simp_1 10 (N + 1))\n                    (congrArg (HPow.hPow 10)\n                      (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℤ)) Nat.cast_one)))))\n                (mul_assoc 2 (10 ^ (-(↑N : ℤ) - 1)) (10 ^ ((↑N : ℤ) + 1))))\n              (Eq.trans\n                (congrArg (HMul.hMul 2)\n                  (Eq.trans\n                    ((fun m n =>\n                        Eq.symm\n                          (zpow_add₀\n                            (have this :=\n                              Mathlib.Meta.NormNum.isNat_eq_false (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0)) (Eq.refl false);\n                            this)\n                            m n))\n                      (-(↑N : ℤ) - 1) ((↑N : ℤ) + 1))\n                    (Eq.trans\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans (sub_add_add_cancel (-(↑N : ℤ)) (↑N : ℤ) 1) (neg_add_cancel (↑N : ℤ))))\n                      (zpow_zero 10))))\n                (mul_one 2))))\n          (eq_self 2))))\n    (div_le_div₀\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n      (le_refl 2)\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n      (le_trans\n        (Eq.mpr\n          (eq_of_heq\n            ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n                Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n                  (fun h =>\n                    Eq.ndrec (motive := fun self' =>\n                      ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                      (fun e_2 h =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                              (fun e_3 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                      (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                                  (Eq.refl a'_1) (HEq.refl e'_4))\n                              (Eq.symm h) e'_3)\n                          (Eq.refl a') (HEq.refl e'_3))\n                      (Eq.symm h) e'_2)\n                  (Eq.refl self') (HEq.refl e'_2))\n              ℚ Rat.instPreorder.toLE Rat.instPartialOrder.toLE (Eq.refl Rat.instPreorder.toLE) ((↑N : ℚ) + 1)\n              (↑(N + 1) : ℚ)\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (Eq ((↑N : ℚ) + 1))\n                    (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℚ)) Nat.cast_one)))\n                  (eq_self ((↑N : ℚ) + 1))))\n              (2 ^ (N + 1)) (↑(2 ^ (N + 1)) : ℚ)\n              (of_eq_true (Eq.trans (congrArg (Eq (2 ^ (N + 1))) (Nat.cast_pow 2 (N + 1))) (eq_self (2 ^ (N + 1)))))))\n          (Nat.cast_le.mpr (Section_4_3.two_pow_geq (N + 1))))\n        (pow_le_pow_left₀\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl true);\n          this)\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true);\n          this)\n          (N + 1))))","type":"∀ (N : ℕ), 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ 2 / ((↑N : ℚ) + 1)","name":["hN'"],"isProp":true,"id":["_uniq",20398]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",32812],"binderInfo":"default"},{"type":"2 / ε < (↑N : ℚ)","name":["hN"],"isProp":true,"id":["_uniq",32815],"binderInfo":"default"}]}],"start":4568},{"state":[{"type":"2 ≤ ε * ((↑N : ℚ) + 1)","tag":[],"mvarId":["_uniq",33185],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"value":"fun N =>\n  Trans.trans\n    (Eq.mpr\n      (id\n        (eq_div_iff._simp_1\n          (ne_of_gt\n            (pow_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                (Eq.refl (Nat.ble 1 10)))\n              (N + 1)))))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (HMul.hMul (2 * 10 ^ (-(↑N : ℤ) - 1)))\n                  (Eq.trans (equiv_example._simp_1 10 (N + 1))\n                    (congrArg (HPow.hPow 10)\n                      (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℤ)) Nat.cast_one)))))\n                (mul_assoc 2 (10 ^ (-(↑N : ℤ) - 1)) (10 ^ ((↑N : ℤ) + 1))))\n              (Eq.trans\n                (congrArg (HMul.hMul 2)\n                  (Eq.trans\n                    ((fun m n =>\n                        Eq.symm\n                          (zpow_add₀\n                            (have this :=\n                              Mathlib.Meta.NormNum.isNat_eq_false (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0)) (Eq.refl false);\n                            this)\n                            m n))\n                      (-(↑N : ℤ) - 1) ((↑N : ℤ) + 1))\n                    (Eq.trans\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans (sub_add_add_cancel (-(↑N : ℤ)) (↑N : ℤ) 1) (neg_add_cancel (↑N : ℤ))))\n                      (zpow_zero 10))))\n                (mul_one 2))))\n          (eq_self 2))))\n    (div_le_div₀\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n      (le_refl 2)\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n      (le_trans\n        (Eq.mpr\n          (eq_of_heq\n            ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n                Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n                  (fun h =>\n                    Eq.ndrec (motive := fun self' =>\n                      ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                      (fun e_2 h =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                              (fun e_3 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                      (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                                  (Eq.refl a'_1) (HEq.refl e'_4))\n                              (Eq.symm h) e'_3)\n                          (Eq.refl a') (HEq.refl e'_3))\n                      (Eq.symm h) e'_2)\n                  (Eq.refl self') (HEq.refl e'_2))\n              ℚ Rat.instPreorder.toLE Rat.instPartialOrder.toLE (Eq.refl Rat.instPreorder.toLE) ((↑N : ℚ) + 1)\n              (↑(N + 1) : ℚ)\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (Eq ((↑N : ℚ) + 1))\n                    (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℚ)) Nat.cast_one)))\n                  (eq_self ((↑N : ℚ) + 1))))\n              (2 ^ (N + 1)) (↑(2 ^ (N + 1)) : ℚ)\n              (of_eq_true (Eq.trans (congrArg (Eq (2 ^ (N + 1))) (Nat.cast_pow 2 (N + 1))) (eq_self (2 ^ (N + 1)))))))\n          (Nat.cast_le.mpr (Section_4_3.two_pow_geq (N + 1))))\n        (pow_le_pow_left₀\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl true);\n          this)\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true);\n          this)\n          (N + 1))))","type":"∀ (N : ℕ), 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ 2 / ((↑N : ℚ) + 1)","name":["hN'"],"isProp":true,"id":["_uniq",20398]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",32812],"binderInfo":"default"},{"type":"2 / ε < (↑N : ℚ)","name":["hN"],"isProp":true,"id":["_uniq",32815],"binderInfo":"default"}]}],"start":4607},{"state":[{"type":"2 ≤ ε * ((↑N : ℚ) + 1)","tag":[],"mvarId":["_uniq",36470],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"value":"fun N =>\n  Trans.trans\n    (Eq.mpr\n      (id\n        (eq_div_iff._simp_1\n          (ne_of_gt\n            (pow_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                (Eq.refl (Nat.ble 1 10)))\n              (N + 1)))))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (HMul.hMul (2 * 10 ^ (-(↑N : ℤ) - 1)))\n                  (Eq.trans (equiv_example._simp_1 10 (N + 1))\n                    (congrArg (HPow.hPow 10)\n                      (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℤ)) Nat.cast_one)))))\n                (mul_assoc 2 (10 ^ (-(↑N : ℤ) - 1)) (10 ^ ((↑N : ℤ) + 1))))\n              (Eq.trans\n                (congrArg (HMul.hMul 2)\n                  (Eq.trans\n                    ((fun m n =>\n                        Eq.symm\n                          (zpow_add₀\n                            (have this :=\n                              Mathlib.Meta.NormNum.isNat_eq_false (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0)) (Eq.refl false);\n                            this)\n                            m n))\n                      (-(↑N : ℤ) - 1) ((↑N : ℤ) + 1))\n                    (Eq.trans\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans (sub_add_add_cancel (-(↑N : ℤ)) (↑N : ℤ) 1) (neg_add_cancel (↑N : ℤ))))\n                      (zpow_zero 10))))\n                (mul_one 2))))\n          (eq_self 2))))\n    (div_le_div₀\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n      (le_refl 2)\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n      (le_trans\n        (Eq.mpr\n          (eq_of_heq\n            ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n                Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n                  (fun h =>\n                    Eq.ndrec (motive := fun self' =>\n                      ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                      (fun e_2 h =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                              (fun e_3 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                      (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                                  (Eq.refl a'_1) (HEq.refl e'_4))\n                              (Eq.symm h) e'_3)\n                          (Eq.refl a') (HEq.refl e'_3))\n                      (Eq.symm h) e'_2)\n                  (Eq.refl self') (HEq.refl e'_2))\n              ℚ Rat.instPreorder.toLE Rat.instPartialOrder.toLE (Eq.refl Rat.instPreorder.toLE) ((↑N : ℚ) + 1)\n              (↑(N + 1) : ℚ)\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (Eq ((↑N : ℚ) + 1))\n                    (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℚ)) Nat.cast_one)))\n                  (eq_self ((↑N : ℚ) + 1))))\n              (2 ^ (N + 1)) (↑(2 ^ (N + 1)) : ℚ)\n              (of_eq_true (Eq.trans (congrArg (Eq (2 ^ (N + 1))) (Nat.cast_pow 2 (N + 1))) (eq_self (2 ^ (N + 1)))))))\n          (Nat.cast_le.mpr (Section_4_3.two_pow_geq (N + 1))))\n        (pow_le_pow_left₀\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl true);\n          this)\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true);\n          this)\n          (N + 1))))","type":"∀ (N : ℕ), 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ 2 / ((↑N : ℚ) + 1)","name":["hN'"],"isProp":true,"id":["_uniq",20398]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",32812],"binderInfo":"default"},{"type":"2 < (↑N : ℚ) * ε","name":["hN"],"isProp":true,"id":["_uniq",36467],"binderInfo":"default"}]}],"start":4640},{"state":[{"type":"∃ N, ∀ n ≥ N, |a n - b n| ≤ ε","tag":[],"mvarId":["_uniq",19759],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"value":"have hN' := fun N =>\n  Trans.trans\n    (Eq.mpr\n      (id\n        (eq_div_iff._simp_1\n          (ne_of_gt\n            (pow_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                (Eq.refl (Nat.ble 1 10)))\n              (N + 1)))))\n      (of_eq_true\n        (Eq.trans\n          (congrArg (fun x => x = 2)\n            (Eq.trans\n              (Eq.trans\n                (congrArg (HMul.hMul (2 * 10 ^ (-(↑N : ℤ) - 1)))\n                  (Eq.trans (equiv_example._simp_1 10 (N + 1))\n                    (congrArg (HPow.hPow 10)\n                      (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℤ)) Nat.cast_one)))))\n                (mul_assoc 2 (10 ^ (-(↑N : ℤ) - 1)) (10 ^ ((↑N : ℤ) + 1))))\n              (Eq.trans\n                (congrArg (HMul.hMul 2)\n                  (Eq.trans\n                    ((fun m n =>\n                        Eq.symm\n                          (zpow_add₀\n                            (have this :=\n                              Mathlib.Meta.NormNum.isNat_eq_false (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10))\n                                (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0)) (Eq.refl false);\n                            this)\n                            m n))\n                      (-(↑N : ℤ) - 1) ((↑N : ℤ) + 1))\n                    (Eq.trans\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans (sub_add_add_cancel (-(↑N : ℤ)) (↑N : ℤ) 1) (neg_add_cancel (↑N : ℤ))))\n                      (zpow_zero 10))))\n                (mul_one 2))))\n          (eq_self 2))))\n    (div_le_div₀\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl (Nat.ble 1 2))))\n      (le_refl 2)\n      (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1))))\n      (le_trans\n        (Eq.mpr\n          (eq_of_heq\n            ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n                Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n                  (fun h =>\n                    Eq.ndrec (motive := fun self' =>\n                      ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                      (fun e_2 h =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                              (fun e_3 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                      (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                                  (Eq.refl a'_1) (HEq.refl e'_4))\n                              (Eq.symm h) e'_3)\n                          (Eq.refl a') (HEq.refl e'_3))\n                      (Eq.symm h) e'_2)\n                  (Eq.refl self') (HEq.refl e'_2))\n              ℚ Rat.instPreorder.toLE Rat.instPartialOrder.toLE (Eq.refl Rat.instPreorder.toLE) ((↑N : ℚ) + 1)\n              (↑(N + 1) : ℚ)\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (Eq ((↑N : ℚ) + 1))\n                    (Eq.trans (Nat.cast_add N 1) (congrArg (HAdd.hAdd (↑N : ℚ)) Nat.cast_one)))\n                  (eq_self ((↑N : ℚ) + 1))))\n              (2 ^ (N + 1)) (↑(2 ^ (N + 1)) : ℚ)\n              (of_eq_true (Eq.trans (congrArg (Eq (2 ^ (N + 1))) (Nat.cast_pow 2 (N + 1))) (eq_self (2 ^ (N + 1)))))))\n          (Nat.cast_le.mpr (Section_4_3.two_pow_geq (N + 1))))\n        (pow_le_pow_left₀\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2)) (Eq.refl true);\n          this)\n          (have this :=\n            Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true);\n          this)\n          (N + 1))));\n(fun N hN =>\n    Exists.intro N\n      (LE.le.trans (hN' N)\n        (Eq.mpr\n          (id\n            (congrArg (fun _a => _a)\n              (propext\n                (div_le_iff₀\n                  (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' N)\n                    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n                      (Eq.refl (Nat.ble 1 1))))))))\n          (equiv_example._proof_1 ε hε hab hab' hN' N\n            (Eq.mp (congrArg (fun _a => _a) (propext (div_lt_iff₀ hε))) hN)))))\n  (Classical.choose (exists_nat_gt (2 / ε))) (Classical.choose_spec (exists_nat_gt (2 / ε)))","type":"∃ N, 2 * 10 ^ (-(↑N : ℤ) - 1) ≤ ε","name":["hN"],"isProp":true,"id":["_uniq",19758]}]}],"start":4661},{"state":[{"type":"|a n - b n| ≤ ε","tag":["h"],"mvarId":["_uniq",40404],"isProp":true,"context":[{"value":"fun n => 1 + 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["a"],"isProp":false,"id":["_uniq",5075]},{"value":"fun n => 1 - 10 ^ (-(↑n : ℤ) - 1)","type":"ℕ → ℚ","name":["b"],"isProp":false,"id":["_uniq",5310]},{"type":"ℚ","name":["ε"],"isProp":false,"id":["_uniq",5366],"binderInfo":"default"},{"type":"ε > 0","name":["hε"],"isProp":true,"id":["_uniq",5369],"binderInfo":"default"},{"value":"fun n =>\n  Trans.trans\n    (Trans.trans rfl\n      (of_eq_true\n        (Eq.trans\n          (congr\n            (congrArg (fun x => Eq |x|)\n              (Eq.trans\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                        ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf'\n                      (congrArg (HPow.hPow 10)\n                        (Eq.trans\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.neg_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                  ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Eq.trans\n                            (congr\n                              (congrArg HAdd.hAdd\n                                (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                  (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                              (Eq.trans\n                                (congrArg (fun x => x + 0)\n                                  (Eq.trans\n                                    (Eq.trans\n                                      (congr\n                                        (congrArg HMul.hMul\n                                          (Eq.trans (congrArg (HPow.hPow (↑n : ℤ)) Mathlib.Tactic.RingNF.nat_rawCast_1)\n                                            (pow_one (↑n : ℤ))))\n                                        (Eq.trans Mathlib.Tactic.RingNF.int_rawCast_neg\n                                          (congrArg Neg.neg Mathlib.Tactic.RingNF.nat_rawCast_1)))\n                                      (Mathlib.Tactic.RingNF.mul_neg (↑n : ℤ) 1))\n                                    (congrArg Neg.neg (mul_one (↑n : ℤ)))))\n                                (add_zero (-(↑n : ℤ)))))\n                            (Mathlib.Tactic.RingNF.add_neg (-1) (↑n : ℤ))))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (10 ^ (-1 - (↑n : ℤ))) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℚ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℚ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((10 ^ (-1 - (↑n : ℤ))) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq (Mathlib.Meta.NormNum.isInt_mul ⋯ ⋯ ⋯ ⋯)))\n                      ⋯)\n                    ⋯))\n                ⋯))\n            ⋯)\n          ⋯)))\n    ⋯","type":"∀ (n : ℕ), |a n - b n| = 2 * 10 ^ (-(↑n : ℤ) - 1)","name":["hab"],"isProp":true,"id":["_uniq",6550]},{"value":"fun N n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)) (hab n)))\n    (mul_le_mul_of_nonneg_left\n      (zpow_le_zpow_right₀\n        (Mathlib.Meta.NormNum.isNat_le_true (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 1))\n          (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 10)) (Eq.refl true))\n        (sub_le_sub_right (neg_le_neg (GCongr.natCast_le_natCast hn)) 1))\n      (le_of_lt\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℚ (Eq.refl 2))\n          (Eq.refl (Nat.ble 1 2)))))","type":"∀ (N n : ℕ), n ≥ N → |a n - b n| ≤ 2 * 10 ^ (-(↑N : ℤ) - 1)","name":["hab'"],"isProp":true,"id":["_uniq",12522]},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",40329],"binderInfo":"default"},{"type":"2 * 10 ^ (-(↑N : ℤ) - 1) ≤ ε","name":["hN"],"isProp":true,"id":["_uniq",40333],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",40400],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",40403],"binderInfo":"default"}]}],"start":4703},{"state":[],"start":4728},{"state":[],"start":4729},{"state":[],"start":4751},{"state":[],"start":4824},{"state":[],"start":4888},{"state":[],"start":4889},{"state":[],"start":4911},{"state":[],"start":5017},{"state":[],"start":5083},{"state":[],"start":5084},{"state":[],"start":5097},{"state":[],"start":5097}]
