[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":79},{"state":[],"start":108},{"state":[],"start":109},{"state":[],"start":113},{"state":[],"start":159},{"state":[],"start":160},{"state":[],"start":256},{"state":[],"start":345},{"state":[],"start":437},{"state":[],"start":534},{"state":[],"start":544},{"state":[],"start":545},{"state":[],"start":593},{"state":[],"start":614},{"state":[],"start":615},{"state":[],"start":618},{"state":[],"start":619},{"state":[],"start":633},{"state":[],"start":653},{"state":[],"start":654},{"state":[],"start":720},{"state":[],"start":814},{"state":[],"start":881},{"state":[],"start":973},{"state":[],"start":1058},{"state":[],"start":1146},{"state":[{"type":"(∃ δ > 0, ∀ x ∈ X \\ {x₀} ∩ Set.Ioo (x₀ - δ) (x₀ + δ), g x ≠ 0) ∧\n  Filter.Tendsto (fun x => f x / g x) (nhdsWithin x₀ (X \\ {x₀})) (nhds (f'x₀ / g'x₀))","tag":[],"mvarId":["_uniq",2724],"isProp":true,"context":[{"type":"Set ℝ","name":["X"],"isProp":false,"id":["_uniq",2713],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",2714],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",2715],"binderInfo":"implicit"},{"type":"ℝ","name":["x₀"],"isProp":false,"id":["_uniq",2716],"binderInfo":"implicit"},{"type":"ℝ","name":["f'x₀"],"isProp":false,"id":["_uniq",2717],"binderInfo":"implicit"},{"type":"ℝ","name":["g'x₀"],"isProp":false,"id":["_uniq",2718],"binderInfo":"implicit"},{"type":"f x₀ = 0","name":["hfx₀"],"isProp":true,"id":["_uniq",2719],"binderInfo":"default"},{"type":"g x₀ = 0","name":["hgx₀"],"isProp":true,"id":["_uniq",2720],"binderInfo":"default"},{"type":"g'x₀ ≠ 0","name":["hg_non"],"isProp":true,"id":["_uniq",2721],"binderInfo":"default"},{"type":"HasDerivWithinAt f f'x₀ X x₀","name":["hf'x₀"],"isProp":true,"id":["_uniq",2722],"binderInfo":"default"},{"type":"HasDerivWithinAt g g'x₀ X x₀","name":["hg'x₀"],"isProp":true,"id":["_uniq",2723],"binderInfo":"default"}]}],"start":1154},{"state":[],"start":1162},{"state":[],"start":1163},{"state":[],"start":1213},{"state":[],"start":1301},{"state":[],"start":1383},{"state":[],"start":1459},{"state":[],"start":1534},{"state":[],"start":1615},{"state":[],"start":1656},{"state":[{"type":"(∀ x ∈ Set.Ioc a b, g x ≠ 0) ∧ Filter.Tendsto (fun x => f x / g x) (nhdsWithin a (Set.Ioc a b)) (nhds L)","tag":[],"mvarId":["_uniq",4289],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"}]}],"start":1729},{"state":[{"type":"(∀ x ∈ Set.Ioc a b, g x ≠ 0) ∧ Filter.Tendsto (fun x => f x / g x) (nhdsWithin a (Set.Ioc a b)) (nhds L)","tag":[],"mvarId":["_uniq",4289],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"}]}],"start":1802},{"state":[{"type":"(∀ x ∈ Set.Ioc a b, g x ≠ 0) ∧ Filter.Tendsto (fun x => f x / g x) (nhdsWithin a (Set.Ioc a b)) (nhds L)","tag":[],"mvarId":["_uniq",55944],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"}]}],"start":1846},{"state":[{"type":"(∀ x ∈ Set.Ioc a b, g x ≠ 0) ∧ Filter.Tendsto (fun x => f x / g x) (nhdsWithin a (Set.Ioc a b)) (nhds L)","tag":[],"mvarId":["_uniq",57489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"}]}],"start":1890},{"state":[{"type":"g x ≠ 0","tag":[],"mvarId":["_uniq",57674],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"x ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",57629],"binderInfo":"default"}]}],"start":1947},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",57687],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"x ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",57629],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"}]}],"start":1966},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",59715],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":1981},{"state":[{"type":"False","tag":["refine_4"],"mvarId":["_uniq",60004],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"value":"HasDerivWithinAt.exist_zero hx.left (ContinuousOn.mono hgcon ?refine_1) (DifferentiableOn.mono hg ?refine_2) ?refine_3","type":"∃ x_1 ∈ Set.Ioo a x, HasDerivWithinAt g 0 (Set.Ioo a x) x_1","name":["this"],"isProp":true,"id":["_uniq",60003]}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2058},{"state":[{"type":"False","tag":["refine_4"],"mvarId":["_uniq",61724],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2101},{"state":[{"type":"False","tag":["refine_4","refine_2"],"mvarId":["_uniq",61848],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"},{"value":"?refine_4.refine_1","type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",61847]}]},{"type":"y ∈ Set.Icc a b","tag":["refine_4","refine_1"],"mvarId":["_uniq",61846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2136},{"state":[{"type":"False","tag":["refine_4","refine_2"],"mvarId":["_uniq",61856],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"},{"value":"?refine_4.refine_1","type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",61847]},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",61853],"binderInfo":"default"}]},{"type":"y ∈ Set.Icc a b","tag":["refine_4","refine_1"],"mvarId":["_uniq",61846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2164},{"state":[{"type":"False","tag":["refine_4","refine_2"],"mvarId":["_uniq",62016],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"type":"DifferentiableWithinAt ℝ g (Set.Icc a b) y","name":["hg"],"isProp":true,"id":["_uniq",62013],"binderInfo":"default"}]},{"type":"y ∈ Set.Icc a b","tag":["refine_4","refine_1"],"mvarId":["_uniq",61846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2226},{"state":[{"type":"HasDerivWithinAt g (g' y) (Set.Ioo a x) y","tag":[],"mvarId":["_uniq",63115],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"type":"DifferentiableWithinAt ℝ g (Set.Icc a b) y","name":["hg"],"isProp":true,"id":["_uniq",62013],"binderInfo":"default"}]}],"start":2288},{"state":[{"type":"False","tag":["refine_4","refine_2"],"mvarId":["_uniq",66108],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n  (HasDerivWithinAt.mono (DifferentiableWithinAt.hasDerivWithinAt _fvar.62013)\n    (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this✝ hx y hgy hy this hgnon _fvar.62013))","type":"HasDerivWithinAt g (g' y) (Set.Ioo a x) y","name":["hg"],"isProp":true,"id":["_uniq",63116]}]},{"type":"y ∈ Set.Icc a b","tag":["refine_4","refine_1"],"mvarId":["_uniq",61846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2342},{"state":[{"type":"False","tag":["refine_4","refine_2","refine_2"],"mvarId":["_uniq",66134],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n  (HasDerivWithinAt.mono (DifferentiableWithinAt.hasDerivWithinAt _fvar.62013)\n    (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this✝ hx y hgy hy this hgnon _fvar.62013))","type":"HasDerivWithinAt g (g' y) (Set.Ioo a x) y","name":["hg"],"isProp":true,"id":["_uniq",63116]},{"value":"derivative_unique ?refine_4.refine_2.refine_1 hg hgy","type":"g' y = 0","name":["hd"],"isProp":true,"id":["_uniq",66133]}]},{"type":"ClusterPt y (Filter.principal (Set.Ioo a x \\ {y}))","tag":["refine_4","refine_2","refine_1"],"mvarId":["_uniq",66113],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n  (HasDerivWithinAt.mono (DifferentiableWithinAt.hasDerivWithinAt _fvar.62013)\n    (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this✝ hx y hgy hy this hgnon _fvar.62013))","type":"HasDerivWithinAt g (g' y) (Set.Ioo a x) y","name":["hg"],"isProp":true,"id":["_uniq",63116]}]},{"type":"y ∈ Set.Icc a b","tag":["refine_4","refine_1"],"mvarId":["_uniq",61846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2385},{"state":[{"type":"ClusterPt y (Filter.principal (Set.Ioo a x \\ {y}))","tag":["refine_4","refine_2","refine_1"],"mvarId":["_uniq",66113],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n  (HasDerivWithinAt.mono (DifferentiableWithinAt.hasDerivWithinAt _fvar.62013)\n    (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this✝ hx y hgy hy this hgnon _fvar.62013))","type":"HasDerivWithinAt g (g' y) (Set.Ioo a x) y","name":["hg"],"isProp":true,"id":["_uniq",63116]}]},{"type":"y ∈ Set.Icc a b","tag":["refine_4","refine_1"],"mvarId":["_uniq",61846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2405},{"state":[{"type":"ClusterPt y (Filter.principal (Set.Ioo a y))","tag":[],"mvarId":["_uniq",66147],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n  (HasDerivWithinAt.mono (DifferentiableWithinAt.hasDerivWithinAt _fvar.62013)\n    (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this✝ hx y hgy hy this hgnon _fvar.62013))","type":"HasDerivWithinAt g (g' y) (Set.Ioo a x) y","name":["hg"],"isProp":true,"id":["_uniq",63116]}]},{"type":"Set.Ioo a y ⊆ Set.Ioo a x \\ {y}","tag":[],"mvarId":["_uniq",66216],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n  (HasDerivWithinAt.mono (DifferentiableWithinAt.hasDerivWithinAt _fvar.62013)\n    (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this✝ hx y hgy hy this hgnon _fvar.62013))","type":"HasDerivWithinAt g (g' y) (Set.Ioo a x) y","name":["hg"],"isProp":true,"id":["_uniq",63116]}]},{"type":"y ∈ Set.Icc a b","tag":["refine_4","refine_1"],"mvarId":["_uniq",61846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2481},{"state":[{"type":"Set.Ioo a y ⊆ Set.Ioo a x \\ {y}","tag":[],"mvarId":["_uniq",66216],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",61921],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",61990],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",61991],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",61992],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",61993],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",61994],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",61995],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",61996],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",61997],"binderInfo":"default"},{"type":"g x = 0","name":["this✝"],"isProp":true,"id":["_uniq",61998],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",61999],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",62000],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",62001],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",62002],"binderInfo":"default"},{"type":"y ∈ Set.Icc a b","name":["this"],"isProp":true,"id":["_uniq",62003],"binderInfo":"default"},{"type":"g' y ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",62004],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n  (HasDerivWithinAt.mono (DifferentiableWithinAt.hasDerivWithinAt _fvar.62013)\n    (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this✝ hx y hgy hy this hgnon _fvar.62013))","type":"HasDerivWithinAt g (g' y) (Set.Ioo a x) y","name":["hg"],"isProp":true,"id":["_uniq",63116]}]},{"type":"y ∈ Set.Icc a b","tag":["refine_4","refine_1"],"mvarId":["_uniq",61846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",60008],"binderInfo":"default"},{"type":"HasDerivWithinAt g 0 (Set.Ioo a x) y","name":["hgy"],"isProp":true,"id":["_uniq",60021],"binderInfo":"default"},{"type":"a < y ∧ y < x","name":["hy"],"isProp":true,"id":["_uniq",61721],"binderInfo":"default"}]},{"type":"Set.Icc a x ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",59763],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"Set.Ioo a x ⊆ Set.Icc a b","tag":["refine_2"],"mvarId":["_uniq",59967],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]},{"type":"g a = g x","tag":["refine_3"],"mvarId":["_uniq",59999],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",57492],"binderInfo":"default"},{"type":"g x = 0","name":["this"],"isProp":true,"id":["_uniq",57686],"binderInfo":"default"},{"type":"a < x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",59712],"binderInfo":"default"}]}],"start":2578},{"state":[{"type":"(∀ x ∈ Set.Ioc a b, g x ≠ 0) ∧ Filter.Tendsto (fun x => f x / g x) (nhdsWithin a (Set.Ioc a b)) (nhds L)","tag":[],"mvarId":["_uniq",57679],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]}]}],"start":2598},{"state":[{"type":"Filter.Tendsto (fun x => f x / g x) (nhdsWithin a (Set.Ioc a b)) (nhds L)","tag":[],"mvarId":["_uniq",83855],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]}]}],"start":2624},{"state":[{"type":"∀ (a_1 : ℕ → ℝ),\n  (∀ (n : ℕ), a_1 n ∈ Set.Ioc a b) →\n    Filter.Tendsto a_1 Filter.atTop (nhds a) → Filter.Tendsto (fun n => f (a_1 n) / g (a_1 n)) Filter.atTop (nhds L)","tag":[],"mvarId":["_uniq",83901],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]}]},{"type":"AdherentPt a (Set.Ioc a b)","tag":["h"],"mvarId":["_uniq",83892],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]}]}],"start":2672},{"state":[{"type":"Filter.Tendsto (fun n => f (x n) / g (x n)) Filter.atTop (nhds L)","tag":[],"mvarId":["_uniq",83920],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"}]}],"start":2693},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":[],"mvarId":["_uniq",84104],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"}]}],"start":2788},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":[],"mvarId":["_uniq",84238],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]}]}],"start":2868},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":[],"mvarId":["_uniq",85000],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]}]}],"start":2936},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":[],"mvarId":["_uniq",88992],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"}]}],"start":2983},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":[],"mvarId":["_uniq",91031],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3017},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":["refine_2"],"mvarId":["_uniq",91272],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3084},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":["refine_2","refine_2"],"mvarId":["_uniq",91412],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3161},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":["refine_2","refine_2","refine_2"],"mvarId":["_uniq",91459],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3191},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":["refine_2","refine_2","refine_2","refine_2"],"mvarId":["_uniq",91491],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]},{"value":"?refine_2.refine_2.refine_2.refine_1","type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",91490]}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3225},{"state":[{"type":"∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","tag":["refine_2","refine_2","refine_2","refine_2"],"mvarId":["_uniq",94021],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]},{"value":"?refine_2.refine_2.refine_2.refine_1","type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",91490]},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94008],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94016],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94020],"binderInfo":"default"}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3310},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right"],"mvarId":["_uniq",94039],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]},{"value":"?refine_2.refine_2.refine_2.refine_1","type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",91490]},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94008],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94016],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94020],"binderInfo":"default"}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3328},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right"],"mvarId":["_uniq",94264],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3370},{"state":[{"type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","tag":[],"mvarId":["_uniq",95497],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"}]}],"start":3437},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right"],"mvarId":["_uniq",95499],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3502},{"state":[{"type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","tag":[],"mvarId":["_uniq",103370],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]}]}],"start":3569},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right"],"mvarId":["_uniq",103372],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3634},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right"],"mvarId":["_uniq",117813],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3740},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right"],"mvarId":["_uniq",124010],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3846},{"state":[{"type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","tag":[],"mvarId":["_uniq",124802],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"}]}],"start":3941},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right"],"mvarId":["_uniq",124804],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":3975},{"state":[{"type":"f' yn * g (x n) - g' yn * f (x n) = 0","tag":[],"mvarId":["_uniq",127142],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]}]}],"start":4035},{"state":[{"type":"ClusterPt yn (Filter.principal (Set.Ioo a (x n) \\ {yn}))","tag":[],"mvarId":["_uniq",127149],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]}]}],"start":4076},{"state":[{"type":"ClusterPt yn (Filter.principal (Set.Ioo a yn))","tag":[],"mvarId":["_uniq",127159],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]}]},{"type":"Set.Ioo a yn ⊆ Set.Ioo a (x n) \\ {yn}","tag":[],"mvarId":["_uniq",127222],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]}]}],"start":4157},{"state":[{"type":"Set.Ioo a yn ⊆ Set.Ioo a (x n) \\ {yn}","tag":[],"mvarId":["_uniq",127222],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]}]}],"start":4248},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right"],"mvarId":["_uniq",127144],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]},{"value":"derivative_unique\n  (ClusterPt.mono\n    (Eq.mpr\n      (id\n        (Eq.trans Filter.Tendsto.of_div'._simp_2\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => yn ∈ x)\n                (closure_Ioo\n                  (have this :=\n                    Filter.Tendsto.of_div'._proof_14 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1\n                      h2 h3 h4 h5;\n                  this)))\n              Set.mem_Icc._simp_1)\n            (Eq.trans (congrArg (And (a ≤ yn)) (le_refl._simp_1 yn)) (and_true (a ≤ yn))))))\n      (Filter.Tendsto.of_div'._proof_15 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5))\n    (Filter.principal_mono.mpr\n      (Filter.Tendsto.of_div'._proof_16 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5)))\n  h5 hdh","type":"f' yn * g (x n) - g' yn * f (x n) = 0","name":["h6"],"isProp":true,"id":["_uniq",127143]}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":4262},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right","refine_2"],"mvarId":["_uniq",142091],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]},{"value":"derivative_unique\n  (ClusterPt.mono\n    (Eq.mpr\n      (id\n        (Eq.trans Filter.Tendsto.of_div'._simp_2\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => yn ∈ x)\n                (closure_Ioo\n                  (have this :=\n                    Filter.Tendsto.of_div'._proof_14 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1\n                      h2 h3 h4 h5;\n                  this)))\n              Set.mem_Icc._simp_1)\n            (Eq.trans (congrArg (And (a ≤ yn)) (le_refl._simp_1 yn)) (and_true (a ≤ yn))))))\n      (Filter.Tendsto.of_div'._proof_15 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5))\n    (Filter.principal_mono.mpr\n      (Filter.Tendsto.of_div'._proof_16 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5)))\n  h5 hdh","type":"f' yn * g (x n) - g' yn * f (x n) = 0","name":["h6"],"isProp":true,"id":["_uniq",127143]},{"value":"?right.refine_1","type":"g (x n) ≠ 0","name":["h7"],"isProp":true,"id":["_uniq",142090]}]},{"type":"g (x n) ≠ 0","tag":["right","refine_1"],"mvarId":["_uniq",142089],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]},{"value":"derivative_unique\n  (ClusterPt.mono\n    (Eq.mpr\n      (id\n        (Eq.trans Filter.Tendsto.of_div'._simp_2\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => yn ∈ x)\n                (closure_Ioo\n                  (have this :=\n                    Filter.Tendsto.of_div'._proof_14 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1\n                      h2 h3 h4 h5;\n                  this)))\n              Set.mem_Icc._simp_1)\n            (Eq.trans (congrArg (And (a ≤ yn)) (le_refl._simp_1 yn)) (and_true (a ≤ yn))))))\n      (Filter.Tendsto.of_div'._proof_15 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5))\n    (Filter.principal_mono.mpr\n      (Filter.Tendsto.of_div'._proof_16 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5)))\n  h5 hdh","type":"f' yn * g (x n) - g' yn * f (x n) = 0","name":["h6"],"isProp":true,"id":["_uniq",127143]}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":4298},{"state":[{"type":"f (x n) / g (x n) = f' yn / g' yn","tag":["right","refine_2","refine_2"],"mvarId":["_uniq",142123],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]},{"value":"derivative_unique\n  (ClusterPt.mono\n    (Eq.mpr\n      (id\n        (Eq.trans Filter.Tendsto.of_div'._simp_2\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => yn ∈ x)\n                (closure_Ioo\n                  (have this :=\n                    Filter.Tendsto.of_div'._proof_14 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1\n                      h2 h3 h4 h5;\n                  this)))\n              Set.mem_Icc._simp_1)\n            (Eq.trans (congrArg (And (a ≤ yn)) (le_refl._simp_1 yn)) (and_true (a ≤ yn))))))\n      (Filter.Tendsto.of_div'._proof_15 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5))\n    (Filter.principal_mono.mpr\n      (Filter.Tendsto.of_div'._proof_16 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5)))\n  h5 hdh","type":"f' yn * g (x n) - g' yn * f (x n) = 0","name":["h6"],"isProp":true,"id":["_uniq",127143]},{"value":"?right.refine_1","type":"g (x n) ≠ 0","name":["h7"],"isProp":true,"id":["_uniq",142090]},{"value":"?right.refine_2.refine_1","type":"g' yn ≠ 0","name":["h8"],"isProp":true,"id":["_uniq",142122]}]},{"type":"g' yn ≠ 0","tag":["right","refine_2","refine_1"],"mvarId":["_uniq",142121],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]},{"value":"derivative_unique\n  (ClusterPt.mono\n    (Eq.mpr\n      (id\n        (Eq.trans Filter.Tendsto.of_div'._simp_2\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => yn ∈ x)\n                (closure_Ioo\n                  (have this :=\n                    Filter.Tendsto.of_div'._proof_14 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1\n                      h2 h3 h4 h5;\n                  this)))\n              Set.mem_Icc._simp_1)\n            (Eq.trans (congrArg (And (a ≤ yn)) (le_refl._simp_1 yn)) (and_true (a ≤ yn))))))\n      (Filter.Tendsto.of_div'._proof_15 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5))\n    (Filter.principal_mono.mpr\n      (Filter.Tendsto.of_div'._proof_16 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5)))\n  h5 hdh","type":"f' yn * g (x n) - g' yn * f (x n) = 0","name":["h6"],"isProp":true,"id":["_uniq",127143]},{"value":"?right.refine_1","type":"g (x n) ≠ 0","name":["h7"],"isProp":true,"id":["_uniq",142090]}]},{"type":"g (x n) ≠ 0","tag":["right","refine_1"],"mvarId":["_uniq",142089],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ f (Set.Icc a b) x","name":["hf"],"isProp":true,"id":["_uniq",94158],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, DifferentiableWithinAt ℝ g (Set.Icc a b) x","name":["hg"],"isProp":true,"id":["_uniq",94232],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",94237],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",94238],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",94239],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",94240],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",94241],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",94242],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",94243],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",94244],"binderInfo":"default"},{"type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",94245],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",94246],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",94247],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",94248],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",94249]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",94250],"binderInfo":"default"},{"type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",94251],"binderInfo":"default"},{"type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",94252],"binderInfo":"default"},{"type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",94253],"binderInfo":"default"},{"type":"h (x n) = 0","name":["hb"],"isProp":true,"id":["_uniq",94254],"binderInfo":"default"},{"type":"ℝ","name":["yn"],"isProp":false,"id":["_uniq",94255],"binderInfo":"default"},{"type":"yn ∈ Set.Ioo a (x n)","name":["hyn"],"isProp":true,"id":["_uniq",94256],"binderInfo":"default"},{"type":"HasDerivWithinAt h 0 (Set.Ioo a (x n)) yn","name":["hdh"],"isProp":true,"id":["_uniq",94257],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hf yn (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh)))\n    (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh))","type":"HasDerivWithinAt f (f' yn) (Set.Ioo a (x n)) yn","name":["h1"],"isProp":true,"id":["_uniq",95498]},{"value":"Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n  (HasDerivWithinAt.mono\n    (DifferentiableWithinAt.hasDerivWithinAt\n      (hg yn (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1)))\n    (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1))","type":"HasDerivWithinAt g (g' yn) (Set.Ioo a (x n)) yn","name":["h2"],"isProp":true,"id":["_uniq",103371]},{"type":"HasDerivWithinAt (fun y => f y * g (x n)) (f' yn * g (x n)) (Set.Ioo a (x n)) yn","name":["h3"],"isProp":true,"id":["_uniq",117812],"binderInfo":"default"},{"type":"HasDerivWithinAt (fun y => g y * f (x n)) (g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h4"],"isProp":true,"id":["_uniq",124009],"binderInfo":"default"},{"value":"id (HasDerivWithinAt.sub h3 h4)","type":"HasDerivWithinAt h (f' yn * g (x n) - g' yn * f (x n)) (Set.Ioo a (x n)) yn","name":["h5"],"isProp":true,"id":["_uniq",124803]},{"value":"derivative_unique\n  (ClusterPt.mono\n    (Eq.mpr\n      (id\n        (Eq.trans Filter.Tendsto.of_div'._simp_2\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => yn ∈ x)\n                (closure_Ioo\n                  (have this :=\n                    Filter.Tendsto.of_div'._proof_14 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1\n                      h2 h3 h4 h5;\n                  this)))\n              Set.mem_Icc._simp_1)\n            (Eq.trans (congrArg (And (a ≤ yn)) (le_refl._simp_1 yn)) (and_true (a ≤ yn))))))\n      (Filter.Tendsto.of_div'._proof_15 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5))\n    (Filter.principal_mono.mpr\n      (Filter.Tendsto.of_div'._proof_16 hderiv hfcon hgcon this x hconv n hx hcon hdiff ha hb yn hyn hdh h1 h2 h3 h4\n        h5)))\n  h5 hdh","type":"f' yn * g (x n) - g' yn * f (x n) = 0","name":["h6"],"isProp":true,"id":["_uniq",127143]}]},{"type":"h (x n) = 0","tag":["refine_2","refine_2","refine_2","refine_1"],"mvarId":["_uniq",91489],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]},{"value":"?refine_2.refine_2.refine_1","type":"h a = 0","name":["ha"],"isProp":true,"id":["_uniq",91458]}]},{"type":"h a = 0","tag":["refine_2","refine_2","refine_1"],"mvarId":["_uniq",91457],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]},{"value":"DifferentiableOn.mono _fvar.84999 ?refine_2.refine_1","type":"DifferentiableOn ℝ h (Set.Ioo a (x n))","name":["hdiff"],"isProp":true,"id":["_uniq",91408]}]},{"type":"Set.Ioo a (x n) ⊆ Set.Icc a b","tag":["refine_2","refine_1"],"mvarId":["_uniq",91385],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"},{"value":"ContinuousOn.mono _fvar.88991 ?refine_1","type":"ContinuousOn h (Set.Icc a (x n))","name":["hcon"],"isProp":true,"id":["_uniq",91268]}]},{"type":"Set.Icc a (x n) ⊆ Set.Icc a b","tag":["refine_1"],"mvarId":["_uniq",91263],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",83923],"binderInfo":"default"},{"value":"fun x' => f x' * g (x n) - g x' * f (x n)","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",84237]},{"value":"DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)))","type":"DifferentiableOn ℝ h (Set.Icc a b)","name":["hdiff"],"isProp":true,"id":["_uniq",84999]},{"type":"ContinuousOn h (Set.Icc a b)","name":["hcon"],"isProp":true,"id":["_uniq",88991],"binderInfo":"default"},{"type":"a < x n ∧ x n ≤ b","name":["hx"],"isProp":true,"id":["_uniq",91028],"binderInfo":"default"}]}],"start":4334},{"state":[{"type":"Filter.Tendsto (fun n => f (x n) / g (x n)) Filter.atTop (nhds L)","tag":[],"mvarId":["_uniq",84107],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"value":"fun n =>\n  let h := fun x' => f x' * g (x n) - g x' * f (x n);\n  have hdiff :=\n    DifferentiableOn.fun_sub (DifferentiableOn.mul_const hf (g (x n))) (DifferentiableOn.mul_const hg (f (x n)));\n  have hcon :=\n    ContinuousOn.mono (ContinuousOn.of_differentiableOn hdiff)\n      (Filter.Tendsto.of_div'._proof_23 hderiv hfcon hgcon this x hconv n hdiff (ContinuousOn.of_differentiableOn hdiff)\n        (Eq.mp Set.mem_Ioc._simp_1 (hx n)));\n  have hdiff :=\n    DifferentiableOn.mono hdiff\n      (Filter.Tendsto.of_div'._proof_22 hderiv hfcon hgcon this x hconv n hdiff (Eq.mp Set.mem_Ioc._simp_1 (hx n))\n        hcon);\n  have ha :=\n    Filter.Tendsto.of_div'._proof_21 hfa hga hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n)) hcon\n      hdiff;\n  have hb :=\n    Filter.Tendsto.of_div'._proof_20 hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n)) hcon hdiff ha;\n  (fun yn x_1 =>\n      Exists.intro yn\n        ⟨x_1.left,\n          have h1 :=\n            Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt f (_a yn) (Set.Ioo a (x n)) yn) hf'))\n              (HasDerivWithinAt.mono\n                (DifferentiableWithinAt.hasDerivWithinAt\n                  (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ f (Set.Icc a b))) hf yn\n                    (Filter.Tendsto.of_div'._proof_10 hderiv hfcon hgcon this x hconv n\n                      (Eq.mp Set.mem_Ioc._simp_1 (hx n)) hcon hdiff ha hb yn x_1.left x_1.right)))\n                (Filter.Tendsto.of_div'._proof_9 hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n))\n                  hcon hdiff ha hb yn x_1.left x_1.right));\n          have h2 :=\n            Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a yn) (Set.Ioo a (x n)) yn) hg'))\n              (HasDerivWithinAt.mono\n                (DifferentiableWithinAt.hasDerivWithinAt\n                  (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg yn\n                    (Filter.Tendsto.of_div'._proof_12 hderiv hfcon hgcon this x hconv n\n                      (Eq.mp Set.mem_Ioc._simp_1 (hx n)) hcon hdiff ha hb yn x_1.left x_1.right h1)))\n                (Filter.Tendsto.of_div'._proof_11 hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n))\n                  hcon hdiff ha hb yn x_1.left x_1.right h1));\n          have h5 :=\n            id\n              (HasDerivWithinAt.sub (HasDerivWithinAt.mul_const h1 (g (x n)))\n                (HasDerivWithinAt.mul_const h2 (f (x n))));\n          have h6 :=\n            derivative_unique\n              (ClusterPt.mono\n                (Eq.mpr\n                  (id\n                    (Eq.trans Filter.Tendsto.of_div'._simp_2\n                      (Eq.trans\n                        (Eq.trans\n                          (congrArg (fun x => yn ∈ x)\n                            (closure_Ioo\n                              (have this :=\n                                Filter.Tendsto.of_div'._proof_14 hderiv hfcon hgcon this x hconv n\n                                  (Eq.mp Set.mem_Ioc._simp_1 (hx n)) hcon hdiff ha hb yn x_1.left x_1.right h1 h2\n                                  (HasDerivWithinAt.mul_const h1 (g (x n))) (HasDerivWithinAt.mul_const h2 (f (x n)))\n                                  h5;\n                              this)))\n                          Set.mem_Icc._simp_1)\n                        (Eq.trans (congrArg (And (a ≤ yn)) (le_refl._simp_1 yn)) (and_true (a ≤ yn))))))\n                  (Filter.Tendsto.of_div'._proof_15 hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n))\n                    hcon hdiff ha hb yn x_1.left x_1.right h1 h2 (HasDerivWithinAt.mul_const h1 (g (x n)))\n                    (HasDerivWithinAt.mul_const h2 (f (x n))) h5))\n                (Filter.principal_mono.mpr\n                  (Filter.Tendsto.of_div'._proof_16 hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n))\n                    hcon hdiff ha hb yn x_1.left x_1.right h1 h2 (HasDerivWithinAt.mul_const h1 (g (x n)))\n                    (HasDerivWithinAt.mul_const h2 (f (x n))) h5)))\n              h5 x_1.right;\n          have h7 :=\n            Filter.Tendsto.of_div'._proof_19 hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n)) hcon\n              hdiff ha hb yn x_1.left x_1.right h1 h2 (HasDerivWithinAt.mul_const h1 (g (x n)))\n              (HasDerivWithinAt.mul_const h2 (f (x n))) h5 h6;\n          have h8 :=\n            Filter.Tendsto.of_div'._proof_18 hgnon hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n))\n              hcon hdiff ha hb yn x_1.left x_1.right h1 h2 (HasDerivWithinAt.mul_const h1 (g (x n)))\n              (HasDerivWithinAt.mul_const h2 (f (x n))) h5 h6 h7;\n          Filter.Tendsto.of_div'._proof_17 hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n)) hcon\n            hdiff ha hb yn x_1.left x_1.right h1 h2 (HasDerivWithinAt.mul_const h1 (g (x n)))\n            (HasDerivWithinAt.mul_const h2 (f (x n))) h5 h6 h7 h8⟩)\n    (Classical.choose\n      (HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 (hx n)).left hcon hdiff\n        (Filter.Tendsto.of_div'._proof_8 hderiv hfcon hgcon this x hconv n (Eq.mp Set.mem_Ioc._simp_1 (hx n)) hcon hdiff\n          ha hb)))\n    (Classical.choose_spec ⋯)","type":"∀ (n : ℕ), ∃ yn ∈ Set.Ioo a (x n), f (x n) / g (x n) = f' yn / g' yn","name":["hxy"],"isProp":true,"id":["_uniq",84106]}]}],"start":4356},{"state":[{"type":"Filter.Tendsto (fun n => f (x n) / g (x n)) Filter.atTop (nhds L)","tag":[],"mvarId":["_uniq",162538],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["y"],"isProp":false,"id":["_uniq",162520],"binderInfo":"default"},{"type":"∀ (n : ℕ), y n ∈ Set.Ioo a (x n)","name":["hy"],"isProp":true,"id":["_uniq",162532],"binderInfo":"default"},{"type":"∀ (n : ℕ), f (x n) / g (x n) = f' (y n) / g' (y n)","name":["hy'"],"isProp":true,"id":["_uniq",162537],"binderInfo":"default"}]}],"start":4386},{"state":[{"type":"Filter.Tendsto y Filter.atTop (nhds a)","tag":[],"mvarId":["_uniq",162712],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["y"],"isProp":false,"id":["_uniq",162520],"binderInfo":"default"},{"type":"∀ (n : ℕ), y n ∈ Set.Ioo a (x n)","name":["hy"],"isProp":true,"id":["_uniq",162532],"binderInfo":"default"},{"type":"∀ (n : ℕ), f (x n) / g (x n) = f' (y n) / g' (y n)","name":["hy'"],"isProp":true,"id":["_uniq",162537],"binderInfo":"default"}]}],"start":4442},{"state":[{"type":"Filter.Tendsto (fun n => f (x n) / g (x n)) Filter.atTop (nhds L)","tag":[],"mvarId":["_uniq",162714],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["y"],"isProp":false,"id":["_uniq",162520],"binderInfo":"default"},{"type":"∀ (n : ℕ), y n ∈ Set.Ioo a (x n)","name":["hy"],"isProp":true,"id":["_uniq",162532],"binderInfo":"default"},{"type":"∀ (n : ℕ), f (x n) / g (x n) = f' (y n) / g' (y n)","name":["hy'"],"isProp":true,"id":["_uniq",162537],"binderInfo":"default"},{"value":"Filter.Tendsto.squeeze tendsto_const_nhds hconv\n  (fun i => Filter.Tendsto.of_div'._proof_24 hderiv hfcon hgcon this x hx hconv y hy hy' i) fun i =>\n  Filter.Tendsto.of_div'._proof_25 hderiv hfcon hgcon this x hx hconv y hy hy' i","type":"Filter.Tendsto y Filter.atTop (nhds a)","name":["hyconv"],"isProp":true,"id":["_uniq",162713]}]}],"start":4508},{"state":[{"type":"Filter.Tendsto (fun n => f (x n) / g (x n)) Filter.atTop (nhds L)","tag":[],"mvarId":["_uniq",171989],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["y"],"isProp":false,"id":["_uniq",162520],"binderInfo":"default"},{"type":"∀ (n : ℕ), f (x n) / g (x n) = f' (y n) / g' (y n)","name":["hy'"],"isProp":true,"id":["_uniq",162537],"binderInfo":"default"},{"value":"Filter.Tendsto.squeeze tendsto_const_nhds hconv\n  (fun i => Filter.Tendsto.of_div'._proof_24 hderiv hfcon hgcon this x hx hconv y _fvar.162532 hy' i) fun i =>\n  Filter.Tendsto.of_div'._proof_25 hderiv hfcon hgcon this x hx hconv y _fvar.162532 hy' i","type":"Filter.Tendsto y Filter.atTop (nhds a)","name":["hyconv"],"isProp":true,"id":["_uniq",162713]},{"value":"Filter.Tendsto.of_div'._proof_26 hderiv hfcon hgcon this x hx hconv y _fvar.162532 hy' hyconv","type":"∀ (n : ℕ), y n ∈ Set.Icc a b","name":["hy"],"isProp":true,"id":["_uniq",168812]}]}],"start":4564},{"state":[{"type":"Filter.Tendsto y Filter.atTop (nhdsWithin a (Set.Icc a b))","tag":[],"mvarId":["_uniq",172419],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]},{"type":"ℕ → ℝ","name":["x"],"isProp":false,"id":["_uniq",83912],"binderInfo":"default"},{"type":"∀ (n : ℕ), x n ∈ Set.Ioc a b","name":["hx"],"isProp":true,"id":["_uniq",83915],"binderInfo":"default"},{"type":"Filter.Tendsto x Filter.atTop (nhds a)","name":["hconv"],"isProp":true,"id":["_uniq",83919],"binderInfo":"default"},{"type":"ℕ → ℝ","name":["y"],"isProp":false,"id":["_uniq",162520],"binderInfo":"default"},{"type":"∀ (n : ℕ), f (x n) / g (x n) = f' (y n) / g' (y n)","name":["hy'"],"isProp":true,"id":["_uniq",162537],"binderInfo":"default"},{"value":"Filter.Tendsto.squeeze tendsto_const_nhds hconv\n  (fun i => Filter.Tendsto.of_div'._proof_24 hderiv hfcon hgcon this x hx hconv y _fvar.162532 hy' i) fun i =>\n  Filter.Tendsto.of_div'._proof_25 hderiv hfcon hgcon this x hx hconv y _fvar.162532 hy' i","type":"Filter.Tendsto y Filter.atTop (nhds a)","name":["hyconv"],"isProp":true,"id":["_uniq",162713]},{"value":"Filter.Tendsto.of_div'._proof_26 hderiv hfcon hgcon this x hx hconv y _fvar.162532 hy' hyconv","type":"∀ (n : ℕ), y n ∈ Set.Icc a b","name":["hy"],"isProp":true,"id":["_uniq",168812]}]}],"start":4601},{"state":[],"start":4677},{"state":[{"type":"AdherentPt a (Set.Ioc a b)","tag":["h"],"mvarId":["_uniq",83892],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",4271],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",4272],"binderInfo":"implicit"},{"type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",4273],"binderInfo":"implicit"},{"type":"a < b","name":["hab"],"isProp":true,"id":["_uniq",4274],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",4275],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",4276],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",4277],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",4278],"binderInfo":"implicit"},{"type":"DifferentiableOn ℝ f (Set.Icc a b)","name":["hf"],"isProp":true,"id":["_uniq",4279],"binderInfo":"default"},{"type":"DifferentiableOn ℝ g (Set.Icc a b)","name":["hg"],"isProp":true,"id":["_uniq",4280],"binderInfo":"default"},{"type":"f' = derivWithin f (Set.Icc a b)","name":["hf'"],"isProp":true,"id":["_uniq",4281],"binderInfo":"default"},{"type":"g' = derivWithin g (Set.Icc a b)","name":["hg'"],"isProp":true,"id":["_uniq",4282],"binderInfo":"default"},{"type":"f a = 0","name":["hfa"],"isProp":true,"id":["_uniq",4283],"binderInfo":"default"},{"type":"g a = 0","name":["hga"],"isProp":true,"id":["_uniq",4284],"binderInfo":"default"},{"type":"∀ x ∈ Set.Icc a b, g' x ≠ 0","name":["hgnon"],"isProp":true,"id":["_uniq",4285],"binderInfo":"default"},{"type":"Filter.Tendsto (fun x => f' x / g' x) (nhdsWithin a (Set.Icc a b)) (nhds L)","name":["hderiv"],"isProp":true,"id":["_uniq",4286],"binderInfo":"default"},{"type":"ContinuousOn f (Set.Icc a b)","name":["hfcon"],"isProp":true,"id":["_uniq",55943],"binderInfo":"default"},{"type":"ContinuousOn g (Set.Icc a b)","name":["hgcon"],"isProp":true,"id":["_uniq",57488],"binderInfo":"default"},{"value":"fun x hx this =>\n  have this_1 :=\n    HasDerivWithinAt.exist_zero (Eq.mp Set.mem_Ioc._simp_1 hx).left\n      (ContinuousOn.mono hgcon\n        (Filter.Tendsto.of_div'._proof_5 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (DifferentiableOn.mono hg\n        (Filter.Tendsto.of_div'._proof_6 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx)))\n      (Filter.Tendsto.of_div'._proof_7 hga hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx));\n  (fun y x_1 =>\n      have this_2 :=\n        Filter.Tendsto.of_div'._proof_4 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n          (Eq.mp Set.mem_Ioo._simp_1 x_1.left);\n      have hg :=\n        Eq.mpr (id (congrArg (fun _a => HasDerivWithinAt g (_a y) (Set.Ioo a x) y) hg'))\n          (HasDerivWithinAt.mono\n            (DifferentiableWithinAt.hasDerivWithinAt\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2))\n            (Filter.Tendsto.of_div'._proof_2 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n              (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2)\n              (Eq.mp (congrArg (fun _a => _a) (DifferentiableOn.eq_1 ℝ g (Set.Icc a b))) hg y this_2)));\n      have hd :=\n        derivative_unique\n          (ClusterPt.mono\n            (of_eq_true\n              (Eq.trans Filter.Tendsto.of_div'._simp_2\n                (Eq.trans\n                  (Eq.trans\n                    (congrArg (fun x => y ∈ x)\n                      (closure_Ioo\n                        (have this :=\n                          Not.intro fun a_1 =>\n                            Mathlib.Tactic.Linarith.lt_irrefl\n                              (Eq.mp\n                                (congrArg (fun _a => _a < 0)\n                                  (Mathlib.Tactic.Ring.of_eq\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                        (Mathlib.Tactic.Ring.atom_pf y)\n                                        (Mathlib.Tactic.Ring.sub_pf\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                    (Eq.refl (Int.negOfNat 1))))))\n                                            Mathlib.Tactic.Ring.neg_zero)\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                      (Mathlib.Tactic.Ring.neg_congr\n                                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a)\n                                          (Mathlib.Tactic.Ring.atom_pf y)\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                (y ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                        (Mathlib.Tactic.Ring.neg_add\n                                          (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                                            (Mathlib.Tactic.Ring.neg_one_mul\n                                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                  (Eq.refl (Int.negOfNat 1))))))\n                                          (Mathlib.Tactic.Ring.neg_add\n                                            (Mathlib.Tactic.Ring.neg_mul y (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                      (Eq.refl (Int.ofNat 1)))))))\n                                            Mathlib.Tactic.Ring.neg_zero)))\n                                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                        (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Eq.refl (Int.ofNat 0)))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Tactic.Ring.add_overlap_pf_zero y (Nat.rawCast 1)\n                                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.ofNat 0)))))\n                                          (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n                                (Mathlib.Tactic.Linarith.lt_of_lt_of_eq\n                                  (Mathlib.Tactic.Linarith.sub_neg_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)\n                                  (neg_eq_zero.mpr (sub_eq_zero_of_eq a_1))));\n                        this)))\n                    Set.mem_Icc._simp_1)\n                  (Eq.trans\n                    (congr (congrArg And (eq_true (le_of_lt (Eq.mp Set.mem_Ioo._simp_1 x_1.left).left)))\n                      (le_refl._simp_1 y))\n                    (and_self True)))))\n            (Filter.principal_mono.mpr\n              (Filter.Tendsto.of_div'._proof_3 hderiv hfcon hgcon x this (Eq.mp Set.mem_Ioc._simp_1 hx) y x_1.right\n                (Eq.mp Set.mem_Ioo._simp_1 x_1.left) this_2 (hgnon y this_2) hg)))\n          hg x_1.right;\n      False.elim (hgnon y this_2 hd))\n    (Classical.choose this_1) (Classical.choose_spec this_1)","type":"∀ x ∈ Set.Ioc a b, g x ≠ 0","name":["this"],"isProp":true,"id":["_uniq",57676]}]}],"start":4710},{"state":[],"start":4779},{"state":[],"start":4780},{"state":[],"start":4781},{"state":[],"start":4795},{"state":[],"start":4795}]
