[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":78},{"state":[],"start":125},{"state":[],"start":181},{"state":[],"start":182},{"state":[],"start":186},{"state":[],"start":238},{"state":[],"start":239},{"state":[],"start":623},{"state":[],"start":624},{"state":[],"start":672},{"state":[],"start":673},{"state":[],"start":701},{"state":[],"start":702},{"state":[],"start":926},{"state":[],"start":927},{"state":[],"start":930},{"state":[],"start":931},{"state":[],"start":950},{"state":[],"start":951},{"state":[],"start":974},{"state":[],"start":975},{"state":[],"start":1077},{"state":[],"start":1119},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",671],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"type":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop < 1","name":["h"],"isProp":true,"id":["_uniq",670],"binderInfo":"default"}]}],"start":1215},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",671],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"type":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop < 1","name":["h"],"isProp":true,"id":["_uniq",670],"binderInfo":"default"}]}],"start":1290},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",1338],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"}]}],"start":1367},{"state":[{"type":"0 ≤ α'","tag":[],"mvarId":["_uniq",1416],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"}]}],"start":1399},{"state":[{"type":"∀ (x : ℤ), 0 ≤ (↑(|s.seq x| ^ (1 / (↑x : ℝ))) : EReal)","tag":[],"mvarId":["_uniq",1434],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"}]}],"start":1485},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",1418],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le\n  (Frequently.of_forall fun x =>\n    EReal.coe_nonneg.mpr (rpow_nonneg (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq x)) (1 / (↑x : ℝ))))\n  isBounded_le_of_top","type":"0 ≤ α'","name":["hpos"],"isProp":true,"id":["_uniq",1417]}]}],"start":1510},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",4878],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le\n  (Frequently.of_forall fun x =>\n    EReal.coe_nonneg.mpr (rpow_nonneg (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq x)) (1 / (↑x : ℝ))))\n  isBounded_le_of_top","type":"0 ≤ α'","name":["hpos"],"isProp":true,"id":["_uniq",1417]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]}]}],"start":1535},{"state":[{"type":"α' = (↑α : EReal)","tag":[],"mvarId":["_uniq",5081],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le\n  (Frequently.of_forall fun x =>\n    EReal.coe_nonneg.mpr (rpow_nonneg (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq x)) (1 / (↑x : ℝ))))\n  isBounded_le_of_top","type":"0 ≤ α'","name":["hpos"],"isProp":true,"id":["_uniq",1417]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]}]}],"start":1568},{"state":[{"type":"α' ≠ ⊤","tag":["hx"],"mvarId":["_uniq",5095],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le\n  (Frequently.of_forall fun x =>\n    EReal.coe_nonneg.mpr (rpow_nonneg (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq x)) (1 / (↑x : ℝ))))\n  isBounded_le_of_top","type":"0 ≤ α'","name":["hpos"],"isProp":true,"id":["_uniq",1417]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]}]},{"type":"α' ≠ ⊥","tag":["h'x"],"mvarId":["_uniq",5096],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le\n  (Frequently.of_forall fun x =>\n    EReal.coe_nonneg.mpr (rpow_nonneg (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq x)) (1 / (↑x : ℝ))))\n  isBounded_le_of_top","type":"0 ≤ α'","name":["hpos"],"isProp":true,"id":["_uniq",1417]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]}]}],"start":1597},{"state":[{"type":"α' ≠ ⊥","tag":["h'x"],"mvarId":["_uniq",5096],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le\n  (Frequently.of_forall fun x =>\n    EReal.coe_nonneg.mpr (rpow_nonneg (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq x)) (1 / (↑x : ℝ))))\n  isBounded_le_of_top","type":"0 ≤ α'","name":["hpos"],"isProp":true,"id":["_uniq",1417]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]}]}],"start":1629},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",5083],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"type":"α' < 1","name":["h"],"isProp":true,"id":["_uniq",1335],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le\n  (Frequently.of_forall fun x =>\n    EReal.coe_nonneg.mpr (rpow_nonneg (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq x)) (1 / (↑x : ℝ))))\n  isBounded_le_of_top","type":"0 ≤ α'","name":["hpos"],"isProp":true,"id":["_uniq",1417]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"value":"Eq.symm\n  (coe_toReal\n    (Mathlib.Tactic.Contrapose.mtr\n      (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_ne_eq α' ⊤) (Mathlib.Tactic.PushNeg.not_lt_eq α' 1)))\n        fun h => of_eq_true (Eq.trans (congrArg (LE.le 1) h) le_top._simp_1))\n      h)\n    (Mathlib.Tactic.Contrapose.mtr\n      (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_ne_eq α' ⊥) (Mathlib.Tactic.PushNeg.not_le_eq 0 α')))\n        fun hpos => of_eq_true (Eq.trans (congrArg (fun x => x < 0) hpos) bot_lt_zero._simp_1))\n      hpos))","type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",5082]}]}],"start":1665},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",8143],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"}]}],"start":1712},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",8336],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]}]}],"start":1735},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",8464],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]}]}],"start":1783},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",12148],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]}]}],"start":1867},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",12439],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]}]}],"start":1920},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",14936],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]}]}],"start":1963},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",15624],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"value":"eventually_lt_of_limsup_lt hε' isBounded_le_of_top","type":"∀ᶠ (a : ℤ) in atTop, (↑(|s.seq a| ^ (1 / (↑a : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",15623]}]}],"start":2029},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",16465],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"∃ a, ∀ b ≥ a, (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",16462],"binderInfo":"default"}]}],"start":2063},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",16569],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]}]}],"start":2120},{"state":[{"type":"|s.seq n| ≤ (α + ε) ^ n","tag":[],"mvarId":["_uniq",16848],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"}]}],"start":2185},{"state":[{"type":"|s.seq n| ≤ (α + ε) ^ n","tag":[],"mvarId":["_uniq",16864],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]}]}],"start":2219},{"state":[{"type":"|s.seq n| ≤ (α + ε) ^ n","tag":[],"mvarId":["_uniq",17080],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]}]}],"start":2255},{"state":[{"type":"|s.seq n| ≤ (α + ε) ^ n","tag":[],"mvarId":["_uniq",17402],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]},{"type":"(↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",17399],"binderInfo":"default"}]}],"start":2282},{"state":[{"type":"|s.seq n| ≤ (α + ε) ^ n","tag":[],"mvarId":["_uniq",17437],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]},{"type":"|s.seq n| ^ (1 / (↑n : ℝ)) < α + ε","name":["hN"],"isProp":true,"id":["_uniq",17434],"binderInfo":"default"}]}],"start":2320},{"state":[{"type":"|s.seq n| ≤ (α + ε) ^ n","tag":[],"mvarId":["_uniq",17437],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]},{"type":"|s.seq n| ^ (1 / (↑n : ℝ)) < α + ε","name":["hN"],"isProp":true,"id":["_uniq",17434],"binderInfo":"default"}]}],"start":2331},{"state":[{"type":"|s.seq n| = (|s.seq n| ^ (1 / (↑n : ℝ))) ^ n","tag":[],"mvarId":["_uniq",17666],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]},{"type":"|s.seq n| ^ (1 / (↑n : ℝ)) < α + ε","name":["hN"],"isProp":true,"id":["_uniq",17434],"binderInfo":"default"}]}],"start":2375},{"state":[{"type":"|s.seq n| = |s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))","tag":[],"mvarId":["_uniq",17770],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]},{"type":"|s.seq n| ^ (1 / (↑n : ℝ)) < α + ε","name":["hN"],"isProp":true,"id":["_uniq",17434],"binderInfo":"default"}]}],"start":2435},{"state":[],"start":2482},{"state":[{"type":"(|s.seq n| ^ (1 / (↑n : ℝ))) ^ n ≤ (α + ε) ^ n","tag":[],"mvarId":["_uniq",17680],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]},{"type":"|s.seq n| ^ (1 / (↑n : ℝ)) < α + ε","name":["hN"],"isProp":true,"id":["_uniq",17434],"binderInfo":"default"}]}],"start":2504},{"state":[{"type":"(|s.seq n| ^ (1 / (↑n : ℝ))) ^ n = (|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat","tag":["h","e'_3"],"mvarId":["_uniq",33866],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]},{"type":"|s.seq n| ^ (1 / (↑n : ℝ)) < α + ε","name":["hN"],"isProp":true,"id":["_uniq",17434],"binderInfo":"default"}]},{"type":"(α + ε) ^ n = (α + ε) ^ n.toNat","tag":["h","e'_4"],"mvarId":["_uniq",33867],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",16724],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",16732],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",16863]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",17079]},{"type":"|s.seq n| ^ (1 / (↑n : ℝ)) < α + ε","name":["hN"],"isProp":true,"id":["_uniq",17434],"binderInfo":"default"}]}],"start":2579},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",16853],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]}]}],"start":2631},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",40280],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]}]}],"start":2660},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",40557],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]}]}],"start":2699},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.converges","tag":[],"mvarId":["_uniq",41606],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]}]}],"start":2765},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",41608],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"value":"of_eq_true\n  (Eq.trans\n    (Eq.trans\n      (congrArg converges\n        ((fun m m_1 e_m =>\n            Eq.rec (motive := fun m_2 e_m =>\n              ∀ (seq seq_1 : ℤ → ℝ) (e_seq : seq = seq_1) (vanish : ∀ n < m, seq n = 0),\n                { m := m, seq := seq, vanish := vanish } =\n                  { m := m_2, seq := seq_1,\n                    vanish :=\n                      Eq.ndrec (motive := fun m => ∀ n < m, seq_1 n = 0)\n                        (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) e_m })\n              (fun seq seq_1 e_seq =>\n                Eq.rec (motive := fun seq_2 e_seq =>\n                  ∀ (vanish : ∀ n < m, seq n = 0),\n                    { m := m, seq := seq, vanish := vanish } =\n                      { m := m, seq := seq_2,\n                        vanish :=\n                          Eq.ndrec (motive := fun m => ∀ n < m, seq_2 n = 0)\n                            (Eq.ndrec (motive := fun seq => ∀ n < m, seq n = 0) vanish e_seq) (Eq.refl m) })\n                  (fun vanish => Eq.refl { m := m, seq := seq, vanish := vanish }) e_seq)\n              e_m)\n          0 0 (Eq.refl 0) (fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0)\n          (fun n => if 0 ≤ n then (α + ε) ^ n.toNat else 0)\n          (funext fun n => ite_congr ge_iff_le._simp_1 (fun a => Eq.refl ((α + ε) ^ n.toNat)) fun a => Eq.refl 0)\n          (instCoe._proof_1 fun n => (α + ε) ^ n)))\n      (root_test_pos._simp_4 (α + ε)))\n    (Eq.trans (congrArg (fun x => x < 1) (abs_of_pos hα')) (eq_true hα)))","type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.converges","name":["hgeom"],"isProp":true,"id":["_uniq",41607]}]}],"start":2819},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",44816],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"}]}],"start":2862},{"state":[{"type":"(s.from N).absConverges","tag":[],"mvarId":["_uniq",44825],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"}]}],"start":2903},{"state":[{"type":"(s.from N).m =\n  ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n      ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n        (↑N.toNat : ℤ))).m","tag":[],"mvarId":["_uniq",44832],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"}]},{"type":"∀ n ≥ (s.from N).m,\n  |(s.from N).seq n| ≤\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n          ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n            (↑N.toNat : ℤ))).seq\n      n","tag":[],"mvarId":["_uniq",44833],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"}]}],"start":2945},{"state":[{"type":"∀ n ≥ (s.from N).m,\n  |(s.from N).seq n| ≤\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n          ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n            (↑N.toNat : ℤ))).seq\n      n","tag":[],"mvarId":["_uniq",44833],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"}]}],"start":2965},{"state":[{"type":"|(s.from N).seq n| ≤\n  ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n        ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n          (↑N.toNat : ℤ))).seq\n    n","tag":[],"mvarId":["_uniq",57302],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",53974],"binderInfo":"default"},{"type":"s.m ≤ n ∧ N ≤ n","name":["hn"],"isProp":true,"id":["_uniq",57299],"binderInfo":"default"}]}],"start":2994},{"state":[{"type":"|(s.from N).seq n| ≤\n  ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n        ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n          (↑N.toNat : ℤ))).seq\n    n","tag":[],"mvarId":["_uniq",57344],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",53974],"binderInfo":"default"},{"type":"s.m ≤ n ∧ N ≤ n","name":["hn"],"isProp":true,"id":["_uniq",57299],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_6 N' hNk n hn a","type":"n ≥ 0","name":["hn'"],"isProp":true,"id":["_uniq",57343]}]}],"start":3031},{"state":[{"type":"|s.seq n| ≤ (α + ε) ^ n.toNat","tag":[],"mvarId":["_uniq",68973],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",53974],"binderInfo":"default"},{"type":"s.m ≤ n ∧ N ≤ n","name":["hn"],"isProp":true,"id":["_uniq",57299],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_6 N' hNk n hn a","type":"n ≥ 0","name":["hn'"],"isProp":true,"id":["_uniq",57343]}]}],"start":3060},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",44827],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this✝"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"},{"value":"(converges_of_le\n    (Eq.mpr\n      (id\n        (congrArg (Eq (max s.m N))\n          (Eq.trans (congrArg (max 0) (Eq.trans (congrArg (HAdd.hAdd 0) (Int.ofNat_toNat N)) (zero_add (max N 0))))\n            (sup_of_le_right (of_eq_true le_sup_right._simp_1)))))\n      (Decidable.byContradiction fun a => root_test_pos._proof_5 N' hNk a))\n    (fun n hn =>\n      have hn' :=\n        Decidable.byContradiction fun a =>\n          root_test_pos._proof_6 N' hNk n (Eq.mp (Eq.trans ge_iff_le._simp_1 sup_le_iff._simp_1) hn) a;\n      Eq.mpr (id (Eq.trans (congr (congrArg (fun x => LE.le |x|) (dite_cond_eq_true ⋯)) ⋯) ⋯)) ⋯)\n    ⋯).left","type":"(s.from N).absConverges","name":["this"],"isProp":true,"id":["_uniq",44826]}]}],"start":3125},{"state":[{"type":"s.abs.converges","tag":[],"mvarId":["_uniq",72653],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this✝"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"},{"value":"(converges_of_le\n    (Eq.mpr\n      (id\n        (congrArg (Eq (max s.m N))\n          (Eq.trans (congrArg (max 0) (Eq.trans (congrArg (HAdd.hAdd 0) (Int.ofNat_toNat N)) (zero_add (max N 0))))\n            (sup_of_le_right (of_eq_true le_sup_right._simp_1)))))\n      (Decidable.byContradiction fun a => root_test_pos._proof_5 N' hNk a))\n    (fun n hn =>\n      have hn' :=\n        Decidable.byContradiction fun a =>\n          root_test_pos._proof_6 N' hNk n (Eq.mp (Eq.trans ge_iff_le._simp_1 sup_le_iff._simp_1) hn) a;\n      Eq.mpr (id (Eq.trans (congr (congrArg (fun x => LE.le |x|) (dite_cond_eq_true ⋯)) ⋯) ⋯)) ⋯)\n    ⋯).left","type":"(s.from N).abs.converges","name":["this"],"isProp":true,"id":["_uniq",44826]}]}],"start":3161},{"state":[{"type":"(fun n => if s.m + (↑k : ℤ) ≤ n then if s.m ≤ n then |s.seq n| else 0 else 0) = fun n =>\n  if s.m ≤ n ∧ N ≤ n then |if s.m ≤ n ∧ N ≤ n then s.seq n else 0| else 0","tag":["h","e'_1"],"mvarId":["_uniq",84252],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this✝"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"},{"value":"(converges_of_le\n    (Eq.mpr\n      (id\n        (congrArg (Eq (max s.m N))\n          (Eq.trans (congrArg (max 0) (Eq.trans (congrArg (HAdd.hAdd 0) (Int.ofNat_toNat N)) (zero_add (max N 0))))\n            (sup_of_le_right (of_eq_true le_sup_right._simp_1)))))\n      (Decidable.byContradiction fun a => root_test_pos._proof_5 N' hNk a))\n    (fun n hn =>\n      have hn' :=\n        Decidable.byContradiction fun a =>\n          root_test_pos._proof_6 N' hNk n (Eq.mp (Eq.trans ge_iff_le._simp_1 sup_le_iff._simp_1) hn) a;\n      Eq.mpr (id (Eq.trans (congr (congrArg (fun x => LE.le |x|) (dite_cond_eq_true ⋯)) ⋯) ⋯)) ⋯)\n    ⋯).left","type":"(s.from N).abs.converges","name":["this"],"isProp":true,"id":["_uniq",44826]}]}],"start":3238},{"state":[{"type":"(if s.m + (↑k : ℤ) ≤ n then if s.m ≤ n then |s.seq n| else 0 else 0) =\n  if s.m ≤ n ∧ N ≤ n then |if s.m ≤ n ∧ N ≤ n then s.seq n else 0| else 0","tag":["h","e'_1","h"],"mvarId":["_uniq",84646],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this✝"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"},{"value":"(converges_of_le\n    (Eq.mpr\n      (id\n        (congrArg (Eq (max s.m N))\n          (Eq.trans (congrArg (max 0) (Eq.trans (congrArg (HAdd.hAdd 0) (Int.ofNat_toNat N)) (zero_add (max N 0))))\n            (sup_of_le_right (of_eq_true le_sup_right._simp_1)))))\n      (Decidable.byContradiction fun a => root_test_pos._proof_5 N' hNk a))\n    (fun n hn =>\n      have hn' :=\n        Decidable.byContradiction fun a =>\n          root_test_pos._proof_6 N' hNk n (Eq.mp (Eq.trans ge_iff_le._simp_1 sup_le_iff._simp_1) hn) a;\n      Eq.mpr (id (Eq.trans (congr (congrArg (fun x => LE.le |x|) (dite_cond_eq_true ⋯)) ⋯) ⋯)) ⋯)\n    ⋯).left","type":"(s.from N).abs.converges","name":["this"],"isProp":true,"id":["_uniq",44826]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",84645],"binderInfo":"default"}]}],"start":3248},{"state":[{"type":"(if s.m + (↑k : ℤ) ≤ n then |s.seq n| else 0) = if N ≤ n then |if N ≤ n then s.seq n else 0| else 0","tag":["pos","_@","_hyg",2214],"mvarId":["_uniq",87413],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",669],"binderInfo":"implicit"},{"value":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","type":"EReal","name":["α'"],"isProp":false,"id":["_uniq",1291]},{"value":"α'.toReal","type":"ℝ","name":["α"],"isProp":false,"id":["_uniq",4877]},{"type":"α' = (↑α : EReal)","name":["hαα'"],"isProp":true,"id":["_uniq",6576],"binderInfo":"default"},{"type":"α < 1","name":["h"],"isProp":true,"id":["_uniq",7965],"binderInfo":"default"},{"type":"0 ≤ α","name":["hpos"],"isProp":true,"id":["_uniq",8142],"binderInfo":"default"},{"value":"(1 - α) / 2","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",8335]},{"value":"Eq.mpr (id (Eq.trans (div_pos_iff_of_pos_right._simp_1 (of_eq_true Nat.ofNat_pos._simp_1)) one_lt_div'._simp_4))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le a))))","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",8463]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(α + ε) : EReal)) hαα'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                    (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                      (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                            (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                          (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                              (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                  (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                    (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                            (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                        (Mathlib.Tactic.Ring.atom_pf α)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                      (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                        (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                          (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                            (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                              (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                    (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                              (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (NNRat.rawCast 1 2)\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap (Mathlib.Tactic.Ring.add_overlap_pf ⋯ ⋯ ⋯) ⋯)))\n                  ⋯ ⋯)\n                ⋯)\n              ⋯))\n          ⋯)))","type":"α' < (↑(α + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",12147]},{"value":"id\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Int.negOfNat 1).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 2 + 0))))\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.mul_one (Nat.rawCast 2)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 2 + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.mul_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf α)\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right α (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1))))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt h)\n          (Eq.mp\n            (congrArg (fun _a => _a ≤ 0)\n              (CancelDenoms.sub_subst rfl\n                (CancelDenoms.add_subst rfl\n                  (CancelDenoms.div_subst (CancelDenoms.sub_subst rfl rfl)\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                        (Mathlib.Meta.NormNum.isNNRat_div\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                    (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2))))\n                                (Eq.refl (Nat.mul 2 1)) (Eq.refl 2))))))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Meta.NormNum.isNat_eq_true\n                      (Mathlib.Meta.NormNum.isNat_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                        (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl 2))\n                      (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))))))\n            (Mathlib.Tactic.Linarith.mul_nonpos (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)\n              (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero)\n                (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)) (Eq.refl false)))))))","type":"α + ε < 1","name":["hα"],"isProp":true,"id":["_uniq",12438]},{"value":"lt_of_not_ge fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add (Mathlib.Tactic.Ring.one_mul (NNRat.rawCast 1 2))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (NNRat.rawCast 1 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_left α (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                  (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                    (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                          (Mathlib.Tactic.Ring.mul_zero (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero\n                            (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (NNRat.rawCast 1 2 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0)))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (NNRat.rawCast 1 2)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (α ^ Nat.rawCast 1 * Rat.rawCast (Int.negOfNat 1) 2 + 0))))))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                          (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                            (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                              (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                          (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                              (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                  (Mathlib.Meta.NormNum.IsRat.den_nz\n                                    (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                        (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                          (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                            (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                              (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                      (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                    (Rat.rawCast (Int.negOfNat 1) 2 + (α ^ Nat.rawCast 1 * NNRat.rawCast 1 2 + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_gt (Rat.rawCast (Int.negOfNat 1) 2)\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Tactic.Ring.add_overlap_pf α (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsRat.to_raw_eq\n                      (Mathlib.Meta.NormNum.isRat_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.to_isRat (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                              (Mathlib.Meta.NormNum.IsRat.to_isNNRat\n                                (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                  (Mathlib.Meta.NormNum.IsRat.of_raw ℝ (Int.negOfNat 1) 2\n                                    (Mathlib.Meta.NormNum.IsRat.den_nz\n                                      (Mathlib.Meta.NormNum.isRat_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.to_isRat\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)))\n                                        (Mathlib.Meta.NormNum.IsNNRat.to_isRat\n                                          (Mathlib.Meta.NormNum.IsNNRat.of_raw ℝ 1 2\n                                            (Mathlib.Meta.NormNum.IsNNRat.den_nz\n                                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2))))))\n                                        (Eq.refl ((Int.negOfNat 1).mul (Int.ofNat 1))) (Eq.refl 2))))\n                                  (Eq.refl ((Int.negOfNat 1).mul (Int.negOfNat 1))) (Eq.refl 2))))))\n                        (Eq.refl (Int.negOfNat 1)) (Eq.refl 2))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf α)\n                (Mathlib.Tactic.Ring.div_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf α)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul α (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (α ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.div_pf\n                    (Mathlib.Tactic.Ring.inv_single\n                      (Mathlib.Meta.NormNum.IsNNRat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 2)))))\n                    (Mathlib.Tactic.Ring.add_mul ⋯ ⋯ ⋯)))\n                ⋯)\n              ⋯ ⋯)\n            ⋯)\n          ⋯))\n      ⋯)","type":"0 < α + ε","name":["hα'"],"isProp":true,"id":["_uniq",14935]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",16471],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(|s.seq b| ^ (1 / (↑b : ℝ))) : EReal) < (↑(α + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",16475],"binderInfo":"default"},{"value":"max N' (max s.m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",16568]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => root_test_pos._proof_1 N' n hn a;\n  have npos := Decidable.byContradiction fun a => root_test_pos._proof_2 N' n hn this a;\n  Trans.trans\n    (Eq.mpr (id (congrArg (fun _a => |s.seq n| = _a) (Eq.symm (rpow_intCast (|s.seq n| ^ (1 / (↑n : ℝ))) n))))\n      (Eq.mpr\n        (id\n          (congrArg (fun _a => |s.seq n| = _a)\n            (Eq.symm (rpow_mul (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) (1 / (↑n : ℝ)) (↑n : ℝ)))))\n        (Eq.symm\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ (|s.seq n| ^ (1 / (↑n : ℝ) * (↑n : ℝ))) (|s.seq n| ^ 1)\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℝ ℝ instHPow |s.seq n| |s.seq n| (Eq.refl |s.seq n|) (1 / (↑n : ℝ) * (↑n : ℝ)) 1\n                    (of_eq_true\n                      (Eq.trans\n                        (congrArg (fun x => x = 1)\n                          (Eq.trans (div_mul_eq_mul_div 1 (↑n : ℝ) (↑n : ℝ))\n                            (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (one_mul (↑n : ℝ)))\n                              (_root_.div_self (ne_of_gt (Int.cast_pos.mpr npos))))))\n                        (eq_self 1)))))\n                |s.seq n| |s.seq n| (Eq.refl |s.seq n|)))\n            (rpow_one |s.seq n|)))))\n    (Eq.mpr\n      (eq_of_heq\n        ((fun α self self' e'_2 a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => self' = a_2 → e'_2 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun self' => ∀ (e_2 : self = self'), e_2 ≍ Eq.refl self → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_2 h =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                          (fun e_3 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                                  (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                              (Eq.refl a'_1) (HEq.refl e'_4))\n                          (Eq.symm h) e'_3)\n                      (Eq.refl a') (HEq.refl e'_3))\n                  (Eq.symm h) e'_2)\n              (Eq.refl self') (HEq.refl e'_2))\n          ℝ instLE instPreorder.toLE (Eq.refl instLE) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n)\n          ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (|s.seq n| ^ (1 / (↑n : ℝ))) (|s.seq n| ^ (1 / (↑n : ℝ)))\n                    (Eq.refl (|s.seq n| ^ (1 / (↑n : ℝ)))) n (↑n.toNat : ℤ)\n                    (Decidable.byContradiction fun a => root_test_pos._proof_3 N' n npos a)))\n                ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat) ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat)\n                (Eq.refl ((|s.seq n| ^ (1 / (↑n : ℝ))) ^ n.toNat))))\n            (zpow_natCast (|s.seq n| ^ (1 / (↑n : ℝ))) n.toNat))\n          ((α + ε) ^ n) ((α + ε) ^ n.toNat)\n          (Eq.mpr\n            (eq_of_heq\n              ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                  Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                    (fun h =>\n                      Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                        (fun e_2 h =>\n                          Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                            (fun h =>\n                              Eq.ndrec (motive := fun a' =>\n                                ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                            (Eq.refl a'_1) (HEq.refl e'_3))\n                        (Eq.symm h) e'_2)\n                    (Eq.refl a') (HEq.refl e'_2))\n                ℝ ((α + ε) ^ n) ((α + ε) ^ (↑n.toNat : ℤ))\n                (eq_of_heq\n                  ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                      Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                        (fun h =>\n                          Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                            (fun e_5 h =>\n                              Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                (fun h =>\n                                  Eq.ndrec (motive := fun a' =>\n                                    ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                    (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                (Eq.refl a'_1) (HEq.refl e'_6))\n                            (Eq.symm h) e'_5)\n                        (Eq.refl a') (HEq.refl e'_5))\n                    ℝ ℤ ℝ instHPow (α + ε) (α + ε) (Eq.refl (⋯ + ⋯)) ⋯ ⋯ ⋯))\n                ⋯ ⋯ ⋯))\n            ⋯)))\n      ⋯)","type":"∀ n ≥ N, |s.seq n| ≤ (α + ε) ^ n","name":["this✝"],"isProp":true,"id":["_uniq",16850]},{"value":"(N - s.m).toNat","type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",40279]},{"value":"Decidable.byContradiction fun a => root_test_pos._proof_4 N' a","type":"N = s.m + (↑k : ℤ)","name":["hNk"],"isProp":true,"id":["_uniq",40556]},{"type":"({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.from\n    ({ m := 0, seq := fun n => if n ≥ 0 then (fun n => (α + ε) ^ n) n.toNat else 0, vanish := ⋯ }.m +\n      (↑N.toNat : ℤ))).converges","name":["hgeom"],"isProp":true,"id":["_uniq",44813],"binderInfo":"default"},{"value":"(converges_of_le\n    (Eq.mpr\n      (id\n        (congrArg (Eq (max s.m N))\n          (Eq.trans (congrArg (max 0) (Eq.trans (congrArg (HAdd.hAdd 0) (Int.ofNat_toNat N)) (zero_add (max N 0))))\n            (sup_of_le_right (of_eq_true le_sup_right._simp_1)))))\n      (Decidable.byContradiction fun a => root_test_pos._proof_5 N' hNk a))\n    (fun n hn =>\n      have hn' :=\n        Decidable.byContradiction fun a =>\n          root_test_pos._proof_6 N' hNk n (Eq.mp (Eq.trans ge_iff_le._simp_1 sup_le_iff._simp_1) hn) a;\n      Eq.mpr (id (Eq.trans (congr (congrArg (fun x => LE.le |x|) (dite_cond_eq_true ⋯)) ⋯) ⋯)) ⋯)\n    ⋯).left","type":"(s.from N).abs.converges","name":["this"],"isProp":true,"id":["_uniq",44826]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",84645],"binderInfo":"default"},{"type":"n ≥ s.m","name":["hnm"],"isProp":true,"id":["_uniq",84673],"binderInfo":"default"}]}],"start":3292},{"state":[],"start":3341},{"state":[],"start":3342},{"state":[],"start":3343},{"state":[],"start":3379},{"state":[],"start":3421},{"state":[{"type":"s.diverges","tag":[],"mvarId":["_uniq",156179],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",156177],"binderInfo":"implicit"},{"type":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop > 1","name":["h"],"isProp":true,"id":["_uniq",156178],"binderInfo":"default"}]}],"start":3513},{"state":[{"type":"s.diverges","tag":[],"mvarId":["_uniq",156179],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",156177],"binderInfo":"implicit"},{"type":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop > 1","name":["h"],"isProp":true,"id":["_uniq",156178],"binderInfo":"default"}]}],"start":3588},{"state":[{"type":"s.diverges","tag":[],"mvarId":["_uniq",156255],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",156177],"binderInfo":"implicit"},{"type":"∃ᶠ (x : ℤ) in atTop, 1 < (↑(|s.seq x| ^ (1 / (↑x : ℝ))) : EReal)","name":["h"],"isProp":true,"id":["_uniq",156252],"binderInfo":"default"}]}],"start":3652},{"state":[{"type":"¬Tendsto s.seq atTop (nhds 0)","tag":["h"],"mvarId":["_uniq",156390],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",156177],"binderInfo":"implicit"},{"type":"∃ᶠ (x : ℤ) in atTop, 1 < (↑(|s.seq x| ^ (1 / (↑x : ℝ))) : EReal)","name":["h"],"isProp":true,"id":["_uniq",156252],"binderInfo":"default"}]}],"start":3682},{"state":[{"type":"False","tag":["h"],"mvarId":["_uniq",157638],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",156177],"binderInfo":"implicit"},{"type":"∃ᶠ (x : ℤ) in atTop, 1 < (↑(|s.seq x| ^ (1 / (↑x : ℝ))) : EReal)","name":["h"],"isProp":true,"id":["_uniq",156252],"binderInfo":"default"},{"type":"∀ᶠ (b : ℤ) in atTop, |s.seq b - 0| < 1","name":["this"],"isProp":true,"id":["_uniq",157635],"binderInfo":"default"}]}],"start":3789},{"state":[{"type":"False","tag":["h"],"mvarId":["_uniq",157821],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",156177],"binderInfo":"implicit"},{"type":"∃ᶠ (x : ℤ) in atTop, 1 < (↑(|s.seq x| ^ (1 / (↑x : ℝ))) : EReal)","name":["h"],"isProp":true,"id":["_uniq",156252],"binderInfo":"default"},{"type":"∀ᶠ (b : ℤ) in atTop, |s.seq b - 0| < 1","name":["this"],"isProp":true,"id":["_uniq",157635],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",157799],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",157807],"binderInfo":"default"},{"type":"1 < (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)","name":["hs"],"isProp":true,"id":["_uniq",157816],"binderInfo":"default"},{"type":"|s.seq n - 0| < 1","name":["hs'"],"isProp":true,"id":["_uniq",157820],"binderInfo":"default"}]}],"start":3867},{"state":[{"type":"False","tag":["h","refine_3"],"mvarId":["_uniq",158955],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",156177],"binderInfo":"implicit"},{"type":"∃ᶠ (x : ℤ) in atTop, 1 < (↑(|s.seq x| ^ (1 / (↑x : ℝ))) : EReal)","name":["h"],"isProp":true,"id":["_uniq",156252],"binderInfo":"default"},{"type":"∀ᶠ (b : ℤ) in atTop, |s.seq b - 0| < 1","name":["this"],"isProp":true,"id":["_uniq",157635],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",157799],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",157807],"binderInfo":"default"},{"type":"1 < (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)","name":["hs"],"isProp":true,"id":["_uniq",157816],"binderInfo":"default"},{"value":"rpow_lt_one (IsAbsoluteValue.abv_nonneg _root_.abs (s.seq n)) _fvar.158748\n  (_root_.div_pos\n    (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))\n    (Int.cast_pos.mpr\n      (lt_of_lt_of_le\n        (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)) (Eq.refl (Nat.ble 1 1)))\n        hn)))","type":"|s.seq n| ^ (1 / (↑n : ℝ)) < 1","name":["hs'"],"isProp":true,"id":["_uniq",158951]}]}],"start":3956},{"state":[{"type":"False","tag":["h","refine_3"],"mvarId":["_uniq",162855],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",156177],"binderInfo":"implicit"},{"type":"∃ᶠ (x : ℤ) in atTop, 1 < (↑(|s.seq x| ^ (1 / (↑x : ℝ))) : EReal)","name":["h"],"isProp":true,"id":["_uniq",156252],"binderInfo":"default"},{"type":"∀ᶠ (b : ℤ) in atTop, |s.seq b - 0| < 1","name":["this"],"isProp":true,"id":["_uniq",157635],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",157799],"binderInfo":"default"},{"type":"n ≥ 1","name":["hn"],"isProp":true,"id":["_uniq",157807],"binderInfo":"default"},{"type":"1 < |s.seq n| ^ (1 / (↑n : ℝ))","name":["hs"],"isProp":true,"id":["_uniq",162849],"binderInfo":"default"},{"type":"|s.seq n| ^ (1 / (↑n : ℝ)) < 1","name":["hs'"],"isProp":true,"id":["_uniq",162852],"binderInfo":"default"}]}],"start":4026},{"state":[],"start":4039},{"state":[],"start":4040},{"state":[],"start":4093},{"state":[],"start":4146},{"state":[{"type":"∃ s, Tendsto (fun n => |s.seq n| ^ (1 / (↑n : ℝ))) atTop (nhds 1) ∧ s.diverges","tag":[],"mvarId":["_uniq",165248],"isProp":true,"context":[]}],"start":4226},{"state":[],"start":4236},{"state":[],"start":4237},{"state":[],"start":4287},{"state":[],"start":4342},{"state":[{"type":"∃ s, Tendsto (fun n => |s.seq n| ^ (1 / (↑n : ℝ))) atTop (nhds 1) ∧ s.absConverges","tag":[],"mvarId":["_uniq",165882],"isProp":true,"context":[]}],"start":4426},{"state":[],"start":4436},{"state":[],"start":4437},{"state":[],"start":4473},{"state":[],"start":4554},{"state":[],"start":4613},{"state":[],"start":4669},{"state":[],"start":4736},{"state":[],"start":4792},{"state":[],"start":4859},{"state":[],"start":4911},{"state":[{"type":"liminf (fun n => (↑(c (n + 1) / c n) : EReal)) atTop ≤ liminf (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ∧\n  liminf (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤\n      limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ∧\n    limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","tag":[],"mvarId":["_uniq",168399],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"}]}],"start":4921},{"state":[{"type":"liminf (fun n => (↑(c (n + 1) / c n) : EReal)) atTop ≤ liminf (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ∧\n  liminf (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤\n      limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ∧\n    limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","tag":[],"mvarId":["_uniq",168399],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"}]}],"start":4994},{"state":[{"type":"liminf (fun n => (↑(c (n + 1) / c n) : EReal)) atTop ≤ liminf (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop","tag":["refine_1"],"mvarId":["_uniq",168406],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"}]},{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","tag":["refine_4"],"mvarId":["_uniq",168770],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"}]}],"start":5067},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","tag":["refine_4"],"mvarId":["_uniq",168770],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"}]}],"start":5077},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ L'","tag":["refine_4"],"mvarId":["_uniq",169719],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]}]}],"start":5143},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ L'","tag":["neg","_@","_hyg",3195],"mvarId":["_uniq",169915],"isProp":false,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"}]}],"start":5179},{"state":[{"type":"0 ≤ L'","tag":[],"mvarId":["_uniq",171007],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"}]}],"start":5210},{"state":[{"type":"∃ᶠ (a : ℤ) in atTop, 0 ≤ (↑(c (a + 1) / c a) : EReal)","tag":["h"],"mvarId":["_uniq",171045],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"}]}],"start":5248},{"state":[{"type":"∀ (a : ℤ), ∃ b ≥ a, 0 ≤ (↑(c (b + 1) / c b) : EReal)","tag":["h"],"mvarId":["_uniq",171493],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"}]}],"start":5274},{"state":[{"type":"0 ≤ (↑(c (max N m + 1) / c (max N m)) : EReal)","tag":["right"],"mvarId":["_uniq",171849],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",171758],"binderInfo":"default"}]}],"start":5309},{"state":[{"type":"0 ≤ (↑(c (max N m + 1) / c (max N m)) : EReal)","tag":["right"],"mvarId":["_uniq",172110],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",171758],"binderInfo":"default"},{"value":"hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a)","type":"c (max N m) > 0","name":["hpos1"],"isProp":true,"id":["_uniq",172109]}]}],"start":5353},{"state":[{"type":"0 ≤ (↑(c (max N m + 1) / c (max N m)) : EReal)","tag":["right"],"mvarId":["_uniq",172334],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",171758],"binderInfo":"default"},{"value":"hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a)","type":"c (max N m) > 0","name":["hpos1"],"isProp":true,"id":["_uniq",172109]},{"value":"hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a)","type":"c (max N m + 1) > 0","name":["hpos2"],"isProp":true,"id":["_uniq",172333]}]}],"start":5401},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ L'","tag":["neg","_@","_hyg",3195],"mvarId":["_uniq",171009],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]}]}],"start":5416},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ L'","tag":["neg","_@","_hyg",3195],"mvarId":["_uniq",175340],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]}]}],"start":5452},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ L'","tag":["neg","_@","_hyg",3195],"mvarId":["_uniq",175350],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]}]}],"start":5473},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ L'","tag":["neg","_@","_hyg",3195],"mvarId":["_uniq",175597],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]}]}],"start":5521},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ L'","tag":["neg","_@","_hyg",3195],"mvarId":["_uniq",175658],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]}]}],"start":5590},{"state":[{"type":"∀ (a : EReal), L' < a → limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ a","tag":["neg","h","_@","_hyg",3195],"mvarId":["_uniq",176222],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]}]}],"start":5630},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ y","tag":["neg","h","_@","_hyg",3195],"mvarId":["_uniq",176267],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L' < y","name":["hy"],"isProp":true,"id":["_uniq",176266],"binderInfo":"default"}]}],"start":5643},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ y","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",176428],"isProp":false,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L' < y","name":["hy"],"isProp":true,"id":["_uniq",176266],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",176427],"binderInfo":"default"}]}],"start":5680},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ y","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",177607],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L' < y","name":["hy"],"isProp":true,"id":["_uniq",176266],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",176427],"binderInfo":"default"},{"value":"Eq.symm\n  (coe_toReal hy'\n    (Mathlib.Tactic.Contrapose.mtr\n      (Eq.mpr (id (implies_congr (Mathlib.Tactic.PushNeg.not_ne_eq y ⊥) (Mathlib.Tactic.PushNeg.not_lt_eq L' y)))\n        fun hy => of_eq_true (Eq.trans (congrArg (fun x => x ≤ L') hy) bot_le._simp_1))\n      hy))","type":"y = (↑y.toReal : EReal)","name":["this"],"isProp":true,"id":["_uniq",177606]}]}],"start":5762},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ y","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",178751],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"type":"y = (↑y.toReal : EReal)","name":["this"],"isProp":true,"id":["_uniq",178748],"binderInfo":"default"}]}],"start":5807},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ y","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",178802],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"type":"y = (↑y.toReal : EReal)","name":["this"],"isProp":true,"id":["_uniq",178748],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]}]}],"start":5832},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ y","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",179009],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"type":"y = (↑y.toReal : EReal)","name":["this"],"isProp":true,"id":["_uniq",178748],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' this","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]}]}],"start":5864},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ y","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",183529],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",182113]}]}],"start":5926},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",183534],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",182113]}]}],"start":5938},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",183658],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]}]}],"start":6015},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",184645],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"value":"eventually_lt_of_limsup_lt hε' isBounded_le_of_top","type":"∀ᶠ (a : ℤ) in atTop, (↑(c (a + 1) / c a) : EReal) < (↑(L + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",184644]}]}],"start":6079},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",185505],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"}]}],"start":6136},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",185596],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]}]}],"start":6164},{"state":[{"type":"c (n + 1) / c n ≤ L + ε","tag":[],"mvarId":["_uniq",185990],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",185805],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",185813],"binderInfo":"default"}]}],"start":6228},{"state":[{"type":"c (n + 1) / c n ≤ L + ε","tag":[],"mvarId":["_uniq",186006],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",185805],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",185813],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",186005]}]}],"start":6260},{"state":[{"type":"c (n + 1) / c n ≤ L + ε","tag":[],"mvarId":["_uniq",186234],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",185805],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",185813],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a","type":"n ≥ N'","name":["this"],"isProp":true,"id":["_uniq",186005]},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a","type":"0 < n","name":["npos"],"isProp":true,"id":["_uniq",186233]}]}],"start":6294},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",185995],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]}]}],"start":6343},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",192883],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]}]}],"start":6372},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",193152],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]}]}],"start":6437},{"state":[{"type":"c n ≤ A * (L + ε) ^ n","tag":[],"mvarId":["_uniq",206645],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206492],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206499],"binderInfo":"default"}]}],"start":6500},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",206650],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]}]}],"start":6510},{"state":[{"type":"(↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","tag":[],"mvarId":["_uniq",207162],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"}]}],"start":6622},{"state":[{"type":"c n ^ (1 / (↑n : ℝ)) ≤ A ^ (1 / (↑n : ℝ)) * (L + ε)","tag":[],"mvarId":["_uniq",207177],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"}]}],"start":6652},{"state":[{"type":"c n ^ (1 / (↑n : ℝ)) ≤ A ^ (1 / (↑n : ℝ)) * (L + ε)","tag":[],"mvarId":["_uniq",207225],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a","type":"n > 0","name":["hn'"],"isProp":true,"id":["_uniq",207224]}]}],"start":6685},{"state":[{"type":"c n ^ (1 / (↑n : ℝ)) ≤ A ^ (1 / (↑n : ℝ)) * (L + ε)","tag":[],"mvarId":["_uniq",207225],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a","type":"n > 0","name":["hn'"],"isProp":true,"id":["_uniq",207224]}]}],"start":6694},{"state":[{"type":"c n ^ (1 / (↑n : ℝ)) ≤ (A * (L + ε) ^ n) ^ (1 / (↑n : ℝ))","tag":[],"mvarId":["_uniq",207851],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a","type":"n > 0","name":["hn'"],"isProp":true,"id":["_uniq",207224]}]}],"start":6739},{"state":[],"start":6814},{"state":[],"start":6907},{"state":[{"type":"A ^ (1 / (↑n : ℝ)) * ((L + ε) ^ n) ^ (1 / (↑n : ℝ)) = A ^ (1 / (↑n : ℝ)) * (L + ε)","tag":[],"mvarId":["_uniq",208198],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a","type":"n > 0","name":["hn'"],"isProp":true,"id":["_uniq",207224]}]}],"start":6925},{"state":[{"type":"((L + ε) ^ n) ^ (1 / (↑n : ℝ)) = L + ε","tag":["e_a","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",232104],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a","type":"n > 0","name":["hn'"],"isProp":true,"id":["_uniq",207224]}]}],"start":6939},{"state":[{"type":"(L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ))) = L + ε","tag":["e_a","_@","Init","Prelude","_hyg",2166],"mvarId":["_uniq",232482],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a","type":"n > 0","name":["hn'"],"isProp":true,"id":["_uniq",207224]}]}],"start":6997},{"state":[{"type":"(↑n : ℝ) * (1 / (↑n : ℝ)) = 1","tag":["h","e'_2","h","e'_6"],"mvarId":["_uniq",243753],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",206657],"binderInfo":"default"},{"type":"n ≥ N","name":["hn"],"isProp":true,"id":["_uniq",206662],"binderInfo":"default"},{"value":"Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a","type":"n > 0","name":["hn'"],"isProp":true,"id":["_uniq",207224]}]}],"start":7024},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",207167],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7043},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤ (↑(L + ε) : EReal)","tag":["neg","_@","_hyg",3670],"mvarId":["_uniq",207167],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7050},{"state":[{"type":"limsup (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤\n  limsup (fun n => (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)) atTop","tag":[],"mvarId":["_uniq",250369],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7132},{"state":[{"type":"(fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) ≤ᶠ[atTop] fun n => (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","tag":["h"],"mvarId":["_uniq",251314],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7186},{"state":[{"type":"∃ a, ∀ b ≥ a, (fun n => (↑(c n ^ (1 / (↑n : ℝ))) : EReal)) b ≤ (fun n => (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)) b","tag":["h"],"mvarId":["_uniq",252057],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7235},{"state":[],"start":7247},{"state":[{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)) atTop ≤\n  limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop * limsup (fun n => (↑(L + ε) : EReal)) atTop","tag":[],"mvarId":["_uniq",251051],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7374},{"state":[{"type":"(↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal) = ((fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) * fun n => (↑(L + ε) : EReal)) n","tag":["h","e'_3","h","e'_4","h"],"mvarId":["_uniq",253833],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",253832],"binderInfo":"default"}]},{"type":"∃ᶠ (x : ℤ) in atTop, 0 ≤ (↑(A ^ (1 / (↑x : ℝ))) : EReal)","tag":["convert_5"],"mvarId":["_uniq",252375],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"0 ≤ᶠ[atTop] fun n => (↑(L + ε) : EReal)","tag":["convert_6"],"mvarId":["_uniq",252376],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ 0 ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ ⊤","tag":["convert_7"],"mvarId":["_uniq",252377],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ ⊤ ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ 0","tag":["convert_8"],"mvarId":["_uniq",252378],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7423},{"state":[{"type":"∃ᶠ (x : ℤ) in atTop, 0 ≤ (↑(A ^ (1 / (↑x : ℝ))) : EReal)","tag":["convert_5"],"mvarId":["_uniq",252375],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"0 ≤ᶠ[atTop] fun n => (↑(L + ε) : EReal)","tag":["convert_6"],"mvarId":["_uniq",252376],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ 0 ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ ⊤","tag":["convert_7"],"mvarId":["_uniq",252377],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ ⊤ ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ 0","tag":["convert_8"],"mvarId":["_uniq",252378],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7435},{"state":[{"type":"0 ≤ᶠ[atTop] fun n => (↑(L + ε) : EReal)","tag":["convert_6"],"mvarId":["_uniq",252376],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ 0 ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ ⊤","tag":["convert_7"],"mvarId":["_uniq",252377],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ ⊤ ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ 0","tag":["convert_8"],"mvarId":["_uniq",252378],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7490},{"state":[{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ 0 ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ ⊤","tag":["convert_7"],"mvarId":["_uniq",252377],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ ⊤ ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ 0","tag":["convert_8"],"mvarId":["_uniq",252378],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7543},{"state":[{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop ≠ ⊤ ∨ limsup (fun n => (↑(L + ε) : EReal)) atTop ≠ 0","tag":["convert_8"],"mvarId":["_uniq",252378],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7567},{"state":[],"start":7596},{"state":[{"type":"limsup (fun n => (↑(A ^ (1 / (↑n : ℝ))) : EReal)) atTop * limsup (fun n => (↑(L + ε) : EReal)) atTop =\n  (↑(L + ε) : EReal)","tag":[],"mvarId":["_uniq",251218],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7621},{"state":[{"type":"limsup (fun n => (↑(A ^ (↑n : ℝ)⁻¹) : EReal)) atTop = 1","tag":["h","e'_2","h","e'_5"],"mvarId":["_uniq",290137],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7651},{"state":[{"type":"Tendsto (fun n => (↑(A ^ (↑n : ℝ)⁻¹) : EReal)) atTop (nhds 1)","tag":["h","e'_2","h","e'_5","h"],"mvarId":["_uniq",291265],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7681},{"state":[{"type":"Tendsto (fun x => (↑x : EReal)) (nhds 1) (nhds 1)","tag":["h","e'_2","h","e'_5","h","convert_3"],"mvarId":["_uniq",291690],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"Tendsto (fun n => A ^ (↑n : ℝ)⁻¹) atTop (nhds 1)","tag":["h","e'_2","h","e'_5","h","convert_4"],"mvarId":["_uniq",291691],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7797},{"state":[{"type":"Tendsto (fun n => A ^ (↑n : ℝ)⁻¹) atTop (nhds 1)","tag":["h","e'_2","h","e'_5","h","convert_4"],"mvarId":["_uniq",291691],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7856},{"state":[{"type":"Tendsto (fun x => A ^ x) (nhds 0) (nhds 1)","tag":["h","e'_2","h","e'_5","h","convert_4","convert_3"],"mvarId":["_uniq",293712],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]},{"type":"Tendsto (fun n => (↑n : ℝ)⁻¹) atTop (nhds 0)","tag":["h","e'_2","h","e'_5","h","convert_4","convert_4"],"mvarId":["_uniq",293713],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":7960},{"state":[{"type":"Tendsto (fun n => (↑n : ℝ)⁻¹) atTop (nhds 0)","tag":["h","e'_2","h","e'_5","h","convert_4","convert_4"],"mvarId":["_uniq",293713],"isProp":true,"context":[{"type":"ℤ → ℝ","name":["c"],"isProp":false,"id":["_uniq",168394],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",168395],"binderInfo":"default"},{"type":"∀ n ≥ m, c n > 0","name":["hpos"],"isProp":true,"id":["_uniq",168396],"binderInfo":"default"},{"value":"limsup (fun n => (↑(c (n + 1) / c n) : EReal)) atTop","type":"EReal","name":["L'"],"isProp":false,"id":["_uniq",169684]},{"type":"¬L' = ⊤","name":["hL"],"isProp":true,"id":["_uniq",169914],"binderInfo":"default"},{"value":"le_limsup_of_frequently_le'\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext frequently_atTop))) fun N =>\n    Exists.intro (max N m)\n      ⟨Decidable.byContradiction fun a => ratio_ineq._proof_1 m N a,\n        have hpos1 := hpos (max N m) (Decidable.byContradiction fun a => ratio_ineq._proof_2 m N a);\n        have hpos2 := hpos (max N m + 1) (Decidable.byContradiction fun a => ratio_ineq._proof_3 m N a);\n        le_of_lt (EReal.coe_pos.mpr (_root_.div_pos hpos2 hpos1))⟩)","type":"0 ≤ L'","name":["hL'pos"],"isProp":true,"id":["_uniq",171008]},{"value":"sorry","type":"L' ≠ ⊥","name":["why"],"isProp":true,"id":["_uniq",175339]},{"value":"L'.toReal","type":"ℝ","name":["L"],"isProp":false,"id":["_uniq",175349]},{"value":"Eq.symm (coe_toReal hL why)","type":"L' = (↑L : EReal)","name":["hL'"],"isProp":true,"id":["_uniq",175596]},{"value":"Eq.mp\n  (Eq.trans\n    (Eq.trans (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.symm Nat.cast_zero))\n      (Eq.trans\n        (congrArg (fun x => x ≤ (↑L : EReal)) (Eq.trans Nat.cast_zero (Eq.symm (congrArg toEReal Nat.cast_zero))))\n        coe_le_coe_iff._simp_1))\n    (congrArg (fun x => x ≤ L) Nat.cast_zero))\n  (Eq.mp (congrArg (fun _a => 0 ≤ _a) hL') hL'pos)","type":"0 ≤ L","name":["hLpos"],"isProp":true,"id":["_uniq",175657]},{"type":"EReal","name":["y"],"isProp":false,"id":["_uniq",176263],"binderInfo":"default"},{"type":"L < y.toReal","name":["hy"],"isProp":true,"id":["_uniq",178744],"binderInfo":"default"},{"type":"¬y = ⊤","name":["hy'"],"isProp":true,"id":["_uniq",178747],"binderInfo":"default"},{"value":"y.toReal - L","type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",178801]},{"value":"ratio_ineq._proof_4 m hpos hL hL'pos why hL' hLpos y hy hy' _fvar.178748","type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",179008]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun α a a_1 a' e'_3 =>\n        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a')) e'_3\n          (fun h =>\n            Eq.ndrec (motive := fun a' => ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n              (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n          (Eq.refl a') (HEq.refl e'_3))\n      EReal y (↑(L + ε) : EReal) (↑y.toReal : EReal)\n      (eq_of_heq\n        ((fun a a' e'_1 =>\n            Eq.casesOn (motive := fun a_1 x => a' = a_1 → e'_1 ≍ x → (↑a : EReal) ≍ (↑a' : EReal)) e'_1\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_1 : a = a'), e_1 ≍ Eq.refl a → (↑a : EReal) ≍ (↑a' : EReal))\n                  (fun e_1 h => HEq.refl (↑a : EReal)) (Eq.symm h) e'_1)\n              (Eq.refl a') (HEq.refl e'_1))\n          (L + ε) y.toReal\n          (of_eq_true (Eq.trans (congrArg (fun x => x = y.toReal) (add_sub_cancel L y.toReal)) (eq_self y.toReal)))))))\n  _fvar.178748","type":"y = (↑(L + ε) : EReal)","name":["this✝"],"isProp":true,"id":["_uniq",182113]},{"value":"Eq.mpr (id (congrArg (fun _a => _a < (↑(L + ε) : EReal)) hL'))\n  (Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_lt_coe_iff)))\n    (lt_of_not_ge fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf L) (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul y.toReal (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (L ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf L)\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf y.toReal)\n                      (Mathlib.Tactic.Ring.atom_pf L)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf L)\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul L (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (L ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (y.toReal ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero L (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero y.toReal (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hy)\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)))))","type":"L' < (↑(L + ε) : EReal)","name":["hε'"],"isProp":true,"id":["_uniq",183657]},{"type":"ℤ","name":["N'"],"isProp":false,"id":["_uniq",185498],"binderInfo":"default"},{"type":"∀ b ≥ N', (↑(c (b + 1) / c b) : EReal) < (↑(L + ε) : EReal)","name":["hN"],"isProp":true,"id":["_uniq",185502],"binderInfo":"default"},{"value":"max N' (max m 1)","type":"ℤ","name":["N"],"isProp":false,"id":["_uniq",185595]},{"value":"fun n hn =>\n  have this := Decidable.byContradiction fun a => ratio_ineq._proof_5 m N' n hn a;\n  have npos := Decidable.byContradiction fun a => ratio_ineq._proof_6 m N' n hn this a;\n  Decidable.byContradiction fun a =>\n    ne_of_lt\n      (Eq.mp\n        (Eq.trans\n          (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n            coe_lt_coe_iff._simp_1)\n          (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n        (hN n this))\n      (le_antisymm\n        (le_trans\n          (le_of_lt\n            (Eq.mp\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => (↑(c (n + x) / c n) : EReal) < (↑(L + ε) : EReal)) (Eq.symm Nat.cast_one))\n                  coe_lt_coe_iff._simp_1)\n                (congrArg (fun x => c (n + x) / c n < L + ε) Nat.cast_one))\n              (hN n this)))\n          (le_refl (L + ε)))\n        (le_trans (le_of_not_ge a) (le_refl (c (n + 1) / c n))))","type":"∀ n ≥ N, c (n + 1) / c n ≤ L + ε","name":["this"],"isProp":true,"id":["_uniq",185992]},{"value":"c N * (L + ε) ^ (-N)","type":"ℝ","name":["A"],"isProp":false,"id":["_uniq",192882]},{"value":"mul_pos (hpos N (Decidable.byContradiction fun a => ratio_ineq._proof_7 m N' a))\n  (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) (-N))","type":"0 < A","name":["hA"],"isProp":true,"id":["_uniq",193151]},{"value":"fun n hn => sorry","type":"∀ n ≥ N, c n ≤ A * (L + ε) ^ n","name":["why2"],"isProp":true,"id":["_uniq",206647]},{"value":"fun n hn =>\n  Eq.mpr (id (congrArg (fun _a => _a) (propext EReal.coe_le_coe_iff)))\n    (have hn' := Decidable.byContradiction fun a => ratio_ineq._proof_8 m N' n hn a;\n    Trans.trans\n      (Trans.trans\n        (rpow_le_rpow (le_of_lt (hpos n (Decidable.byContradiction fun a => ratio_ineq._proof_9 m N' n hn hn' a)))\n          (why2 n hn)\n          (le_of_lt\n            (_root_.div_pos\n              (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one)\n                (Eq.refl (Nat.ble 1 1)))\n              (Int.cast_pos.mpr hn'))))\n        (mul_rpow (le_of_lt hA) (le_of_lt (zpow_pos (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε) n))))\n      ((fun {α β γ} [HMul α β γ] a a_1 e_a =>\n          Eq.rec (motive := fun a_2 e_a => ∀ (a_3 a_4 : β), a_3 = a_4 → a * a_3 = a_2 * a_4)\n            (fun a_2 a_3 e_a => e_a ▸ Eq.refl (a * a_2)) e_a)\n        (A ^ (1 / (↑n : ℝ))) (A ^ (1 / (↑n : ℝ))) (Eq.refl (A ^ (1 / (↑n : ℝ)))) (((L + ε) ^ n) ^ (1 / (↑n : ℝ)))\n        (L + ε)\n        (Eq.mpr (id (congrArg (fun _a => _a ^ (1 / (↑n : ℝ)) = L + ε) (Eq.symm (rpow_intCast (L + ε) n))))\n          (Eq.mpr\n            (id\n              (congrArg (fun _a => _a = L + ε)\n                (Eq.symm\n                  (rpow_mul (le_of_lt (Right.add_pos_of_nonneg_of_pos (toReal_nonneg hL'pos) hε)) (↑n : ℝ)\n                    (1 / (↑n : ℝ))))))\n            (Eq.mpr\n              (eq_of_heq\n                ((fun α a a' e'_2 a_1 a'_1 e'_3 =>\n                    Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_2 ≍ x → (a = a_1) ≍ (a' = a'_1)) e'_2\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_2 : a = a'), e_2 ≍ Eq.refl a → (a = a_1) ≍ (a' = a'_1))\n                          (fun e_2 h =>\n                            Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_3 ≍ x → (a = a_1) ≍ (a = a'_1)) e'_3\n                              (fun h =>\n                                Eq.ndrec (motive := fun a' =>\n                                  ∀ (e_3 : a_1 = a'), e_3 ≍ Eq.refl a_1 → (a = a_1) ≍ (a = a'))\n                                  (fun e_3 h => HEq.refl (a = a_1)) (Eq.symm h) e'_3)\n                              (Eq.refl a'_1) (HEq.refl e'_3))\n                          (Eq.symm h) e'_2)\n                      (Eq.refl a') (HEq.refl e'_2))\n                  ℝ ((L + ε) ^ ((↑n : ℝ) * (1 / (↑n : ℝ)))) ((L + ε) ^ 1)\n                  (eq_of_heq\n                    ((fun α β γ self a a' e'_5 a_1 a'_1 e'_6 =>\n                        Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_5 ≍ x → a ^ a_1 ≍ a' ^ a'_1) e'_5\n                          (fun h =>\n                            Eq.ndrec (motive := fun a' => ∀ (e_5 : a = a'), e_5 ≍ Eq.refl a → a ^ a_1 ≍ a' ^ a'_1)\n                              (fun e_5 h =>\n                                Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_6 ≍ x → a ^ a_1 ≍ a ^ a'_1) e'_6\n                                  (fun h =>\n                                    Eq.ndrec (motive := fun a' =>\n                                      ∀ (e_6 : a_1 = a'), e_6 ≍ Eq.refl a_1 → a ^ a_1 ≍ a ^ a')\n                                      (fun e_6 h => HEq.refl (a ^ a_1)) (Eq.symm h) e'_6)\n                                  (Eq.refl a'_1) (HEq.refl e'_6))\n                              (Eq.symm h) e'_5)\n                          (Eq.refl a') (HEq.refl e'_5))\n                      ℝ ℝ ℝ instHPow (L + ε) (L + ε) (Eq.refl (L + ε)) ((↑n : ℝ) * (1 / (↑n : ℝ))) 1\n                      (of_eq_true\n                        (Eq.trans\n                          (congrArg (fun x => x = 1)\n                            (Eq.trans (mul_div_assoc' (↑n : ℝ) 1 (↑n : ℝ))\n                              (Eq.trans (congrArg (fun x => x / (↑n : ℝ)) (mul_one (↑n : ℝ)))\n                                (_root_.div_self (ne_of_gt (Int.cast_pos.mpr hn'))))))\n                          (eq_self 1)))))\n                  (L + ε) (L + ε) (Eq.refl (L + ε))))\n              (rpow_one (L + ε)))))))","type":"∀ n ≥ N, (↑(c n ^ (1 / (↑n : ℝ))) : EReal) ≤ (↑(A ^ (1 / (↑n : ℝ)) * (L + ε)) : EReal)","name":["why2_root"],"isProp":true,"id":["_uniq",207164]}]}],"start":8029},{"state":[],"start":8097},{"state":[],"start":8098},{"state":[],"start":8133},{"state":[],"start":8213},{"state":[{"type":"s.absConverges","tag":[],"mvarId":["_uniq",304774],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",304769],"binderInfo":"implicit"},{"type":"∀ n ≥ s.m, s.seq n ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",304770],"binderInfo":"default"},{"type":"limsup (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop < 1","name":["h"],"isProp":true,"id":["_uniq",304771],"binderInfo":"default"}]}],"start":8313},{"state":[{"type":"limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop ≤\n  limsup (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop","tag":[],"mvarId":["_uniq",304782],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",304769],"binderInfo":"implicit"},{"type":"∀ n ≥ s.m, s.seq n ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",304770],"binderInfo":"default"},{"type":"limsup (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop < 1","name":["h"],"isProp":true,"id":["_uniq",304771],"binderInfo":"default"}]}],"start":8365},{"state":[{"type":"∀ n ≥ s.m, |s.seq n| > 0","tag":["convert_2"],"mvarId":["_uniq",304868],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",304769],"binderInfo":"implicit"},{"type":"∀ n ≥ s.m, s.seq n ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",304770],"binderInfo":"default"},{"type":"limsup (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop < 1","name":["h"],"isProp":true,"id":["_uniq",304771],"binderInfo":"default"}]}],"start":8400},{"state":[{"type":"n ≥ s.m → |s.seq n| > 0 ↔ n ≥ s.m → s.seq n ≠ 0","tag":["h","a"],"mvarId":["_uniq",305175],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",304769],"binderInfo":"implicit"},{"type":"∀ n ≥ s.m, s.seq n ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",304770],"binderInfo":"default"},{"type":"limsup (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop < 1","name":["h"],"isProp":true,"id":["_uniq",304771],"binderInfo":"default"},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",305110],"binderInfo":"default"}]}],"start":8432},{"state":[],"start":8441},{"state":[],"start":8442},{"state":[],"start":8477},{"state":[],"start":8557},{"state":[{"type":"s.diverges","tag":[],"mvarId":["_uniq",308492],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",308487],"binderInfo":"implicit"},{"type":"∀ n ≥ s.m, s.seq n ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",308488],"binderInfo":"default"},{"type":"liminf (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop > 1","name":["h"],"isProp":true,"id":["_uniq",308489],"binderInfo":"default"}]}],"start":8653},{"state":[{"type":"liminf (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop ≤\n  limsup (fun n => (↑(|s.seq n| ^ (1 / (↑n : ℝ))) : EReal)) atTop","tag":[],"mvarId":["_uniq",308570],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",308487],"binderInfo":"implicit"},{"type":"∀ n ≥ s.m, s.seq n ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",308488],"binderInfo":"default"},{"type":"liminf (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop > 1","name":["h"],"isProp":true,"id":["_uniq",308489],"binderInfo":"default"}]}],"start":8705},{"state":[{"type":"∀ n ≥ s.m, |s.seq n| > 0","tag":["convert_1"],"mvarId":["_uniq",308589],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",308487],"binderInfo":"implicit"},{"type":"∀ n ≥ s.m, s.seq n ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",308488],"binderInfo":"default"},{"type":"liminf (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop > 1","name":["h"],"isProp":true,"id":["_uniq",308489],"binderInfo":"default"}]},{"type":"∀ n ≥ s.m, |s.seq n| > 0","tag":["convert_3"],"mvarId":["_uniq",308616],"isProp":true,"context":[{"type":"Series","name":["s"],"isProp":false,"id":["_uniq",308487],"binderInfo":"implicit"},{"type":"∀ n ≥ s.m, s.seq n ≠ 0","name":["hnon"],"isProp":true,"id":["_uniq",308488],"binderInfo":"default"},{"type":"liminf (fun n => (↑(|s.seq (n + 1)| / |s.seq n|) : EReal)) atTop > 1","name":["h"],"isProp":true,"id":["_uniq",308489],"binderInfo":"default"}]}],"start":8779},{"state":[],"start":8827},{"state":[],"start":8828},{"state":[],"start":8881},{"state":[],"start":8970},{"state":[{"type":"∃ s, (∀ n ≥ s.m, s.seq n ≠ 0) ∧ Tendsto (fun n => |s.seq n + 1| / |s.seq n|) atTop (nhds 1) ∧ s.diverges","tag":[],"mvarId":["_uniq",316533],"isProp":true,"context":[]}],"start":9052},{"state":[],"start":9062},{"state":[],"start":9063},{"state":[],"start":9116},{"state":[],"start":9207},{"state":[{"type":"∃ s, (∀ n ≥ s.m, s.seq n ≠ 0) ∧ Tendsto (fun n => |s.seq n + 1| / |s.seq n|) atTop (nhds 1) ∧ s.absConverges","tag":[],"mvarId":["_uniq",317206],"isProp":true,"context":[]}],"start":9293},{"state":[],"start":9303},{"state":[],"start":9304},{"state":[],"start":9329},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (↑n : ℝ) ^ (1 / (↑n : ℝ))) n.toNat else 0, vanish := ⋯ }.convergesTo 1","tag":[],"mvarId":["_uniq",317496],"isProp":true,"context":[]}],"start":9435},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (↑n : ℝ) ^ (1 / (↑n : ℝ))) n.toNat else 0, vanish := ⋯ }.convergesTo 1","tag":[],"mvarId":["_uniq",317496],"isProp":true,"context":[]}],"start":9508},{"state":[],"start":9516},{"state":[],"start":9517},{"state":[],"start":9539},{"state":[],"start":9659},{"state":[{"type":"{ m := 0, seq := fun n => if n ≥ 0 then (fun n => (↑n : ℝ) ^ q * x ^ n) n.toNat else 0, vanish := ⋯ }.converges ∧\n  Tendsto (fun n => (↑n : ℝ) ^ q * x ^ n) atTop (nhds 0)","tag":[],"mvarId":["_uniq",318163],"isProp":true,"context":[{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",318160],"binderInfo":"implicit"},{"type":"|x| < 1","name":["hx"],"isProp":true,"id":["_uniq",318161],"binderInfo":"default"},{"type":"ℝ","name":["q"],"isProp":false,"id":["_uniq",318162],"binderInfo":"default"}]}],"start":9726},{"state":[],"start":9734},{"state":[],"start":9735},{"state":[],"start":9748},{"state":[],"start":9748}]
