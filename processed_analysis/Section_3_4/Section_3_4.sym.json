[{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","f_3_4_9_a","_proof_1"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"[inst : Chapter3.SetTheory] →\n  (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)).toSubtype →\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype","name":["Chapter3","f_3_4_9_a"],"kind":"definition","isProp":false},{"valueReferences":[["Eq","trans"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["Lean","Grind","not_eq_prop"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","imp_eq_of_eq_true_left"],["False","elim"],["Or"],["Eq","symm"],["Eq"],["Lean","Grind","or_eq_of_eq_false_left"],["Not"],["True"],["And"],["Lean","Grind","not_not"],["Lean","Grind","eq_true_of_not_eq_false"],["True","intro"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["eq_false"],["Eq","refl"],["Iff"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["And","casesOn"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object) (Y : inst.Set),\n  (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem Y x → Or (Eq x a) (Or (Eq x b) (Eq x c))) →\n    Not (Chapter3.SetTheory.objects_mem_sets.mem Y a) →\n      Chapter3.SetTheory.objects_mem_sets.mem Y b →\n        Not (Chapter3.SetTheory.objects_mem_sets.mem Y c) →\n          ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Y x) (Eq x b)","name":["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Grind","not_and"],["Eq","trans"],["Eq","mp"],["Lean","Grind","and_eq_of_eq_true_right"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Lean","Grind","not_or"],["eq_true"],["Lean","Grind","not_eq_prop"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","or_of_and_eq_false"],["Lean","Grind","imp_eq_of_eq_true_left"],["False","elim"],["Or"],["congr"],["Eq","symm"],["Eq"],["Lean","Grind","or_eq_of_eq_false_left"],["Not"],["True"],["Lean","Grind","eq_true_of_and_eq_true_right"],["And"],["Lean","Grind","not_not"],["True","intro"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["eq_false"],["Eq","refl"],["Iff"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["And","casesOn"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object) (Y : inst.Set),\n  (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem Y x → Or (Eq x a) (Or (Eq x b) (Eq x c))) →\n    Chapter3.SetTheory.objects_mem_sets.mem Y a →\n      Chapter3.SetTheory.objects_mem_sets.mem Y b →\n        Not (Chapter3.SetTheory.objects_mem_sets.mem Y c) →\n          ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Y x) (Or (Eq x a) (Eq x b))","name":["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Decidable"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["Decidable"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  Decidable\n    (∀ (X Y : inst.Set) (f : X.toSubtype → Y.toSubtype) (A B : inst.Set),\n      Eq (Chapter3.SetTheory.Set.image f (Chapter3.SetTheory.Set.instIntersection.inter A B))\n        (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.image f A)\n          (Chapter3.SetTheory.Set.image f B)))","name":["Chapter3","SetTheory","Set","image_of_inter'"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","image"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Insert","insert"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","nat"],["Chapter3","f_3_4_2"],["Ne"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set","image"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","nat"],["Chapter3","f_3_4_2"],["Ne"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Ne\n    (Chapter3.SetTheory.Set.image Chapter3.f_3_4_2\n      (Chapter3.SetTheory.Set.preimage Chapter3.f_3_4_2\n        (Chapter3.SetTheory.Set.instInsert.insert 1\n          (Chapter3.SetTheory.Set.instInsert.insert 2 (Chapter3.SetTheory.Set.instSingleton.singleton 3)))))\n    (Chapter3.SetTheory.Set.instInsert.insert 1\n      (Chapter3.SetTheory.Set.instInsert.insert 2 (Chapter3.SetTheory.Set.instSingleton.singleton 3)))","name":["Chapter3","SetTheory","Set","image_preimage_f_3_4_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","image","_proof_1"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {X Y : inst.Set} → (X.toSubtype → Y.toSubtype) → inst.Set → inst.Set","name":["Chapter3","SetTheory","Set","image"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","mem_image","_proof_1_2"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["Iff"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set) (y : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.image f S) y)\n    (Exists fun x => And (Chapter3.SetTheory.objects_mem_sets.mem S x.val) (Eq (f x).val y))","name":["Chapter3","SetTheory","Set","mem_image"],"kind":"theorem","isProp":true},{"valueReferences":[["instHPow"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Object"],["HPow","hPow"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","coe_of_fun"],["Chapter3","SetTheory","Set","inst_pow"],["Eq"],["Chapter3","SetTheory","Set","powerset_axiom"],["propext"]],"typeReferences":[["instHPow"],["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","coe_of_fun"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","inst_pow"],["HPow","hPow"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (F : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (instHPow.hPow X Y) F)\n    (Exists fun f => Eq (Chapter3.SetTheory.Set.coe_of_fun f) F)","name":["Chapter3","SetTheory","Set","powerset_axiom","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["And"],["Exists","intro"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","mem_powerset"],["DFunLike","coe"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (X : inst.Set),\n  Exists fun Z =>\n    ∀ (x : inst.Object),\n      Iff (Chapter3.SetTheory.objects_mem_sets.mem Z x)\n        (Exists fun Y =>\n          And (Eq x (Function.instFunLikeEmbedding.coe inst.set_to_object Y))\n            (Chapter3.SetTheory.Set.instSubset.Subset Y X))","name":["Chapter3","SetTheory","Set","exists_powerset"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["Lean","Grind","not_eq_prop"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","imp_eq_of_eq_true_left"],["False","elim"],["Or"],["Eq","symm"],["Eq"],["Not"],["True"],["And"],["Lean","Grind","not_not"],["Lean","Grind","eq_true_of_not_eq_false"],["True","intro"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["Lean","Grind","or_eq_of_eq_false_right"],["eq_false"],["Eq","refl"],["Iff"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["And","casesOn"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object) (Y : inst.Set),\n  (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem Y x → Or (Eq x a) (Or (Eq x b) (Eq x c))) →\n    Not (Chapter3.SetTheory.objects_mem_sets.mem Y a) →\n      Not (Chapter3.SetTheory.objects_mem_sets.mem Y b) →\n        Chapter3.SetTheory.objects_mem_sets.mem Y c →\n          ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Y x) (Eq x c)","name":["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_10"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.preimage f (Chapter3.SetTheory.Set.instIntersection.inter A B))\n    (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.preimage f A)\n      (Chapter3.SetTheory.Set.preimage f B))","name":["Chapter3","SetTheory","Set","preimage_of_inter"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Function","Embedding"],["Chapter3","SetTheory","union"],["Insert","insert"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Lean","Name","num"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Function","Embedding"],["Chapter3","SetTheory","union"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSingleton"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Eq\n    (inst.union\n      (Chapter3.SetTheory.Set.instInsert.insert\n        (Function.instFunLikeEmbedding.coe inst.set_to_object\n          (Chapter3.SetTheory.Set.instInsert.insert 2 (Chapter3.SetTheory.Set.instSingleton.singleton 3)))\n        (Chapter3.SetTheory.Set.instInsert.insert\n          (Function.instFunLikeEmbedding.coe inst.set_to_object\n            (Chapter3.SetTheory.Set.instInsert.insert 3 (Chapter3.SetTheory.Set.instSingleton.singleton 4)))\n          (Chapter3.SetTheory.Set.instSingleton.singleton\n            (Function.instFunLikeEmbedding.coe inst.set_to_object\n              (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 5)))))))\n    (Chapter3.SetTheory.Set.instInsert.insert 2\n      (Chapter3.SetTheory.Set.instInsert.insert 3\n        (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 5))))","name":["Chapter3","SetTheory","Set","example_3_4_12"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["True"],["Chapter3","SetTheory","Set","image_eq_image","_proof_1_1"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Object"],["Subtype","val"],["Lean","Grind","nestedProof"],["congrArg"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Subtype","property"],["Eq","symm"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["Subtype"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image_eq_image","_proof_1_1"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"],["Lean","Grind","nestedProof"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set}\n  (f :\n    (Subtype fun x => Chapter3.SetTheory.objects_mem_sets.mem X x) →\n      Subtype fun x => Chapter3.SetTheory.objects_mem_sets.mem Y x)\n  (x w : inst.Object) (w_1 : Chapter3.SetTheory.objects_mem_sets.mem X w),\n  Eq (f ⟨w, ⋯⟩).val x → Chapter3.SetTheory.objects_mem_sets.mem Y x","name":["Chapter3","SetTheory","Set","image_eq_image","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","f_3_4_9_b","_proof_1"],["Subtype","mk"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"[inst : Chapter3.SetTheory] →\n  (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)).toSubtype →\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype","name":["Chapter3","f_3_4_9_d"],"kind":"definition","isProp":false},{"valueReferences":[["Subtype"],["Eq","trans"],["True"],["Eq","mp"],["Membership","mem"],["And"],["eq_true"],["Chapter3","SetTheory","Object"],["True","intro"],["Subtype","val"],["Lean","Grind","nestedProof"],["congrArg"],["Exists","casesOn"],["Chapter3","SetTheory","Set"],["eq_false"],["Subtype","property"],["Classical","byContradiction"],["Eq","symm"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","casesOn"],["Subtype","mk"],["Eq"],["And","casesOn"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set) (x : inst.Object),\n  (Exists fun x_1 => And (Chapter3.SetTheory.objects_mem_sets.mem S x_1.val) (Eq (f x_1).val x)) →\n    Chapter3.SetTheory.objects_mem_sets.mem Y x","name":["Chapter3","SetTheory","Set","image_in_codomain","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Subtype"],["Lean","Grind","not_and"],["Eq","trans"],["Eq","mp"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","replacement_axiom"],["Lean","Grind","not_exists"],["DFunLike","coe"],["Chapter3","SetTheory","Set","iUnion","_proof_1"],["Lean","Grind","eq_false_of_not_eq_true"],["forall_not_of_not_exists"],["Lean","Grind","imp_eq_of_eq_true_left"],["Or"],["False","casesOn"],["forall_congr"],["Eq","symm"],["Lean","Grind","forall_forall_or"],["Function","instFunLikeEmbedding"],["Eq"],["Not"],["of_eq_false"],["Exists"],["True"],["Function","Embedding"],["And"],["Lean","Grind","nestedProof"],["Chapter3","SetTheory","replace"],["Exists","casesOn"],["false_or"],["Chapter3","SetTheory","Set"],["Lean","Grind","iff_eq"],["Iff"],["Eq","refl"],["Classical","byContradiction"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Subtype","casesOn"],["Lean","Grind","intro_with_eq"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","iUnion","_proof_1"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} (A : I.toSubtype → inst.Set) (x : inst.Object),\n  (Exists fun α => Chapter3.SetTheory.objects_mem_sets.mem (A α) x) →\n    Exists fun S =>\n      And (Chapter3.SetTheory.objects_mem_sets.mem S x)\n        (Chapter3.SetTheory.objects_mem_sets.mem (I.replace ⋯) (Function.instFunLikeEmbedding.coe inst.set_to_object S))","name":["Chapter3","SetTheory","Set","mem_iUnion","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Eq","trans"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["Inter","inter"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["eq_true"],["or_true"],["Union","union"],["Subtype","val"],["congrArg"],["Or"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Subtype","property"],["Eq"],["Chapter3","SetTheory","Set","iInter"],["True"],["Chapter3","SetTheory","Set","mem_union","_simp_1"],["true_or"],["Chapter3","SetTheory","Set","union_of_nonempty"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Subtype","mk"]],"typeReferences":[["Eq","trans"],["Inter","inter"],["Membership","mem"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["eq_true"],["or_true"],["Union","union"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"],["Subtype","val"],["congrArg"],["Or"],["Chapter3","SetTheory","Set","instIntersection"],["Subtype","property"],["Eq"],["Chapter3","SetTheory","Set","iInter"],["true_or"],["True"],["Chapter3","SetTheory","Set","mem_union","_simp_1"],["Chapter3","SetTheory","Set","union_of_nonempty"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["Ne"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"type":"∀ [inst : Chapter3.SetTheory] {I J : inst.Set} (hI : Ne I Chapter3.SetTheory.Set.instEmpty.emptyCollection)\n  (hJ : Ne J Chapter3.SetTheory.Set.instEmpty.emptyCollection)\n  (A : (Chapter3.SetTheory.Set.instUnion.union I J).toSubtype → inst.Set),\n  Eq\n    (Chapter3.SetTheory.Set.instIntersection.inter (I.iInter hI fun α => A ⟨α.val, ⋯⟩)\n      (J.iInter hJ fun α => A ⟨α.val, ⋯⟩))\n    ((Chapter3.SetTheory.Set.instUnion.union I J).iInter ⋯ A)","name":["Chapter3","SetTheory","Set","inter_iInter"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Eq","trans"],["Eq","mp"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["Lean","Grind","nestedProof_congr"],["heq_of_eq"],["Subtype","val"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Subtype","mk","inj"],["eq_of_heq"],["Subtype","property"],["Chapter3","SetTheory","Set","instSingleton"],["Eq","symm"],["Eq","ndrec"],["Eq"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_3"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_2"],["HEq","trans"],["HEq","refl"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["True","intro"],["Chapter3","f_3_4_9_b","_proof_1"],["OfNat","ofNat"],["Lean","Grind","nestedProof"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["HEq"],["id"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["eq_false_of_decide"],["Bool"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","f_3_4_9_d"],["or_true"],["Subtype","val"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["or_false"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["instOfNatAtLeastTwo"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["AddMonoidWithOne","toNatCast"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["instDecidableEqNat"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"type":"∀ [inst : Chapter3.SetTheory]\n  (f :\n    (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)).toSubtype →\n      (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype),\n  Eq (f ⟨4, ⋯⟩).val 1 →\n    Eq (f ⟨7, ⋯⟩).val 1 →\n      ∀ (val : inst.Object)\n        (hx :\n          Chapter3.SetTheory.objects_mem_sets.mem\n            (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)) val),\n        Or (Eq val 4) (Eq val 7) → Eq (f ⟨val, hx⟩).val (Chapter3.f_3_4_9_d ⟨val, hx⟩).val","name":["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["eq_false_of_decide"],["Bool"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["or_false"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["instOfNatAtLeastTwo"],["OfNat","ofNat"],["eq_self"],["Nat"],["AddMonoidWithOne","toNatCast"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["instDecidableEqNat"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)) 4","name":["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["Exists"],["True"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Object"],["True","intro"],["Lean","Grind","not_exists"],["Lean","Grind","nestedProof"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Classical","byContradiction"],["forall_congr"],["Eq","symm"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Grind","intro_with_eq"],["Lean","Grind","forall_propagator"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} (A : I.toSubtype → inst.Set) (x : inst.Object) (x_1 : inst.Set),\n  Chapter3.SetTheory.objects_mem_sets.mem x_1 x →\n    ∀ (x_2 : inst.Object) (x_3 : Chapter3.SetTheory.objects_mem_sets.mem I x_2),\n      Eq x_1 (A ⟨x_2, x_3⟩) → Exists fun a => Exists fun b => Chapter3.SetTheory.objects_mem_sets.mem (A ⟨a, b⟩) x","name":["Chapter3","SetTheory","Set","mem_iUnion","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nonempty_choose"],["Chapter3","SetTheory","Set","iInter'"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["Ne"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  (I : inst.Set) → Ne I Chapter3.SetTheory.Set.instEmpty.emptyCollection → (I.toSubtype → inst.Set) → inst.Set","name":["Chapter3","SetTheory","Set","iInter"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Function","Surjective"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["HasSubset","Subset"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Function","Surjective"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype),\n  Iff\n    (∀ (S : inst.Set),\n      Chapter3.SetTheory.Set.instSubset.Subset S Y →\n        Eq (Chapter3.SetTheory.Set.image f (Chapter3.SetTheory.Set.preimage f S)) S)\n    (Function.Surjective f)","name":["Chapter3","SetTheory","Set","image_preimage_of_surj"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Lean","Name","anonymous"],["sorryAx"],["Eq","trans"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instUnion"],["eq_true"],["or_true"],["Union","union"],["Subtype","val"],["congrArg"],["Or"],["instOfNatNat"],["Subtype","property"],["Eq"],["True"],["Chapter3","SetTheory","Set","mem_union","_simp_1"],["true_or"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["true_or"],["Chapter3","SetTheory","Set","mem_union","_simp_1"],["True"],["Eq","trans"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object"],["or_true"],["Union","union"],["Chapter3","SetTheory"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set"],["Or"],["of_eq_true"],["Subtype","property"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {I J : inst.Set} (A : (Chapter3.SetTheory.Set.instUnion.union I J).toSubtype → inst.Set),\n  Eq (Chapter3.SetTheory.Set.instUnion.union (I.iUnion fun α => A ⟨α.val, ⋯⟩) (J.iUnion fun α => A ⟨α.val, ⋯⟩))\n    ((Chapter3.SetTheory.Set.instUnion.union I J).iUnion A)","name":["Chapter3","SetTheory","Set","union_iUnion"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","mem_preimage'","_proof_1_1"],["Chapter3","SetTheory","Set","preimage"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["Classical","propDecidable"],["Chapter3","SetTheory","Object"],["Exists","intro"],["eq_true"],["Subtype","val"],["Iff","intro"],["congrArg"],["congr"],["Eq","ndrec"],["Eq"],["propext"],["Exists"],["True"],["And"],["Chapter3","SetTheory","Set","mem_preimage"],["Exists","casesOn"],["eq_self"],["and_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["dite"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Exists"],["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (U : inst.Set) (x : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.preimage f U) x)\n    (Exists fun x' => And (Eq x'.val x) (Chapter3.SetTheory.objects_mem_sets.mem U (f x').val))","name":["Chapter3","SetTheory","Set","mem_preimage'"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","mem_preimage'"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (U : inst.Set) (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.preimage f U) x)\n    (Exists fun x' => And (Eq x'.val x) (Chapter3.SetTheory.objects_mem_sets.mem U (f x').val))","name":["Chapter3","SetTheory","Set","preimage_f_3_4_2","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","union"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","union_axiom"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["propext"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","union"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set) (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (inst.union A) x)\n    (Exists fun S =>\n      And (Chapter3.SetTheory.objects_mem_sets.mem S x)\n        (Chapter3.SetTheory.objects_mem_sets.mem A (Function.instFunLikeEmbedding.coe inst.set_to_object S)))","name":["Chapter3","SetTheory","Set","union_eq","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Inter","inter"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instIntersection"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instIntersection"],["Inter","inter"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (A B : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset\n    (Chapter3.SetTheory.Set.image f (Chapter3.SetTheory.Set.instIntersection.inter A B))\n    (Chapter3.SetTheory.Set.instIntersection.inter (Chapter3.SetTheory.Set.image f A)\n      (Chapter3.SetTheory.Set.image f B))","name":["Chapter3","SetTheory","Set","image_of_inter"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","mem_image","_simp_1"],["Chapter3","SetTheory","Set","preimage"],["Subtype"],["Eq","trans"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Subtype","val"],["exists_eq_right","_simp_1"],["congrArg"],["iff_self"],["Chapter3","SetTheory","Set","specification_axiom''","_simp_1"],["congr"],["funext"],["Subtype","exists","_simp_1"],["Eq"],["propext"],["Set","preimage"],["exists_and_right","_simp_1"],["Exists"],["Chapter3","SetTheory","Set","specify"],["True"],["Set"],["And"],["exists_prop_congr"],["Set","instMembership"],["Set","image"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Iff","of_eq"],["Iff"],["Iff","mpr"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["Set","ext"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["setOf"]],"typeReferences":[["Set","preimage"],["Chapter3","SetTheory","Set","preimage"],["Subtype"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Set","image"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (U : inst.Set),\n  Eq (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.preimage f U) x)\n    (Set.image Subtype.val (Set.preimage f (setOf fun y => Chapter3.SetTheory.objects_mem_sets.mem U y.val)))","name":["Chapter3","SetTheory","Set","preimage_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Eq","trans"],["Eq","mp"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["Lean","Grind","nestedProof_congr"],["heq_of_eq"],["Subtype","val"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Subtype","mk","inj"],["eq_of_heq"],["Subtype","property"],["Chapter3","SetTheory","Set","instSingleton"],["Eq","symm"],["Eq","ndrec"],["Eq"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_3"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_2"],["HEq","trans"],["HEq","refl"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["True","intro"],["OfNat","ofNat"],["Lean","Grind","nestedProof"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["Chapter3","f_3_4_9_a","_proof_1"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["HEq"],["id"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["eq_false_of_decide"],["Bool"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Chapter3","f_3_4_9_a"],["Subtype","val"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["or_false"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["instOfNatAtLeastTwo"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["AddMonoidWithOne","toNatCast"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["instDecidableEqNat"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"type":"∀ [inst : Chapter3.SetTheory]\n  (f :\n    (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)).toSubtype →\n      (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype),\n  Eq (f ⟨4, ⋯⟩).val 0 →\n    Eq (f ⟨7, ⋯⟩).val 0 →\n      ∀ (val : inst.Object)\n        (hx :\n          Chapter3.SetTheory.objects_mem_sets.mem\n            (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)) val),\n        Or (Eq val 4) (Eq val 7) → Eq (f ⟨val, hx⟩).val (Chapter3.f_3_4_9_a ⟨val, hx⟩).val","name":["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","refl"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","coe_of_fun"]],"typeReferences":[["Chapter3","SetTheory","function_to_object"],["Subtype"],["Chapter3","SetTheory","Set"],["Function","Embedding"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Chapter3","SetTheory","Set","coe_of_fun"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype),\n  Eq (Chapter3.SetTheory.Set.coe_of_fun f) (Function.instFunLikeEmbedding.coe (inst.function_to_object X Y) f)","name":["Chapter3","SetTheory","Set","coe_of_fun","eq_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Chapter3","SetTheory","Set","image"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Set","image_f_3_4_2","_simp_1_1"],["Nat","instMulOneClass"],["Exists","intro"],["HMul","hMul"],["Chapter3","SetTheory","Object"],["or_true"],["Subtype","val"],["Equiv"],["Or"],["Nat","instCharZero"],["funext"],["Eq","ndrec"],["Exists"],["And"],["Insert","insert"],["OfNat","ofNat_ne_one","_simp_1"],["Exists","casesOn"],["or_self"],["Nat"],["Eq","refl"],["Iff"],["Chapter3","SetTheory","nat"],["Chapter3","f_3_4_2"],["id"],["instHMul"],["instNatAtLeastTwo"],["Eq","mpr"],["eq_false_of_decide"],["Bool"],["Nat","cast"],["Equiv","instEquivLike"],["Eq","mp"],["Nat","succ_ne_self","_simp_1"],["DFunLike","coe"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Iff","intro"],["Chapter3","SetTheory","Set","instNatCast"],["Chapter3","SetTheory","Set","nat_coe_eq_iff'","_simp_1"],["or_false"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","instOfNat"],["instMulNat"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Set","image_f_3_4_2","_simp_1_2"],["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe''"],["True"],["Chapter3","SetTheory","Set","instInsert"],["instOfNatAtLeastTwo"],["mul_one"],["OfNat","one_ne_ofNat","_simp_1"],["OfNat","ofNat"],["Or","casesOn"],["eq_self"],["and_self"],["Chapter3","SetTheory","Set"],["Chapter3","Nat"],["of_eq_true"],["Chapter3","SetTheory","Set","ext"],["Chapter3","SetTheory","Set","toSubtype"],["instDecidableEqNat"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set","image"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","f_3_4_2"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Eq\n    (Chapter3.SetTheory.Set.image Chapter3.f_3_4_2\n      (Chapter3.SetTheory.Set.instInsert.insert 1\n        (Chapter3.SetTheory.Set.instInsert.insert 2 (Chapter3.SetTheory.Set.instSingleton.singleton 3))))\n    (Chapter3.SetTheory.Set.instInsert.insert 2\n      (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 6)))","name":["Chapter3","SetTheory","Set","image_f_3_4_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Subtype"],["Eq","refl"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Eq","ndrec"],["Eq"],["Eq","rec"],["Chapter3","SetTheory","replace"]],"typeReferences":[["Subtype"],["Chapter3","SetTheory","Set"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Eq","ndrec"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","replace"]],"type":"∀ [self : Chapter3.SetTheory] (A : self.Set) (P P_1 : (Subtype fun x => self.mem x A) → self.Object → Prop)\n  (e_P : Eq P P_1) (hP : ∀ (x : Subtype fun x => self.mem x A) (y y' : self.Object), And (P x y) (P x y') → Eq y y'),\n  Eq (self.replace A P hP) (self.replace A P_1 ⋯)","name":["Chapter3","SetTheory","replace","congr_simp"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","mem_triple"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a b c : inst.Object),\n  Eq\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (Chapter3.SetTheory.Set.instInsert.insert a\n        (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))\n      x)\n    (Or (Eq x a) (Or (Eq x b) (Eq x c)))","name":["Chapter3","SetTheory","Set","image_f_3_4_2","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Exists","choose_spec"],["Membership","mem"],["Chapter3","SetTheory","Set","nonempty_def"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","nonempty_def"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","objects_mem_sets"],["Ne"],["Exists","choose"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} (hI : Ne I Chapter3.SetTheory.Set.instEmpty.emptyCollection),\n  Chapter3.SetTheory.objects_mem_sets.mem I ⋯.choose","name":["Chapter3","SetTheory","Set","nonempty_choose","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["True"],["Eq","mp"],["Membership","mem"],["Function","Embedding"],["And"],["eq_true"],["Chapter3","SetTheory","Object"],["True","intro"],["DFunLike","coe"],["Lean","Grind","nestedProof"],["Chapter3","SetTheory","Set"],["eq_false"],["Classical","byContradiction"],["Eq","symm"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","casesOn"],["Subtype","mk"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (A : I.toSubtype → inst.Set) (x : I.toSubtype) (y y' : inst.Object),\n  And ((fun α S => Eq S (Function.instFunLikeEmbedding.coe inst.set_to_object (A α))) x y)\n      ((fun α S => Eq S (Function.instFunLikeEmbedding.coe inst.set_to_object (A α))) x y') →\n    Eq y y'","name":["Chapter3","SetTheory","Set","iUnion","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","instInsert"],["ite"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","f_3_4_9_b","_proof_1"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set"],["Chapter3","f_3_4_9_a","_proof_1"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"[inst : Chapter3.SetTheory] →\n  (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)).toSubtype →\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype","name":["Chapter3","f_3_4_9_b"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","instInsert"],["ite"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","f_3_4_9_b","_proof_1"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set"],["Chapter3","f_3_4_9_a","_proof_1"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"[inst : Chapter3.SetTheory] →\n  (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)).toSubtype →\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype","name":["Chapter3","f_3_4_9_c"],"kind":"definition","isProp":false},{"valueReferences":[["instHPow"],["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["And"],["Insert","insert"],["Chapter3","SetTheory","Object"],["HPow","hPow"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_pow"]],"typeReferences":[["instHPow"],["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["And"],["Insert","insert"],["Chapter3","SetTheory","Object"],["HPow","hPow"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","inst_pow"]],"type":"∀ [inst : Chapter3.SetTheory] (X : inst.Set)\n  (x :\n    (instHPow.hPow (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1))\n        X).toSubtype)\n  (y y' : inst.Object), And (sorry x y) (sorry x y') → Eq y y'","name":["Chapter3","SetTheory","Set","powerset","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","replacement_axiom"],["propext"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {A : inst.Set} {P : A.toSubtype → inst.Object → Prop}\n  (hP : ∀ (x : A.toSubtype) (y y' : inst.Object), And (P x y) (P x y') → Eq y y') (y : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (A.replace hP) y) (Exists fun x => P x y)","name":["Chapter3","SetTheory","Set","mem_iUnion","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","powerset_axiom"]],"typeReferences":[["instHPow"],["Exists"],["Membership","mem"],["Chapter3","SetTheory","Object"],["HPow","hPow"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","coe_of_fun"],["Chapter3","SetTheory","Set","inst_pow"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (F : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (instHPow.hPow X Y) F)\n    (Exists fun f => Eq (Chapter3.SetTheory.Set.coe_of_fun f) F)","name":["Chapter3","SetTheory","Set","powerset_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → (I : inst.Set) → I.toSubtype → (I.toSubtype → inst.Set) → inst.Set","name":["Chapter3","SetTheory","Set","iInter'"],"kind":"definition","isProp":false},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","coe_of_fun"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Exists"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","coe_of_fun"],["Eq"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set},\n  Exists fun Z =>\n    ∀ (F : inst.Object),\n      Iff (Chapter3.SetTheory.objects_mem_sets.mem Z F)\n        (Exists fun X' =>\n          Exists fun Y' =>\n            And (Chapter3.SetTheory.Set.instSubset.Subset X' X)\n              (And (Chapter3.SetTheory.Set.instSubset.Subset Y' Y)\n                (Exists fun f => Eq F (Chapter3.SetTheory.Set.coe_of_fun f))))","name":["Chapter3","SetTheory","Set","partial_functions"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","mem_image","_simp_1"],["Subtype"],["Eq","trans"],["Chapter3","SetTheory","Set","image"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","image_eq_image","_proof_1_3"],["Subtype","val"],["exists_eq_right","_simp_1"],["congrArg"],["exists_and_left","_simp_1"],["congr"],["funext"],["Subtype","exists","_simp_1"],["Chapter3","SetTheory","Set","image","_proof_1"],["Eq"],["propext"],["exists_and_right","_simp_1"],["Exists"],["Set"],["And"],["exists_prop_congr"],["Chapter3","SetTheory","Set","replacement_axiom","_simp_1"],["Set","instMembership"],["Set","image"],["Chapter3","SetTheory","Set"],["Iff","of_eq"],["Iff"],["Iff","mpr"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["Set","ext"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["setOf"]],"typeReferences":[["Subtype"],["Chapter3","SetTheory","Set","image"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Set","image"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set),\n  Eq (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.image f S) x)\n    (Set.image Subtype.val (Set.image f (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem S x.val)))","name":["Chapter3","SetTheory","Set","image_eq_image"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Chapter3","SetTheory","function_to_object"],["Eq","trans"],["True"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Function","instEmbeddingLikeEmbedding"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["congrArg"],["iff_self"],["of_eq_true"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","mem"],["Eq"],["Function","instFunLikeEmbedding"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","coe_of_fun"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f g : X.toSubtype → Y.toSubtype),\n  Iff (Eq (Chapter3.SetTheory.Set.coe_of_fun f) (Chapter3.SetTheory.Set.coe_of_fun g)) (Eq f g)","name":["Chapter3","SetTheory","Set","coe_of_fun_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Omega","LinearCombo","mul_eval"],["Int","instSub"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["le_of_le_of_eq"],["HMul","hMul"],["GT","gt"],["Equiv"],["Or"],["Int","instLEInt"],["Eq","symm"],["Lean","Omega","tidy_sat"],["HSub","hSub"],["Lean","Omega","LinearCombo","add_eval"],["Int","add_one_le_of_lt"],["Bool","true"],["List","cons"],["List","decidableBAll"],["instLTNat"],["Lean","Omega","combo_sat'"],["Neg","neg"],["And","right"],["Lean","Omega","Constraint","addInequality_sat"],["Lean","Omega","LinearCombo","coordinate"],["Int","instNegInt"],["instDecidableEqBool"],["Nat"],["instOfNat"],["Eq","refl"],["id"],["Lean","Omega","Constraint","addEquality_sat"],["instHMul"],["Lean","Omega","LinearCombo","instAdd"],["Lean","Omega","Int","sub_congr"],["Or","elim"],["Equiv","instEquivLike"],["Bool"],["Nat","cast"],["Lean","Omega","LinearCombo","coordinate_eval_0"],["Option","some"],["Int","sub_eq_zero_of_eq"],["DFunLike","coe"],["Decidable","decide"],["Int","instMul"],["Lean","Omega","LinearCombo","mk"],["Nat","lt_or_gt_of_ne"],["Lean","Omega","Int","mul_congr"],["Lean","Omega","LinearCombo","instSub"],["Lean","Omega","Coeffs","ofList"],["instOfNatNat"],["Int","instAdd"],["Int","instDecidableEq"],["EquivLike","toFunLike"],["instMulNat"],["Equiv","symm"],["Lean","Omega","Constraint","not_sat'_of_isImpossible"],["Eq"],["instDecidableOr"],["Lean","Omega","and_not_not_of_not_or"],["Int","ofNat_mul"],["of_decide_eq_true"],["instNatCastInt"],["Not"],["List","nil"],["instHAdd"],["Lean","Omega","LinearCombo"],["Lean","Omega","Int","ofNat_congr"],["Lean","Omega","Int","add_congr"],["Lean","Omega","Constraint","isImpossible"],["Int","sub_nonneg_of_le"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LT","lt"],["Lean","Omega","LinearCombo","mul"],["Lean","Omega","Int","ofNat_lt_of_lt"],["Lean","Omega","LinearCombo","sub_eval"],["Chapter3","Nat"],["Option","none"],["Lean","Omega","Coeffs","isZero"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Lean","Omega","Constraint","mk"],["Lean","Omega","LinearCombo","eval"],["instHSub"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["HMul","hMul"],["Chapter3","SetTheory"],["DFunLike","coe"],["OfNat","ofNat"],["Equiv"],["Nat"],["Chapter3","Nat"],["Or"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["instMulNat"],["False"],["Equiv","symm"],["instHMul"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.nat.toSubtype),\n  Eq (instHMul.hMul 2 (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm x)) 6 →\n    Not\n        (Or (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm x) 1)\n          (Or (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm x) 2)\n            (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm x) 3))) →\n      False","name":["Chapter3","SetTheory","Set","preimage_f_3_4_2","_proof_1_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set","iUnion_example","_simp_1_1"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["exists_const","_simp_1"],["Bool","false"],["Membership","mem"],["Classical","propDecidable"],["Exists","intro"],["eq_true"],["Chapter3","SetTheory","Object"],["ite_cond_eq_true"],["or_true"],["Union","union"],["Subtype","val"],["Or"],["Nat","instCharZero"],["funext"],["Eq","symm"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Subtype","exists","_simp_1"],["Eq","ndrec"],["Eq","rec"],["Exists"],["Insert","insert"],["OfNat","ofNat_ne_one","_simp_1"],["ite_cond_eq_false"],["Exists","casesOn"],["or_self"],["Nat"],["AddMonoidWithOne","toNatCast"],["Iff","of_eq"],["instNonemptyOfInhabited"],["Iff","mpr"],["Iff"],["Eq","refl"],["id"],["instNatAtLeastTwo"],["Eq","mpr"],["eq_false_of_decide"],["Or","inr"],["Bool"],["Subtype"],["Chapter3","SetTheory","Set","index_example"],["Eq","mp"],["Nat","succ_ne_self","_simp_1"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Iff","intro"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["or_false"],["Or","inl"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Eq"],["propext"],["True"],["Chapter3","SetTheory","Set","instInsert"],["Chapter3","SetTheory","Set","mem_union","_simp_1"],["ite"],["instOfNatAtLeastTwo"],["OfNat","one_ne_ofNat","_simp_1"],["OfNat","ofNat"],["exists_prop_congr"],["Or","casesOn"],["eq_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","ext"],["Chapter3","SetTheory","Set","toSubtype"],["instDecidableEqNat"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["instInhabitedTrue"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Chapter3","SetTheory","Set","index_example"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Eq\n    ((Chapter3.SetTheory.Set.instInsert.insert 1\n          (Chapter3.SetTheory.Set.instInsert.insert 2 (Chapter3.SetTheory.Set.instSingleton.singleton 3))).iUnion\n      Chapter3.SetTheory.Set.index_example)\n    (Chapter3.SetTheory.Set.instInsert.insert 2\n      (Chapter3.SetTheory.Set.instInsert.insert 3\n        (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 5))))","name":["Chapter3","SetTheory","Set","iUnion_example"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","image_in_codomain","_proof_1_1"],["Exists"],["Chapter3","SetTheory","Set","image"],["Eq","mp"],["Chapter3","SetTheory","Set","mem_image"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.image f S) Y","name":["Chapter3","SetTheory","Set","image_in_codomain"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Chapter3","SetTheory","Set","image"],["Chapter3","SetTheory","Set","specify"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Subtype","val"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Chapter3","SetTheory","Set","image"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set),\n  Eq (Chapter3.SetTheory.Set.image f S)\n    (Y.specify fun y => Exists fun x => And (Chapter3.SetTheory.objects_mem_sets.mem S x.val) (Eq (f x) y))","name":["Chapter3","SetTheory","Set","image_eq_specify"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","mem_iUnion"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} (A : I.toSubtype → inst.Set) (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (I.iUnion A) x)\n    (Exists fun α => Chapter3.SetTheory.objects_mem_sets.mem (A α) x)","name":["Chapter3","SetTheory","Set","iUnion_eq","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","coe_of_fun_inj"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","coe_of_fun"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","coe_of_fun"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f g : X.toSubtype → Y.toSubtype),\n  Eq (Eq (Chapter3.SetTheory.Set.coe_of_fun f) (Chapter3.SetTheory.Set.coe_of_fun g)) (Eq f g)","name":["Chapter3","SetTheory","Set","coe_of_fun_inj","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","mem_union_powerset_replace_iff","_proof_1_2"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set","replace"],["Function","Embedding"],["Membership","mem"],["And"],["Chapter3","SetTheory","union"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] {S : inst.Set} {P : S.powerset.toSubtype → inst.Object → Prop}\n  {hP : ∀ (x : S.powerset.toSubtype) (y y' : inst.Object), And (P x y) (P x y') → Eq y y'} {x : inst.Object},\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (inst.union (S.powerset.replace hP)) x)\n    (Exists fun S' =>\n      Exists fun U =>\n        And (P S' (Function.instFunLikeEmbedding.coe inst.set_to_object U))\n          (Chapter3.SetTheory.objects_mem_sets.mem U x))","name":["Chapter3","SetTheory","Set","mem_union_powerset_replace_iff"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Eq","trans"],["Chapter3","SetTheory","Set","image_eq_image","_proof_1_1"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["heq_of_eq"],["Subtype","val"],["Lean","Grind","not_eq_prop"],["Or"],["Lean","Grind","eq_false_of_imp_eq_true"],["forall_congr"],["eq_of_heq"],["Eq","symm"],["Lean","Grind","forall_forall_or"],["Lean","Grind","not_eq_of_eq_true"],["Eq","ndrec"],["Lean","Grind","forall_propagator"],["Exists"],["HEq","trans"],["And"],["Lean","Grind","not_not"],["True","intro"],["Lean","Grind","nestedProof"],["Exists","casesOn"],["false_or"],["Iff","of_eq"],["eq_false"],["Eq","refl"],["Iff"],["Iff","mpr"],["Classical","byContradiction"],["id"],["HEq"],["Lean","Grind","eq_false_of_imp_eq_false"],["Subtype"],["Lean","Grind","not_and"],["Eq","mp"],["Lean","Grind","nestedProof_congr"],["Lean","Grind","not_exists"],["Chapter3","SetTheory","Set","image_eq_image","_proof_1_2"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","of_forall_eq_false"],["Lean","Grind","imp_eq_of_eq_true_left"],["Subtype","property"],["Eq"],["propext"],["Not"],["True"],["HEq","refl"],["Lean","Grind","eq_true_of_not_eq_false"],["exists_prop_congr"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["False"],["Lean","Grind","eq_true_of_imp_eq_false"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["Subtype","mk"],["And","casesOn"]],"typeReferences":[["Subtype"],["Exists"],["Membership","mem"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Subtype","val"],["Chapter3","SetTheory","Set"],["Iff","of_eq"],["Eq","refl"],["Iff"],["Iff","mpr"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set) (x : inst.Object),\n  Iff (Exists fun a => And (Exists fun x_1 => Eq (f ⟨a, ⋯⟩).val x) (Chapter3.SetTheory.objects_mem_sets.mem S a))\n    (Exists fun x_1 =>\n      Exists fun a => And (Chapter3.SetTheory.objects_mem_sets.mem S a) (Exists fun x_2 => Eq (f ⟨a, ⋯⟩) ⟨x, ⋯⟩))","name":["Chapter3","SetTheory","Set","image_eq_image","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Subtype","val"],["Or"],["Nat","instCharZero"],["funext"],["Eq","symm"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Eq","ndrec"],["instHPow"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Exists"],["Insert","insert"],["Subtype","ext"],["Chapter3","f_3_4_9_c"],["Exists","casesOn"],["Nat"],["AddMonoidWithOne","toNatCast"],["Eq","refl"],["Iff"],["id"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_5"],["Eq","mpr"],["instNatAtLeastTwo"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_6"],["Chapter3","SetTheory","Set","powerset_axiom"],["eq_false_of_decide"],["Or","inr"],["Bool"],["Eq","mp"],["Chapter3","f_3_4_9_b"],["Chapter3","f_3_4_9_d"],["Chapter3","f_3_4_9_a"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_4"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Iff","intro"],["Nat","instAddMonoidWithOne"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["or_false"],["Or","inl"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_7"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Subtype","property"],["exists_eq","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","inst_pow"],["propext"],["Chapter3","SetTheory","Set","coe_of_fun_inj","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["instOfNatAtLeastTwo"],["HPow","hPow"],["OfNat","ofNat"],["Or","casesOn"],["eq_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","toSubtype"],["instDecidableEqNat"],["False"],["Chapter3","SetTheory","Set","coe_of_fun"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","casesOn"],["Subtype","mk"]],"typeReferences":[["instHPow"],["Chapter3","SetTheory","Set","instInsert"],["Chapter3","f_3_4_9_b"],["Singleton","singleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","f_3_4_9_d"],["Chapter3","f_3_4_9_a"],["HPow","hPow"],["Chapter3","f_3_4_9_c"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","coe_of_fun"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory","Set","inst_pow"]],"type":"∀ [inst : Chapter3.SetTheory] (F : inst.Object),\n  Iff\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (instHPow.hPow (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1))\n        (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)))\n      F)\n    (Or (Eq F (Chapter3.SetTheory.Set.coe_of_fun Chapter3.f_3_4_9_a))\n      (Or (Eq F (Chapter3.SetTheory.Set.coe_of_fun Chapter3.f_3_4_9_b))\n        (Or (Eq F (Chapter3.SetTheory.Set.coe_of_fun Chapter3.f_3_4_9_c))\n          (Eq F (Chapter3.SetTheory.Set.coe_of_fun Chapter3.f_3_4_9_d)))))","name":["Chapter3","SetTheory","Set","example_3_4_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Omega","LinearCombo","mul_eval"],["Int","instSub"],["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["le_of_le_of_eq"],["HMul","hMul"],["GT","gt"],["Equiv"],["Or"],["Int","instLEInt"],["Eq","symm"],["HSub","hSub"],["Lean","Omega","tidy_sat"],["Lean","Omega","LinearCombo","add_eval"],["Int","add_one_le_of_lt"],["Bool","true"],["List","cons"],["List","decidableBAll"],["And","left"],["instLTNat"],["Lean","Omega","combo_sat'"],["Neg","neg"],["And","right"],["Lean","Omega","Constraint","addInequality_sat"],["Lean","Omega","LinearCombo","coordinate"],["Int","instNegInt"],["instDecidableEqBool"],["Nat"],["instOfNat"],["Eq","refl"],["id"],["Lean","Omega","Constraint","addEquality_sat"],["instHMul"],["Lean","Omega","LinearCombo","instAdd"],["Lean","Omega","Int","sub_congr"],["Or","elim"],["Equiv","instEquivLike"],["Bool"],["Nat","cast"],["Lean","Omega","LinearCombo","coordinate_eval_0"],["Option","some"],["Int","sub_eq_zero_of_eq"],["DFunLike","coe"],["Decidable","decide"],["Int","instMul"],["Lean","Omega","LinearCombo","mk"],["Nat","lt_or_gt_of_ne"],["Lean","Omega","Int","mul_congr"],["Lean","Omega","LinearCombo","instSub"],["Lean","Omega","Coeffs","ofList"],["instOfNatNat"],["Int","instAdd"],["Int","instDecidableEq"],["EquivLike","toFunLike"],["instMulNat"],["Equiv","symm"],["Lean","Omega","Constraint","not_sat'_of_isImpossible"],["Eq"],["instDecidableOr"],["Lean","Omega","and_not_not_of_not_or"],["Int","ofNat_mul"],["of_decide_eq_true"],["instNatCastInt"],["Not"],["List","nil"],["instHAdd"],["Lean","Omega","LinearCombo"],["Lean","Omega","Int","ofNat_congr"],["Lean","Omega","Int","add_congr"],["Lean","Omega","Constraint","isImpossible"],["Int","sub_nonneg_of_le"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LT","lt"],["Lean","Omega","LinearCombo","mul"],["Lean","Omega","Int","ofNat_lt_of_lt"],["Lean","Omega","LinearCombo","sub_eval"],["Chapter3","Nat"],["Option","none"],["Lean","Omega","Coeffs","isZero"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Lean","Omega","Constraint","mk"],["Lean","Omega","LinearCombo","eval"],["instHSub"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["HMul","hMul"],["Chapter3","SetTheory"],["DFunLike","coe"],["OfNat","ofNat"],["Equiv"],["Nat"],["Chapter3","Nat"],["Or"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["instMulNat"],["False"],["Equiv","symm"],["instHMul"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory] (x : inst.nat.toSubtype),\n  Eq (instHMul.hMul 2 (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm x)) 4 →\n    Not\n        (Or (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm x) 1)\n          (Or (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm x) 2)\n            (Eq (EquivLike.toFunLike.coe Chapter3.SetTheory.Set.nat_equiv.symm x) 3))) →\n      False","name":["Chapter3","SetTheory","Set","preimage_f_3_4_2","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Exists"],["True"],["Eq","trans"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Set","iUnion"],["Set","mem_iUnion","_simp_1"],["congrArg"],["Set","instMembership"],["Chapter3","SetTheory","Set"],["iff_self"],["of_eq_true"],["congr"],["Iff"],["funext"],["Chapter3","SetTheory","Set","toSubtype"],["Subtype","exists","_simp_1"],["Set","ext"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Chapter3","SetTheory","Set","iUnion_eq","_simp_1_1"],["setOf"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set"],["Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Set","iUnion"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (I : inst.Set) (A : I.toSubtype → inst.Set),\n  Eq (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (I.iUnion A) x)\n    (Set.iUnion fun α => setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (A α) x)","name":["Chapter3","SetTheory","Set","iUnion_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Decidable"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["Chapter3","SetTheory","Set","toSubtype"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["Decidable"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] →\n  Decidable\n    (∀ (X Y : inst.Set) (f : X.toSubtype → Y.toSubtype) (A B : inst.Set),\n      Eq (Chapter3.SetTheory.Set.image f (Chapter3.SetTheory.Set.instSDiff.sdiff A B))\n        (Chapter3.SetTheory.Set.instSDiff.sdiff (Chapter3.SetTheory.Set.image f A) (Chapter3.SetTheory.Set.image f B)))","name":["Chapter3","SetTheory","Set","image_of_diff'"],"kind":"definition","isProp":false},{"valueReferences":[["implies_congr"],["Subtype"],["Lean","Grind","not_and"],["Chapter3","SetTheory","specify"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Set","specification_axiom"],["eq_true"],["Chapter3","SetTheory","Object"],["Lean","Grind","not_exists"],["Subtype","val"],["Or"],["Lean","Grind","eq_false_of_imp_eq_true"],["forall_congr"],["Eq","symm"],["Lean","Grind","forall_forall_or"],["Eq"],["Not"],["Exists"],["Chapter3","SetTheory","Set","specify"],["True"],["And"],["True","intro"],["Chapter3","SetTheory","Set"],["false_or"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set","preimage"],["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (U : inst.Set) (x : inst.Object),\n  Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.preimage f U) x →\n    Not (Chapter3.SetTheory.objects_mem_sets.mem X x) →\n      Exists fun x' => And (Eq x'.val x) (Chapter3.SetTheory.objects_mem_sets.mem U (f x').val)","name":["Chapter3","SetTheory","Set","mem_preimage'","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Membership","mem"],["Chapter3","SetTheory","Set","subset_def"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","instSubset"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Eq (Chapter3.SetTheory.Set.instSubset.Subset X Y)\n    (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem X x → Chapter3.SetTheory.objects_mem_sets.mem Y x)","name":["Chapter3","SetTheory","Set","powerset_of_triple","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Grind","not_and"],["Eq","trans"],["Eq","mp"],["Lean","Grind","and_eq_of_eq_true_right"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Lean","Grind","not_or"],["eq_true"],["Lean","Grind","not_eq_prop"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","or_of_and_eq_false"],["Lean","Grind","imp_eq_of_eq_true_left"],["False","elim"],["Or"],["congr"],["Eq","symm"],["Lean","Grind","not_eq_of_eq_true"],["Eq"],["Not"],["True"],["Lean","Grind","eq_true_of_and_eq_true_right"],["And"],["Lean","Grind","not_not"],["True","intro"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["Lean","Grind","iff_eq"],["eq_false"],["Eq","refl"],["Lean","Grind","or_eq_of_eq_false_right"],["Iff"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object) (Y : inst.Set),\n  (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem Y x → Or (Eq x a) (Or (Eq x b) (Eq x c))) →\n    Chapter3.SetTheory.objects_mem_sets.mem Y a →\n      Chapter3.SetTheory.objects_mem_sets.mem Y b →\n        Chapter3.SetTheory.objects_mem_sets.mem Y c →\n          ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Y x) (Or (Eq x a) (Or (Eq x b) (Eq x c)))","name":["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_4"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instNeZeroSucc"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["one_ne_zero","_simp_1"],["Nat","instOne"],["Or"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["False"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)) 1","name":["Chapter3","f_3_4_9_b","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Chapter3","SetTheory","Object"],["eq_true"],["ite_cond_eq_true"],["heq_of_eq"],["Subtype","val"],["Or"],["Subtype","mk","inj"],["eq_of_heq"],["Eq","symm"],["Eq","ndrec"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_3"],["HEq","trans"],["Insert","insert"],["True","intro"],["ite_cond_eq_false"],["Lean","Grind","nestedProof"],["Chapter3","f_3_4_9_a","_proof_1"],["Eq","refl"],["eq_false"],["Classical","byContradiction"],["id"],["HEq"],["Subtype"],["Eq","mp"],["Lean","Grind","nestedProof_congr"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Lean","Grind","nestedDecidable"],["Chapter3","SetTheory","Set","instSingleton"],["Subtype","property"],["Eq"],["Lean","Grind","or_eq_of_eq_false_left"],["Not"],["Lean","Grind","em"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_2"],["Lean","Grind","alreadyNorm"],["Chapter3","SetTheory","Set","instInsert"],["True"],["HEq","refl"],["ite"],["Chapter3","f_3_4_9_b","_proof_1"],["OfNat","ofNat"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["eq_false_of_decide"],["Bool"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Subtype","val"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["or_false"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["instOfNatAtLeastTwo"],["Insert","insert"],["Chapter3","f_3_4_9_c"],["OfNat","ofNat"],["eq_self"],["Nat"],["AddMonoidWithOne","toNatCast"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["instDecidableEqNat"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"type":"∀ [inst : Chapter3.SetTheory]\n  (f :\n    (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)).toSubtype →\n      (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype),\n  Eq (f ⟨4, ⋯⟩).val 1 →\n    Eq (f ⟨7, ⋯⟩).val 0 →\n      ∀ (val : inst.Object)\n        (hx :\n          Chapter3.SetTheory.objects_mem_sets.mem\n            (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)) val),\n        Or (Eq val 4) (Eq val 7) → Eq (f ⟨val, hx⟩).val (Chapter3.f_3_4_9_c ⟨val, hx⟩).val","name":["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","instInsert"],["ite"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Subtype","val"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Insert","insert"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"[inst : Chapter3.SetTheory] →\n  (Chapter3.SetTheory.Set.instInsert.insert 1\n        (Chapter3.SetTheory.Set.instInsert.insert 2 (Chapter3.SetTheory.Set.instSingleton.singleton 3))).toSubtype →\n    inst.Set","name":["Chapter3","SetTheory","Set","index_example"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["Chapter3","SetTheory","Object"],["Subtype","val"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Exists"],["Chapter3","SetTheory","Set","image"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Exists fun X =>\n    Exists fun Y =>\n      Exists fun f =>\n        Exists fun S =>\n          Exists fun x =>\n            Not\n              (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.image f S) (f x).val →\n                Chapter3.SetTheory.objects_mem_sets.mem S x.val)","name":["Chapter3","SetTheory","Set","mem_image_of_eval_counter"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","pow"],["Pow","mk"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Pow"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → Pow inst.Set inst.Set","name":["Chapter3","SetTheory","Set","inst_pow"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","iInter"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["Ne"],["Eq"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory","Set","iInter"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X I : inst.Set} (hI : Ne I Chapter3.SetTheory.Set.instEmpty.emptyCollection)\n  (A : I.toSubtype → inst.Set),\n  Eq (Chapter3.SetTheory.Set.instSDiff.sdiff X (I.iUnion A))\n    (I.iInter hI fun α => Chapter3.SetTheory.Set.instSDiff.sdiff X (A α))","name":["Chapter3","SetTheory","Set","compl_iUnion"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","iInter"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["Ne"],["Eq"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory","Set","iInter"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X I : inst.Set} (hI : Ne I Chapter3.SetTheory.Set.instEmpty.emptyCollection)\n  (A : I.toSubtype → inst.Set),\n  Eq (Chapter3.SetTheory.Set.instSDiff.sdiff X (I.iInter hI A))\n    (I.iUnion fun α => Chapter3.SetTheory.Set.instSDiff.sdiff X (A α))","name":["Chapter3","SetTheory","Set","compl_iInter"],"kind":"theorem","isProp":true},{"valueReferences":[["instHPow"],["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","instInsert"],["Lean","Name"],["Chapter3","SetTheory","Set","replace"],["Singleton","singleton"],["Lean","Name","str"],["Bool","false"],["Insert","insert"],["Chapter3","SetTheory","Object"],["HPow","hPow"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Chapter3","SetTheory","Set","powerset","_proof_1"],["Chapter3","SetTheory","Set","inst_pow"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.Set → inst.Set","name":["Chapter3","SetTheory","Set","powerset"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.preimage f (Chapter3.SetTheory.Set.instUnion.union A B))\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.preimage f A) (Chapter3.SetTheory.Set.preimage f B))","name":["Chapter3","SetTheory","Set","preimage_of_union"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","mem_sUnion","_simp_1"],["Membership","mem"],["Set","sUnion"],["Chapter3","SetTheory","union"],["Exists","intro"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Iff","intro"],["congrArg"],["And","intro"],["congr"],["funext"],["Chapter3","SetTheory","Set","union_eq","_simp_1_1"],["Eq","symm"],["Eq","ndrec"],["Eq"],["Function","instFunLikeEmbedding"],["Exists"],["Set"],["Function","Embedding"],["And"],["Set","instMembership"],["Exists","casesOn"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Iff"],["id"],["Set","ext"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["Chapter3","SetTheory","set_to_object"],["And","casesOn"],["setOf"]],"typeReferences":[["Exists"],["Set"],["Function","Embedding"],["Membership","mem"],["Chapter3","SetTheory","union"],["Set","sUnion"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","set_to_object"],["setOf"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set),\n  Eq (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem (inst.union A) x)\n    (setOf fun S =>\n        Exists fun S' =>\n          And (Eq S (setOf fun x => Chapter3.SetTheory.objects_mem_sets.mem S' x))\n            (Chapter3.SetTheory.objects_mem_sets.mem A\n              (Function.instFunLikeEmbedding.coe inst.set_to_object S'))).sUnion","name":["Chapter3","SetTheory","Set","union_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {X Y : inst.Set} → (X.toSubtype → Y.toSubtype) → inst.Set → inst.Set","name":["Chapter3","SetTheory","Set","preimage"],"kind":"definition","isProp":false},{"valueReferences":[["Eq","trans"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["Lean","Grind","not_eq_prop"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","Grind","imp_eq_of_eq_true_left"],["False","elim"],["Or"],["Eq","symm"],["Eq"],["Lean","Grind","or_eq_of_eq_false_left"],["Not"],["True"],["And"],["Lean","Grind","not_not"],["Lean","Grind","eq_true_of_not_eq_false"],["True","intro"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["eq_false"],["Eq","refl"],["Iff"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["And","casesOn"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object) (Y : inst.Set),\n  (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem Y x → Or (Eq x a) (Or (Eq x b) (Eq x c))) →\n    Chapter3.SetTheory.objects_mem_sets.mem Y a →\n      Not (Chapter3.SetTheory.objects_mem_sets.mem Y b) →\n        Not (Chapter3.SetTheory.objects_mem_sets.mem Y c) →\n          ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Y x) (Eq x a)","name":["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instUnion"],["Union","union"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.image f (Chapter3.SetTheory.Set.instUnion.union A B))\n    (Chapter3.SetTheory.Set.instUnion.union (Chapter3.SetTheory.Set.image f A) (Chapter3.SetTheory.Set.image f B))","name":["Chapter3","SetTheory","Set","image_of_union"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["forall_eq_or_imp","_simp_1"],["Chapter3","SetTheory","Set","powerset_of_triple","_simp_1_1"],["DFunLike"],["exists_eq_left'","_simp_1"],["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["eq_true"],["Chapter3","SetTheory","Object"],["or_true"],["heq_of_eq"],["IsEmpty","forall_iff","_simp_1"],["Function","instEmbeddingLikeEmbedding"],["Or"],["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_8"],["funext"],["forall_congr"],["eq_of_heq"],["Eq","symm"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Function","instFunLikeEmbedding"],["Eq","ndrec"],["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_6"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Exists"],["Function","Embedding"],["And"],["Insert","insert"],["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_11"],["Exists","casesOn"],["implies_true"],["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_10"],["HasSubset","Subset"],["Iff"],["Eq","refl"],["id"],["HEq"],["Eq","mpr"],["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_4"],["implies_congr_ctx"],["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_5"],["Chapter3","SetTheory","Set","mem_powerset","_simp_1"],["Chapter3","SetTheory","set_to_object"],["Chapter3","SetTheory","Set","instSubset"],["Or","inr"],["Chapter3","SetTheory","Set","powerset_of_triple","_simp_1_2"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["DFunLike","coe"],["congrArg"],["Chapter3","SetTheory","Set","powerset"],["Iff","intro"],["Or","inl"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Eq"],["Not"],["true_or"],["True"],["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_9"],["Chapter3","SetTheory","Set","instInsert"],["HEq","refl"],["iff_false"],["instIsEmptyFalse"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Or","casesOn"],["eq_self"],["and_self"],["Chapter3","SetTheory","Set","not_mem_empty","_simp_1"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Chapter3","SetTheory","Set","ext"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["dite"],["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_7"],["And","casesOn"]],"typeReferences":[["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Function","Embedding"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","Object"],["EmptyCollection","emptyCollection"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c x : inst.Object),\n  Iff\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (Chapter3.SetTheory.Set.instInsert.insert a\n          (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c))).powerset\n      x)\n    (Or (Eq x (Function.instFunLikeEmbedding.coe inst.set_to_object Chapter3.SetTheory.Set.instEmpty.emptyCollection))\n      (Or\n        (Eq x (Function.instFunLikeEmbedding.coe inst.set_to_object (Chapter3.SetTheory.Set.instSingleton.singleton a)))\n        (Or\n          (Eq x\n            (Function.instFunLikeEmbedding.coe inst.set_to_object (Chapter3.SetTheory.Set.instSingleton.singleton b)))\n          (Or\n            (Eq x\n              (Function.instFunLikeEmbedding.coe inst.set_to_object (Chapter3.SetTheory.Set.instSingleton.singleton c)))\n            (Or\n              (Eq x\n                (Function.instFunLikeEmbedding.coe inst.set_to_object\n                  (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton b))))\n              (Or\n                (Eq x\n                  (Function.instFunLikeEmbedding.coe inst.set_to_object\n                    (Chapter3.SetTheory.Set.instInsert.insert a (Chapter3.SetTheory.Set.instSingleton.singleton c))))\n                (Or\n                  (Eq x\n                    (Function.instFunLikeEmbedding.coe inst.set_to_object\n                      (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c))))\n                  (Eq x\n                    (Function.instFunLikeEmbedding.coe inst.set_to_object\n                      (Chapter3.SetTheory.Set.instInsert.insert a\n                        (Chapter3.SetTheory.Set.instInsert.insert b\n                          (Chapter3.SetTheory.Set.instSingleton.singleton c))))))))))))","name":["Chapter3","SetTheory","Set","powerset_of_triple"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Classical","propDecidable"],["Chapter3","SetTheory","Object"],["eq_true"],["ite_cond_eq_true"],["heq_of_eq"],["Subtype","val"],["Or"],["Subtype","mk","inj"],["eq_of_heq"],["Eq","symm"],["Eq","ndrec"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_3"],["HEq","trans"],["Insert","insert"],["True","intro"],["ite_cond_eq_false"],["Lean","Grind","nestedProof"],["Chapter3","f_3_4_9_a","_proof_1"],["Eq","refl"],["eq_false"],["Classical","byContradiction"],["id"],["HEq"],["Subtype"],["Eq","mp"],["Lean","Grind","nestedProof_congr"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Lean","Grind","nestedDecidable"],["Chapter3","SetTheory","Set","instSingleton"],["Subtype","property"],["Eq"],["Lean","Grind","or_eq_of_eq_false_left"],["Not"],["Lean","Grind","em"],["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_2"],["Lean","Grind","alreadyNorm"],["Chapter3","SetTheory","Set","instInsert"],["True"],["HEq","refl"],["ite"],["Chapter3","f_3_4_9_b","_proof_1"],["OfNat","ofNat"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"typeReferences":[["eq_false_of_decide"],["Bool"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Chapter3","f_3_4_9_b"],["Singleton","singleton"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Subtype","val"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["Nat","instAddMonoidWithOne"],["congrArg"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["or_false"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["instOfNatAtLeastTwo"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["AddMonoidWithOne","toNatCast"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Eq","refl"],["Chapter3","SetTheory","Set","toSubtype"],["instDecidableEqNat"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"]],"type":"∀ [inst : Chapter3.SetTheory]\n  (f :\n    (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)).toSubtype →\n      (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)).toSubtype),\n  Eq (f ⟨4, ⋯⟩).val 0 →\n    Eq (f ⟨7, ⋯⟩).val 1 →\n      ∀ (val : inst.Object)\n        (hx :\n          Chapter3.SetTheory.objects_mem_sets.mem\n            (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)) val),\n        Or (Eq val 4) (Eq val 7) → Eq (f ⟨val, hx⟩).val (Chapter3.f_3_4_9_b ⟨val, hx⟩).val","name":["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Grind","not_and"],["Eq","trans"],["Eq","mp"],["Lean","Grind","and_eq_of_eq_true_right"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Lean","Grind","not_or"],["eq_true"],["Lean","Grind","not_eq_prop"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","or_of_and_eq_false"],["Lean","Grind","imp_eq_of_eq_true_left"],["False","elim"],["Or"],["congr"],["Eq","symm"],["Eq"],["Lean","Grind","or_eq_of_eq_false_left"],["Not"],["True"],["Lean","Grind","eq_true_of_and_eq_true_right"],["And"],["Lean","Grind","not_not"],["True","intro"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["eq_false"],["Eq","refl"],["Lean","Grind","or_eq_of_eq_false_right"],["Iff"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["And","casesOn"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object) (Y : inst.Set),\n  (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem Y x → Or (Eq x a) (Or (Eq x b) (Eq x c))) →\n    Chapter3.SetTheory.objects_mem_sets.mem Y a →\n      Not (Chapter3.SetTheory.objects_mem_sets.mem Y b) →\n        Chapter3.SetTheory.objects_mem_sets.mem Y c →\n          ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Y x) (Or (Eq x a) (Eq x c))","name":["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","mem_triple"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a b c : inst.Object),\n  Eq\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (Chapter3.SetTheory.Set.instInsert.insert a\n        (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))\n      x)\n    (Or (Eq x a) (Or (Eq x b) (Eq x c)))","name":["Chapter3","SetTheory","Set","preimage_f_3_4_2","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set","specify"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","specification_axiom'"],["Iff","rfl"],["Subtype","val"],["congrArg"],["Chapter3","SetTheory","Set"],["Iff"],["id"],["Eq","mpr"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (U : inst.Set) (x : X.toSubtype),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.preimage f U) x.val)\n    (Chapter3.SetTheory.objects_mem_sets.mem U (f x).val)","name":["Chapter3","SetTheory","Set","mem_preimage"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Eq","trans"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["Subtype","val"],["Lean","Grind","not_eq_prop"],["forall_not_of_not_exists"],["Or"],["forall_congr"],["Eq","symm"],["Lean","Grind","forall_forall_or"],["Chapter3","SetTheory","Set","image","_proof_1"],["of_eq_false"],["Exists"],["And"],["True","intro"],["Lean","Grind","nestedProof"],["Chapter3","SetTheory","replace"],["Exists","casesOn"],["false_or"],["Iff"],["Eq","refl"],["eq_false"],["Classical","byContradiction"],["Lean","Grind","eq_false_of_imp_eq_false"],["Lean","Grind","not_and"],["Subtype"],["Eq","mp"],["Chapter3","SetTheory","Set","replacement_axiom"],["Lean","Grind","not_exists"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","Grind","imp_eq_of_eq_true_left"],["Lean","Grind","of_forall_eq_false"],["Eq"],["Not"],["True"],["Lean","Grind","eq_true_of_not_eq_false"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","eq_true_of_imp_eq_false"],["Lean","Grind","intro_with_eq"],["Subtype","casesOn"],["Subtype","mk"],["And","casesOn"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["Iff"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set) (y : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.image f S) y)\n    (Exists fun x => And (Chapter3.SetTheory.objects_mem_sets.mem S x.val) (Eq (f x).val y))","name":["Chapter3","SetTheory","Set","mem_image","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["True"],["and_imp","_simp_1"],["Membership","mem"],["And"],["eq_true"],["Chapter3","SetTheory","Object"],["and_true"],["Subtype","val"],["congrArg"],["implies_true"],["eq_self"],["Chapter3","SetTheory","Set"],["of_eq_true"],["congr"],["Eq","refl"],["forall_congr"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["implies_congr_ctx"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set) (a : X.toSubtype)\n  (a_1 a_2 : inst.Object),\n  And (And (Eq (f a).val a_1) (Chapter3.SetTheory.objects_mem_sets.mem S a.val))\n      (And (Eq (f a).val a_2) (Chapter3.SetTheory.objects_mem_sets.mem S a.val)) →\n    Eq a_1 a_2","name":["Chapter3","SetTheory","Set","image","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["exists_eq_left'","_simp_1"],["Membership","mem"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Function","instEmbeddingLikeEmbedding"],["Chapter3","SetTheory","Set","powerset"],["congrArg"],["iff_self"],["funext"],["Function","instFunLikeEmbedding"],["Eq"],["Exists"],["True"],["Function","Embedding"],["And"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["of_eq_true"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","mem_powerset","_simp_1"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {S S' : inst.Set},\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem S.powerset (Function.instFunLikeEmbedding.coe inst.set_to_object S'))\n    (Chapter3.SetTheory.Set.instSubset.Subset S' S)","name":["Chapter3","SetTheory","Set","mem_powerset'"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (A B : inst.Set),\n  Eq (Chapter3.SetTheory.Set.preimage f (Chapter3.SetTheory.Set.instSDiff.sdiff A B))\n    (Chapter3.SetTheory.Set.instSDiff.sdiff (Chapter3.SetTheory.Set.preimage f A) (Chapter3.SetTheory.Set.preimage f B))","name":["Chapter3","SetTheory","Set","preimage_of_diff"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nonempty_choose","_proof_1"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","nonempty_def"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Exists","choose"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["Ne"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {I : inst.Set} → Ne I Chapter3.SetTheory.Set.instEmpty.emptyCollection → I.toSubtype","name":["Chapter3","SetTheory","Set","nonempty_choose"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set"],["Iff","of_eq"],["Eq","refl"],["Iff","mpr"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X : inst.Set} (a : inst.Object),\n  Chapter3.SetTheory.objects_mem_sets.mem X a → Chapter3.SetTheory.objects_mem_sets.mem X a","name":["Chapter3","SetTheory","Set","image_eq_image","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Equiv","instEquivLike"],["Nat","cast"],["HMul","hMul"],["DFunLike","coe"],["OfNat","ofNat"],["Equiv"],["Chapter3","SetTheory","Set","instNatCast"],["Nat"],["Chapter3","Nat"],["instOfNatNat"],["EquivLike","toFunLike"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["instMulNat"],["Equiv","symm"],["instHMul"]],"typeReferences":[["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → inst.nat.toSubtype → inst.nat.toSubtype","name":["Chapter3","f_3_4_2"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["Lean","Name","anonymous"],["sorryAx"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","instSubset"],["Function","Injective"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["HasSubset","Subset"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"],["Function","Injective"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype),\n  Iff\n    (∀ (S : inst.Set),\n      Chapter3.SetTheory.Set.instSubset.Subset S X →\n        Eq (Chapter3.SetTheory.Set.preimage f (Chapter3.SetTheory.Set.image f S)) S)\n    (Function.Injective f)","name":["Chapter3","SetTheory","Set","preimage_image_of_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Exists"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["Or"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (X Y : inst.Set),\n  Exists fun Z =>\n    ∀ (x : inst.Object),\n      Iff (Chapter3.SetTheory.objects_mem_sets.mem Z x)\n        (Or (Chapter3.SetTheory.objects_mem_sets.mem X x) (Chapter3.SetTheory.objects_mem_sets.mem Y x))","name":["Chapter3","SetTheory","Set","union_pair_exists"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","function_to_object"],["Subtype"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","mem"],["Function","instFunLikeEmbedding"],["DFunLike","coe"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {X Y : inst.Set} → (X.toSubtype → Y.toSubtype) → inst.Object","name":["Chapter3","SetTheory","Set","coe_of_fun"],"kind":"definition","isProp":false},{"valueReferences":[["implies_congr"],["Eq","trans"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["Chapter3","SetTheory","Object"],["eq_true"],["Lean","Grind","not_eq_prop"],["forall_not_of_not_exists"],["Or"],["forall_congr"],["Eq","symm"],["Lean","Grind","forall_forall_or"],["Function","instFunLikeEmbedding"],["of_eq_false"],["Exists"],["Function","Embedding"],["And"],["True","intro"],["Chapter3","SetTheory","Set","union_axiom"],["Lean","Grind","nestedProof"],["Chapter3","SetTheory","replace"],["Exists","casesOn"],["false_or"],["eq_false"],["Iff"],["Eq","refl"],["Classical","byContradiction"],["Chapter3","SetTheory","set_to_object"],["Lean","Grind","eq_false_of_imp_eq_false"],["Subtype"],["Lean","Grind","not_and"],["Eq","mp"],["Chapter3","SetTheory","union"],["Chapter3","SetTheory","Set","replacement_axiom"],["Lean","Grind","not_exists"],["DFunLike","coe"],["congrArg"],["Chapter3","SetTheory","Set","powerset"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","Grind","of_forall_eq_false"],["Lean","Grind","imp_eq_of_eq_true_left"],["Eq"],["Not"],["True"],["Lean","Grind","eq_true_of_not_eq_false"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["Chapter3","SetTheory","Set","toSubtype"],["False"],["Lean","Grind","eq_true_of_imp_eq_false"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["Subtype","casesOn"],["Subtype","mk"],["And","casesOn"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set","replace"],["Function","Embedding"],["Membership","mem"],["And"],["Chapter3","SetTheory","union"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] {S : inst.Set} {P : S.powerset.toSubtype → inst.Object → Prop}\n  {hP : ∀ (x : S.powerset.toSubtype) (y y' : inst.Object), And (P x y) (P x y') → Eq y y'} {x : inst.Object},\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (inst.union (S.powerset.replace hP)) x)\n    (Exists fun S' =>\n      Exists fun U =>\n        And (P S' (Function.instFunLikeEmbedding.coe inst.set_to_object U))\n          (Chapter3.SetTheory.objects_mem_sets.mem U x))","name":["Chapter3","SetTheory","Set","mem_union_powerset_replace_iff","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","replace"],["Function","Embedding"],["Chapter3","SetTheory","union"],["Chapter3","SetTheory","Object"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","iUnion","_proof_1"],["DFunLike","coe"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → (I : inst.Set) → (I.toSubtype → inst.Set) → inst.Set","name":["Chapter3","SetTheory","Set","iUnion"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory","Set","mem_iUnion"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} (A : I.toSubtype → inst.Set) (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (I.iUnion A) x)\n    (Exists fun α => Chapter3.SetTheory.objects_mem_sets.mem (A α) x)","name":["Chapter3","SetTheory","Set","iUnion_example","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["True"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["eq_true"],["Chapter3","SetTheory","Object"],["Lean","Grind","not_not"],["True","intro"],["congrArg"],["Lean","Grind","imp_eq_of_eq_true_left"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["Or"],["of_eq_true"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["Eq","symm"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["Eq"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Or"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object) (Y : inst.Set),\n  (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem Y x → Or (Eq x a) (Or (Eq x b) (Eq x c))) →\n    Not (Chapter3.SetTheory.objects_mem_sets.mem Y a) →\n      Not (Chapter3.SetTheory.objects_mem_sets.mem Y b) →\n        Not (Chapter3.SetTheory.objects_mem_sets.mem Y c) →\n          ∀ (x : inst.Object), Not (Chapter3.SetTheory.objects_mem_sets.mem Y x)","name":["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_11"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Chapter3","SetTheory","Set","iInter"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","instEmpty"],["Chapter3","SetTheory","objects_mem_sets"],["Ne"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory","Set","iInter"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} (hI : Ne I Chapter3.SetTheory.Set.instEmpty.emptyCollection)\n  (A : I.toSubtype → inst.Set) (x : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (I.iInter hI A) x)\n    (∀ (α : I.toSubtype), Chapter3.SetTheory.objects_mem_sets.mem (A α) x)","name":["Chapter3","SetTheory","Set","mem_iInter"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Set"],["Membership","mem"],["And"],["Set","sUnion"],["Set","mem_sUnion"],["propext"],["Set","instMembership"]],"typeReferences":[["Exists"],["Set"],["Membership","mem"],["And"],["Set","sUnion"],["Eq"],["Set","instMembership"]],"type":"∀ {α : Type u} {x : α} {S : Set (Set α)},\n  Eq (Set.instMembership.mem S.sUnion x) (Exists fun t => And (Set.instMembership.mem S t) (Set.instMembership.mem t x))","name":["Chapter3","SetTheory","Set","union_eq","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Singleton","singleton"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instNeZeroSucc"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["zero_ne_one","_simp_1"],["or_false"],["Nat","instOne"],["Or"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Nat","instMulZeroClass"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["of_eq_true"],["MulZeroClass","toZero"],["False"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 0 (Chapter3.SetTheory.Set.instSingleton.singleton 1)) 0","name":["Chapter3","f_3_4_9_a","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Chapter3","SetTheory","Set","preimage"],["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","specification_axiom''","_simp_1"],["Eq","mp"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","mk"],["Subtype","val"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (U : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset (Chapter3.SetTheory.Set.preimage f U) X","name":["Chapter3","SetTheory","Set","preimage_in_domain"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["OfNat","ofNat"],["Chapter3","SetTheory","Set","powerset"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"],["Function","instFunLikeEmbedding"],["Eq"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] {X : inst.Set} (x : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem X.powerset x)\n    (Exists fun Y =>\n      And (Eq x (Function.instFunLikeEmbedding.coe inst.set_to_object Y))\n        (Chapter3.SetTheory.Set.instSubset.Subset Y X))","name":["Chapter3","SetTheory","Set","mem_powerset"],"kind":"theorem","isProp":true},{"valueReferences":[["CoeOut","mk"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","coe_of_fun"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["CoeOut"],["Chapter3","SetTheory"]],"type":"[inst : Chapter3.SetTheory] → {X Y : inst.Set} → CoeOut (X.toSubtype → Y.toSubtype) inst.Object","name":["Chapter3","SetTheory","Set","inst_coe_of_fun"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter3","SetTheory","union_axiom"]],"typeReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","union"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set"],["Iff"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set) (x : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (inst.union A) x)\n    (Exists fun S =>\n      And (Chapter3.SetTheory.objects_mem_sets.mem S x)\n        (Chapter3.SetTheory.objects_mem_sets.mem A (Function.instFunLikeEmbedding.coe inst.set_to_object S)))","name":["Chapter3","SetTheory","Set","union_axiom"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["Subtype"],["Eq","trans"],["and_imp","_simp_1"],["Chapter3","SetTheory","Set","replace"],["Membership","mem"],["Chapter3","SetTheory","union"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory","Set","iUnion","_proof_1"],["Function","instEmbeddingLikeEmbedding"],["congrArg"],["Iff","intro"],["forall_congr"],["funext"],["Subtype","exists","_simp_1"],["Eq"],["Function","instFunLikeEmbedding"],["propext"],["Exists"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Set","mem_iUnion","_proof_1_5"],["Chapter3","SetTheory","Set","union_axiom"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Chapter3","SetTheory","Set","replacement_axiom","_simp_1"],["Chapter3","SetTheory","Set"],["Eq","refl"],["Iff"],["Chapter3","SetTheory","Set","mem_iUnion","_proof_1_3"],["Chapter3","SetTheory","Set","toSubtype"],["id"],["forall_exists_index","_simp_1"],["Chapter3","SetTheory","objects_mem_sets"],["Eq","mpr"],["implies_congr_ctx"],["Subtype","mk"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Exists"],["Chapter3","SetTheory","Set"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} (A : I.toSubtype → inst.Set) (x : inst.Object),\n  Iff (Chapter3.SetTheory.objects_mem_sets.mem (I.iUnion A) x)\n    (Exists fun α => Chapter3.SetTheory.objects_mem_sets.mem (A α) x)","name":["Chapter3","SetTheory","Set","mem_iUnion"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Eq","refl"],["Chapter3","SetTheory","Set","replace"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq","ndrec"],["Eq"],["Eq","rec"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","replace"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Eq","ndrec"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : inst.Set) {P P_1 : A.toSubtype → inst.Object → Prop} (e_P : Eq P P_1)\n  (hP : ∀ (x : A.toSubtype) (y y' : inst.Object), And (P x y) (P x y') → Eq y y'), Eq (A.replace hP) (A.replace ⋯)","name":["Chapter3","SetTheory","Set","replace","congr_simp"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","iUnion"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instEmpty"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Chapter3","SetTheory","Set","iUnion"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Set","instEmpty"],["Eq"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (A : Chapter3.SetTheory.Set.instEmpty.emptyCollection.toSubtype → inst.Set),\n  Eq (Chapter3.SetTheory.Set.instEmpty.emptyCollection.iUnion A) Chapter3.SetTheory.Set.instEmpty.emptyCollection","name":["Chapter3","SetTheory","Set","iUnion_of_empty"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","mem_triple"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Or"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (x a b c : inst.Object),\n  Eq\n    (Chapter3.SetTheory.objects_mem_sets.mem\n      (Chapter3.SetTheory.Set.instInsert.insert a\n        (Chapter3.SetTheory.Set.instInsert.insert b (Chapter3.SetTheory.Set.instSingleton.singleton c)))\n      x)\n    (Or (Eq x a) (Or (Eq x b) (Eq x c)))","name":["Chapter3","SetTheory","Set","powerset_of_triple","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Grind","not_and"],["Eq","trans"],["Eq","mp"],["Lean","Grind","and_eq_of_eq_true_right"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Lean","Grind","not_or"],["eq_true"],["Lean","Grind","not_eq_prop"],["Lean","Grind","eq_false_of_not_eq_true"],["congrArg"],["Lean","Grind","of_eq_eq_true"],["Lean","Grind","or_of_and_eq_false"],["Lean","Grind","imp_eq_of_eq_true_left"],["False","elim"],["Or"],["congr"],["Eq","symm"],["Eq"],["Not"],["True"],["Lean","Grind","eq_true_of_and_eq_true_right"],["And"],["Lean","Grind","not_not"],["True","intro"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["Lean","Grind","iff_eq"],["eq_false"],["Eq","refl"],["Lean","Grind","or_eq_of_eq_false_right"],["Iff"],["Classical","byContradiction"],["False"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Grind","intro_with_eq"],["And","casesOn"]],"typeReferences":[["Not"],["Chapter3","SetTheory","Set"],["Or"],["Iff"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] (a b c : inst.Object) (Y : inst.Set),\n  (∀ (x : inst.Object), Chapter3.SetTheory.objects_mem_sets.mem Y x → Or (Eq x a) (Or (Eq x b) (Eq x c))) →\n    Not (Chapter3.SetTheory.objects_mem_sets.mem Y a) →\n      Chapter3.SetTheory.objects_mem_sets.mem Y b →\n        Chapter3.SetTheory.objects_mem_sets.mem Y c →\n          ∀ (x : inst.Object), Iff (Chapter3.SetTheory.objects_mem_sets.mem Y x) (Or (Eq x b) (Eq x c))","name":["Chapter3","SetTheory","Set","powerset_of_triple","_proof_1_8"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Object"],["Subtype","val"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Chapter3","SetTheory","objects_mem_sets"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set) (x : X.toSubtype),\n  Chapter3.SetTheory.objects_mem_sets.mem S x.val →\n    Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.image f S) (f x).val","name":["Chapter3","SetTheory","Set","mem_image_of_eval"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["instOfNatNat"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Lean","Name","num"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["HasSubset","Subset"],["Chapter3","SetTheory","Set","instSDiff"],["SDiff","sdiff"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (A B : inst.Set),\n  Chapter3.SetTheory.Set.instSubset.Subset\n    (Chapter3.SetTheory.Set.instSDiff.sdiff (Chapter3.SetTheory.Set.image f A) (Chapter3.SetTheory.Set.image f B))\n    (Chapter3.SetTheory.Set.image f (Chapter3.SetTheory.Set.instSDiff.sdiff A B))","name":["Chapter3","SetTheory","Set","image_of_diff"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["Chapter3","SetTheory","Set","mem_image"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["propext"]],"typeReferences":[["Exists"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["Membership","mem"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (S : inst.Set) (y : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.image f S) y)\n    (Exists fun x => And (Chapter3.SetTheory.objects_mem_sets.mem S x.val) (Eq (f x).val y))","name":["Chapter3","SetTheory","Set","image_f_3_4_2","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["DFunLike","coe"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","objects_mem_sets"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","mem_powerset'"],["propext"],["Chapter3","SetTheory","set_to_object"],["Chapter3","SetTheory","Set","instSubset"]],"typeReferences":[["Membership","mem"],["Function","Embedding"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","set_to_object"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {S S' : inst.Set},\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem S.powerset (Function.instFunLikeEmbedding.coe inst.set_to_object S'))\n    (Chapter3.SetTheory.Set.instSubset.Subset S' S)","name":["Chapter3","SetTheory","Set","mem_powerset'","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","mem_powerset"],["DFunLike","coe"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","instSubset"],["propext"],["Chapter3","SetTheory","set_to_object"]],"typeReferences":[["Exists"],["Membership","mem"],["Function","Embedding"],["And"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["DFunLike","coe"],["Chapter3","SetTheory","Set","powerset"],["Chapter3","SetTheory","Set"],["HasSubset","Subset"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Function","instFunLikeEmbedding"],["Chapter3","SetTheory","Set","instSubset"],["Chapter3","SetTheory","set_to_object"]],"type":"∀ [inst : Chapter3.SetTheory] {X : inst.Set} (x : inst.Object),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem X.powerset x)\n    (Exists fun Y =>\n      And (Eq x (Function.instFunLikeEmbedding.coe inst.set_to_object Y))\n        (Chapter3.SetTheory.Set.instSubset.Subset Y X))","name":["Chapter3","SetTheory","Set","mem_powerset","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","Set","mem_preimage"],["Chapter3","SetTheory","objects_mem_sets"],["Subtype","val"],["propext"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Membership","mem"],["Chapter3","SetTheory","Set","toSubtype"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Eq"],["Subtype","val"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y : inst.Set} (f : X.toSubtype → Y.toSubtype) (U : inst.Set) (x : X.toSubtype),\n  Eq (Chapter3.SetTheory.objects_mem_sets.mem (Chapter3.SetTheory.Set.preimage f U) x.val)\n    (Chapter3.SetTheory.objects_mem_sets.mem U (f x).val)","name":["Chapter3","SetTheory","Set","mem_preimage","_simp_1"],"kind":"theorem","isProp":true},{"valueReferences":[["eq_false_of_decide"],["Bool"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["Bool","false"],["Membership","mem"],["Chapter3","SetTheory","Object"],["or_true"],["Chapter3","SetTheory","Object","instOfNat"],["congrArg"],["Nat","instAddMonoidWithOne"],["Chapter3","SetTheory","Set","ofNat_inj'","_simp_1"],["Or"],["Nat","instCharZero"],["instOfNatNat"],["congr"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","mem_singleton","_simp_1"],["Eq"],["Chapter3","SetTheory","Set","mem_insert","_simp_1"],["Chapter3","SetTheory","Set","instInsert"],["True"],["Insert","insert"],["instOfNatAtLeastTwo"],["OfNat","ofNat"],["eq_self"],["Nat"],["Chapter3","SetTheory","Set"],["AddMonoidWithOne","toNatCast"],["of_eq_true"],["Eq","refl"],["instDecidableEqNat"],["False"],["instNatAtLeastTwo"],["Chapter3","SetTheory","objects_mem_sets"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Chapter3","SetTheory","Set","instSingleton"],["Membership","mem"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory","objects_mem_sets"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Object","instOfNat"],["OfNat","ofNat"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Chapter3.SetTheory.objects_mem_sets.mem\n    (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 7)) 7","name":["Chapter3","SetTheory","Set","example_3_4_9","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["Eq"],["Chapter3","SetTheory","Set","iInter'"],["OfNat","ofNat"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory","Set","iInter'"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I : inst.Set} (β β' : I.toSubtype) (A : I.toSubtype → inst.Set),\n  Eq (I.iInter' β A) (I.iInter' β' A)","name":["Chapter3","SetTheory","Set","iInter'_insensitive"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Set","instEmpty"],["Union","union"],["EmptyCollection","emptyCollection"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Ne"],["Lean","Name","num"]],"typeReferences":[["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","instUnion"],["Chapter3","SetTheory","Set","instEmpty"],["Ne"],["Union","union"],["EmptyCollection","emptyCollection"],["Chapter3","SetTheory"]],"type":"∀ [inst : Chapter3.SetTheory] {I J : inst.Set},\n  Ne I Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n    Ne J Chapter3.SetTheory.Set.instEmpty.emptyCollection →\n      Ne (Chapter3.SetTheory.Set.instUnion.union I J) Chapter3.SetTheory.Set.instEmpty.emptyCollection","name":["Chapter3","SetTheory","Set","union_of_nonempty"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","preimage"],["sorryAx"],["Lean","Name","anonymous"],["Chapter3","SetTheory","Set","image"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Chapter3","SetTheory","Set"],["instOfNatNat"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Function","RightInverse"],["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","Set","image"],["HasSubset","Subset"],["Function","LeftInverse"],["And"],["Chapter3","SetTheory","Set","toSubtype"],["Eq"],["Chapter3","SetTheory"],["Chapter3","SetTheory","Set","instSubset"]],"type":"∀ [inst : Chapter3.SetTheory] {X Y V : inst.Set} (f : X.toSubtype → Y.toSubtype) (f_inv : Y.toSubtype → X.toSubtype),\n  And (Function.LeftInverse f_inv f) (Function.RightInverse f_inv f) →\n    Chapter3.SetTheory.Set.instSubset.Subset V Y →\n      Eq (Chapter3.SetTheory.Set.image f_inv V) (Chapter3.SetTheory.Set.preimage f V)","name":["Chapter3","SetTheory","Set","preimage_eq_image_of_inv"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter3","SetTheory","Set","nat_equiv"],["Eq","trans"],["OfNat","ofNat_eq_ofNat","_simp_1"],["Singleton","singleton"],["Bool","false"],["Nat","instMulOneClass"],["Exists","intro"],["MonoidWithZero","toMulZeroOneClass"],["or_true"],["Subtype","val"],["Equiv"],["IsDomain","toCancelMonoidWithZero"],["Nat","instCharZero"],["Eq","symm"],["Eq","ndrec"],["Chapter3","SetTheory","Object","instNatCast"],["Exists"],["or_self"],["Eq","refl"],["Iff"],["Nat","instStarOrderedRing"],["Chapter3","SetTheory","nat"],["Eq","mpr"],["AddMonoid","toAddZeroClass"],["Bool"],["MulZeroOneClass","toMulOneClass"],["CancelMonoidWithZero","toMonoidWithZero"],["Nat","instAddMonoidWithOne"],["Chapter3","SetTheory","Set","instNatCast"],["or_false"],["Chapter3","SetTheory","Set","preimage_f_3_4_2","_simp_1_1"],["Nat","instSemiring"],["instOfNatNat"],["congr"],["EquivLike","toFunLike"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","SetTheory","Set","instOfNat"],["Equiv","symm"],["Eq"],["Chapter3","SetTheory","Set","nat_coe_eq_iff","_simp_1"],["Chapter3","SetTheory","Set","nat_equiv_coe_of_coe''"],["instOfNatAtLeastTwo"],["mul_one"],["OfNat","ofNat"],["eq_self"],["and_self"],["Chapter3","Nat"],["OfNat","ofNat_ne_zero","_simp_1"],["instDecidableEqNat"],["Chapter3","SetTheory","objects_mem_sets"],["Nat","instIsStrictOrderedRing"],["And","casesOn"],["Chapter3","SetTheory","Set","preimage"],["Membership","mem"],["Chapter3","SetTheory","Object"],["HMul","hMul"],["AddMonoidWithOne","toAddMonoid"],["not_false_eq_true"],["Or"],["funext"],["StarOrderedRing","toExistsAddOfLE"],["Nat","instLinearOrder"],["Chapter3","SetTheory","Set","preimage_f_3_4_2","_proof_1_3"],["Chapter3","SetTheory","Set","preimage_f_3_4_2","_simp_1_2"],["AddZeroClass","toZero"],["Nat","instPartialOrder"],["Insert","insert"],["And"],["Nat","instStarRing"],["Chapter3","SetTheory","Set","preimage_f_3_4_2","_proof_1_4"],["Nat","instNonUnitalSemiring"],["Exists","casesOn"],["Nat"],["Decidable","byContradiction"],["AddMonoidWithOne","toNatCast"],["id"],["Chapter3","f_3_4_2"],["instHMul"],["instNatAtLeastTwo"],["eq_false_of_decide"],["Equiv","instEquivLike"],["Nat","cast"],["Eq","mp"],["DFunLike","coe"],["Chapter3","SetTheory","Object","instOfNat"],["Iff","intro"],["congrArg"],["Chapter3","SetTheory","Set","nat_coe_eq_iff'","_simp_1"],["MulOneClass","toOne"],["instMulNat"],["Zero","toOfNat0"],["instDecidableOr"],["Not"],["Chapter3","SetTheory","Set","instInsert"],["True"],["IsStrictOrderedRing","isDomain"],["OfNat","one_ne_ofNat","_simp_1"],["mul_eq_left₀","_simp_1"],["Or","casesOn"],["Chapter3","SetTheory","Set"],["of_eq_true"],["One","toOfNat1"],["Chapter3","SetTheory","Set","ext"],["Chapter3","SetTheory","Set","toSubtype"],["False"]],"typeReferences":[["Chapter3","SetTheory","Set","preimage"],["Chapter3","SetTheory","Set","instInsert"],["Singleton","singleton"],["Insert","insert"],["Chapter3","SetTheory","Object"],["Chapter3","SetTheory"],["OfNat","ofNat"],["Chapter3","SetTheory","Object","instOfNat"],["Chapter3","SetTheory","Set"],["Chapter3","SetTheory","nat"],["Chapter3","SetTheory","Set","instSingleton"],["Chapter3","f_3_4_2"],["Eq"]],"type":"∀ [inst : Chapter3.SetTheory],\n  Eq\n    (Chapter3.SetTheory.Set.preimage Chapter3.f_3_4_2\n      (Chapter3.SetTheory.Set.instInsert.insert 2\n        (Chapter3.SetTheory.Set.instInsert.insert 4 (Chapter3.SetTheory.Set.instSingleton.singleton 6))))\n    (Chapter3.SetTheory.Set.instInsert.insert 1\n      (Chapter3.SetTheory.Set.instInsert.insert 2 (Chapter3.SetTheory.Set.instSingleton.singleton 3)))","name":["Chapter3","SetTheory","Set","preimage_f_3_4_2"],"kind":"theorem","isProp":true}]
