[{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["instLENat"],["GE","ge"],["OfNat","ofNat"]],"typeReferences":[["Nat"],["instLENat"],["GE","ge"],["Nat","instPreorder"],["StrictMono"]],"type":"∀ {n : Nat → Nat}, StrictMono n → ∀ (j : Nat), GE.ge (n j) j","name":["Chapter9","why_7_6_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Lean","Grind","not_and"],["PartialOrder","toPreorder"],["Eq","trans"],["Real","instAddGroup"],["Eq","mp"],["Preorder","toLT"],["eq_true"],["Real","instNatCast"],["Classical","choose"],["Lean","Grind","eq_false_of_not_eq_true"],["Or"],["NatCast","natCast"],["Real","instLT"],["Eq","symm"],["Lean","Grind","not_eq_of_eq_true"],["Preorder","toLE"],["abs"],["Real","lattice"],["Not"],["Exists"],["True"],["Real"],["And"],["True","intro"],["Lean","Grind","nestedProof"],["Real","instLE"],["LT","lt"],["LinearOrder","toPartialOrder"],["Lean","Grind","or_eq_of_eq_false_right"],["LE","le"],["Classical","byContradiction"],["False"],["Real","linearOrder"],["Lean","Grind","intro_with_eq"],["Chapter9","BddOn","of_continuous_on_compact","_proof_1_1"],["And","casesOn"]],"typeReferences":[["Real","instPreorder"],["Nat","cast"],["Exists"],["PartialOrder","toPreorder"],["Real","instAddGroup"],["Real"],["And"],["Preorder","toLT"],["Real","instNatCast"],["Exists","choose"],["Real","instLE"],["LT","lt"],["LinearOrder","toPartialOrder"],["Nat"],["Real","instLT"],["LE","le"],["Real","linearOrder"],["Preorder","toLE"],["abs"],["Real","lattice"]],"type":"∀ {a b : Real} {f : Real → Real}\n  (hunbound :\n    ∀ (x : Real),\n      Exists fun x_1 =>\n        And (Real.instPreorder.le a x_1) (And (Real.instPreorder.le x_1 b) (Real.linearOrder.lt x (abs (f x_1)))))\n  (n : Nat),\n  And (Real.instLE.le a ((fun n => ⋯.choose) n))\n      (And (Real.instLE.le ((fun n => ⋯.choose) n) b) (Real.instLT.lt n.cast (abs (f ((fun n => ⋯.choose) n))))) →\n    And (Real.instPreorder.le a ((fun n => ⋯.choose) n)) (Real.instPreorder.le ((fun n => ⋯.choose) n) b)","name":["Chapter9","BddOn","of_continuous_on_compact","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Real","instPreorder"],["Lean","Grind","Field","toDiv"],["Eq","trans"],["Lean","Grind","Semiring","toMul"],["Classical","propDecidable"],["eq_true"],["eagerReduce"],["ite_cond_eq_true"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Linarith","Expr","add"],["ConditionallyCompleteLinearOrder","toConditionallyCompleteLattice"],["NatCast","natCast"],["SupSet","sSup"],["Eq","symm"],["Bool","true"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Lean","Grind","CommRing","toRing"],["Lean","Grind","CommSemiring","toSemiring"],["Real","instAddCommSemigroup"],["Exists"],["instPreorder_mathlib"],["Set","mem_image"],["Set","instMembership"],["Lean","Grind","Semiring","toNatModule"],["false_or"],["instOfNat"],["Iff"],["Eq","refl"],["Lean","Grind","CommRing","Poly","num"],["Lean","Grind","Field","div_eq_mul_inv"],["Classical","byContradiction"],["covariant_swap_add_of_covariant_add"],["Bool"],["Real","instIsStrictOrderedRing"],["Lean","Grind","CommRing","Expr","mul"],["Set","Icc"],["Real","field"],["Real","instNatCast"],["Real","instConditionallyCompleteLinearOrder"],["Lean","Grind","not_exists"],["instHDiv"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","Grind","imp_eq_of_eq_true_left"],["Lean","Grind","Linarith","le_of_eq"],["Lean","Grind","Ring","toSemiring"],["Lean","Grind","nestedDecidable"],["contravariant_lt_of_covariant_le"],["instOfNatNat"],["AddCommMagma","toAdd"],["Lean","Grind","AddCommMonoid","toZero"],["Preorder","toLE"],["Eq"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["ite"],["Set"],["Real","instSupSet"],["Real","instAdd"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["Real","instInv"],["Real","instZero"],["Lean","Grind","iff_eq"],["instHSub"],["Real","instDivInvMonoid"],["And","casesOn"],["contravariant_swap_add_of_contravariant_add"],["Lean","Grind","CommRing","lt_norm"],["PartialOrder","toPreorder"],["Membership","mem"],["Preorder","toLT"],["One","one"],["HMul","hMul"],["Lean","Grind","Field","toCommRing"],["HDiv","hDiv"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["Or"],["Lean","Grind","Linarith","le_norm"],["funext"],["forall_congr"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","Poly","add"],["HSub","hSub"],["Lean","Grind","forall_forall_or"],["Real","instAddCommMonoid"],["Lean","Grind","Ring","toIntModule"],["Lean","Grind","CommRing","Power","mk"],["SemilatticeInf","toPartialOrder"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["Lean","Grind","CommRing","eq_norm"],["Lean","Grind","Semiring","ofNat"],["And"],["IsOrderedAddMonoid","toAddLeftMono"],["Real","instSub"],["True","intro"],["Int","instNegInt"],["Real","instLE"],["Exists","casesOn"],["Lean","Grind","CommRing","le_norm"],["Lean","Grind","CommRing","inv_split"],["Set","image"],["Nat"],["Lean","Grind","NatModule","toAddCommMonoid"],["Real","instAddRightCancelSemigroup"],["instHMul"],["Lean","Grind","CommRing","Expr","var"],["Real","linearOrder"],["Real","instOne"],["ConditionallyCompleteLattice","toLattice"],["Lean","Grind","Linarith","le_lt_combine"],["Lean","Grind","not_and"],["Eq","mp"],["congrArg"],["Lean","RArray","leaf"],["Lean","Grind","Linarith","Expr","var"],["Real","instLT"],["Lean","RArray","branch"],["AddCommSemigroup","toAddCommMagma"],["Zero","toOfNat0"],["Real","partialOrder"],["Real","instMul"],["Not"],["Lean","Grind","Field","toInv"],["Inv","inv"],["Lattice","toSemilatticeInf"],["Lean","Grind","em"],["True"],["Lean","Grind","alreadyNorm"],["instHAdd"],["Lean","Grind","Linarith","lt_norm"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","CommRing","Mon","unit"],["Real","semiring"],["DivInvMonoid","toDiv"],["Lean","Grind","CommRing","Expr","sub"],["LT","lt"],["Or","casesOn"],["Lean","Grind","CommRing","Expr","num"],["Lean","Grind","CommRing","toCommSemiring"],["of_eq_true"],["One","toOfNat1"],["Field","toGrindField"],["LE","le"],["False"],["Lean","Grind","intro_with_eq"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"]],"typeReferences":[["Real","instPreorder"],["Nat","cast"],["PartialOrder","toPreorder"],["Set","Icc"],["Membership","mem"],["Preorder","toLT"],["Real","instNatCast"],["Real","instConditionallyCompleteLinearOrder"],["instHDiv"],["HDiv","hDiv"],["ConditionallyCompleteLinearOrder","toConditionallyCompleteLattice"],["SupSet","sSup"],["Real","instLT"],["HSub","hSub"],["SemilatticeInf","toPartialOrder"],["Exists"],["Lattice","toSemilatticeInf"],["Real"],["instHAdd"],["Set"],["Real","instSupSet"],["And"],["Real","instAdd"],["Real","instSub"],["OfNat","ofNat"],["DivInvMonoid","toDiv"],["Real","instLE"],["Set","instMembership"],["HAdd","hAdd"],["LT","lt"],["Nat"],["Set","image"],["One","toOfNat1"],["LE","le"],["Real","instOne"],["ConditionallyCompleteLattice","toLattice"],["instHSub"],["Real","instDivInvMonoid"]],"type":"∀ {a b : Real} {f : Real → Real} (M : Real),\n  (∀ {y : Real},\n      Set.instMembership.mem (Set.image f (Set.Icc a b)) y →\n        Real.instLE.le y (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))) →\n    ∀ (n : Nat),\n      (Exists fun a_1 =>\n          And (Set.instMembership.mem (Set.image f (Set.Icc a b)) a_1)\n            (Real.instConditionallyCompleteLinearOrder.toSemilatticeInf.lt\n              (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n                (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n              a_1)) →\n        Exists fun x =>\n          And (Set.instMembership.mem (Set.Icc a b) x)\n            (Real.instLT.lt\n              (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n                (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n              (f x))","name":["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["IsLeast"],["Set","mem_image","_simp_1"],["Real","instPreorder"],["PartialOrder","toPreorder"],["Eq","trans"],["and_imp","_simp_1"],["Membership","mem"],["Exists","intro"],["Real","instConditionallyCompleteLinearOrder"],["congrArg"],["And","intro"],["ConditionallyCompleteLinearOrder","toConditionallyCompleteLattice"],["congr"],["forall_congr"],["Preorder","toLE"],["Eq"],["SemilatticeInf","toPartialOrder"],["rfl"],["Lattice","toSemilatticeInf"],["Exists"],["Chapter9","sInf","of_isMinOn","_simp_1_1"],["Real"],["Set"],["IsLeast","csInf_eq"],["And"],["Set","instMembership"],["Set","image"],["Eq","refl"],["LE","le"],["lowerBounds"],["id"],["forall_exists_index","_simp_1"],["Eq","mpr"],["forall_apply_eq_imp_iff₂","_simp_1"],["ConditionallyCompleteLattice","toLattice"]],"typeReferences":[["Set","image"],["Real","instPreorder"],["Real"],["Set"],["InfSet","sInf"],["Membership","mem"],["IsMinOn"],["Real","instInfSet"],["Eq"],["Set","instMembership"]],"type":"∀ {f : Real → Real} {X : Set Real} {x₀ : Real},\n  Set.instMembership.mem X x₀ → IsMinOn f X x₀ → Eq (Real.instInfSet.sInf (Set.image f X)) (f x₀)","name":["Chapter9","sInf","of_isMinOn"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Lean","Grind","Field","toDiv"],["Lean","Grind","Semiring","toMul"],["Set","Icc"],["Membership","mem"],["Real","field"],["HMul","hMul"],["Real","instNatCast"],["Lean","Grind","Field","toCommRing"],["instHDiv"],["congrArg"],["HDiv","hDiv"],["Lean","Grind","Ring","toSemiring"],["NatCast","natCast"],["SupSet","sSup"],["Real","instLT"],["funext"],["forall_congr"],["HSub","hSub"],["Eq","ndrec"],["Lean","Grind","CommRing","toRing"],["Real","instMul"],["Lean","Grind","Field","toInv"],["Inv","inv"],["Exists"],["Real"],["Set"],["instHAdd"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["DivInvMonoid","toDiv"],["OfNat","ofNat"],["Eq","mpr_prop"],["Set","instMembership"],["LT","lt"],["HAdd","hAdd"],["Real","instInv"],["Nat"],["Set","image"],["One","toOfNat1"],["Field","toGrindField"],["Lean","Grind","Field","div_eq_mul_inv"],["instHMul"],["Real","instOne"],["instHSub"],["Real","instDivInvMonoid"]],"typeReferences":[["Real","instPreorder"],["Set","Icc"],["Membership","mem"],["Real","instNatCast"],["HMul","hMul"],["NatCast","natCast"],["SupSet","sSup"],["Real","instLT"],["HSub","hSub"],["Real","instMul"],["Inv","inv"],["Exists"],["Real"],["instHAdd"],["Set"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["OfNat","ofNat"],["Set","instMembership"],["HAdd","hAdd"],["LT","lt"],["Real","instInv"],["Nat"],["Set","image"],["One","toOfNat1"],["instHMul"],["Real","instOne"],["instHSub"]],"type":"∀ {a b : Real} {f : Real → Real},\n  (∀ (n : Nat),\n      Exists fun x =>\n        And (Set.instMembership.mem (Set.Icc a b) x)\n          (Real.instLT.lt\n            (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n              (instHMul.hMul 1 (Real.instInv.inv (instHAdd.hAdd (Real.instNatCast.natCast n) 1))))\n            (f x))) →\n    ∀ (n : Nat → Nat) (j : Nat),\n      Exists fun x =>\n        And (Set.instMembership.mem (Set.Icc a b) x)\n          (Real.instLT.lt\n            (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n              (instHMul.hMul 1 (Real.instInv.inv (instHAdd.hAdd (Real.instNatCast.natCast (n j)) 1))))\n            (f x))","name":["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Real"],["Set"],["LE","le"],["Membership","mem"],["Real","instLE"],["Set","instMembership"]],"typeReferences":[["Real"],["Set"]],"type":"(Real → Real) → Set Real → Prop","name":["Chapter9","BddAboveOn"],"kind":"definition","isProp":false},{"valueReferences":[["Classical","choose_spec"],["implies_congr"],["SubtractionMonoid","toSubNegZeroMonoid"],["Real","instPreorder"],["sorryAx"],["PartialOrder","toPreorder"],["Eq","trans"],["Real","instAddGroup"],["Lean","Name"],["AddCommGroup","toAddGroup"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["Preorder","toLT"],["eq_true"],["Chapter9","BddOn","of_continuous_on_compact"],["Classical","choose"],["le_csSup"],["BddAbove","mono"],["ConditionallyCompleteLinearOrder","toConditionallyCompleteLattice"],["SupSet","sSup"],["Eq","ndrec"],["abs"],["Real","lattice"],["bddAbove_Icc"],["SemilatticeInf","toPartialOrder"],["Exists"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["And"],["Set","instMembership"],["Real","instLE"],["Exists","casesOn"],["Nat"],["Set","image"],["IsMaxOn"],["id"],["Set","mem_Icc","_simp_1"],["Real","linearOrder"],["Eq","mpr"],["Lean","Name","anonymous"],["Set","Icc"],["Real","instConditionallyCompleteLinearOrder"],["SubtractionCommMonoid","toSubtractionMonoid"],["EmptyCollection","emptyCollection"],["Set","instEmptyCollection"],["SubNegZeroMonoid","toNegZeroClass"],["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_2"],["congrArg"],["instDistribLatticeOfLinearOrder"],["instOfNatNat"],["Real","instLT"],["Real","instNeg"],["Preorder","toLE"],["Eq"],["Not"],["Mathlib","Tactic","PushNeg","not_not_eq"],["Chapter9","IsMaxOn","of_continuous_on_compact","_simp_1_1"],["Lattice","toSemilatticeInf"],["True"],["Set"],["Mathlib","Tactic","PushNeg","not_lt_eq"],["Real","instSupSet"],["OfNat","ofNat"],["Mathlib","Tactic","Contrapose","mtr"],["LT","lt"],["LinearOrder","toPartialOrder"],["DistribLattice","toLattice"],["NegZeroClass","toNeg"],["Set","image_eq_empty","_simp_1"],["of_eq_true"],["AddCommGroup","toDivisionAddCommMonoid"],["LE","le"],["Real","instAddCommGroup"],["Ne"],["Lean","Name","num"],["And","casesOn"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["Set"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["And"],["ContinuousOn"],["Set","instMembership"],["LT","lt"],["IsMaxOn"],["Real","pseudoMetricSpace"],["Real","instLT"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ {f : Real → Real},\n      ContinuousOn f (Set.Icc a b) →\n        Exists fun xmax => And (Set.instMembership.mem (Set.Icc a b) xmax) (IsMaxOn f (Set.Icc a b) xmax)","name":["Chapter9","IsMaxOn","of_continuous_on_compact"],"kind":"theorem","isProp":true},{"valueReferences":[["SubtractionMonoid","toSubNegZeroMonoid"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Neg","neg"],["AddCommGroup","toAddGroup"],["And"],["abs_le"],["SubtractionCommMonoid","toSubtractionMonoid"],["SubNegZeroMonoid","toNegZeroClass"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["NegZeroClass","toNeg"],["AddCommGroup","toDivisionAddCommMonoid"],["LE","le"],["Eq","symm"],["Preorder","toLE"],["abs"],["propext"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["SubtractionMonoid","toSubNegZeroMonoid"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["Neg","neg"],["AddCommGroup","toAddGroup"],["LinearOrder"],["And"],["SubtractionCommMonoid","toSubtractionMonoid"],["AddCommGroup"],["SubNegZeroMonoid","toNegZeroClass"],["instDistribLatticeOfLinearOrder"],["NegZeroClass","toNeg"],["DistribLattice","toLattice"],["AddCommGroup","toDivisionAddCommMonoid"],["IsOrderedAddMonoid"],["LE","le"],["AddCommGroup","toAddCommMonoid"],["abs"],["Eq"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : LinearOrder G] [IsOrderedAddMonoid G] {a b : G},\n  Eq\n    (And\n      (instDistribLatticeOfLinearOrder.toSemilatticeInf.le (SubtractionMonoid.toSubNegZeroMonoid.toNegZeroClass.neg b)\n        a)\n      (instDistribLatticeOfLinearOrder.toSemilatticeInf.le a b))\n    (instDistribLatticeOfLinearOrder.toSemilatticeInf.le (abs a) b)","name":["Chapter9","BddOn","of_continuous_on_compact","_simp_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["PseudoMetricSpace","toUniformSpace"],["Real"],["Set"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["And"],["Exists","intro"],["Nat","instPreorder"],["Set","instMembership"],["Exists","casesOn"],["And","intro"],["Nat"],["Filter","atTop"],["Real","pseudoMetricSpace"],["Filter","Tendsto"],["nhds"],["And","casesOn"],["StrictMono"]],"typeReferences":[["Exists"],["PseudoMetricSpace","toUniformSpace"],["Real"],["Set"],["Membership","mem"],["UniformSpace","toTopologicalSpace"],["And"],["Exists","intro"],["Nat","instPreorder"],["Set","instMembership"],["And","intro"],["Nat"],["Filter","atTop"],["Real","pseudoMetricSpace"],["Filter","Tendsto"],["nhds"],["StrictMono"]],"type":"∀ (x : Nat → Real) (X : Set Real)\n  (motive :\n    (Exists fun n =>\n        And (StrictMono n)\n          (Exists fun L =>\n            And (Set.instMembership.mem X L) (Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)))) →\n      Prop)\n  (x_1 :\n    Exists fun n =>\n      And (StrictMono n)\n        (Exists fun L => And (Set.instMembership.mem X L) (Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)))),\n  (∀ (n : Nat → Nat) (hn : StrictMono n) (L : Real) (hLX : Set.instMembership.mem X L)\n      (hconv : Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)), motive ⋯) →\n    motive x_1","name":["Chapter9","BddOn","of_continuous_on_compact","match_1_3"],"kind":"definition","isProp":true},{"valueReferences":[["Classical","choose_spec"],["Real","instPreorder"],["Real"],["Set"],["Set","Icc"],["Chapter9","IsMaxOn","of_continuous_on_compact"],["Membership","mem"],["And","right"],["And"],["Classical","choose"],["Chapter9","sSup","of_continuous_on_compact","_proof_1_1"],["Set","instMembership"],["IsMaxOn"],["And","left"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["Set"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["Real","instSupSet"],["And"],["ContinuousOn"],["Set","instMembership"],["LT","lt"],["Set","image"],["SupSet","sSup"],["Real","pseudoMetricSpace"],["Real","instLT"],["Eq"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ (f : Real → Real),\n      ContinuousOn f (Set.Icc a b) →\n        Exists fun xmax =>\n          And (Set.instMembership.mem (Set.Icc a b) xmax)\n            (Eq (Real.instSupSet.sSup (Set.image f (Set.Icc a b))) (f xmax))","name":["Chapter9","sSup","of_continuous_on_compact"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Real","instPreorder"],["Lean","Grind","not_and"],["Eq","trans"],["Eq","mp"],["Set","Icc"],["Membership","mem"],["eq_true"],["Lean","Grind","not_exists"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","Grind","imp_eq_of_eq_true_left"],["Or"],["SupSet","sSup"],["Lean","Grind","eq_false_of_imp_eq_true"],["forall_congr"],["Eq","symm"],["Lean","Grind","forall_forall_or"],["Eq"],["Not"],["Exists"],["True"],["Real"],["Set"],["Real","instSupSet"],["And"],["True","intro"],["Set","instMembership"],["Set","image"],["false_or"],["IsMaxOn"],["Eq","refl"],["Classical","byContradiction"],["Chapter9","sSup","of_isMaxOn"],["False"],["Lean","Grind","intro_with_eq"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["Set"],["Set","Icc"],["Membership","mem"],["And"],["Real","instSupSet"],["Set","instMembership"],["Set","image"],["IsMaxOn"],["SupSet","sSup"],["Eq"]],"type":"∀ {a b : Real} (f : Real → Real) (x : Real),\n  Set.instMembership.mem (Set.Icc a b) x →\n    IsMaxOn f (Set.Icc a b) x →\n      Exists fun xmax =>\n        And (Set.instMembership.mem (Set.Icc a b) xmax) (Eq (Real.instSupSet.sSup (Set.image f (Set.Icc a b))) (f xmax))","name":["Chapter9","sSup","of_continuous_on_compact","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Classical","choose_spec"],["Real","instPreorder"],["Real"],["Set"],["Set","Icc"],["Membership","mem"],["And","right"],["And"],["Chapter9","sInf","of_continuous_on_compact","_proof_1_1"],["Classical","choose"],["Set","instMembership"],["IsMinOn"],["Chapter9","IsMinOn","of_continuous_on_compact"],["And","left"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["Set"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["And"],["ContinuousOn"],["Set","instMembership"],["LT","lt"],["Set","image"],["Real","pseudoMetricSpace"],["Real","instLT"],["InfSet","sInf"],["Real","instInfSet"],["Eq"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ (f : Real → Real),\n      ContinuousOn f (Set.Icc a b) →\n        Exists fun xmin =>\n          And (Set.instMembership.mem (Set.Icc a b) xmin)\n            (Eq (Real.instInfSet.sInf (Set.image f (Set.Icc a b))) (f xmin))","name":["Chapter9","sInf","of_continuous_on_compact"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["LE","le"],["lowerBounds"],["Membership","mem"],["Preorder","toLE"],["mem_lowerBounds"],["propext"],["Set","instMembership"]],"typeReferences":[["Preorder"],["Set"],["LE","le"],["lowerBounds"],["Membership","mem"],["Preorder","toLE"],["Eq"],["Set","instMembership"]],"type":"∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α},\n  Eq (Set.instMembership.mem (lowerBounds s) a) (∀ (x : α), Set.instMembership.mem s x → inst.le a x)","name":["Chapter9","sInf","of_isMinOn","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["PseudoMetricSpace","toUniformSpace"],["Lean","Grind","Field","toDiv"],["Real","instAddGroup"],["Lean","Grind","Semiring","toMul"],["eagerReduce"],["Lean","Grind","intro_with_eq'"],["Lean","Grind","CommRing","Mon","mult"],["Classical","choose"],["Lean","Grind","Linarith","Expr","add"],["NatCast","natCast"],["SupSet","sSup"],["Eq","ndrec"],["abs"],["Real","lattice"],["Bool","true"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["nhds"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["Exists"],["instPreorder_mathlib"],["instLinearOrder_mathlib"],["Lean","Grind","Linarith","lt_lt_combine"],["Set","instMembership"],["Filter","atTop"],["instOfNat"],["Eq","refl"],["Lean","Grind","CommRing","Poly","num"],["Lean","Grind","Field","div_eq_mul_inv"],["Classical","byContradiction"],["covariant_swap_add_of_covariant_add"],["StrictMono"],["Bool"],["Real","instIsStrictOrderedRing"],["Lean","Grind","CommRing","Expr","mul"],["Set","Icc"],["Real","field"],["Real","instNatCast"],["instHDiv"],["Nat","instPreorder"],["Lean","Grind","Ring","toSemiring"],["contravariant_lt_of_covariant_le"],["instOfNatNat"],["congr"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["PseudoMetricSpace","toBornology"],["Lean","Grind","Linarith","Expr","zero"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["Set"],["Real","instSupSet"],["Real","instAdd"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["Real","instInv"],["instHSub"],["Real","instDivInvMonoid"],["contravariant_swap_add_of_contravariant_add"],["Lean","Grind","CommRing","lt_norm"],["PartialOrder","toPreorder"],["Membership","mem"],["Preorder","toLT"],["One","one"],["HMul","hMul"],["Lean","Grind","Field","toCommRing"],["HDiv","hDiv"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["Lean","Grind","Linarith","Poly","add"],["Lean","Grind","Linarith","Poly","nil"],["forall_congr"],["funext"],["HSub","hSub"],["Real","instAddCommMonoid"],["Lean","Grind","Ring","toIntModule"],["Lean","Grind","CommRing","Power","mk"],["Filter","Tendsto"],["IsClosed"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["And"],["IsOrderedAddMonoid","toAddLeftMono"],["Real","instSub"],["Lean","Grind","nestedProof"],["Int","instNegInt"],["Real","instLE"],["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_6"],["Nat"],["Set","image"],["Real","pseudoMetricSpace"],["Real","instAddRightCancelSemigroup"],["instHMul"],["Lean","Grind","CommRing","Expr","var"],["Real","linearOrder"],["Real","instOne"],["Eq","mp"],["UniformSpace","toTopologicalSpace"],["Classical","choose","congr_simp"],["congrArg"],["Lean","Grind","Linarith","Expr","var"],["Lean","RArray","leaf"],["Real","instLT"],["Bornology","IsBounded"],["Lean","RArray","branch"],["AddCommSemigroup","toAddCommMagma"],["Real","partialOrder"],["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_7"],["Real","instMul"],["Not"],["Lean","Grind","Field","toInv"],["Inv","inv"],["instHAdd"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","Linarith","lt_norm"],["Lean","Grind","CommRing","Mon","unit"],["Real","semiring"],["DivInvMonoid","toDiv"],["Lean","Grind","CommRing","Expr","sub"],["Eq","mpr_prop"],["LT","lt"],["Lean","Grind","CommRing","Expr","num"],["One","toOfNat1"],["Field","toGrindField"],["LE","le"],["Lean","Grind","CommRing","not_le_norm"],["False"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","intro_with_eq"],["Lean","Grind","CommRing","Poly","add"],["instLENat"]],"typeReferences":[["Real","instPreorder"],["Nat","cast"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["Real","instNatCast"],["GE","ge"],["instHDiv"],["Nat","instPreorder"],["HDiv","hDiv"],["SupSet","sSup"],["Real","instLT"],["HSub","hSub"],["Bornology","IsBounded"],["Preorder","toLE"],["nhds"],["Filter","Tendsto"],["PseudoMetricSpace","toBornology"],["IsClosed"],["Exists"],["Real"],["instHAdd"],["Set"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["Exists","choose"],["DivInvMonoid","toDiv"],["OfNat","ofNat"],["Real","instLE"],["Set","instMembership"],["LT","lt"],["HAdd","hAdd"],["Filter","atTop"],["Nat"],["Set","image"],["One","toOfNat1"],["Real","pseudoMetricSpace"],["LE","le"],["Real","instOne"],["instHSub"],["instLENat"],["Real","instDivInvMonoid"],["StrictMono"]],"type":"∀ {a b : Real} {f : Real → Real} (M : Real)\n  (claim2 :\n    ∀ (n : Nat),\n      Exists fun x =>\n        And (Set.instMembership.mem (Set.Icc a b) x)\n          (Real.instLT.lt\n            (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n              (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n            (f x))),\n  (∀ (n : Nat), Set.instMembership.mem (Set.Icc a b) ((fun n => ⋯.choose) n)) →\n    (∀ (n : Nat),\n        Real.instLT.lt\n          (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b))) (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n          (f ((fun n => ⋯.choose) n))) →\n      IsClosed (Set.Icc a b) →\n        Bornology.IsBounded (Set.Icc a b) →\n          ∀ (n : Nat → Nat),\n            StrictMono n →\n              ∀ (xmax : Real),\n                Set.instMembership.mem (Set.Icc a b) xmax →\n                  Filter.Tendsto (fun j => (fun n => ⋯.choose) (n j)) Filter.atTop (nhds xmax) →\n                    (∀ (j : Nat), GE.ge (n j) j) →\n                      Filter.Tendsto (fun j => f ((fun n => ⋯.choose) (n j))) Filter.atTop (nhds (f xmax)) →\n                        (∀ (j : Nat),\n                            Real.instLT.lt\n                              (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n                                (instHDiv.hDiv 1 (instHAdd.hAdd j.cast 1)))\n                              (f ((fun n => ⋯.choose) (n j)))) →\n                          (∀ (j : Nat),\n                              Real.instLE.le (f ((fun n => ⋯.choose) (n j)))\n                                (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))) →\n                            ∀ (i : Nat),\n                              ((fun i => Real.instPreorder.toLE) i).le\n                                ((fun j =>\n                                    instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n                                      (instHDiv.hDiv 1 (instHAdd.hAdd j.cast 1)))\n                                  i)\n                                ((fun j => f ((fun n => ⋯.choose) (n j))) i)","name":["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_10"],"kind":"theorem","isProp":true},{"valueReferences":[["Classical","choose_spec"],["implies_congr"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["Real","instPreorder"],["Ring","toNonAssocRing"],["PseudoMetricSpace","toUniformSpace"],["Real","instAddGroup"],["Eq","trans"],["AddCommGroup","toAddGroup"],["eq_true"],["AddGroupWithOne","toAddMonoidWithOne"],["Classical","choose"],["not_exists","_simp_1"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Mathlib","Tactic","Linarith","sub_neg_of_lt"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["False","elim"],["SubNegMonoid","toSub"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["abs"],["Real","lattice"],["NonAssocSemiring","toAddCommMonoidWithOne"],["nhds"],["rfl"],["Real","instCommSemiring"],["Exists"],["Exists","choose_spec"],["Chapter9","Convergesto"],["Real","instArchimedean"],["Set","instMembership"],["Filter","atTop"],["Chapter9","BddOn","of_continuous_on_compact","_simp_1_7"],["AddMonoid","toAddSemigroup"],["Eq","refl"],["Classical","byContradiction"],["Int","negOfNat"],["Eq","mpr"],["Nat","rawCast"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["StrictMono"],["Real","instIsStrictOrderedRing"],["Set","Icc"],["Real","instNatCast"],["ContinuousOn"],["not_le","_simp_1"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Nat","instPreorder"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Mathlib","Tactic","Ring","neg_one_mul"],["Eq"],["Preorder","toLE"],["Chapter9","Convergesto","comp"],["PseudoMetricSpace","toBornology"],["propext"],["ge_iff_le","_simp_1"],["Distrib","toAdd"],["Mathlib","Tactic","Ring","neg_zero"],["Set"],["HPow","hPow"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LinearOrder","toPartialOrder"],["AddGroupWithOne","toAddGroup"],["Monoid","toNatPow"],["Real","instZero"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["instHSub"],["Real","instAddMonoid"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Membership","mem"],["Iff","mp"],["Preorder","toLT"],["Int","rawCast"],["HMul","hMul"],["GT","gt"],["GE","ge"],["Chapter9","isBounded_def"],["Chapter9","Heine_Borel"],["And","intro"],["Semiring","toNonAssocSemiring"],["Real","instRCLike"],["Ring","toAddGroupWithOne"],["forall_congr"],["funext"],["Mathlib","Tactic","Linarith","add_neg"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["Classical","not_imp","_simp_1"],["AddGroup","toSubNegMonoid"],["Chapter9","why_7_6_3"],["Int","ofNat"],["Real","instAddCommMonoid"],["Chapter9","BddOn"],["Filter","Tendsto"],["NonAssocRing","toNonUnitalNonAssocRing"],["RCLike","charZero_rclike"],["IsClosed"],["SemilatticeInf","toPartialOrder"],["AddSemigroup","toAdd"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Real"],["Neg","neg"],["Real","instIsOrderedAddMonoid"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["And","right"],["And"],["Classical","not_forall","_simp_1"],["Chapter9","BddOn","of_continuous_on_compact","_proof_1_6"],["IsOrderedAddMonoid","toAddLeftMono"],["Real","instLE"],["Nat"],["Metric","isBounded_range_of_tendsto"],["Mathlib","Tactic","Ring","atom_pf"],["AddMonoidWithOne","toNatCast"],["HasSubset","Subset"],["Real","pseudoMetricSpace"],["Nat","cast_zero"],["id"],["instHMul"],["Set","mem_Icc","_simp_1"],["Real","linearOrder"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Nat","cast"],["Eq","mp"],["and_imp","_simp_1"],["UniformSpace","toTopologicalSpace"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["ContinuousOn","continuousWithinAt"],["Real","instRing"],["Real","instIsOrderedRing"],["Chapter9","ContinuousWithinAt","iff"],["Set","range"],["congrArg"],["ContinuousWithinAt"],["instDistribLatticeOfLinearOrder"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["Real","instLT"],["Real","instNeg"],["MonoidWithZero","toMonoid"],["Bornology","IsBounded"],["Mathlib","Tactic","Ring","sub_congr"],["Zero","toOfNat0"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Real","partialOrder"],["Mathlib","Tactic","Ring","of_eq"],["Chapter9","BddOn","of_continuous_on_compact","match_1_3"],["Not"],["Lattice","toSemilatticeInf"],["Chapter9","BddOn","of_continuous_on_compact","_proof_1_2"],["True"],["instHAdd"],["Nat","cast_le","_simp_1"],["Distrib","toMul"],["CommSemiring","toSemiring"],["Chapter9","Icc_bounded"],["Real","instZeroLEOneClass"],["Semiring","toMonoidWithZero"],["Exists","choose"],["Mathlib","Tactic","Ring","add_congr"],["Real","semiring"],["LT","lt"],["Set","instHasSubset"],["DistribLattice","toLattice"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["Mathlib","Tactic","Ring","neg_add"],["of_eq_true"],["Chapter9","AdherentPt","of_mem"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["LE","le"],["Real","instAddCommGroup"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["False"],["instLENat"],["exists_nat_gt"],["Chapter9","Icc_closed"]],"typeReferences":[["LT","lt"],["Real","instPreorder"],["PseudoMetricSpace","toUniformSpace"],["Real"],["Set","Icc"],["Real","pseudoMetricSpace"],["Real","instLT"],["UniformSpace","toTopologicalSpace"],["ContinuousOn"],["Chapter9","BddOn"]],"type":"∀ {a b : Real}, Real.instLT.lt a b → ∀ {f : Real → Real}, ContinuousOn f (Set.Icc a b) → Chapter9.BddOn f (Set.Icc a b)","name":["Chapter9","BddOn","of_continuous_on_compact"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Real","instAddGroup"],["Real"],["Set"],["LE","le"],["Membership","mem"],["Real","lattice"],["abs"],["Real","instLE"],["Set","instMembership"]],"typeReferences":[["Real"],["Set"]],"type":"(Real → Real) → Set Real → Prop","name":["Chapter9","BddOn"],"kind":"definition","isProp":false},{"valueReferences":[["Real","instAddGroup"],["Real"],["Set"],["LE","le"],["Membership","mem"],["Exists","intro"],["Real","lattice"],["abs"],["Real","instLE"],["Set","instMembership"]],"typeReferences":[["Real","instAddGroup"],["Real"],["Set"],["LE","le"],["Membership","mem"],["Real","lattice"],["abs"],["Chapter9","BddOn"],["Real","instLE"],["Set","instMembership"]],"type":"∀ {f : Real → Real} {X : Set Real} {M : Real},\n  (∀ (x : Real), Set.instMembership.mem X x → Real.instLE.le (abs (f x)) M) → Chapter9.BddOn f X","name":["Chapter9","BddOn","of_bounded"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["PartialOrder","toPreorder"],["Real","instAddGroup"],["Eq","trans"],["Membership","mem"],["Preorder","toLT"],["eq_true"],["Classical","choose"],["forall_not_of_not_exists"],["NatCast","natCast"],["Lean","Grind","eq_false_of_imp_eq_true"],["Eq","symm"],["Real","lattice"],["abs"],["Exists"],["of_eq_false"],["Real"],["Neg","neg"],["And"],["Chapter9","BddOn","of_continuous_on_compact","_proof_1_5"],["Set","subset_def"],["Lean","Grind","nestedProof"],["Set","instMembership"],["Nat"],["HasSubset","Subset"],["Eq","refl"],["Iff"],["eq_false"],["Classical","byContradiction"],["Real","linearOrder"],["Set","Icc"],["Eq","mp"],["Real","instNatCast"],["Set","range"],["False","casesOn"],["Real","instNeg"],["Preorder","toLE"],["Eq"],["Not"],["True"],["Set"],["LT","lt"],["Set","instHasSubset"],["LinearOrder","toPartialOrder"],["of_eq_true"],["Lean","Grind","iff_eq"],["LE","le"],["False"],["Set","mem_range"]],"typeReferences":[["Real","instPreorder"],["PartialOrder","toPreorder"],["Nat","cast"],["Real","instAddGroup"],["Set","Icc"],["Membership","mem"],["Preorder","toLT"],["Real","instNatCast"],["Set","range"],["Real","instNeg"],["Real","lattice"],["abs"],["Preorder","toLE"],["Exists"],["Real"],["Set"],["Neg","neg"],["And"],["Exists","choose"],["Set","instMembership"],["LT","lt"],["Set","instHasSubset"],["LinearOrder","toPartialOrder"],["Nat"],["HasSubset","Subset"],["LE","le"],["Real","linearOrder"]],"type":"∀ {a b : Real} {f : Real → Real}\n  (hunbound :\n    ∀ (x : Real),\n      Exists fun x_1 =>\n        And (Real.instPreorder.le a x_1) (And (Real.instPreorder.le x_1 b) (Real.linearOrder.lt x (abs (f x_1)))))\n  (n : Nat → Nat) (M : Real),\n  Set.instHasSubset.Subset (Set.range fun n_1 => f ((fun n => ⋯.choose) (n n_1))) (Set.Icc (Real.instNeg.neg M) M) →\n    ∀ (j : Nat), Set.instMembership.mem (Set.Icc (Real.instNeg.neg M) M) (f ((fun n => ⋯.choose) (n j)))","name":["Chapter9","BddOn","of_continuous_on_compact","_proof_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["contravariant_swap_add_of_contravariant_add"],["Real","instPreorder"],["PartialOrder","toPreorder"],["Eq","trans"],["Preorder","toLT"],["One","one"],["eq_true"],["eagerReduce"],["Lean","Grind","CommRing","Mon","mult"],["Lean","Grind","Field","toCommRing"],["Lean","Grind","Linarith","Expr","add"],["IsRightCancelAdd","addRightReflectLE_of_addRightReflectLT"],["Lean","Grind","Linarith","Expr","intMul"],["Lean","Grind","Linarith","Poly","nil"],["Lean","Grind","Linarith","Poly","add"],["Eq","symm"],["Set","Icc_eq_empty_iff"],["Lean","Grind","CommRing","Power","mk"],["Lean","Grind","Ring","toIntModule"],["Real","instAddCommMonoid"],["Bool","true"],["instOrderedAddOfAddRightMonoOfAddRightReflectLE"],["Lean","Grind","CommRing","toRing"],["Real","instAddCommSemigroup"],["of_eq_false"],["Real"],["instPreorder_mathlib"],["Neg","neg"],["instLinearOrder_mathlib"],["Real","instIsOrderedAddMonoid"],["Lean","Grind","Linarith","lt_lt_combine"],["IsOrderedAddMonoid","toAddLeftMono"],["Int","instNegInt"],["Real","instLE"],["Nat"],["instOfNat"],["Iff"],["Eq","refl"],["Real","instAddRightCancelSemigroup"],["Lean","Grind","CommRing","Poly","num"],["Classical","byContradiction"],["Lean","Grind","CommRing","Expr","var"],["Real","linearOrder"],["Real","instOne"],["covariant_swap_add_of_covariant_add"],["Bool"],["Real","instIsStrictOrderedRing"],["Eq","mp"],["Set","Icc"],["Real","field"],["Set","instEmptyCollection"],["EmptyCollection","emptyCollection"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","RArray","leaf"],["Lean","Grind","Linarith","Expr","var"],["contravariant_lt_of_covariant_le"],["instOfNatNat"],["Real","instLT"],["Lean","RArray","branch"],["AddCommSemigroup","toAddCommMagma"],["AddCommMagma","toAdd"],["Eq"],["Preorder","toLE"],["Real","partialOrder"],["Lean","Grind","Linarith","Expr","zero"],["Not"],["AddRightCancelSemigroup","toIsRightCancelAdd"],["True"],["Set"],["instHAdd"],["Real","instAdd"],["instOrderedRingOfIsStrictOrderedRing"],["Lean","Grind","Linarith","lt_norm"],["Lean","Grind","CommRing","Mon","unit"],["Real","semiring"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LT","lt"],["LinearOrder","toPartialOrder"],["Lean","Grind","iff_eq"],["Field","toGrindField"],["LE","le"],["Lean","Grind","CommRing","not_le_norm"],["Lean","Grind","Linarith","lt_unsat"],["Lean","Grind","CommRing","Poly","add"]],"typeReferences":[["LinearOrder","toPartialOrder"],["Real","instPreorder"],["PartialOrder","toPreorder"],["Real"],["Set","Icc"],["Set"],["LE","le"],["Real","linearOrder"],["Preorder","toLE"],["Set","instEmptyCollection"],["EmptyCollection","emptyCollection"],["Eq"]],"type":"∀ {a b : Real} (M : Real), Eq (Set.Icc a b) Set.instEmptyCollection.emptyCollection → Real.linearOrder.le b a","name":["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Chapter9","BddAboveOn"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Real","instPreorder"],["IsMaxOn"],["Real"],["Set"],["Chapter9","BddAboveOn"]],"type":"∀ {f : Real → Real} {X : Set Real} {x₀ : Real}, IsMaxOn f X x₀ → Chapter9.BddAboveOn f X","name":["Chapter9","BddAboveOn","isMaxOn"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Lean","Name","anonymous"],["sorryAx"],["Exists"],["Real"],["Lean","Name"],["Set"],["Set","Icc"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["And"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["instOfNatNat"],["IsMinOn"],["Lean","Name","num"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["Set"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["And"],["ContinuousOn"],["Set","instMembership"],["LT","lt"],["Real","pseudoMetricSpace"],["Real","instLT"],["IsMinOn"]],"type":"∀ {a b : Real},\n  Real.instLT.lt a b →\n    ∀ {f : Real → Real},\n      ContinuousOn f (Set.Icc a b) →\n        Exists fun xmin => And (Set.instMembership.mem (Set.Icc a b) xmin) (IsMinOn f (Set.Icc a b) xmin)","name":["Chapter9","IsMinOn","of_continuous_on_compact"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["Real","instPreorder"],["Eq","trans"],["Lean","Grind","Field","toDiv"],["PseudoMetricSpace","toUniformSpace"],["Lean","Grind","Semiring","toMul"],["Membership","mem"],["eq_true"],["HMul","hMul"],["Lean","Grind","intro_with_eq'"],["Lean","Grind","Field","toCommRing"],["Classical","choose"],["HDiv","hDiv"],["SupSet","sSup"],["NatCast","natCast"],["funext"],["forall_congr"],["Eq","symm"],["HSub","hSub"],["Eq","ndrec"],["Filter","Tendsto"],["nhds"],["Lean","Grind","CommRing","toRing"],["IsClosed"],["Exists"],["Real"],["Lean","Grind","rfl_true"],["And"],["Real","instSub"],["True","intro"],["Set","instMembership"],["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_6"],["Set","image"],["Nat"],["Filter","atTop"],["Real","pseudoMetricSpace"],["Eq","refl"],["Classical","byContradiction"],["Lean","Grind","Field","div_eq_mul_inv"],["instHMul"],["Real","instOne"],["StrictMono"],["Eq","mp"],["Set","Icc"],["UniformSpace","toTopologicalSpace"],["Classical","choose","congr_simp"],["Real","field"],["Real","instNatCast"],["instHDiv"],["congrArg"],["Nat","instPreorder"],["Lean","Grind","Ring","toSemiring"],["Nat","not_le_eq"],["instOfNatNat"],["congr"],["Real","instLT"],["Bornology","IsBounded"],["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_7"],["PseudoMetricSpace","toBornology"],["Not"],["Real","instMul"],["Lean","Grind","Field","toInv"],["Inv","inv"],["Lean","Grind","Nat","le_eq_false_of_lo"],["True"],["Set"],["instHAdd"],["Real","instSupSet"],["Real","instAdd"],["OfNat","ofNat"],["DivInvMonoid","toDiv"],["Eq","mpr_prop"],["LT","lt"],["HAdd","hAdd"],["Real","instInv"],["One","toOfNat1"],["Field","toGrindField"],["LE","le"],["False"],["Lean","Grind","intro_with_eq"],["instHSub"],["instLENat"],["Real","instDivInvMonoid"]],"typeReferences":[["Real","instPreorder"],["Nat","cast"],["PseudoMetricSpace","toUniformSpace"],["Set","Icc"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["Real","instNatCast"],["GE","ge"],["instHDiv"],["Nat","instPreorder"],["HDiv","hDiv"],["SupSet","sSup"],["Real","instLT"],["HSub","hSub"],["Bornology","IsBounded"],["nhds"],["Filter","Tendsto"],["PseudoMetricSpace","toBornology"],["IsClosed"],["Exists"],["Real"],["instHAdd"],["Set"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["Exists","choose"],["DivInvMonoid","toDiv"],["OfNat","ofNat"],["Set","instMembership"],["LT","lt"],["HAdd","hAdd"],["Filter","atTop"],["Nat"],["Set","image"],["One","toOfNat1"],["Real","pseudoMetricSpace"],["LE","le"],["Real","instOne"],["instHSub"],["instLENat"],["Real","instDivInvMonoid"],["StrictMono"]],"type":"∀ {a b : Real} {f : Real → Real}\n  (claim2 :\n    ∀ (n : Nat),\n      Exists fun x =>\n        And (Set.instMembership.mem (Set.Icc a b) x)\n          (Real.instLT.lt\n            (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n              (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n            (f x))),\n  (∀ (n : Nat), Set.instMembership.mem (Set.Icc a b) ((fun n => ⋯.choose) n)) →\n    (∀ (n : Nat),\n        Real.instLT.lt\n          (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b))) (instHDiv.hDiv 1 (instHAdd.hAdd n.cast 1)))\n          (f ((fun n => ⋯.choose) n))) →\n      IsClosed (Set.Icc a b) →\n        Bornology.IsBounded (Set.Icc a b) →\n          ∀ (n : Nat → Nat),\n            StrictMono n →\n              ∀ (xmax : Real),\n                Set.instMembership.mem (Set.Icc a b) xmax →\n                  Filter.Tendsto (fun j => (fun n => ⋯.choose) (n j)) Filter.atTop (nhds xmax) →\n                    (∀ (j : Nat), GE.ge (n j) j) →\n                      Filter.Tendsto (fun j => f ((fun n => ⋯.choose) (n j))) Filter.atTop (nhds (f xmax)) →\n                        ∀ (j : Nat), instLENat.le j (n j)","name":["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_8"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","image"],["Exists"],["Set"],["Membership","mem"],["And"],["Set","mem_image"],["Eq"],["propext"],["Set","instMembership"]],"typeReferences":[["Set","image"],["Exists"],["Set"],["Membership","mem"],["And"],["Eq"],["Set","instMembership"]],"type":"∀ {α : Type u} {β : Type v} (f : α → β) (s : Set α) (y : β),\n  Eq (Set.instMembership.mem (Set.image f s) y) (Exists fun x => And (Set.instMembership.mem s x) (Eq (f x) y))","name":["Chapter9","IsMaxOn","of_continuous_on_compact","_simp_1_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Real"],["NatCast","natCast"],["Real","instNatCast"]],"typeReferences":[["Real","instPreorder"],["Exists"],["PartialOrder","toPreorder"],["Real","instAddGroup"],["Real"],["And"],["Preorder","toLT"],["Real","instNatCast"],["LT","lt"],["LinearOrder","toPartialOrder"],["Nat"],["NatCast","natCast"],["LE","le"],["Real","linearOrder"],["Preorder","toLE"],["abs"],["Real","lattice"]],"type":"∀ {a b : Real} {f : Real → Real},\n  (∀ (x : Real),\n      Exists fun x_1 =>\n        And (Real.instPreorder.le a x_1) (And (Real.instPreorder.le x_1 b) (Real.linearOrder.lt x (abs (f x_1))))) →\n    ∀ (n : Nat),\n      Exists fun x =>\n        And (Real.instPreorder.le a x)\n          (And (Real.instPreorder.le x b) (Real.linearOrder.lt (Real.instNatCast.natCast n) (abs (f x))))","name":["Chapter9","BddOn","of_continuous_on_compact","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Exists"],["PseudoMetricSpace","toUniformSpace"],["Real"],["Set"],["Set","Icc"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["And"],["Exists","intro"],["Nat","instPreorder"],["Set","instMembership"],["Exists","casesOn"],["And","intro"],["Filter","atTop"],["Nat"],["Real","pseudoMetricSpace"],["nhds"],["Filter","Tendsto"],["And","casesOn"],["StrictMono"]],"typeReferences":[["Real","instPreorder"],["Exists"],["PseudoMetricSpace","toUniformSpace"],["Real"],["Set"],["Set","Icc"],["UniformSpace","toTopologicalSpace"],["Membership","mem"],["And"],["Exists","intro"],["Nat","instPreorder"],["Set","instMembership"],["And","intro"],["Nat"],["Filter","atTop"],["Real","pseudoMetricSpace"],["nhds"],["Filter","Tendsto"],["StrictMono"]],"type":"∀ {a b : Real} (x : Nat → Real)\n  (motive :\n    (Exists fun n =>\n        And (StrictMono n)\n          (Exists fun L =>\n            And (Set.instMembership.mem (Set.Icc a b) L) (Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)))) →\n      Prop)\n  (x_1 :\n    Exists fun n =>\n      And (StrictMono n)\n        (Exists fun L =>\n          And (Set.instMembership.mem (Set.Icc a b) L) (Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds L)))),\n  (∀ (n : Nat → Nat) (hn : StrictMono n) (xmax : Real) (hmax : Set.instMembership.mem (Set.Icc a b) xmax)\n      (hconv : Filter.Tendsto (fun j => x (n j)) Filter.atTop (nhds xmax)), motive ⋯) →\n    motive x_1","name":["Chapter9","IsMaxOn","of_continuous_on_compact","match_1_4"],"kind":"definition","isProp":true},{"valueReferences":[["Real"],["NatCast","natCast"],["Real","instNatCast"]],"typeReferences":[["Real","instPreorder"],["Exists"],["PartialOrder","toPreorder"],["Real","instAddGroup"],["Real"],["And"],["Preorder","toLT"],["Real","instNatCast"],["LT","lt"],["LinearOrder","toPartialOrder"],["Nat"],["NatCast","natCast"],["LE","le"],["Real","linearOrder"],["Preorder","toLE"],["abs"],["Real","lattice"]],"type":"∀ {a b : Real} {f : Real → Real},\n  (∀ (x : Real),\n      Exists fun x_1 =>\n        And (Real.instPreorder.le a x_1) (And (Real.instPreorder.le x_1 b) (Real.linearOrder.lt x (abs (f x_1))))) →\n    ∀ (n : Nat → Nat) (j : Nat),\n      Exists fun x =>\n        And (Real.instPreorder.le a x)\n          (And (Real.instPreorder.le x b) (Real.linearOrder.lt (Real.instNatCast.natCast (n j)) (abs (f x))))","name":["Chapter9","BddOn","of_continuous_on_compact","_proof_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Real"],["Neg","neg"],["Set"],["Real","instNeg"],["LE","le"],["Membership","mem"],["Real","instLE"],["Set","instMembership"]],"typeReferences":[["Real"],["Set"]],"type":"(Real → Real) → Set Real → Prop","name":["Chapter9","BddBelowOn"],"kind":"definition","isProp":false},{"valueReferences":[["mem_upperBounds"],["upperBounds"],["Set"],["LE","le"],["Membership","mem"],["Preorder","toLE"],["propext"],["Set","instMembership"]],"typeReferences":[["Preorder"],["upperBounds"],["Set"],["LE","le"],["Membership","mem"],["Preorder","toLE"],["Eq"],["Set","instMembership"]],"type":"∀ {α : Type u} [inst : Preorder α] {s : Set α} {a : α},\n  Eq (Set.instMembership.mem (upperBounds s) a) (∀ (x : α), Set.instMembership.mem s x → inst.le x a)","name":["Chapter9","sSup","of_isMaxOn","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["SubtractionMonoid","toSubNegZeroMonoid"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Neg","neg"],["AddCommGroup","toAddGroup"],["And"],["abs_le"],["SubtractionCommMonoid","toSubtractionMonoid"],["SubNegZeroMonoid","toNegZeroClass"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["NegZeroClass","toNeg"],["AddCommGroup","toDivisionAddCommMonoid"],["LE","le"],["Eq","symm"],["Preorder","toLE"],["abs"],["propext"],["SemilatticeInf","toPartialOrder"]],"typeReferences":[["SubtractionMonoid","toSubNegZeroMonoid"],["Lattice","toSemilatticeInf"],["PartialOrder","toPreorder"],["Neg","neg"],["AddCommGroup","toAddGroup"],["LinearOrder"],["And"],["SubtractionCommMonoid","toSubtractionMonoid"],["AddCommGroup"],["SubNegZeroMonoid","toNegZeroClass"],["instDistribLatticeOfLinearOrder"],["NegZeroClass","toNeg"],["DistribLattice","toLattice"],["AddCommGroup","toDivisionAddCommMonoid"],["IsOrderedAddMonoid"],["LE","le"],["AddCommGroup","toAddCommMonoid"],["abs"],["Eq"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"type":"∀ {G : Type u_1} [inst : AddCommGroup G] [inst_1 : LinearOrder G] [IsOrderedAddMonoid G] {a b : G},\n  Eq\n    (And\n      (instDistribLatticeOfLinearOrder.toSemilatticeInf.le (SubtractionMonoid.toSubNegZeroMonoid.toNegZeroClass.neg b)\n        a)\n      (instDistribLatticeOfLinearOrder.toSemilatticeInf.le a b))\n    (instDistribLatticeOfLinearOrder.toSemilatticeInf.le (abs a) b)","name":["Chapter9","IsMaxOn","of_continuous_on_compact","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Real"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["OfNat","ofNat"],["Nat"],["Set","image"],["instOfNatNat"],["Real","pseudoMetricSpace"],["Iff"],["Bornology","IsBounded"],["Lean","Name","num"],["Chapter9","BddOn"],["PseudoMetricSpace","toBornology"]],"typeReferences":[["Set","image"],["Real"],["Real","pseudoMetricSpace"],["Set"],["Iff"],["Bornology","IsBounded"],["Chapter9","BddOn"],["PseudoMetricSpace","toBornology"]],"type":"∀ (f : Real → Real) (X : Set Real), Iff (Chapter9.BddOn f X) (Bornology.IsBounded (Set.image f X))","name":["Chapter9","BddOn","iff'"],"kind":"theorem","isProp":true},{"valueReferences":[["Real","instPreorder"],["Lean","Grind","Field","toDiv"],["Lean","Grind","Semiring","toMul"],["Set","Icc"],["Membership","mem"],["Real","field"],["HMul","hMul"],["Real","instNatCast"],["Lean","Grind","Field","toCommRing"],["instHDiv"],["congrArg"],["HDiv","hDiv"],["Lean","Grind","Ring","toSemiring"],["NatCast","natCast"],["SupSet","sSup"],["Real","instLT"],["funext"],["forall_congr"],["HSub","hSub"],["Eq","ndrec"],["Lean","Grind","CommRing","toRing"],["Real","instMul"],["Lean","Grind","Field","toInv"],["Inv","inv"],["Exists"],["Real"],["Set"],["instHAdd"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["DivInvMonoid","toDiv"],["OfNat","ofNat"],["Eq","mpr_prop"],["Set","instMembership"],["LT","lt"],["HAdd","hAdd"],["Real","instInv"],["Nat"],["Set","image"],["One","toOfNat1"],["Field","toGrindField"],["Lean","Grind","Field","div_eq_mul_inv"],["instHMul"],["Real","instOne"],["instHSub"],["Real","instDivInvMonoid"]],"typeReferences":[["Real","instPreorder"],["Set","Icc"],["Membership","mem"],["Real","instNatCast"],["HMul","hMul"],["NatCast","natCast"],["SupSet","sSup"],["Real","instLT"],["HSub","hSub"],["Real","instMul"],["Inv","inv"],["Exists"],["Real"],["instHAdd"],["Set"],["And"],["Real","instSupSet"],["Real","instAdd"],["Real","instSub"],["OfNat","ofNat"],["Set","instMembership"],["HAdd","hAdd"],["LT","lt"],["Real","instInv"],["Nat"],["Set","image"],["One","toOfNat1"],["instHMul"],["Real","instOne"],["instHSub"]],"type":"∀ {a b : Real} {f : Real → Real},\n  (∀ (n : Nat),\n      Exists fun x =>\n        And (Set.instMembership.mem (Set.Icc a b) x)\n          (Real.instLT.lt\n            (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n              (instHMul.hMul 1 (Real.instInv.inv (instHAdd.hAdd (Real.instNatCast.natCast n) 1))))\n            (f x))) →\n    ∀ (n : Nat),\n      Exists fun x =>\n        And (Set.instMembership.mem (Set.Icc a b) x)\n          (Real.instLT.lt\n            (instHSub.hSub (Real.instSupSet.sSup (Set.image f (Set.Icc a b)))\n              (instHMul.hMul 1 (Real.instInv.inv (instHAdd.hAdd (Real.instNatCast.natCast n) 1))))\n            (f x))","name":["Chapter9","IsMaxOn","of_continuous_on_compact","_proof_1_6"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter9","BddBelowOn"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Real","instPreorder"],["Real"],["Set"],["IsMinOn"],["Chapter9","BddBelowOn"]],"type":"∀ {f : Real → Real} {X : Set Real} {x₀ : Real}, IsMinOn f X x₀ → Chapter9.BddBelowOn f X","name":["Chapter9","BddBelowOn","isMinOn"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Real","instPreorder"],["Lean","Grind","not_and"],["Eq","trans"],["Eq","mp"],["Set","Icc"],["Membership","mem"],["eq_true"],["Lean","Grind","not_exists"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","Grind","imp_eq_of_eq_true_left"],["Or"],["Lean","Grind","eq_false_of_imp_eq_true"],["InfSet","sInf"],["forall_congr"],["Eq","symm"],["IsMinOn"],["Lean","Grind","forall_forall_or"],["Eq"],["Not"],["Chapter9","sInf","of_isMinOn"],["Exists"],["True"],["Real"],["Set"],["And"],["True","intro"],["Set","instMembership"],["Set","image"],["false_or"],["Eq","refl"],["Classical","byContradiction"],["False"],["Lean","Grind","intro_with_eq"],["Real","instInfSet"]],"typeReferences":[["Real","instPreorder"],["Exists"],["Real"],["Set"],["Set","Icc"],["Membership","mem"],["And"],["Set","instMembership"],["Set","image"],["InfSet","sInf"],["IsMinOn"],["Eq"],["Real","instInfSet"]],"type":"∀ {a b : Real} (f : Real → Real) (x : Real),\n  Set.instMembership.mem (Set.Icc a b) x →\n    IsMinOn f (Set.Icc a b) x →\n      Exists fun xmin =>\n        And (Set.instMembership.mem (Set.Icc a b) xmin) (Eq (Real.instInfSet.sInf (Set.image f (Set.Icc a b))) (f xmin))","name":["Chapter9","sInf","of_continuous_on_compact","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["And"],["Chapter9","BddBelowOn"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["Iff"],["Chapter9","BddAboveOn"],["Lean","Name","num"],["Chapter9","BddOn"]],"typeReferences":[["Real"],["Set"],["Chapter9","BddAboveOn"],["Iff"],["And"],["Chapter9","BddBelowOn"],["Chapter9","BddOn"]],"type":"∀ (f : Real → Real) (X : Set Real), Iff (Chapter9.BddOn f X) (And (Chapter9.BddAboveOn f X) (Chapter9.BddBelowOn f X))","name":["Chapter9","BddOn","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Set","mem_image","_simp_1"],["Real","instPreorder"],["PartialOrder","toPreorder"],["Eq","trans"],["and_imp","_simp_1"],["Membership","mem"],["Exists","intro"],["Real","instConditionallyCompleteLinearOrder"],["congrArg"],["IsGreatest"],["And","intro"],["ConditionallyCompleteLinearOrder","toConditionallyCompleteLattice"],["congr"],["forall_congr"],["Preorder","toLE"],["Eq"],["SemilatticeInf","toPartialOrder"],["rfl"],["Lattice","toSemilatticeInf"],["Exists"],["Real"],["Set"],["And"],["IsGreatest","csSup_eq"],["Set","instMembership"],["Set","image"],["upperBounds"],["Eq","refl"],["LE","le"],["id"],["forall_exists_index","_simp_1"],["Eq","mpr"],["forall_apply_eq_imp_iff₂","_simp_1"],["ConditionallyCompleteLattice","toLattice"],["Chapter9","sSup","of_isMaxOn","_simp_1_1"]],"typeReferences":[["Set","image"],["Real","instPreorder"],["IsMaxOn"],["Real"],["SupSet","sSup"],["Set"],["Membership","mem"],["Real","instSupSet"],["Eq"],["Set","instMembership"]],"type":"∀ {f : Real → Real} {X : Set Real} {x₀ : Real},\n  Set.instMembership.mem X x₀ → IsMaxOn f X x₀ → Eq (Real.instSupSet.sSup (Set.image f X)) (f x₀)","name":["Chapter9","sSup","of_isMaxOn"],"kind":"theorem","isProp":true}]
