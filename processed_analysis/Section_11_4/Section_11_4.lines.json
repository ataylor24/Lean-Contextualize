[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":79},{"state":[],"start":80},{"state":[],"start":84},{"state":[],"start":153},{"state":[],"start":154},{"state":[],"start":250},{"state":[],"start":338},{"state":[],"start":433},{"state":[],"start":526},{"state":[],"start":536},{"state":[],"start":537},{"state":[],"start":585},{"state":[],"start":629},{"state":[],"start":630},{"state":[],"start":633},{"state":[],"start":634},{"state":[],"start":654},{"state":[],"start":668},{"state":[],"start":669},{"state":[],"start":712},{"state":[],"start":824},{"state":[{"type":"IntegrableOn (f + g) I ∧ integ (f + g) I = integ f I + integ g I","tag":[],"mvarId":["_uniq",227],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",222],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",223],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",224],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",225],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",226],"binderInfo":"default"}]}],"start":899},{"state":[],"start":907},{"state":[],"start":908},{"state":[],"start":951},{"state":[],"start":1047},{"state":[{"type":"IntegrableOn (c • f) I ∧ integ (c • f) I = c * integ f I","tag":[],"mvarId":["_uniq",448],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",444],"binderInfo":"implicit"},{"type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",445],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",446],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",447],"binderInfo":"default"}]}],"start":1118},{"state":[],"start":1126},{"state":[],"start":1127},{"state":[],"start":1214},{"state":[],"start":1313},{"state":[],"start":1314},{"state":[],"start":1357},{"state":[],"start":1469},{"state":[{"type":"IntegrableOn (f - g) I ∧ integ (f - g) I = integ f I - integ g I","tag":[],"mvarId":["_uniq",154974],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",154969],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",154970],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",154971],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",154972],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",154973],"binderInfo":"default"}]}],"start":1544},{"state":[],"start":1552},{"state":[],"start":1553},{"state":[],"start":1596},{"state":[],"start":1722},{"state":[{"type":"0 ≤ integ f I","tag":[],"mvarId":["_uniq",155176],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155170],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",155171],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",155172],"binderInfo":"default"},{"type":"∀ x ∈ I, 0 ≤ f x","name":["hf_nonneg"],"isProp":true,"id":["_uniq",155173],"binderInfo":"default"}]}],"start":1746},{"state":[],"start":1754},{"state":[],"start":1755},{"state":[],"start":1798},{"state":[],"start":1909},{"state":[],"start":1936},{"state":[{"type":"integ f I ≤ integ g I","tag":[],"mvarId":["_uniq",155226],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155218],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",155219],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",155220],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",155221],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",155222],"binderInfo":"default"},{"type":"MajorizesOn g f I","name":["h"],"isProp":true,"id":["_uniq",155223],"binderInfo":"default"}]}],"start":1968},{"state":[],"start":1976},{"state":[],"start":1977},{"state":[],"start":2020},{"state":[],"start":2078},{"state":[{"type":"IntegrableOn (fun x => c) I ∧ integ (fun x => c) I = c * I.length","tag":[],"mvarId":["_uniq",155295],"isProp":true,"context":[{"type":"ℝ","name":["c"],"isProp":false,"id":["_uniq",155293],"binderInfo":"default"},{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155294],"binderInfo":"default"}]}],"start":2154},{"state":[],"start":2162},{"state":[],"start":2163},{"state":[],"start":2206},{"state":[],"start":2294},{"state":[{"type":"IntegrableOn f I ∧ integ f I = constant_value_on f (↑I : Set ℝ) * I.length","tag":[],"mvarId":["_uniq",155451],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155448],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",155449],"binderInfo":"implicit"},{"type":"ConstantOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",155450],"binderInfo":"default"}]}],"start":2368},{"state":[],"start":2376},{"state":[],"start":2377},{"state":[],"start":2378},{"state":[],"start":2396},{"state":[],"start":2441},{"state":[],"start":2510},{"state":[],"start":2553},{"state":[{"type":"IntegrableOn (fun x => if x ∈ I then f x else 0) J","tag":[],"mvarId":["_uniq",155537],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155532],"binderInfo":"implicit"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",155533],"binderInfo":"implicit"},{"type":"I ⊆ J","name":["hIJ"],"isProp":true,"id":["_uniq",155534],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",155535],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["h"],"isProp":true,"id":["_uniq",155536],"binderInfo":"default"}]}],"start":2615},{"state":[],"start":2623},{"state":[],"start":2624},{"state":[],"start":2642},{"state":[],"start":2687},{"state":[],"start":2757},{"state":[],"start":2800},{"state":[{"type":"integ (fun x => if x ∈ I then f x else 0) J = integ f I","tag":[],"mvarId":["_uniq",155621],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155616],"binderInfo":"implicit"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",155617],"binderInfo":"implicit"},{"type":"I ⊆ J","name":["hIJ"],"isProp":true,"id":["_uniq",155618],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",155619],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["h"],"isProp":true,"id":["_uniq",155620],"binderInfo":"default"}]}],"start":2867},{"state":[],"start":2875},{"state":[],"start":2876},{"state":[],"start":2942},{"state":[],"start":3013},{"state":[],"start":3056},{"state":[{"type":"IntegrableOn f I ∧ IntegrableOn f J ∧ integ f K = integ f I + integ f J","tag":[],"mvarId":["_uniq",155705],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155699],"binderInfo":"implicit"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",155700],"binderInfo":"implicit"},{"type":"BoundedInterval","name":["K"],"isProp":false,"id":["_uniq",155701],"binderInfo":"implicit"},{"type":"K.joins I J","name":["hIJK"],"isProp":true,"id":["_uniq",155702],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",155703],"binderInfo":"implicit"},{"type":"IntegrableOn f K","name":["h"],"isProp":true,"id":["_uniq",155704],"binderInfo":"default"}]}],"start":3140},{"state":[],"start":3148},{"state":[],"start":3149},{"state":[],"start":3226},{"state":[],"start":3291},{"state":[{"type":"IntegrableOn f J","tag":[],"mvarId":["_uniq",155745],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155740],"binderInfo":"implicit"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",155741],"binderInfo":"implicit"},{"type":"J ⊆ I","name":["hIJ"],"isProp":true,"id":["_uniq",155742],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",155743],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["h"],"isProp":true,"id":["_uniq",155744],"binderInfo":"default"}]}],"start":3357},{"state":[],"start":3365},{"state":[],"start":3366},{"state":[],"start":3451},{"state":[],"start":3513},{"state":[],"start":3547},{"state":[{"type":"integ f J = integ f I","tag":[],"mvarId":["_uniq",155797],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",155790],"binderInfo":"implicit"},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",155791],"binderInfo":"implicit"},{"type":"J ⊆ I","name":["hIJ"],"isProp":true,"id":["_uniq",155792],"binderInfo":"default"},{"type":"J.a = I.a","name":["ha"],"isProp":true,"id":["_uniq",155793],"binderInfo":"default"},{"type":"J.b = I.b","name":["hb"],"isProp":true,"id":["_uniq",155794],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",155795],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["h"],"isProp":true,"id":["_uniq",155796],"binderInfo":"default"}]}],"start":3618},{"state":[],"start":3626},{"state":[],"start":3627},{"state":[],"start":3692},{"state":[{"type":"x ≤ 0","tag":[],"mvarId":["_uniq",156064],"isProp":true,"context":[{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",156059],"binderInfo":"implicit"},{"type":"ℝ","name":["C"],"isProp":false,"id":["_uniq",156060],"binderInfo":"implicit"},{"type":"∀ ε > 0, x ≤ C * ε","name":["h"],"isProp":true,"id":["_uniq",156061],"binderInfo":"default"}]}],"start":3779},{"state":[{"type":"x ≤ 0","tag":["pos","_@","_hyg",775],"mvarId":["_uniq",156132],"isProp":false,"context":[{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",156059],"binderInfo":"implicit"},{"type":"ℝ","name":["C"],"isProp":false,"id":["_uniq",156060],"binderInfo":"implicit"},{"type":"∀ ε > 0, x ≤ C * ε","name":["h"],"isProp":true,"id":["_uniq",156061],"binderInfo":"default"},{"type":"C > 0","name":["hC"],"isProp":true,"id":["_uniq",156131],"binderInfo":"default"}]},{"type":"x ≤ 0","tag":["neg","_@","_hyg",775],"mvarId":["_uniq",156139],"isProp":false,"context":[{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",156059],"binderInfo":"implicit"},{"type":"ℝ","name":["C"],"isProp":false,"id":["_uniq",156060],"binderInfo":"implicit"},{"type":"∀ ε > 0, x ≤ C * ε","name":["h"],"isProp":true,"id":["_uniq",156061],"binderInfo":"default"},{"type":"¬C > 0","name":["hC"],"isProp":true,"id":["_uniq",156138],"binderInfo":"default"}]}],"start":3800},{"state":[{"type":"False","tag":["pos","_@","_hyg",775],"mvarId":["_uniq",156625],"isProp":true,"context":[{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",156059],"binderInfo":"implicit"},{"type":"ℝ","name":["C"],"isProp":false,"id":["_uniq",156060],"binderInfo":"implicit"},{"type":"∀ ε > 0, x ≤ C * ε","name":["h"],"isProp":true,"id":["_uniq",156061],"binderInfo":"default"},{"type":"C > 0","name":["hC"],"isProp":true,"id":["_uniq",156131],"binderInfo":"default"},{"type":"0 < x","name":["this"],"isProp":true,"id":["_uniq",156624],"binderInfo":"default"}]}],"start":3815},{"state":[{"type":"False","tag":["pos","_@","_hyg",775],"mvarId":["_uniq",158515],"isProp":true,"context":[{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",156059],"binderInfo":"implicit"},{"type":"ℝ","name":["C"],"isProp":false,"id":["_uniq",156060],"binderInfo":"implicit"},{"type":"C > 0","name":["hC"],"isProp":true,"id":["_uniq",156131],"binderInfo":"default"},{"type":"0 < x","name":["this"],"isProp":true,"id":["_uniq",156624],"binderInfo":"default"},{"type":"x ≤ x / 2","name":["h"],"isProp":true,"id":["_uniq",158512],"binderInfo":"default"}]}],"start":3892},{"state":[{"type":"x ≤ 0","tag":["neg","_@","_hyg",775],"mvarId":["_uniq",156139],"isProp":false,"context":[{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",156059],"binderInfo":"implicit"},{"type":"ℝ","name":["C"],"isProp":false,"id":["_uniq",156060],"binderInfo":"implicit"},{"type":"∀ ε > 0, x ≤ C * ε","name":["h"],"isProp":true,"id":["_uniq",156061],"binderInfo":"default"},{"type":"¬C > 0","name":["hC"],"isProp":true,"id":["_uniq",156138],"binderInfo":"default"}]}],"start":3905},{"state":[],"start":3935},{"state":[],"start":3936},{"state":[],"start":3994},{"state":[],"start":4106},{"state":[{"type":"IntegrableOn (f ⊔ g) I","tag":[],"mvarId":["_uniq",166636],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"}]}],"start":4140},{"state":[{"type":"IntegrableOn (f ⊔ g) I","tag":[],"mvarId":["_uniq",166636],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"}]}],"start":4213},{"state":[{"type":"IntegrableOn (f ⊔ g) I","tag":[],"mvarId":["_uniq",166638],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"}]}],"start":4244},{"state":[{"type":"BddOn (f ⊔ g) (↑I : Set ℝ)","tag":[],"mvarId":["_uniq",166823],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"}]}],"start":4288},{"state":[{"type":"BddOn (f ⊔ g) (↑I : Set ℝ)","tag":[],"mvarId":["_uniq",166850],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",166833],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",166836],"binderInfo":"default"},{"type":"ℝ","name":["M'"],"isProp":false,"id":["_uniq",166844],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",166847],"binderInfo":"default"}]}],"start":4341},{"state":[{"type":"|Max.max f g x| ≤ Max.max M M'","tag":["h","h","h"],"mvarId":["_uniq",167095],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",166833],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM✝"],"isProp":true,"id":["_uniq",166836],"binderInfo":"default"},{"type":"ℝ","name":["M'"],"isProp":false,"id":["_uniq",166844],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",167026],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",167050],"binderInfo":"default"},{"type":"|f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",167051],"binderInfo":"default"},{"type":"|g x| ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",167092],"binderInfo":"default"}]}],"start":4401},{"state":[{"type":"|Max.max (f x) (g x)| ≤ Max.max M M'","tag":["h","h","h"],"mvarId":["_uniq",167206],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"type":"ℝ","name":["M"],"isProp":false,"id":["_uniq",166833],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M","name":["hM✝"],"isProp":true,"id":["_uniq",166836],"binderInfo":"default"},{"type":"ℝ","name":["M'"],"isProp":false,"id":["_uniq",166844],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",167026],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",167050],"binderInfo":"default"},{"type":"|f x| ≤ M","name":["hM"],"isProp":true,"id":["_uniq",167051],"binderInfo":"default"},{"type":"|g x| ≤ M'","name":["hM'"],"isProp":true,"id":["_uniq",167092],"binderInfo":"default"}]}],"start":4430},{"state":[{"type":"IntegrableOn (f ⊔ g) I","tag":[],"mvarId":["_uniq",166825],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]}]}],"start":4489},{"state":[{"type":"IntegrableOn (f ⊔ g) I","tag":[],"mvarId":["_uniq",168161],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]}]}],"start":4627},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",169038],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"}]}],"start":4730},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",179989],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"}]}],"start":4844},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",179989],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"}]}],"start":4858},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",192140],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"}]}],"start":4982},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",205659],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"}]}],"start":5110},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",220560],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"}]}],"start":5238},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",220796],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]}]}],"start":5275},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",221106],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]}]}],"start":5331},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",221114],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]}]}],"start":5387},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",221122],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]}]}],"start":5445},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",221130],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]}]}],"start":5503},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",221151],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]}]}],"start":5557},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",221169],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]}]}],"start":5611},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",221187],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]}]}],"start":5676},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",221289],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]}]}],"start":5733},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",223083],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]}]}],"start":5783},{"state":[{"type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","tag":[],"mvarId":["_uniq",223251],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]}]}],"start":5850},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",223255],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]}]}],"start":5862},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",223272],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]}]}],"start":5908},{"state":[{"type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","tag":[],"mvarId":["_uniq",223415],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]}]}],"start":5971},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",223419],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]}]}],"start":5983},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",223443],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]}]}],"start":6067},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",223459],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]},{"value":"integ_le_lower_integral hmax_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f ⊔ g) I","name":["hf'g'_le"],"isProp":true,"id":["_uniq",223458]}]}],"start":6145},{"state":[{"type":"MinorizesOn (f'' ⊔ g'') (f' ⊔ g' + h) I","tag":[],"mvarId":["_uniq",223593],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]},{"value":"integ_le_lower_integral hmax_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f ⊔ g) I","name":["hf'g'_le"],"isProp":true,"id":["_uniq",223458]}]}],"start":6206},{"state":[{"type":"Max.max f'' g'' x ≤ (f' ⊔ g' + h) x","tag":["h","h"],"mvarId":["_uniq",223760],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min✝"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]},{"value":"integ_le_lower_integral hmax_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f ⊔ g) I","name":["hf'g'_le"],"isProp":true,"id":["_uniq",223458]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",223631],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",223655],"binderInfo":"default"},{"type":"f' x ≤ f x","name":["hf'min"],"isProp":true,"id":["_uniq",223656],"binderInfo":"default"},{"type":"g' x ≤ g x","name":["hg'min"],"isProp":true,"id":["_uniq",223697],"binderInfo":"default"},{"type":"f x ≤ f'' x","name":["hf''max"],"isProp":true,"id":["_uniq",223727],"binderInfo":"default"},{"type":"g x ≤ g'' x","name":["hg''max"],"isProp":true,"id":["_uniq",223757],"binderInfo":"default"}]}],"start":6315},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",223597],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]},{"value":"integ_le_lower_integral hmax_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f ⊔ g) I","name":["hf'g'_le"],"isProp":true,"id":["_uniq",223458]},{"value":"forall_imp\n  (fun x hf'min =>\n    forall_imp\n      (fun hx hf'min =>\n        Eq.mpr (id sup_le_iff._simp_1)\n          ⟨le_of_not_gt fun a =>\n              Mathlib.Tactic.Linarith.lt_irrefl\n                (Eq.mp\n                  (congrArg (fun _a => _a < 0)\n                    (Mathlib.Tactic.Ring.of_eq\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g' x))\n                              (Mathlib.Tactic.Ring.atom_pf (g x))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (g x) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (g' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (g x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g x))\n                              (Mathlib.Tactic.Ring.atom_pf (g'' x))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (g'' x) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (g x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (g'' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (g' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero (g x) (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (g'' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (Max.max (f' x) (g' x)))\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n                                  (Mathlib.Tactic.Ring.atom_pf (f' x))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x))\n                                  (Mathlib.Tactic.Ring.atom_pf (g' x))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯ ⋯)\n                          ⋯)\n                        ⋯ ⋯)\n                      ⋯))\n                  ⋯),\n            ⋯⟩)\n      ⋯)\n  ⋯","type":"MinorizesOn (f'' ⊔ g'') (f' ⊔ g' + h) I","name":["this"],"isProp":true,"id":["_uniq",223594]}]}],"start":6411},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",235733],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]},{"value":"integ_le_lower_integral hmax_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f ⊔ g) I","name":["hf'g'_le"],"isProp":true,"id":["_uniq",223458]},{"value":"forall_imp\n  (fun x hf'min =>\n    forall_imp\n      (fun hx hf'min =>\n        Eq.mpr (id sup_le_iff._simp_1)\n          ⟨le_of_not_gt fun a =>\n              Mathlib.Tactic.Linarith.lt_irrefl\n                (Eq.mp\n                  (congrArg (fun _a => _a < 0)\n                    (Mathlib.Tactic.Ring.of_eq\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g' x))\n                              (Mathlib.Tactic.Ring.atom_pf (g x))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (g x) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (g' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (g x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g x))\n                              (Mathlib.Tactic.Ring.atom_pf (g'' x))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (g'' x) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (g x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (g'' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (g' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero (g x) (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (g'' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (Max.max (f' x) (g' x)))\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n                                  (Mathlib.Tactic.Ring.atom_pf (f' x))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x))\n                                  (Mathlib.Tactic.Ring.atom_pf (g' x))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯ ⋯)\n                          ⋯)\n                        ⋯ ⋯)\n                      ⋯))\n                  ⋯),\n            ⋯⟩)\n      ⋯)\n  ⋯","type":"MinorizesOn (f'' ⊔ g'') (f' ⊔ g' + h) I","name":["this"],"isProp":true,"id":["_uniq",223594]},{"value":"integ_of_piecewise_const hf'g'_const","type":"IntegrableOn (f' ⊔ g') I ∧ integ (f' ⊔ g') I = hf'g'_const.integ'","name":["hf'g'_integ"],"isProp":true,"id":["_uniq",235732]}]}],"start":6472},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",235741],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]},{"value":"integ_le_lower_integral hmax_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f ⊔ g) I","name":["hf'g'_le"],"isProp":true,"id":["_uniq",223458]},{"value":"forall_imp\n  (fun x hf'min =>\n    forall_imp\n      (fun hx hf'min =>\n        Eq.mpr (id sup_le_iff._simp_1)\n          ⟨le_of_not_gt fun a =>\n              Mathlib.Tactic.Linarith.lt_irrefl\n                (Eq.mp\n                  (congrArg (fun _a => _a < 0)\n                    (Mathlib.Tactic.Ring.of_eq\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g' x))\n                              (Mathlib.Tactic.Ring.atom_pf (g x))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (g x) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (g' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (g x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g x))\n                              (Mathlib.Tactic.Ring.atom_pf (g'' x))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (g'' x) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (g x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (g'' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (g' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero (g x) (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (g'' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (Max.max (f' x) (g' x)))\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n                                  (Mathlib.Tactic.Ring.atom_pf (f' x))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x))\n                                  (Mathlib.Tactic.Ring.atom_pf (g' x))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯ ⋯)\n                          ⋯)\n                        ⋯ ⋯)\n                      ⋯))\n                  ⋯),\n            ⋯⟩)\n      ⋯)\n  ⋯","type":"MinorizesOn (f'' ⊔ g'') (f' ⊔ g' + h) I","name":["this"],"isProp":true,"id":["_uniq",223594]},{"value":"integ_of_piecewise_const hf'g'_const","type":"IntegrableOn (f' ⊔ g') I ∧ integ (f' ⊔ g') I = hf'g'_const.integ'","name":["hf'g'_integ"],"isProp":true,"id":["_uniq",235732]},{"value":"integ_of_piecewise_const hf''g''_const","type":"IntegrableOn (f'' ⊔ g'') I ∧ integ (f'' ⊔ g'') I = hf''g''_const.integ'","name":["hf''g''_integ"],"isProp":true,"id":["_uniq",235740]}]}],"start":6537},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",235759],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]},{"value":"integ_le_lower_integral hmax_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f ⊔ g) I","name":["hf'g'_le"],"isProp":true,"id":["_uniq",223458]},{"value":"forall_imp\n  (fun x hf'min =>\n    forall_imp\n      (fun hx hf'min =>\n        Eq.mpr (id sup_le_iff._simp_1)\n          ⟨le_of_not_gt fun a =>\n              Mathlib.Tactic.Linarith.lt_irrefl\n                (Eq.mp\n                  (congrArg (fun _a => _a < 0)\n                    (Mathlib.Tactic.Ring.of_eq\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g' x))\n                              (Mathlib.Tactic.Ring.atom_pf (g x))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (g x) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (g' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (g x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g x))\n                              (Mathlib.Tactic.Ring.atom_pf (g'' x))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (g'' x) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (g x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (g'' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (g' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                (Mathlib.Tactic.Ring.add_overlap_pf_zero (g x) (Nat.rawCast 1)\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.ofNat 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (g'' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (Max.max (f' x) (g' x)))\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n                                  (Mathlib.Tactic.Ring.atom_pf (f' x))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_zero_add\n                                        (f' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x))\n                                  (Mathlib.Tactic.Ring.atom_pf (g' x))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_gt (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                      (Mathlib.Tactic.Ring.add_pf_add_zero\n                                        (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯ ⋯)\n                          ⋯)\n                        ⋯ ⋯)\n                      ⋯))\n                  ⋯),\n            ⋯⟩)\n      ⋯)\n  ⋯","type":"MinorizesOn (f'' ⊔ g'') (f' ⊔ g' + h) I","name":["this"],"isProp":true,"id":["_uniq",223594]},{"value":"integ_of_piecewise_const hf'g'_const","type":"IntegrableOn (f' ⊔ g') I ∧ integ (f' ⊔ g') I = hf'g'_const.integ'","name":["hf'g'_integ"],"isProp":true,"id":["_uniq",235732]},{"value":"integ_of_piecewise_const hf''g''_const","type":"IntegrableOn (f'' ⊔ g'') I ∧ integ (f'' ⊔ g'') I = hf''g''_const.integ'","name":["hf''g''_integ"],"isProp":true,"id":["_uniq",235740]},{"value":"add hf'g'_integ.left hh_IntegrableOn.eq.left","type":"IntegrableOn (f' ⊔ g' + (f'' - f' + (g'' - g'))) I ∧\n  integ (f' ⊔ g' + (f'' - f' + (g'' - g'))) I = integ (f' ⊔ g') I + integ (f'' - f' + (g'' - g')) I","name":["hf'g'h_integ"],"isProp":true,"id":["_uniq",235758]}]}],"start":6601},{"state":[{"type":"upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","tag":[],"mvarId":["_uniq",235793],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",168745],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",168786],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",179965],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",179973],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",179984],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",179988],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",192116],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",192124],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",192135],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",192139],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",205635],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''max"],"isProp":true,"id":["_uniq",205643],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",205654],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",205658],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",220536],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''max"],"isProp":true,"id":["_uniq",220544],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",220555],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",220559],"binderInfo":"default"},{"value":"f'' - f' + (g'' - g')","type":"ℝ → ℝ","name":["h"],"isProp":false,"id":["_uniq",220795]},{"value":"integ_of_piecewise_const hf'const","type":"IntegrableOn f' I ∧ integ f' I = hf'const.integ'","name":["hf'_integ"],"isProp":true,"id":["_uniq",221105]},{"value":"integ_of_piecewise_const hg'const","type":"IntegrableOn g' I ∧ integ g' I = hg'const.integ'","name":["hg'_integ"],"isProp":true,"id":["_uniq",221113]},{"value":"integ_of_piecewise_const hf''const","type":"IntegrableOn f'' I ∧ integ f'' I = hf''const.integ'","name":["hf''_integ"],"isProp":true,"id":["_uniq",221121]},{"value":"integ_of_piecewise_const hg''const","type":"IntegrableOn g'' I ∧ integ g'' I = hg''const.integ'","name":["hg''_integ"],"isProp":true,"id":["_uniq",221129]},{"value":"sub hf''_integ.left hf'_integ.left","type":"IntegrableOn (f'' - f') I ∧ integ (f'' - f') I = integ f'' I - integ f' I","name":["hf''f'_integ"],"isProp":true,"id":["_uniq",221150]},{"value":"sub hg''_integ.left hg'_integ.left","type":"IntegrableOn (g'' - g') I ∧ integ (g'' - g') I = integ g'' I - integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",221168]},{"value":"add hf''f'_integ.left hg''g'_integ.left","type":"IntegrableOn (f'' - f' + (g'' - g')) I ∧ integ (f'' - f' + (g'' - g')) I = integ (f'' - f') I + integ (g'' - g') I","name":["hh_IntegrableOn","eq"],"isProp":true,"id":["_uniq",221186]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε)\n                                    (Mathlib.Tactic.Ring.sub_pf\n                                      (Mathlib.Tactic.Ring.neg_add\n                                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                          (Mathlib.Tactic.Ring.neg_one_mul\n                                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                                (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                  (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                                (Eq.refl (Int.negOfNat 1))))))\n                                        Mathlib.Tactic.Ring.neg_zero)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                                  (Mathlib.Tactic.Ring.atom_pf (PiecewiseConstantOn.integ f' I))\n                                  (Mathlib.Tactic.Ring.sub_pf\n                                    (Mathlib.Tactic.Ring.neg_add\n                                      (Mathlib.Tactic.Ring.neg_mul (PiecewiseConstantOn.integ f' I) (Nat.rawCast 1)\n                                        (Mathlib.Tactic.Ring.neg_one_mul\n                                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                              (Eq.refl (Int.negOfNat 1))))))\n                                      Mathlib.Tactic.Ring.neg_zero)\n                                    (Mathlib.Tactic.Ring.add_pf_add_lt (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                                          (PiecewiseConstantOn.integ f' I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                                            0))))))\n                                (Mathlib.Tactic.Ring.sub_congr\n                                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                                    (Mathlib.Tactic.Ring.atom_pf ε) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                                  ⋯ ⋯)\n                                ⋯)\n                              ⋯ ⋯)\n                            ⋯ ⋯)\n                          ⋯ ⋯)\n                        ⋯ ⋯)\n                      ⋯ ⋯)\n                    ⋯ ⋯)\n                  ⋯ ⋯)\n                ⋯ ⋯)\n              ⋯ ⋯)\n            ⋯ ⋯)\n          ⋯))\n      ⋯)","type":"integ h I ≤ 4 * ε","name":["hinteg_le"],"isProp":true,"id":["_uniq",221288]},{"value":"PiecewiseConstantOn.max hf''const hg''const","type":"PiecewiseConstantOn (f'' ⊔ g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",223082]},{"value":"sorry","type":"MajorizesOn (f'' ⊔ g'') (f ⊔ g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",223252]},{"value":"PiecewiseConstantOn.max hf'const hg'const","type":"PiecewiseConstantOn (f' ⊔ g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",223271]},{"value":"sorry","type":"MinorizesOn (f' ⊔ g') (f ⊔ g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",223416]},{"value":"upper_integral_le_integ hmax_bound hf''g''_maj hf''g''_const","type":"upper_integral (f ⊔ g) I ≤ hf''g''_const.integ'","name":["hff'g''_ge"],"isProp":true,"id":["_uniq",223442]},{"value":"integ_le_lower_integral hmax_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f ⊔ g) I","name":["hf'g'_le"],"isProp":true,"id":["_uniq",223458]},{"type":"MajorizesOn (f' ⊔ g' + h) (f'' ⊔ g'') I","name":["this"],"isProp":true,"id":["_uniq",235783],"binderInfo":"default"},{"type":"IntegrableOn (f' ⊔ g') I ∧ integ (f' ⊔ g') I = hf'g'_const.integ'","name":["hf'g'_integ"],"isProp":true,"id":["_uniq",235788],"binderInfo":"default"},{"type":"IntegrableOn (f'' ⊔ g'') I ∧ integ (f'' ⊔ g'') I = hf''g''_const.integ'","name":["hf''g''_integ"],"isProp":true,"id":["_uniq",235789],"binderInfo":"default"},{"type":"IntegrableOn (f' ⊔ g' + (f'' - f' + (g'' - g'))) I ∧\n  integ (f' ⊔ g' + (f'' - f' + (g'' - g'))) I = integ (f' ⊔ g') I + integ (f'' - f' + (g'' - g')) I","name":["hf'g'h_integ"],"isProp":true,"id":["_uniq",235790],"binderInfo":"default"}]}],"start":6634},{"state":[{"type":"IntegrableOn (f ⊔ g) I","tag":[],"mvarId":["_uniq",169043],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",166631],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",166632],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",166633],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",166634],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",166635],"binderInfo":"default"},{"value":"(fun M hM =>\n    (fun M' hM' =>\n        Exists.intro (Max.max M M')\n          (forall_imp\n            (fun x hM =>\n              forall_imp (fun hx hM => id (LE.le.trans abs_max_le_max_abs_abs (sup_le_sup hM (hM' x hx)))) hM)\n            hM))\n      (Classical.choose hg.left) (Classical.choose_spec hg.left))\n  (Classical.choose hf.left) (Classical.choose_spec hf.left)","type":"BddOn (f ⊔ g) (↑I : Set ℝ)","name":["hmax_bound"],"isProp":true,"id":["_uniq",166824]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f ⊔ g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f ⊔ g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f ⊔ g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f ⊔ g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f ⊔ g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmax_bound))))","type":"0 ≤ upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",168160]},{"value":"fun ε hε =>\n  (fun f' x =>\n      (fun g' x_1 =>\n          (fun f'' x_2 =>\n              (fun g'' x_3 =>\n                  let h := f'' - f' + (g'' - g');\n                  have hf'_integ := integ_of_piecewise_const x.right.left;\n                  have hg'_integ := integ_of_piecewise_const x_1.right.left;\n                  have hf''_integ := integ_of_piecewise_const x_2.right.left;\n                  have hg''_integ := integ_of_piecewise_const x_3.right.left;\n                  have hf''f'_integ := sub hf''_integ.left hf'_integ.left;\n                  have hg''g'_integ := sub hg''_integ.left hg'_integ.left;\n                  have hh_IntegrableOn.eq := add hf''f'_integ.left hg''g'_integ.left;\n                  have hinteg_le :=\n                    le_of_not_gt fun a =>\n                      Mathlib.Tactic.Linarith.lt_irrefl\n                        (Eq.mp\n                          (congrArg (fun _a => _a < 0)\n                            (Mathlib.Tactic.Ring.of_eq\n                              (Mathlib.Tactic.Ring.add_congr\n                                (Mathlib.Tactic.Ring.add_congr\n                                  (Mathlib.Tactic.Ring.add_congr\n                                    (Mathlib.Tactic.Ring.add_congr\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr\n                                              (Mathlib.Tactic.Ring.add_congr\n                                                (Mathlib.Tactic.Ring.add_congr\n                                                  (Mathlib.Tactic.Ring.add_congr\n                                                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.sub_congr ⋯ ⋯ ⋯)\n                                                      ⋯ ⋯)\n                                                    ⋯ ⋯)\n                                                  ⋯ ⋯)\n                                                ⋯ ⋯)\n                                              ⋯ ⋯)\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯ ⋯)\n                                      ⋯ ⋯)\n                                    ⋯ ⋯)\n                                  ⋯ ⋯)\n                                ⋯ ⋯)\n                              ⋯))\n                          ⋯);\n                  ⋯)\n                ⋯ ⋯)\n            ⋯ ⋯)\n        ⋯ ⋯)\n    ⋯ ⋯","type":"∀ (ε : ℝ), 0 < ε → upper_integral (f ⊔ g) I - lower_integral (f ⊔ g) I ≤ 4 * ε","name":["this"],"isProp":true,"id":["_uniq",169040]}]}],"start":6690},{"state":[],"start":6764},{"state":[],"start":6765},{"state":[],"start":6766},{"state":[],"start":6767},{"state":[],"start":6876},{"state":[],"start":6988},{"state":[{"type":"IntegrableOn (f ⊓ g) I","tag":[],"mvarId":["_uniq",239029],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",239024],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",239025],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",239026],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",239027],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",239028],"binderInfo":"default"}]}],"start":7022},{"state":[],"start":7030},{"state":[],"start":7031},{"state":[],"start":7055},{"state":[],"start":7142},{"state":[{"type":"IntegrableOn |f| I","tag":[],"mvarId":["_uniq",239252],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",239249],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",239250],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",239251],"binderInfo":"default"}]}],"start":7173},{"state":[{"type":"IntegrableOn |f| I","tag":[],"mvarId":["_uniq",239280],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",239249],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",239250],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",239251],"binderInfo":"default"},{"value":"(const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",239279]}]}],"start":7210},{"state":[{"type":"|f| = (f ⊔ fun x => 0) - f ⊓ fun x => 0","tag":["h","e'_1"],"mvarId":["_uniq",239567],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",239249],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",239250],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",239251],"binderInfo":"default"},{"value":"(const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",239279]}]}],"start":7264},{"state":[],"start":7342},{"state":[],"start":7343},{"state":[],"start":7405},{"state":[],"start":7466},{"state":[],"start":7579},{"state":[],"start":7645},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",264190],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"}]}],"start":7676},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",264190],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"}]}],"start":7749},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",264295],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"}]},{"type":"IntegrableOn (f * g) I","tag":["neg","_@","_hyg",2326],"mvarId":["_uniq",264302],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"¬(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264301],"binderInfo":"default"}]}],"start":7786},{"state":[{"type":"IntegrableOn (f * g) I","tag":["neg","_@","_hyg",2326],"mvarId":["_uniq",264302],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"¬(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264301],"binderInfo":"default"}]},{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",264295],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"}]}],"start":7793},{"state":[{"type":"I.length = 0","tag":[],"mvarId":["_uniq",264309],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"¬(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264301],"binderInfo":"default"}]}],"start":7831},{"state":[{"type":"Subsingleton (↑(↑I : Set ℝ) : Type)","tag":[],"mvarId":["_uniq",264324],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"¬(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264301],"binderInfo":"default"}]}],"start":7882},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",264295],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"}]}],"start":7927},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",264805],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"}]}],"start":7958},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",264817],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"}]}],"start":7989},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",264828],"isProp":false,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"}]}],"start":8020},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",265333],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]}]}],"start":8101},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",266017],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]}]}],"start":8182},{"state":[{"type":"BddOn (f * g) (↑I : Set ℝ)","tag":[],"mvarId":["_uniq",266240],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]}]}],"start":8224},{"state":[{"type":"|(f * g) x| ≤ M₁ * M₂","tag":["h","h","h"],"mvarId":["_uniq",266467],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁✝"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁✝ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",266398],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",266422],"binderInfo":"default"},{"type":"|f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",266423],"binderInfo":"default"},{"type":"|g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",266464],"binderInfo":"default"}]}],"start":8295},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",266242],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]}]}],"start":8359},{"state":[{"type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","tag":[],"mvarId":["_uniq",277828],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]}]}],"start":8447},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",277830],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]}]}],"start":8497},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",278715],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"}]}],"start":8608},{"state":[{"type":"∃ f',\n  MinorizesOn f' f I ∧ PiecewiseConstantOn f' I ∧ integ f I - ε < PiecewiseConstantOn.integ f' I ∧ MajorizesOn f' 0 I","tag":[],"mvarId":["_uniq",278810],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"}]}],"start":8756},{"state":[{"type":"∃ f',\n  MinorizesOn f' f I ∧ PiecewiseConstantOn f' I ∧ integ f I - ε < PiecewiseConstantOn.integ f' I ∧ MajorizesOn f' 0 I","tag":[],"mvarId":["_uniq",279618],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"}]}],"start":8885},{"state":[{"type":"MinorizesOn (f' ⊔ 0) f I ∧\n  PiecewiseConstantOn (f' ⊔ 0) I ∧ integ f I - ε < PiecewiseConstantOn.integ (f' ⊔ 0) I ∧ MajorizesOn (f' ⊔ 0) 0 I","tag":["h"],"mvarId":["_uniq",279624],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"}]}],"start":8904},{"state":[{"type":"MinorizesOn (f' ⊔ 0) f I ∧\n  PiecewiseConstantOn (f' ⊔ 0) I ∧ integ f I - ε < PiecewiseConstantOn.integ (f' ⊔ 0) I ∧ MajorizesOn (f' ⊔ 0) 0 I","tag":["h"],"mvarId":["_uniq",279982],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]}],"start":8971},{"state":[{"type":"MinorizesOn (f' ⊔ 0) f I","tag":["h","refine_1"],"mvarId":["_uniq",279987],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]},{"type":"PiecewiseConstantOn (f' ⊔ 0) I","tag":["h","refine_2","refine_1"],"mvarId":["_uniq",279997],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]},{"type":"integ f I - ε < PiecewiseConstantOn.integ (f' ⊔ 0) I","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",280005],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]},{"type":"MajorizesOn (f' ⊔ 0) 0 I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",280006],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]}],"start":8988},{"state":[{"type":"PiecewiseConstantOn (f' ⊔ 0) I","tag":["h","refine_2","refine_1"],"mvarId":["_uniq",279997],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]},{"type":"integ f I - ε < PiecewiseConstantOn.integ (f' ⊔ 0) I","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",280005],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]},{"type":"MajorizesOn (f' ⊔ 0) 0 I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",280006],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]}],"start":9054},{"state":[{"type":"integ f I - ε < PiecewiseConstantOn.integ (f' ⊔ 0) I","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",280005],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]},{"type":"MajorizesOn (f' ⊔ 0) 0 I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",280006],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]}],"start":9087},{"state":[{"type":"MajorizesOn (f' ⊔ 0) 0 I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",280006],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",279594],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",279602],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",279613],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",279617],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",279981]}]}],"start":9174},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",278812],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"value":"(fun f' x =>\n    Exists.intro (f' ⊔ 0)\n      (have hzero := ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ));\n      ⟨forall_imp\n          (fun x_1 this =>\n            forall_imp\n              (fun hx this =>\n                of_eq_true\n                  (Eq.trans sup_le_iff._simp_1\n                    (Eq.trans (congr (congrArg And (eq_true (x.left x_1 hx))) (eq_true (id (id this))))\n                      (and_self True))))\n              this)\n          hf_nonneg,\n        ⟨PiecewiseConstantOn.max x.right.left hzero,\n          ⟨lt_of_lt_of_le x.right.right\n              (PiecewiseConstantOn.integ_mono\n                (of_eq_true\n                  (Eq.trans\n                    (forall_congr fun x =>\n                      Eq.trans (implies_congr (Eq.refl (x ∈ I)) le_sup_left._simp_1) (implies_true (x ∈ I)))\n                    (implies_true ℝ)))\n                x.right.left (PiecewiseConstantOn.max x.right.left hzero)),\n            fun x =>\n            of_eq_true\n              (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1)\n                (implies_true (x ∈ (↑I : Set ℝ))))⟩⟩⟩))\n  (Classical.choose\n    (gt_of_lt_lower_integral hf.left\n      (have this :=\n        lt_of_not_ge fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                          (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Eq.refl (Int.ofNat 1)))))))\n                            Mathlib.Tactic.Ring.neg_zero)))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                        (Mathlib.Tactic.Ring.atom_pf ε)\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul) ⋯ ⋯ ⋯)))))\n                            ⋯))\n                        ⋯))\n                    ⋯)\n                  ⋯))\n              ⋯);\n      ⋯)))\n  ⋯","type":"∃ f',\n  MinorizesOn f' f I ∧ PiecewiseConstantOn f' I ∧ integ f I - ε < PiecewiseConstantOn.integ f' I ∧ MajorizesOn f' 0 I","name":["this"],"isProp":true,"id":["_uniq",278811]}]}],"start":9194},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",322845],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"}]}],"start":9253},{"state":[{"type":"∃ g',\n  MinorizesOn g' g I ∧ PiecewiseConstantOn g' I ∧ integ g I - ε < PiecewiseConstantOn.integ g' I ∧ MajorizesOn g' 0 I","tag":[],"mvarId":["_uniq",322960],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"}]}],"start":9401},{"state":[{"type":"∃ g',\n  MinorizesOn g' g I ∧ PiecewiseConstantOn g' I ∧ integ g I - ε < PiecewiseConstantOn.integ g' I ∧ MajorizesOn g' 0 I","tag":["intro","intro","intro"],"mvarId":["_uniq",323855],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"}]}],"start":9538},{"state":[{"type":"MinorizesOn (g' ⊔ 0) g I ∧\n  PiecewiseConstantOn (g' ⊔ 0) I ∧ integ g I - ε < PiecewiseConstantOn.integ (g' ⊔ 0) I ∧ MajorizesOn (g' ⊔ 0) 0 I","tag":["h"],"mvarId":["_uniq",323861],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"}]}],"start":9557},{"state":[{"type":"MinorizesOn (g' ⊔ 0) g I ∧\n  PiecewiseConstantOn (g' ⊔ 0) I ∧ integ g I - ε < PiecewiseConstantOn.integ (g' ⊔ 0) I ∧ MajorizesOn (g' ⊔ 0) 0 I","tag":["h"],"mvarId":["_uniq",324225],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]}],"start":9624},{"state":[{"type":"MinorizesOn (g' ⊔ 0) g I","tag":["h","refine_1"],"mvarId":["_uniq",324230],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]},{"type":"PiecewiseConstantOn (g' ⊔ 0) I","tag":["h","refine_2","refine_1"],"mvarId":["_uniq",324240],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]},{"type":"integ g I - ε < PiecewiseConstantOn.integ (g' ⊔ 0) I","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",324248],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]},{"type":"MajorizesOn (g' ⊔ 0) 0 I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",324249],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]}],"start":9641},{"state":[{"type":"PiecewiseConstantOn (g' ⊔ 0) I","tag":["h","refine_2","refine_1"],"mvarId":["_uniq",324240],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]},{"type":"integ g I - ε < PiecewiseConstantOn.integ (g' ⊔ 0) I","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",324248],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]},{"type":"MajorizesOn (g' ⊔ 0) 0 I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",324249],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]}],"start":9707},{"state":[{"type":"integ g I - ε < PiecewiseConstantOn.integ (g' ⊔ 0) I","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",324248],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]},{"type":"MajorizesOn (g' ⊔ 0) 0 I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",324249],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]}],"start":9740},{"state":[{"type":"MajorizesOn (g' ⊔ 0) 0 I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",324249],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",323811],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",323833],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",323853],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",323854],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => 0) I","name":["hzero"],"isProp":true,"id":["_uniq",324224]}]}],"start":9827},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",322962],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"value":"Exists.casesOn\n  (gt_of_lt_lower_integral hg.left\n    (have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral g I))\n                        (Mathlib.Tactic.Ring.atom_pf (upper_integral g I))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (upper_integral g I) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt (lower_integral g I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                              (upper_integral g I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (lower_integral g I) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (upper_integral g I) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                          Mathlib.Tactic.Ring.neg_zero)))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (lower_integral g I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral g I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral g I))\n                    (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral g I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (upper_integral g I) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (lower_integral g I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          (upper_integral g I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast +\n                            (ε ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral g I) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral g I) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                        (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt ⋯) ⋯)))\n                        ⋯))))\n                ⋯))\n            ⋯);\n    ⋯))\n  ⋯","type":"∃ g',\n  MinorizesOn g' g I ∧ PiecewiseConstantOn g' I ∧ integ g I - ε < PiecewiseConstantOn.integ g' I ∧ MajorizesOn g' 0 I","name":["this"],"isProp":true,"id":["_uniq",322961]}]}],"start":9847},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",370269],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"}]}],"start":9906},{"state":[{"type":"∃ f'',\n  MajorizesOn f'' f I ∧\n    PiecewiseConstantOn f'' I ∧ PiecewiseConstantOn.integ f'' I < integ f I + ε ∧ MinorizesOn f'' (fun x => M₁) I","tag":[],"mvarId":["_uniq",370343],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"}]}],"start":10074},{"state":[{"type":"∃ f'',\n  MajorizesOn f'' f I ∧\n    PiecewiseConstantOn f'' I ∧ PiecewiseConstantOn.integ f'' I < integ f I + ε ∧ MinorizesOn f'' (fun x => M₁) I","tag":["intro","intro","intro"],"mvarId":["_uniq",371241],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"}]}],"start":10216},{"state":[{"type":"MajorizesOn (f'' ⊓ fun x => M₁) f I ∧\n  PiecewiseConstantOn (f'' ⊓ fun x => M₁) I ∧\n    PiecewiseConstantOn.integ (f'' ⊓ fun x => M₁) I < integ f I + ε ∧ MinorizesOn (f'' ⊓ fun x => M₁) (fun x => M₁) I","tag":["h"],"mvarId":["_uniq",371247],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"}]}],"start":10251},{"state":[{"type":"MajorizesOn (f'' ⊓ fun x => M₁) f I ∧\n  PiecewiseConstantOn (f'' ⊓ fun x => M₁) I ∧\n    PiecewiseConstantOn.integ (f'' ⊓ fun x => M₁) I < integ f I + ε ∧ MinorizesOn (f'' ⊓ fun x => M₁) (fun x => M₁) I","tag":["h"],"mvarId":["_uniq",371574],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]}],"start":10327},{"state":[{"type":"MajorizesOn (f'' ⊓ fun x => M₁) f I","tag":["h","refine_1"],"mvarId":["_uniq",371579],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]},{"type":"PiecewiseConstantOn (f'' ⊓ fun x => M₁) I","tag":["h","refine_2","refine_1"],"mvarId":["_uniq",371589],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]},{"type":"PiecewiseConstantOn.integ (f'' ⊓ fun x => M₁) I < integ f I + ε","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",371597],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]},{"type":"MinorizesOn (f'' ⊓ fun x => M₁) (fun x => M₁) I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",371598],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]}],"start":10344},{"state":[{"type":"f x ≤ min f'' (fun x => M₁) x","tag":["h","refine_1","h","h"],"mvarId":["_uniq",371983],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁✝"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁✝ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁✝)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",371638],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",371662],"binderInfo":"default"},{"type":"f x ≤ M₁ ∧ -f x ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",371980],"binderInfo":"default"}]}],"start":10402},{"state":[{"type":"PiecewiseConstantOn (f'' ⊓ fun x => M₁) I","tag":["h","refine_2","refine_1"],"mvarId":["_uniq",371589],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]},{"type":"PiecewiseConstantOn.integ (f'' ⊓ fun x => M₁) I < integ f I + ε","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",371597],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]},{"type":"MinorizesOn (f'' ⊓ fun x => M₁) (fun x => M₁) I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",371598],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]}],"start":10439},{"state":[{"type":"PiecewiseConstantOn.integ (f'' ⊓ fun x => M₁) I < integ f I + ε","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",371597],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]},{"type":"MinorizesOn (f'' ⊓ fun x => M₁) (fun x => M₁) I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",371598],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]}],"start":10479},{"state":[{"type":"∀ x ∈ I, min f'' (fun x => M₁) x ≤ f'' x","tag":[],"mvarId":["_uniq",375012],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]}],"start":10569},{"state":[{"type":"MinorizesOn (f'' ⊓ fun x => M₁) (fun x => M₁) I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",371598],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",371197],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",371219],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",371239],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",371240],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₁) I","name":["hM₁_piece"],"isProp":true,"id":["_uniq",371573]}]}],"start":10582},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",370345],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"value":"Exists.casesOn\n  (lt_of_gt_upper_integral hf.left\n    (have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (integ f I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (integ f I) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Tactic.Ring.add_overlap_pf_zero (integ f I) (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)));\n    this))\n  fun f'' h =>\n  And.casesOn h fun hf''maj right =>\n    And.casesOn right fun hf''const hf''int =>\n      Exists.intro (f'' ⊓ fun x => M₁)\n        (have hM₁_piece := ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₁ (↑I : Set ℝ));\n        ⟨forall_imp\n            (fun x hM₁ =>\n              forall_imp\n                (fun hx hM₁ =>\n                  of_eq_true\n                    (Eq.trans le_inf_iff._simp_1\n                      (Eq.trans\n                        (congr (congrArg And (eq_true (hf''maj x hx)))\n                          (eq_true (Eq.mp (congrArg (fun _a => _a) (propext abs_le')) hM₁).left))\n                        (and_self True))))\n                hM₁)\n            hM₁,\n          ⟨PiecewiseConstantOn.min hf''const hM₁_piece,\n            ⟨lt_of_le_of_lt\n                (PiecewiseConstantOn.integ_mono\n                  (of_eq_true\n                    (Eq.trans\n                      (forall_congr fun x =>\n                        Eq.trans (implies_congr (Eq.refl (x ∈ I)) inf_le_left._simp_1) (implies_true (x ∈ I)))\n                      (implies_true ℝ)))\n                  (PiecewiseConstantOn.min hf''const hM₁_piece) hf''const)\n                hf''int,\n              fun x =>\n              of_eq_true\n                (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) inf_le_right._simp_1)\n                  (implies_true (x ∈ (↑I : Set ℝ))))⟩⟩⟩)","type":"∃ f'',\n  MajorizesOn f'' f I ∧\n    PiecewiseConstantOn f'' I ∧ PiecewiseConstantOn.integ f'' I < integ f I + ε ∧ MinorizesOn f'' (fun x => M₁) I","name":["this"],"isProp":true,"id":["_uniq",370344]}]}],"start":10602},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",379490],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"}]}],"start":10664},{"state":[{"type":"∃ g'',\n  MajorizesOn g'' g I ∧\n    PiecewiseConstantOn g'' I ∧ PiecewiseConstantOn.integ g'' I < integ g I + ε ∧ MinorizesOn g'' (fun x => M₂) I","tag":[],"mvarId":["_uniq",379565],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"}]}],"start":10832},{"state":[{"type":"∃ g'',\n  MajorizesOn g'' g I ∧\n    PiecewiseConstantOn g'' I ∧ PiecewiseConstantOn.integ g'' I < integ g I + ε ∧ MinorizesOn g'' (fun x => M₂) I","tag":["intro","intro","intro"],"mvarId":["_uniq",380487],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"}]}],"start":10973},{"state":[{"type":"MajorizesOn (g'' ⊓ fun x => M₂) g I ∧\n  PiecewiseConstantOn (g'' ⊓ fun x => M₂) I ∧\n    PiecewiseConstantOn.integ (g'' ⊓ fun x => M₂) I < integ g I + ε ∧ MinorizesOn (g'' ⊓ fun x => M₂) (fun x => M₂) I","tag":["h"],"mvarId":["_uniq",380493],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"}]}],"start":11008},{"state":[{"type":"MajorizesOn (g'' ⊓ fun x => M₂) g I ∧\n  PiecewiseConstantOn (g'' ⊓ fun x => M₂) I ∧\n    PiecewiseConstantOn.integ (g'' ⊓ fun x => M₂) I < integ g I + ε ∧ MinorizesOn (g'' ⊓ fun x => M₂) (fun x => M₂) I","tag":["h"],"mvarId":["_uniq",380826],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]}],"start":11084},{"state":[{"type":"MajorizesOn (g'' ⊓ fun x => M₂) g I","tag":["h","refine_1"],"mvarId":["_uniq",380831],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]},{"type":"PiecewiseConstantOn (g'' ⊓ fun x => M₂) I","tag":["h","refine_2","refine_1"],"mvarId":["_uniq",380841],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]},{"type":"PiecewiseConstantOn.integ (g'' ⊓ fun x => M₂) I < integ g I + ε","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",380849],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]},{"type":"MinorizesOn (g'' ⊓ fun x => M₂) (fun x => M₂) I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",380850],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]}],"start":11101},{"state":[{"type":"g x ≤ min g'' (fun x => M₂) x","tag":["h","refine_1","h","h"],"mvarId":["_uniq",381235],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂✝"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂✝ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂✝ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",380890],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",380914],"binderInfo":"default"},{"type":"g x ≤ M₂ ∧ -g x ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",381232],"binderInfo":"default"}]}],"start":11159},{"state":[{"type":"PiecewiseConstantOn (g'' ⊓ fun x => M₂) I","tag":["h","refine_2","refine_1"],"mvarId":["_uniq",380841],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]},{"type":"PiecewiseConstantOn.integ (g'' ⊓ fun x => M₂) I < integ g I + ε","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",380849],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]},{"type":"MinorizesOn (g'' ⊓ fun x => M₂) (fun x => M₂) I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",380850],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]}],"start":11196},{"state":[{"type":"PiecewiseConstantOn.integ (g'' ⊓ fun x => M₂) I < integ g I + ε","tag":["h","refine_2","refine_2","refine_1"],"mvarId":["_uniq",380849],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]},{"type":"MinorizesOn (g'' ⊓ fun x => M₂) (fun x => M₂) I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",380850],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]}],"start":11236},{"state":[{"type":"∀ x ∈ I, min g'' (fun x => M₂) x ≤ g'' x","tag":[],"mvarId":["_uniq",384264],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]}],"start":11326},{"state":[{"type":"MinorizesOn (g'' ⊓ fun x => M₂) (fun x => M₂) I","tag":["h","refine_2","refine_2","refine_2"],"mvarId":["_uniq",380850],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",380443],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",380465],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",380485],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",380486],"binderInfo":"default"},{"value":"ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ))","type":"PiecewiseConstantOn (fun x => M₂) I","name":["hM₂_piece"],"isProp":true,"id":["_uniq",380825]}]}],"start":11339},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",379567],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"value":"Exists.casesOn\n  (lt_of_gt_upper_integral hg.left\n    (have this :=\n      lt_of_not_ge fun a =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (integ g I))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (integ g I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.atom_pf (upper_integral g I))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (integ g I) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (ε ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                          (Mathlib.Tactic.Ring.add_overlap_pf_zero (integ g I) (Nat.rawCast 1)\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero ε (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt hε)\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le a)));\n    this))\n  fun g'' h =>\n  And.casesOn h fun hg''maj right =>\n    And.casesOn right fun hg''const hg''int =>\n      Exists.intro (g'' ⊓ fun x => M₂)\n        (have hM₂_piece := ConstantOn.piecewiseConstantOn (ConstantOn.of_const' M₂ (↑I : Set ℝ));\n        ⟨forall_imp\n            (fun x hM₂ =>\n              forall_imp\n                (fun hx hM₂ =>\n                  of_eq_true\n                    (Eq.trans le_inf_iff._simp_1\n                      (Eq.trans\n                        (congr (congrArg And (eq_true (hg''maj x hx)))\n                          (eq_true (Eq.mp (congrArg (fun _a => _a) (propext abs_le')) hM₂).left))\n                        (and_self True))))\n                hM₂)\n            hM₂,\n          ⟨PiecewiseConstantOn.min hg''const hM₂_piece,\n            ⟨lt_of_le_of_lt\n                (PiecewiseConstantOn.integ_mono\n                  (of_eq_true\n                    (Eq.trans\n                      (forall_congr fun x =>\n                        Eq.trans (implies_congr (Eq.refl (x ∈ I)) inf_le_left._simp_1) (implies_true (x ∈ I)))\n                      (implies_true ℝ)))\n                  (PiecewiseConstantOn.min hg''const hM₂_piece) hg''const)\n                hg''int,\n              fun x a => of_eq_true inf_le_right._simp_1⟩⟩⟩)","type":"∃ g'',\n  MajorizesOn g'' g I ∧\n    PiecewiseConstantOn g'' I ∧ PiecewiseConstantOn.integ g'' I < integ g I + ε ∧ MinorizesOn g'' (fun x => M₂) I","name":["this"],"isProp":true,"id":["_uniq",379566]}]}],"start":11361},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",388696],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"}]}],"start":11423},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",388709],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]}]}],"start":11469},{"state":[{"type":"MinorizesOn (f' * g') (f * g) I","tag":[],"mvarId":["_uniq",388875],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]}]}],"start":11528},{"state":[{"type":"(f' * g') x ≤ (f * g) x","tag":["h","h"],"mvarId":["_uniq",388982],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min✝"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",388913],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",388937],"binderInfo":"default"},{"type":"f' x ≤ f x","name":["hf'min"],"isProp":true,"id":["_uniq",388938],"binderInfo":"default"},{"type":"g' x ≤ g x","name":["hg'min"],"isProp":true,"id":["_uniq",388979],"binderInfo":"default"}]}],"start":11588},{"state":[{"type":"(f' * g') x ≤ (f * g) x","tag":["h","h"],"mvarId":["_uniq",389042],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min✝"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",388913],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",388937],"binderInfo":"default"},{"type":"f' x ≤ f x","name":["hf'min"],"isProp":true,"id":["_uniq",388938],"binderInfo":"default"},{"type":"g' x ≤ g x","name":["hg'min"],"isProp":true,"id":["_uniq",388979],"binderInfo":"default"},{"type":"0 x ≤ f' x","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",389009],"binderInfo":"default"},{"type":"0 x ≤ g' x","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",389039],"binderInfo":"default"}]}],"start":11649},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",388879],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]}]}],"start":11707},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",450770],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]}]}],"start":11757},{"state":[{"type":"MajorizesOn (f'' * g'') (f * g) I","tag":[],"mvarId":["_uniq",450936],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]}]}],"start":11820},{"state":[{"type":"(f * g) x ≤ (f'' * g'') x","tag":["h","h"],"mvarId":["_uniq",451043],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj✝"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj✝ hf''const hf''int hf''bound g'' _fvar.388669\n              hg''const hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj✝ hf''const hf''int hf''bound g'' _fvar.388669\n              hg''const hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",450974],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",450998],"binderInfo":"default"},{"type":"f x ≤ f'' x","name":["hf''maj"],"isProp":true,"id":["_uniq",450999],"binderInfo":"default"},{"type":"g x ≤ g'' x","name":["hg''maj"],"isProp":true,"id":["_uniq",451040],"binderInfo":"default"}]}],"start":11882},{"state":[{"type":"(f * g) x ≤ (f'' * g'') x","tag":["h","h"],"mvarId":["_uniq",451103],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj✝"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg _fvar.264184 _fvar.264185 hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε\n              f' hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj✝ hf''const hf''int hf''bound g'' _fvar.388669\n              hg''const hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg _fvar.264184 _fvar.264185 hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε\n              f' hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj✝ hf''const hf''int hf''bound g'' _fvar.388669\n              hg''const hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",450974],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",450998],"binderInfo":"default"},{"type":"f x ≤ f'' x","name":["hf''maj"],"isProp":true,"id":["_uniq",450999],"binderInfo":"default"},{"type":"g x ≤ g'' x","name":["hg''maj"],"isProp":true,"id":["_uniq",451040],"binderInfo":"default"},{"type":"0 x ≤ g x","name":["hg_nonneg"],"isProp":true,"id":["_uniq",451070],"binderInfo":"default"},{"type":"0 x ≤ f x","name":["hf_nonneg"],"isProp":true,"id":["_uniq",451100],"binderInfo":"default"}]}],"start":11941},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",450940],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]}]}],"start":12001},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",514169],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]}]}],"start":12084},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",514185],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]}]}],"start":12163},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",514202],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]}]}],"start":12214},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",514219],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]}]}],"start":12271},{"state":[{"type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","tag":[],"mvarId":["_uniq",514800],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]}]}],"start":12370},{"state":[{"type":"(f'' * g'' - f' * g') x ≤ (M₁ • (g'' - g') + M₂ • (f'' - f')) x","tag":[],"mvarId":["_uniq",514813],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",514809],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",514812],"binderInfo":"default"}]}],"start":12387},{"state":[{"type":"f'' x * g'' x - f' x * g' x ≤ M₁ * (g'' x - g' x) + M₂ * (f'' x - f' x)","tag":[],"mvarId":["_uniq",515413],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",514809],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",514812],"binderInfo":"default"}]}],"start":12474},{"state":[{"type":"f'' x * g'' x - f' x * g' x ≤ M₁ * (g'' x - g' x) + M₂ * (f'' x - f' x)","tag":[],"mvarId":["_uniq",515413],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",514809],"binderInfo":"default"},{"type":"x ∈ (↑I : Set ℝ)","name":["hx"],"isProp":true,"id":["_uniq",514812],"binderInfo":"default"}]}],"start":12485},{"state":[],"start":12559},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",514804],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]}]}],"start":12598},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643454],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]}]}],"start":12646},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643471],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]}]}],"start":12700},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643483],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]}]}],"start":12752},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643495],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]}]}],"start":12809},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643509],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]},{"value":"PiecewiseConstantOn.sub hf''const hf'const","type":"PiecewiseConstantOn (f'' - f') I","name":["hf''f'_const"],"isProp":true,"id":["_uniq",643508]}]}],"start":12857},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643523],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]},{"value":"PiecewiseConstantOn.sub hf''const hf'const","type":"PiecewiseConstantOn (f'' - f') I","name":["hf''f'_const"],"isProp":true,"id":["_uniq",643508]},{"value":"PiecewiseConstantOn.integ_sub hf''const hf'const","type":"PiecewiseConstantOn.integ (f'' - f') I = PiecewiseConstantOn.integ f'' I - PiecewiseConstantOn.integ f' I","name":["hf''f_integ"],"isProp":true,"id":["_uniq",643522]}]}],"start":12910},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643535],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]},{"value":"PiecewiseConstantOn.sub hf''const hf'const","type":"PiecewiseConstantOn (f'' - f') I","name":["hf''f'_const"],"isProp":true,"id":["_uniq",643508]},{"value":"PiecewiseConstantOn.integ_sub hf''const hf'const","type":"PiecewiseConstantOn.integ (f'' - f') I = PiecewiseConstantOn.integ f'' I - PiecewiseConstantOn.integ f' I","name":["hf''f_integ"],"isProp":true,"id":["_uniq",643522]},{"value":"PiecewiseConstantOn.smul M₂ hf''f'_const","type":"PiecewiseConstantOn (M₂ • (f'' - f')) I","name":["hM₂f''f'_const"],"isProp":true,"id":["_uniq",643534]}]}],"start":12962},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643547],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]},{"value":"PiecewiseConstantOn.sub hf''const hf'const","type":"PiecewiseConstantOn (f'' - f') I","name":["hf''f'_const"],"isProp":true,"id":["_uniq",643508]},{"value":"PiecewiseConstantOn.integ_sub hf''const hf'const","type":"PiecewiseConstantOn.integ (f'' - f') I = PiecewiseConstantOn.integ f'' I - PiecewiseConstantOn.integ f' I","name":["hf''f_integ"],"isProp":true,"id":["_uniq",643522]},{"value":"PiecewiseConstantOn.smul M₂ hf''f'_const","type":"PiecewiseConstantOn (M₂ • (f'' - f')) I","name":["hM₂f''f'_const"],"isProp":true,"id":["_uniq",643534]},{"value":"PiecewiseConstantOn.integ_smul M₂ hf''f'_const","type":"PiecewiseConstantOn.integ (M₂ • (f'' - f')) I = M₂ * PiecewiseConstantOn.integ (f'' - f') I","name":["hM₂f''f_integ"],"isProp":true,"id":["_uniq",643546]}]}],"start":13019},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643561],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]},{"value":"PiecewiseConstantOn.sub hf''const hf'const","type":"PiecewiseConstantOn (f'' - f') I","name":["hf''f'_const"],"isProp":true,"id":["_uniq",643508]},{"value":"PiecewiseConstantOn.integ_sub hf''const hf'const","type":"PiecewiseConstantOn.integ (f'' - f') I = PiecewiseConstantOn.integ f'' I - PiecewiseConstantOn.integ f' I","name":["hf''f_integ"],"isProp":true,"id":["_uniq",643522]},{"value":"PiecewiseConstantOn.smul M₂ hf''f'_const","type":"PiecewiseConstantOn (M₂ • (f'' - f')) I","name":["hM₂f''f'_const"],"isProp":true,"id":["_uniq",643534]},{"value":"PiecewiseConstantOn.integ_smul M₂ hf''f'_const","type":"PiecewiseConstantOn.integ (M₂ • (f'' - f')) I = M₂ * PiecewiseConstantOn.integ (f'' - f') I","name":["hM₂f''f_integ"],"isProp":true,"id":["_uniq",643546]},{"value":"PiecewiseConstantOn.add hM₁g''g'_const hM₂f''f'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hsum_const"],"isProp":true,"id":["_uniq",643560]}]}],"start":13080},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643575],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]},{"value":"PiecewiseConstantOn.sub hf''const hf'const","type":"PiecewiseConstantOn (f'' - f') I","name":["hf''f'_const"],"isProp":true,"id":["_uniq",643508]},{"value":"PiecewiseConstantOn.integ_sub hf''const hf'const","type":"PiecewiseConstantOn.integ (f'' - f') I = PiecewiseConstantOn.integ f'' I - PiecewiseConstantOn.integ f' I","name":["hf''f_integ"],"isProp":true,"id":["_uniq",643522]},{"value":"PiecewiseConstantOn.smul M₂ hf''f'_const","type":"PiecewiseConstantOn (M₂ • (f'' - f')) I","name":["hM₂f''f'_const"],"isProp":true,"id":["_uniq",643534]},{"value":"PiecewiseConstantOn.integ_smul M₂ hf''f'_const","type":"PiecewiseConstantOn.integ (M₂ • (f'' - f')) I = M₂ * PiecewiseConstantOn.integ (f'' - f') I","name":["hM₂f''f_integ"],"isProp":true,"id":["_uniq",643546]},{"value":"PiecewiseConstantOn.add hM₁g''g'_const hM₂f''f'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hsum_const"],"isProp":true,"id":["_uniq",643560]},{"value":"PiecewiseConstantOn.integ_add hM₁g''g'_const hM₂f''f'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g') + M₂ • (f'' - f')) I =\n  PiecewiseConstantOn.integ (M₁ • (g'' - g')) I + PiecewiseConstantOn.integ (M₂ • (f'' - f')) I","name":["hsum_integ"],"isProp":true,"id":["_uniq",643574]}]}],"start":13147},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643628],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]},{"value":"PiecewiseConstantOn.sub hf''const hf'const","type":"PiecewiseConstantOn (f'' - f') I","name":["hf''f'_const"],"isProp":true,"id":["_uniq",643508]},{"value":"PiecewiseConstantOn.integ_sub hf''const hf'const","type":"PiecewiseConstantOn.integ (f'' - f') I = PiecewiseConstantOn.integ f'' I - PiecewiseConstantOn.integ f' I","name":["hf''f_integ"],"isProp":true,"id":["_uniq",643522]},{"value":"PiecewiseConstantOn.smul M₂ hf''f'_const","type":"PiecewiseConstantOn (M₂ • (f'' - f')) I","name":["hM₂f''f'_const"],"isProp":true,"id":["_uniq",643534]},{"value":"PiecewiseConstantOn.integ_smul M₂ hf''f'_const","type":"PiecewiseConstantOn.integ (M₂ • (f'' - f')) I = M₂ * PiecewiseConstantOn.integ (f'' - f') I","name":["hM₂f''f_integ"],"isProp":true,"id":["_uniq",643546]},{"value":"PiecewiseConstantOn.add hM₁g''g'_const hM₂f''f'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hsum_const"],"isProp":true,"id":["_uniq",643560]},{"value":"PiecewiseConstantOn.integ_add hM₁g''g'_const hM₂f''f'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g') + M₂ • (f'' - f')) I =\n  PiecewiseConstantOn.integ (M₁ • (g'' - g')) I + PiecewiseConstantOn.integ (M₂ • (f'' - f')) I","name":["hsum_integ"],"isProp":true,"id":["_uniq",643574]},{"value":"PiecewiseConstantOn.integ_mono hhmin hh_const hsum_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I ≤ PiecewiseConstantOn.integ (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hsum_bound"],"isProp":true,"id":["_uniq",643627]}]}],"start":13207},{"state":[{"type":"upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","tag":[],"mvarId":["_uniq",643628],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",278394],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",278435],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f'"],"isProp":false,"id":["_uniq",322809],"binderInfo":"default"},{"type":"MinorizesOn f' f I","name":["hf'min"],"isProp":true,"id":["_uniq",322818],"binderInfo":"default"},{"type":"PiecewiseConstantOn f' I","name":["hf'const"],"isProp":true,"id":["_uniq",322829],"binderInfo":"default"},{"type":"integ f I - ε < PiecewiseConstantOn.integ f' I","name":["hf'int"],"isProp":true,"id":["_uniq",322838],"binderInfo":"default"},{"type":"MajorizesOn f' 0 I","name":["hf'_nonneg"],"isProp":true,"id":["_uniq",322842],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g'"],"isProp":false,"id":["_uniq",370233],"binderInfo":"default"},{"type":"MinorizesOn g' g I","name":["hg'min"],"isProp":true,"id":["_uniq",370242],"binderInfo":"default"},{"type":"PiecewiseConstantOn g' I","name":["hg'const"],"isProp":true,"id":["_uniq",370253],"binderInfo":"default"},{"type":"integ g I - ε < PiecewiseConstantOn.integ g' I","name":["hg'int"],"isProp":true,"id":["_uniq",370262],"binderInfo":"default"},{"type":"MajorizesOn g' 0 I","name":["hg'_nonneg"],"isProp":true,"id":["_uniq",370266],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["f''"],"isProp":false,"id":["_uniq",379454],"binderInfo":"default"},{"type":"MajorizesOn f'' f I","name":["hf''maj"],"isProp":true,"id":["_uniq",379463],"binderInfo":"default"},{"type":"PiecewiseConstantOn f'' I","name":["hf''const"],"isProp":true,"id":["_uniq",379474],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ f'' I < integ f I + ε","name":["hf''int"],"isProp":true,"id":["_uniq",379483],"binderInfo":"default"},{"type":"MinorizesOn f'' (fun x => M₁) I","name":["hf''bound"],"isProp":true,"id":["_uniq",379487],"binderInfo":"default"},{"type":"ℝ → ℝ","name":["g''"],"isProp":false,"id":["_uniq",388660],"binderInfo":"default"},{"type":"MajorizesOn g'' g I","name":["hg''maj"],"isProp":true,"id":["_uniq",388669],"binderInfo":"default"},{"type":"PiecewiseConstantOn g'' I","name":["hg''const"],"isProp":true,"id":["_uniq",388680],"binderInfo":"default"},{"type":"PiecewiseConstantOn.integ g'' I < integ g I + ε","name":["hg''int"],"isProp":true,"id":["_uniq",388689],"binderInfo":"default"},{"type":"MinorizesOn g'' (fun x => M₂) I","name":["hg''bound"],"isProp":true,"id":["_uniq",388693],"binderInfo":"default"},{"value":"PiecewiseConstantOn.mul hf'const hg'const","type":"PiecewiseConstantOn (f' * g') I","name":["hf'g'_const"],"isProp":true,"id":["_uniq",388708]},{"value":"forall_imp\n  (fun x hf'min_1 =>\n    forall_imp\n      (fun hx hf'min_2 =>\n        id\n          (mul_le_mul hf'min_2 (hg'min x hx)\n            (integ_of_mul_nonneg._proof_3 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_4 hf hg hf_nonneg hg_nonneg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f'\n              hf'min hf'const hf'int g' hg'const hg'int f'' hf''maj hf''const hf''int hf''bound g'' hg''maj hg''const\n              hg''int hg''bound hf'g'_const x hx hf'min_2 (hg'min x hx) (hf'_nonneg x hx) (hg'_nonneg x hx)\n              (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf'min_1)\n  hf'min","type":"MinorizesOn (f' * g') (f * g) I","name":["hf'g'_maj"],"isProp":true,"id":["_uniq",388876]},{"value":"PiecewiseConstantOn.mul hf''const hg''const","type":"PiecewiseConstantOn (f'' * g'') I","name":["hf''g''_const"],"isProp":true,"id":["_uniq",450769]},{"value":"forall_imp\n  (fun x hf''maj_1 =>\n    forall_imp\n      (fun hx hf''maj_2 =>\n        id\n          (mul_le_mul hf''maj_2 (hg''maj x hx)\n            (integ_of_mul_nonneg._proof_5 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))\n            (integ_of_mul_nonneg._proof_6 hf hg hI M₁ hM₁ M₂ hM₂ hM₁pos hM₂pos hmul_bound ε hε f' hf'min hf'const hf'int\n              hf'_nonneg g' hg'min hg'const hg'int hg'_nonneg f'' hf''maj hf''const hf''int hf''bound g'' hg''const\n              hg''int hg''bound hf'g'_const hf'g'_maj hf''g''_const x hx hf''maj_2 (hg''maj x hx) (hg_nonneg x hx)\n              (hf_nonneg x hx) (Eq.mp one_le_div'._simp_4 lower_le_upper))))\n      hf''maj_1)\n  hf''maj","type":"MajorizesOn (f'' * g'') (f * g) I","name":["hf''g''_maj"],"isProp":true,"id":["_uniq",450937]},{"value":"upper_integral_le_integ hmul_bound hf''g''_maj hf''g''_const","type":"upper_integral (f * g) I ≤ hf''g''_const.integ'","name":["hupper_le"],"isProp":true,"id":["_uniq",514168]},{"value":"integ_le_lower_integral hmul_bound hf'g'_maj hf'g'_const","type":"hf'g'_const.integ' ≤ lower_integral (f * g) I","name":["hlower_ge"],"isProp":true,"id":["_uniq",514184]},{"value":"PiecewiseConstantOn.sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn (f'' * g'' - f' * g') I","name":["hh_const"],"isProp":true,"id":["_uniq",514201]},{"value":"PiecewiseConstantOn.integ_sub hf''g''_const hf'g'_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I =\n  PiecewiseConstantOn.integ (f'' * g'') I - PiecewiseConstantOn.integ (f' * g') I","name":["hh_integ"],"isProp":true,"id":["_uniq",514218]},{"value":"fun x hx =>\n  id\n    (Trans.trans\n      (Mathlib.Tactic.Ring.of_eq\n        (Mathlib.Tactic.Ring.sub_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x)) (Mathlib.Tactic.Ring.atom_pf (g'' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_zero (f' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0)))\n              (Mathlib.Tactic.Ring.zero_mul (g' x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n              (Mathlib.Tactic.Ring.add_pf_add_zero\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * Nat.rawCast 1) + 0))))\n          (Mathlib.Tactic.Ring.sub_pf\n            (Mathlib.Tactic.Ring.neg_add\n              (Mathlib.Tactic.Ring.neg_mul (f' x) (Nat.rawCast 1)\n                (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.neg_one_mul\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                        (Eq.refl (Int.negOfNat 1)))))))\n              Mathlib.Tactic.Ring.neg_zero)\n            (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n              (Mathlib.Tactic.Ring.add_pf_zero_add\n                (f' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))))\n        (Mathlib.Tactic.Ring.add_congr\n          (Mathlib.Tactic.Ring.mul_congr (Mathlib.Tactic.Ring.atom_pf (f'' x))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (g'' x)) (Mathlib.Tactic.Ring.atom_pf (g' x))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (g' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_mul\n              (Mathlib.Tactic.Ring.mul_add\n                (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.mul_pf_right (g'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1))))\n                (Mathlib.Tactic.Ring.mul_add\n                  (Mathlib.Tactic.Ring.mul_pf_left (f'' x) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.mul_pf_right (g' x) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.one_mul (Int.negOfNat 1).rawCast)))\n                  (Mathlib.Tactic.Ring.mul_zero (f'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast) + 0)))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (f'' x ^ Nat.rawCast 1 * (g'' x ^ Nat.rawCast 1 * Nat.rawCast 1))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (f'' x ^ Nat.rawCast 1 * (g' x ^ Nat.rawCast ⋯ * ⋯) + ⋯))))\n              ⋯ ⋯))\n          ⋯ ⋯))\n      ⋯)","type":"MinorizesOn (f'' * g'' - f' * g') (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hhmin"],"isProp":true,"id":["_uniq",514801]},{"value":"PiecewiseConstantOn.sub hg''const hg'const","type":"PiecewiseConstantOn (g'' - g') I","name":["hg''g'_const"],"isProp":true,"id":["_uniq",643453]},{"value":"PiecewiseConstantOn.integ_sub hg''const hg'const","type":"PiecewiseConstantOn.integ (g'' - g') I = PiecewiseConstantOn.integ g'' I - PiecewiseConstantOn.integ g' I","name":["hg''g'_integ"],"isProp":true,"id":["_uniq",643470]},{"value":"PiecewiseConstantOn.smul M₁ hg''g'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g')) I","name":["hM₁g''g'_const"],"isProp":true,"id":["_uniq",643482]},{"value":"PiecewiseConstantOn.integ_smul M₁ hg''g'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g')) I = M₁ * PiecewiseConstantOn.integ (g'' - g') I","name":["hM₁g''g_integ"],"isProp":true,"id":["_uniq",643494]},{"value":"PiecewiseConstantOn.sub hf''const hf'const","type":"PiecewiseConstantOn (f'' - f') I","name":["hf''f'_const"],"isProp":true,"id":["_uniq",643508]},{"value":"PiecewiseConstantOn.integ_sub hf''const hf'const","type":"PiecewiseConstantOn.integ (f'' - f') I = PiecewiseConstantOn.integ f'' I - PiecewiseConstantOn.integ f' I","name":["hf''f_integ"],"isProp":true,"id":["_uniq",643522]},{"value":"PiecewiseConstantOn.smul M₂ hf''f'_const","type":"PiecewiseConstantOn (M₂ • (f'' - f')) I","name":["hM₂f''f'_const"],"isProp":true,"id":["_uniq",643534]},{"value":"PiecewiseConstantOn.integ_smul M₂ hf''f'_const","type":"PiecewiseConstantOn.integ (M₂ • (f'' - f')) I = M₂ * PiecewiseConstantOn.integ (f'' - f') I","name":["hM₂f''f_integ"],"isProp":true,"id":["_uniq",643546]},{"value":"PiecewiseConstantOn.add hM₁g''g'_const hM₂f''f'_const","type":"PiecewiseConstantOn (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hsum_const"],"isProp":true,"id":["_uniq",643560]},{"value":"PiecewiseConstantOn.integ_add hM₁g''g'_const hM₂f''f'_const","type":"PiecewiseConstantOn.integ (M₁ • (g'' - g') + M₂ • (f'' - f')) I =\n  PiecewiseConstantOn.integ (M₁ • (g'' - g')) I + PiecewiseConstantOn.integ (M₂ • (f'' - f')) I","name":["hsum_integ"],"isProp":true,"id":["_uniq",643574]},{"value":"PiecewiseConstantOn.integ_mono hhmin hh_const hsum_const","type":"PiecewiseConstantOn.integ (f'' * g'' - f' * g') I ≤ PiecewiseConstantOn.integ (M₁ • (g'' - g') + M₂ • (f'' - f')) I","name":["hsum_bound"],"isProp":true,"id":["_uniq",643627]}]}],"start":13216},{"state":[],"start":13337},{"state":[],"start":13405},{"state":[{"type":"IntegrableOn (f * g) I","tag":["pos","_@","_hyg",2326],"mvarId":["_uniq",278720],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",264179],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",264180],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",264181],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ) ∧ lower_integral f I = upper_integral f I","name":["hf"],"isProp":true,"id":["_uniq",264182],"binderInfo":"default"},{"type":"BddOn g (↑I : Set ℝ) ∧ lower_integral g I = upper_integral g I","name":["hg"],"isProp":true,"id":["_uniq",264183],"binderInfo":"default"},{"type":"MajorizesOn f 0 I","name":["hf_nonneg"],"isProp":true,"id":["_uniq",264184],"binderInfo":"default"},{"type":"MajorizesOn g 0 I","name":["hg_nonneg"],"isProp":true,"id":["_uniq",264185],"binderInfo":"default"},{"type":"(↑I : Set ℝ).Nonempty","name":["hI"],"isProp":true,"id":["_uniq",264294],"binderInfo":"default"},{"type":"ℝ","name":["M₁"],"isProp":false,"id":["_uniq",264811],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |f x| ≤ M₁","name":["hM₁"],"isProp":true,"id":["_uniq",264814],"binderInfo":"default"},{"type":"ℝ","name":["M₂"],"isProp":false,"id":["_uniq",264822],"binderInfo":"default"},{"type":"∀ x ∈ (↑I : Set ℝ), |g x| ≤ M₂","name":["hM₂"],"isProp":true,"id":["_uniq",264825],"binderInfo":"default"},{"value":"LE.le.trans (abs_nonneg (f hI.some)) (hM₁ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₁","name":["hM₁pos"],"isProp":true,"id":["_uniq",265332]},{"value":"LE.le.trans (abs_nonneg (g hI.some)) (hM₂ hI.some (Set.Nonempty.some_mem hI))","type":"0 ≤ M₂","name":["hM₂pos"],"isProp":true,"id":["_uniq",266016]},{"value":"Exists.intro (M₁ * M₂)\n  (forall_imp\n    (fun x hM₁ =>\n      forall_imp\n        (fun hx hM₁ =>\n          Eq.mpr (id (congrArg (fun x => x ≤ M₁ * M₂) (abs_mul (f x) (g x))))\n            (mul_le_mul hM₁ (hM₂ x hx) (IsAbsoluteValue.abv_nonneg abs (g x)) hM₁pos))\n        hM₁)\n    hM₁)","type":"BddOn (f * g) (↑I : Set ℝ)","name":["hmul_bound"],"isProp":true,"id":["_uniq",266241]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n                (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (lower_integral (f * g) I) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (upper_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral (f * g) I))\n              (Mathlib.Tactic.Ring.atom_pf (upper_integral (f * g) I))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul (upper_integral (f * g) I) (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_gt (upper_integral (f * g) I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero\n                    (lower_integral (f * g) I ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero (upper_integral (f * g) I) (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero (lower_integral (f * g) I) (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (Mathlib.Tactic.Linarith.sub_neg_of_lt a)\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (lower_integral_le_upper hmul_bound))))","type":"0 ≤ upper_integral (f * g) I - lower_integral (f * g) I","name":["lower_le_upper"],"isProp":true,"id":["_uniq",277829]},{"value":"fun ε hε =>\n  have this :=\n    (fun f' x =>\n        Exists.intro (f' ⊔ 0)\n          (have hzero := ConstantOn.piecewiseConstantOn (ConstantOn.of_const' 0 (↑I : Set ℝ));\n          ⟨forall_imp\n              (fun x_1 this =>\n                forall_imp\n                  (fun hx this =>\n                    of_eq_true\n                      (Eq.trans sup_le_iff._simp_1\n                        (Eq.trans (congr (congrArg And (eq_true (x.left x_1 hx))) (eq_true (id (id this))))\n                          (and_self True))))\n                  this)\n              hf_nonneg,\n            ⟨PiecewiseConstantOn.max x.right.left hzero,\n              ⟨lt_of_lt_of_le x.right.right\n                  (PiecewiseConstantOn.integ_mono\n                    (of_eq_true\n                      (Eq.trans\n                        (forall_congr fun x =>\n                          Eq.trans (implies_congr (Eq.refl (x ∈ I)) le_sup_left._simp_1) (implies_true (x ∈ I)))\n                        (implies_true ℝ)))\n                    x.right.left (PiecewiseConstantOn.max x.right.left hzero)),\n                fun x =>\n                of_eq_true\n                  (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1)\n                    (implies_true (x ∈ (↑I : Set ℝ))))⟩⟩⟩))\n      (Classical.choose\n        (gt_of_lt_lower_integral hf.left\n          (have this :=\n            lt_of_not_ge fun a =>\n              Mathlib.Tactic.Linarith.lt_irrefl\n                (Eq.mp\n                  (congrArg (fun _a => _a < 0)\n                    (Mathlib.Tactic.Ring.of_eq\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.neg_congr\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                              (Mathlib.Tactic.Ring.atom_pf (upper_integral f I))\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (lower_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (upper_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (lower_integral f I) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                          (Eq.refl (Int.ofNat 1)))))))\n                                Mathlib.Tactic.Ring.neg_zero)))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.add_pf_add_lt\n                            (lower_integral f I ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (lower_integral f I))\n                          (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (integ f I))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                        (Eq.refl (Int.negOfNat 1))))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_lt (upper_integral f I ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.add_pf_zero_add\n                                  (ε ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (upper_integral f I) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_mul ε (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl ⋯) ⋯ ⋯ ⋯)))))\n                                ⋯))\n                            ⋯))\n                        ⋯)\n                      ⋯))\n                  ⋯);\n          ⋯)))\n      ⋯;\n  ⋯","type":"∀ (ε : ℝ), 0 < ε → upper_integral (f * g) I - lower_integral (f * g) I ≤ 2 * (M₁ + M₂) * ε","name":["this"],"isProp":true,"id":["_uniq",278717]}]}],"start":13428},{"state":[],"start":13502},{"state":[],"start":13503},{"state":[],"start":13504},{"state":[],"start":13612},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",704338],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"}]}],"start":13643},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",704338],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"}]}],"start":13716},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",704398],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]}]}],"start":13751},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",704549],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]}]}],"start":13788},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",704648],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]}]}],"start":13823},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",704760],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]}]}],"start":13860},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",704874],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]}]}],"start":13897},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",758713],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"}]}],"start":13943},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",760423],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"}]}],"start":13989},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",760523],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]}]}],"start":14057},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",760570],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]}]}],"start":14125},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",760623],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]}]}],"start":14198},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",768767],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]}]}],"start":14274},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",775716],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]}]}],"start":14347},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",783861],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gminus 0 I","name":["hgminus_nonneg"],"isProp":true,"id":["_uniq",783858]}]}],"start":14423},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",790820],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gminus 0 I","name":["hgminus_nonneg"],"isProp":true,"id":["_uniq",783858]},{"value":"integ_of_mul_nonneg hfplus_integ hgplus_integ hfplus_nonneg hgplus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * (g ⊔ fun x => 0)) I","name":["hfplusgplus"],"isProp":true,"id":["_uniq",790819]}]}],"start":14519},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",790837],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gminus 0 I","name":["hgminus_nonneg"],"isProp":true,"id":["_uniq",783858]},{"value":"integ_of_mul_nonneg hfplus_integ hgplus_integ hfplus_nonneg hgplus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * (g ⊔ fun x => 0)) I","name":["hfplusgplus"],"isProp":true,"id":["_uniq",790819]},{"value":"integ_of_mul_nonneg hfplus_integ hgminus_integ hfplus_nonneg hgminus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * gminus) I","name":["hfplusgminus"],"isProp":true,"id":["_uniq",790836]}]}],"start":14618},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",790854],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gminus 0 I","name":["hgminus_nonneg"],"isProp":true,"id":["_uniq",783858]},{"value":"integ_of_mul_nonneg hfplus_integ hgplus_integ hfplus_nonneg hgplus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * (g ⊔ fun x => 0)) I","name":["hfplusgplus"],"isProp":true,"id":["_uniq",790819]},{"value":"integ_of_mul_nonneg hfplus_integ hgminus_integ hfplus_nonneg hgminus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * gminus) I","name":["hfplusgminus"],"isProp":true,"id":["_uniq",790836]},{"value":"integ_of_mul_nonneg hfminus_integ hgplus_integ hfminus_nonneg hgplus_nonneg","type":"IntegrableOn (fminus * (g ⊔ fun x => 0)) I","name":["hfminusgplus"],"isProp":true,"id":["_uniq",790853]}]}],"start":14717},{"state":[{"type":"IntegrableOn (f * g) I","tag":[],"mvarId":["_uniq",790867],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gminus 0 I","name":["hgminus_nonneg"],"isProp":true,"id":["_uniq",783858]},{"value":"integ_of_mul_nonneg hfplus_integ hgplus_integ hfplus_nonneg hgplus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * (g ⊔ fun x => 0)) I","name":["hfplusgplus"],"isProp":true,"id":["_uniq",790819]},{"value":"integ_of_mul_nonneg hfplus_integ hgminus_integ hfplus_nonneg hgminus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * gminus) I","name":["hfplusgminus"],"isProp":true,"id":["_uniq",790836]},{"value":"integ_of_mul_nonneg hfminus_integ hgplus_integ hfminus_nonneg hgplus_nonneg","type":"IntegrableOn (fminus * (g ⊔ fun x => 0)) I","name":["hfminusgplus"],"isProp":true,"id":["_uniq",790853]},{"value":"integ_of_mul_nonneg hfminus_integ hgminus_integ hfminus_nonneg hgminus_nonneg","type":"IntegrableOn (fminus * gminus) I","name":["hfminusgminus"],"isProp":true,"id":["_uniq",790866]}]}],"start":14819},{"state":[{"type":"IntegrableOn ((fplus - fminus) * g) I","tag":[],"mvarId":["_uniq",790977],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gminus 0 I","name":["hgminus_nonneg"],"isProp":true,"id":["_uniq",783858]},{"value":"integ_of_mul_nonneg hfplus_integ hgplus_integ hfplus_nonneg hgplus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * (g ⊔ fun x => 0)) I","name":["hfplusgplus"],"isProp":true,"id":["_uniq",790819]},{"value":"integ_of_mul_nonneg hfplus_integ hgminus_integ hfplus_nonneg hgminus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * gminus) I","name":["hfplusgminus"],"isProp":true,"id":["_uniq",790836]},{"value":"integ_of_mul_nonneg hfminus_integ hgplus_integ hfminus_nonneg hgplus_nonneg","type":"IntegrableOn (fminus * (g ⊔ fun x => 0)) I","name":["hfminusgplus"],"isProp":true,"id":["_uniq",790853]},{"value":"integ_of_mul_nonneg hfminus_integ hgminus_integ hfminus_nonneg hgminus_nonneg","type":"IntegrableOn (fminus * gminus) I","name":["hfminusgminus"],"isProp":true,"id":["_uniq",790866]}]}],"start":14879},{"state":[{"type":"IntegrableOn ((fplus - fminus) * (gplus - gminus)) I","tag":[],"mvarId":["_uniq",804036],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gminus 0 I","name":["hgminus_nonneg"],"isProp":true,"id":["_uniq",783858]},{"value":"integ_of_mul_nonneg hfplus_integ hgplus_integ hfplus_nonneg hgplus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * (g ⊔ fun x => 0)) I","name":["hfplusgplus"],"isProp":true,"id":["_uniq",790819]},{"value":"integ_of_mul_nonneg hfplus_integ hgminus_integ hfplus_nonneg hgminus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * gminus) I","name":["hfplusgminus"],"isProp":true,"id":["_uniq",790836]},{"value":"integ_of_mul_nonneg hfminus_integ hgplus_integ hfminus_nonneg hgplus_nonneg","type":"IntegrableOn (fminus * (g ⊔ fun x => 0)) I","name":["hfminusgplus"],"isProp":true,"id":["_uniq",790853]},{"value":"integ_of_mul_nonneg hfminus_integ hgminus_integ hfminus_nonneg hgminus_nonneg","type":"IntegrableOn (fminus * gminus) I","name":["hfminusgminus"],"isProp":true,"id":["_uniq",790866]}]}],"start":14939},{"state":[{"type":"IntegrableOn (fplus * gplus + (-(fplus * gminus) - fminus * gplus) + fminus * gminus) I","tag":[],"mvarId":["_uniq",818490],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",704333],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",704334],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["g"],"isProp":false,"id":["_uniq",704335],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",704336],"binderInfo":"default"},{"type":"IntegrableOn g I","name":["hg"],"isProp":true,"id":["_uniq",704337],"binderInfo":"default"},{"value":"f ⊔ fun x => 0","type":"ℝ → ℝ","name":["fplus"],"isProp":false,"id":["_uniq",704397]},{"value":"-(f ⊓ fun x => 0)","type":"ℝ → ℝ","name":["fminus"],"isProp":false,"id":["_uniq",704548]},{"value":"g ⊔ fun x => 0","type":"ℝ → ℝ","name":["gplus"],"isProp":false,"id":["_uniq",704647]},{"value":"-(g ⊓ fun x => 0)","type":"ℝ → ℝ","name":["gminus"],"isProp":false,"id":["_uniq",704759]},{"value":"(IntegrableOn.const 0 I).left","type":"IntegrableOn (fun x => 0) I","name":["this"],"isProp":true,"id":["_uniq",704873]},{"type":"IntegrableOn (f ⊔ fun x => 0) I","name":["hfplus_integ"],"isProp":true,"id":["_uniq",758712],"binderInfo":"default"},{"type":"IntegrableOn (g ⊔ fun x => 0) I","name":["hgplus_integ"],"isProp":true,"id":["_uniq",760422],"binderInfo":"default"},{"value":"(IntegrableOn.neg (IntegrableOn.min hf this)).left","type":"IntegrableOn fminus I","name":["hfminus_integ"],"isProp":true,"id":["_uniq",760522]},{"value":"(IntegrableOn.neg (IntegrableOn.min hg this)).left","type":"IntegrableOn gminus I","name":["hgminus_integ"],"isProp":true,"id":["_uniq",760569]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fplus 0 I","name":["hfplus_nonneg"],"isProp":true,"id":["_uniq",760620]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn fminus 0 I","name":["hfminus_nonneg"],"isProp":true,"id":["_uniq",768764]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) le_sup_right._simp_1) (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gplus 0 I","name":["hgplus_nonneg"],"isProp":true,"id":["_uniq",775713]},{"value":"fun x =>\n  of_eq_true\n    (Eq.trans (implies_congr (Eq.refl (x ∈ (↑I : Set ℝ))) (Eq.trans Left.one_le_inv_iff._simp_4 inf_le_right._simp_1))\n      (implies_true (x ∈ (↑I : Set ℝ))))","type":"MajorizesOn gminus 0 I","name":["hgminus_nonneg"],"isProp":true,"id":["_uniq",783858]},{"value":"integ_of_mul_nonneg hfplus_integ hgplus_integ hfplus_nonneg hgplus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * (g ⊔ fun x => 0)) I","name":["hfplusgplus"],"isProp":true,"id":["_uniq",790819]},{"value":"integ_of_mul_nonneg hfplus_integ hgminus_integ hfplus_nonneg hgminus_nonneg","type":"IntegrableOn ((f ⊔ fun x => 0) * gminus) I","name":["hfplusgminus"],"isProp":true,"id":["_uniq",790836]},{"value":"integ_of_mul_nonneg hfminus_integ hgplus_integ hfminus_nonneg hgplus_nonneg","type":"IntegrableOn (fminus * (g ⊔ fun x => 0)) I","name":["hfminusgplus"],"isProp":true,"id":["_uniq",790853]},{"value":"integ_of_mul_nonneg hfminus_integ hgminus_integ hfminus_nonneg hgminus_nonneg","type":"IntegrableOn (fminus * gminus) I","name":["hfminusgminus"],"isProp":true,"id":["_uniq",790866]}]}],"start":14949},{"state":[],"start":15039},{"state":[],"start":15060},{"state":[],"start":15061},{"state":[],"start":15084},{"state":[],"start":15191},{"state":[{"type":"integ f I = ∑ J ∈ P.intervals, integ f J","tag":[],"mvarId":["_uniq",818797],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",818793],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",818794],"binderInfo":"implicit"},{"type":"IntegrableOn f I","name":["hf"],"isProp":true,"id":["_uniq",818795],"binderInfo":"default"},{"type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",818796],"binderInfo":"default"}]}],"start":15244},{"state":[],"start":15254},{"state":[],"start":15255},{"state":[],"start":15269},{"state":[],"start":15269}]
