[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":50},{"state":[],"start":79},{"state":[],"start":80},{"state":[],"start":84},{"state":[],"start":156},{"state":[],"start":157},{"state":[],"start":253},{"state":[],"start":341},{"state":[],"start":436},{"state":[],"start":529},{"state":[],"start":539},{"state":[],"start":540},{"state":[],"start":588},{"state":[],"start":635},{"state":[],"start":636},{"state":[],"start":639},{"state":[],"start":640},{"state":[],"start":660},{"state":[],"start":690},{"state":[],"start":691},{"state":[],"start":726},{"state":[],"start":752},{"state":[],"start":835},{"state":[{"type":"IntegrableOn f (Icc a b)","tag":[],"mvarId":["_uniq",223],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"MonotoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",222],"binderInfo":"default"}]}],"start":868},{"state":[{"type":"IntegrableOn f (Icc a b)","tag":[],"mvarId":["_uniq",223],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"MonotoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",222],"binderInfo":"default"}]}],"start":936},{"state":[{"type":"IntegrableOn f (Icc a b)","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",341],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"MonotoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",222],"binderInfo":"default"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"}]},{"type":"IntegrableOn f (Icc a b)","tag":["neg","_@","_hyg",41],"mvarId":["_uniq",348],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"MonotoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",222],"binderInfo":"default"},{"type":"¬0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",347],"binderInfo":"default"}]}],"start":961},{"state":[{"type":"IntegrableOn f (Icc a b)","tag":["neg","_@","_hyg",41],"mvarId":["_uniq",348],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"MonotoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",222],"binderInfo":"default"},{"type":"¬0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",347],"binderInfo":"default"}]},{"type":"IntegrableOn f (Icc a b)","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",341],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"MonotoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",222],"binderInfo":"default"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"}]}],"start":968},{"state":[{"type":"IntegrableOn f (Icc a b)","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",341],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"MonotoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",222],"binderInfo":"default"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"}]}],"start":1061},{"state":[{"type":"IntegrableOn f (Icc a b)","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",4698],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"MonotoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",222],"binderInfo":"default"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone hf","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]}]}],"start":1099},{"state":[{"type":"IntegrableOn f I","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",4769],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"}]}],"start":1118},{"state":[{"type":"IntegrableOn f I","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",4805],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]}]}],"start":1155},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",5523],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"}]}],"start":1263},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",5662],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"}]}],"start":1306},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",5710],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]}]}],"start":1380},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",10037],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]}]}],"start":1402},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",10242],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]}]}],"start":1444},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",12902],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]}]}],"start":1501},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",31846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]}]}],"start":1542},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",31846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]}]}],"start":1589},{"state":[],"start":1660},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",31846],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]}]}],"start":1666},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",227618],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]}]}],"start":1695},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",227618],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]}]}],"start":1751},{"state":[{"type":"∀ x ∈ I, ∃! J, J ∈ insert (Icc b b) (Finset.map e (Finset.range N)) ∧ x ∈ J","tag":[],"mvarId":["_uniq",32129],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]}]}],"start":1777},{"state":[{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["pos","_@","_hyg",1132],"mvarId":["_uniq",35681],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"x = b","name":["hb"],"isProp":true,"id":["_uniq",35680],"binderInfo":"default"}]},{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["neg","_@","_hyg",1132],"mvarId":["_uniq",35688],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"}]}],"start":1822},{"state":[{"type":"(Icc b b = Icc b b ∨ ∃ a < N, e a = Icc b b) ∧ x ∈ Icc b b","tag":["pos","h₁","_@","_hyg",1132],"mvarId":["_uniq",35700],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"x = b","name":["hb"],"isProp":true,"id":["_uniq",35680],"binderInfo":"default"}]},{"type":"∀ (y : BoundedInterval), (y = Icc b b ∨ ∃ a < N, e a = y) ∧ x ∈ y → y = Icc b b","tag":["pos","h₂","_@","_hyg",1132],"mvarId":["_uniq",35701],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"x = b","name":["hb"],"isProp":true,"id":["_uniq",35680],"binderInfo":"default"}]}],"start":1867},{"state":[{"type":"∀ (y : BoundedInterval), (y = Icc b b ∨ ∃ a < N, e a = y) ∧ x ∈ y → y = Icc b b","tag":["pos","h₂","_@","_hyg",1132],"mvarId":["_uniq",35701],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"x = b","name":["hb"],"isProp":true,"id":["_uniq",35680],"binderInfo":"default"}]}],"start":1898},{"state":[{"type":"e j = Icc b b","tag":["pos","h₂","intro","inr","intro","intro","_@","_hyg",1132],"mvarId":["_uniq",36820],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"x = b","name":["hb"],"isProp":true,"id":["_uniq",35680],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",36789],"binderInfo":"default"},{"type":"j < N","name":["hA"],"isProp":true,"id":["_uniq",36807],"binderInfo":"default"},{"type":"x ∈ e j","name":["hJb"],"isProp":true,"id":["_uniq",36819],"binderInfo":"default"}]}],"start":1960},{"state":[{"type":"e j = Icc b b","tag":["pos","h₂","intro","inr","intro","intro","_@","_hyg",1132],"mvarId":["_uniq",59663],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"x = b","name":["hb"],"isProp":true,"id":["_uniq",35680],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",36789],"binderInfo":"default"},{"type":"j < N","name":["hA"],"isProp":true,"id":["_uniq",36807],"binderInfo":"default"},{"type":"δ * (↑j : ℝ) ≤ δ * (↑N : ℝ) ∧ δ * (↑N : ℝ) < δ * ((↑j : ℝ) + 1)","name":["hJb"],"isProp":true,"id":["_uniq",59660],"binderInfo":"default"}]}],"start":2005},{"state":[{"type":"e j = Icc b b","tag":["pos","h₂","intro","inr","intro","intro","_@","_hyg",1132],"mvarId":["_uniq",59674],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"x = b","name":["hb"],"isProp":true,"id":["_uniq",35680],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",36789],"binderInfo":"default"},{"type":"j < N","name":["hA"],"isProp":true,"id":["_uniq",36807],"binderInfo":"default"},{"type":"δ * (↑N : ℝ) < δ * ((↑j : ℝ) + 1)","name":["hJb"],"isProp":true,"id":["_uniq",59670]}]}],"start":2036},{"state":[{"type":"e j = Icc b b","tag":["pos","h₂","intro","inr","intro","intro","_@","_hyg",1132],"mvarId":["_uniq",59997],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"x = b","name":["hb"],"isProp":true,"id":["_uniq",35680],"binderInfo":"default"},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",36789],"binderInfo":"default"},{"type":"j < N","name":["hA"],"isProp":true,"id":["_uniq",36807],"binderInfo":"default"},{"type":"(↑N : ℝ) < (↑j : ℝ) + 1","name":["hJb"],"isProp":true,"id":["_uniq",59994],"binderInfo":"default"}]}],"start":2092},{"state":[{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["neg","_@","_hyg",1132],"mvarId":["_uniq",35688],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"x ∈ I","name":["hx"],"isProp":true,"id":["_uniq",32151],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"}]}],"start":2129},{"state":[{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["neg","_@","_hyg",1132],"mvarId":["_uniq",66523],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"}]}],"start":2161},{"state":[{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["neg","_@","_hyg",1132],"mvarId":["_uniq",66820],"isProp":false,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]}]}],"start":2198},{"state":[{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["neg","_@","_hyg",1132],"mvarId":["_uniq",67105],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]}]}],"start":2242},{"state":[{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["neg","_@","_hyg",1132],"mvarId":["_uniq",68949],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]}]}],"start":2295},{"state":[{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["neg","_@","_hyg",1132],"mvarId":["_uniq",77400],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]}]}],"start":2332},{"state":[{"type":"x ∈ e j","tag":[],"mvarId":["_uniq",79883],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]}]}],"start":2367},{"state":[{"type":"a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ) ≤ x","tag":["refine_1"],"mvarId":["_uniq",95793],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]}]},{"type":"x < a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1)","tag":["refine_2"],"mvarId":["_uniq",95794],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]}]}],"start":2410},{"state":[{"type":"a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ) ≤ x","tag":["refine_1"],"mvarId":["_uniq",95793],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]}]}],"start":2427},{"state":[],"start":2502},{"state":[{"type":"x < a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1)","tag":["refine_2"],"mvarId":["_uniq",95794],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]}]}],"start":2534},{"state":[{"type":"x < a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1)","tag":["refine_2"],"mvarId":["_uniq",95794],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]}]}],"start":2549},{"state":[],"start":2602},{"state":[{"type":"∃! J, (J = Icc b b ∨ ∃ a < N, e a = J) ∧ x ∈ J","tag":["neg","_@","_hyg",1132],"mvarId":["_uniq",79885],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"value":"Eq.mpr\n  (id\n    (Eq.trans (integ_of_monotone._simp_2 (Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))) x)\n      (Eq.trans\n        (congrArg (fun x_1 => x ∈ x_1) (set_Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))))\n        Set.mem_Ico._simp_1)))\n  ⟨Trans.trans\n      (add_le_add_left\n        (mul_le_mul_of_nonneg_left\n          (integ_of_monotone._proof_3 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb)\n          (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))\n        a)\n      (integ_of_monotone._proof_4 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb),\n    Trans.trans\n      (of_eq_true\n        (Eq.trans\n          (congrArg (Eq x)\n            (Eq.trans\n              (congrArg (HAdd.hAdd a)\n                (Eq.trans (mul_div_assoc' δ (x - a) δ)\n                  (mul_div_cancel_left₀ (x - a) (ne_of_gt (div_pos hab (Nat.cast_pos'.mpr hNpos))))))\n              (add_sub_cancel a x)))\n          (eq_self x)))\n      (add_lt_add_left\n        (mul_lt_mul_of_pos_left (Nat.lt_floor_add_one ((x - a) / δ)) (div_pos hab (Nat.cast_pos'.mpr hNpos))) a)⟩","type":"x ∈ e j","name":["hxj"],"isProp":true,"id":["_uniq",79884]}]}],"start":2661},{"state":[{"type":"(e j = Icc b b ∨ ∃ a < N, e a = e j) ∧ x ∈ e j","tag":["neg","h₁","_@","_hyg",1132],"mvarId":["_uniq",127896],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"value":"Eq.mpr\n  (id\n    (Eq.trans (integ_of_monotone._simp_2 (Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))) x)\n      (Eq.trans\n        (congrArg (fun x_1 => x ∈ x_1) (set_Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))))\n        Set.mem_Ico._simp_1)))\n  ⟨Trans.trans\n      (add_le_add_left\n        (mul_le_mul_of_nonneg_left\n          (integ_of_monotone._proof_3 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb)\n          (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))\n        a)\n      (integ_of_monotone._proof_4 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb),\n    Trans.trans\n      (of_eq_true\n        (Eq.trans\n          (congrArg (Eq x)\n            (Eq.trans\n              (congrArg (HAdd.hAdd a)\n                (Eq.trans (mul_div_assoc' δ (x - a) δ)\n                  (mul_div_cancel_left₀ (x - a) (ne_of_gt (div_pos hab (Nat.cast_pos'.mpr hNpos))))))\n              (add_sub_cancel a x)))\n          (eq_self x)))\n      (add_lt_add_left\n        (mul_lt_mul_of_pos_left (Nat.lt_floor_add_one ((x - a) / δ)) (div_pos hab (Nat.cast_pos'.mpr hNpos))) a)⟩","type":"x ∈ e j","name":["hxj"],"isProp":true,"id":["_uniq",79884]}]},{"type":"∀ (y : BoundedInterval), (y = Icc b b ∨ ∃ a < N, e a = y) ∧ x ∈ y → y = e j","tag":["neg","h₂","_@","_hyg",1132],"mvarId":["_uniq",127897],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"value":"Eq.mpr\n  (id\n    (Eq.trans (integ_of_monotone._simp_2 (Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))) x)\n      (Eq.trans\n        (congrArg (fun x_1 => x ∈ x_1) (set_Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))))\n        Set.mem_Ico._simp_1)))\n  ⟨Trans.trans\n      (add_le_add_left\n        (mul_le_mul_of_nonneg_left\n          (integ_of_monotone._proof_3 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb)\n          (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))\n        a)\n      (integ_of_monotone._proof_4 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb),\n    Trans.trans\n      (of_eq_true\n        (Eq.trans\n          (congrArg (Eq x)\n            (Eq.trans\n              (congrArg (HAdd.hAdd a)\n                (Eq.trans (mul_div_assoc' δ (x - a) δ)\n                  (mul_div_cancel_left₀ (x - a) (ne_of_gt (div_pos hab (Nat.cast_pos'.mpr hNpos))))))\n              (add_sub_cancel a x)))\n          (eq_self x)))\n      (add_lt_add_left\n        (mul_lt_mul_of_pos_left (Nat.lt_floor_add_one ((x - a) / δ)) (div_pos hab (Nat.cast_pos'.mpr hNpos))) a)⟩","type":"x ∈ e j","name":["hxj"],"isProp":true,"id":["_uniq",79884]}]}],"start":2700},{"state":[{"type":"∀ (y : BoundedInterval), (y = Icc b b ∨ ∃ a < N, e a = y) ∧ x ∈ y → y = e j","tag":["neg","h₂","_@","_hyg",1132],"mvarId":["_uniq",127897],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"value":"Eq.mpr\n  (id\n    (Eq.trans (integ_of_monotone._simp_2 (Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))) x)\n      (Eq.trans\n        (congrArg (fun x_1 => x ∈ x_1) (set_Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))))\n        Set.mem_Ico._simp_1)))\n  ⟨Trans.trans\n      (add_le_add_left\n        (mul_le_mul_of_nonneg_left\n          (integ_of_monotone._proof_3 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb)\n          (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))\n        a)\n      (integ_of_monotone._proof_4 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb),\n    Trans.trans\n      (of_eq_true\n        (Eq.trans\n          (congrArg (Eq x)\n            (Eq.trans\n              (congrArg (HAdd.hAdd a)\n                (Eq.trans (mul_div_assoc' δ (x - a) δ)\n                  (mul_div_cancel_left₀ (x - a) (ne_of_gt (div_pos hab (Nat.cast_pos'.mpr hNpos))))))\n              (add_sub_cancel a x)))\n          (eq_self x)))\n      (add_lt_add_left\n        (mul_lt_mul_of_pos_left (Nat.lt_floor_add_one ((x - a) / δ)) (div_pos hab (Nat.cast_pos'.mpr hNpos))) a)⟩","type":"x ∈ e j","name":["hxj"],"isProp":true,"id":["_uniq",79884]}]}],"start":2810},{"state":[{"type":"Icc b b = e j","tag":["neg","h₂","intro","inl","_@","_hyg",1132],"mvarId":["_uniq",133242],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"value":"Eq.mpr\n  (id\n    (Eq.trans (integ_of_monotone._simp_2 (Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))) x)\n      (Eq.trans\n        (congrArg (fun x_1 => x ∈ x_1) (set_Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))))\n        Set.mem_Ico._simp_1)))\n  ⟨Trans.trans\n      (add_le_add_left\n        (mul_le_mul_of_nonneg_left\n          (integ_of_monotone._proof_3 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb)\n          (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))\n        a)\n      (integ_of_monotone._proof_4 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb),\n    Trans.trans\n      (of_eq_true\n        (Eq.trans\n          (congrArg (Eq x)\n            (Eq.trans\n              (congrArg (HAdd.hAdd a)\n                (Eq.trans (mul_div_assoc' δ (x - a) δ)\n                  (mul_div_cancel_left₀ (x - a) (ne_of_gt (div_pos hab (Nat.cast_pos'.mpr hNpos))))))\n              (add_sub_cancel a x)))\n          (eq_self x)))\n      (add_lt_add_left\n        (mul_lt_mul_of_pos_left (Nat.lt_floor_add_one ((x - a) / δ)) (div_pos hab (Nat.cast_pos'.mpr hNpos))) a)⟩","type":"x ∈ e j","name":["hxj"],"isProp":true,"id":["_uniq",79884]},{"type":"x ∈ Icc b b","name":["hxJ"],"isProp":true,"id":["_uniq",133241],"binderInfo":"default"}]},{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","_@","_hyg",1132],"mvarId":["_uniq",133294],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"value":"Eq.mpr\n  (id\n    (Eq.trans (integ_of_monotone._simp_2 (Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))) x)\n      (Eq.trans\n        (congrArg (fun x_1 => x ∈ x_1) (set_Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))))\n        Set.mem_Ico._simp_1)))\n  ⟨Trans.trans\n      (add_le_add_left\n        (mul_le_mul_of_nonneg_left\n          (integ_of_monotone._proof_3 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb)\n          (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))\n        a)\n      (integ_of_monotone._proof_4 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb),\n    Trans.trans\n      (of_eq_true\n        (Eq.trans\n          (congrArg (Eq x)\n            (Eq.trans\n              (congrArg (HAdd.hAdd a)\n                (Eq.trans (mul_div_assoc' δ (x - a) δ)\n                  (mul_div_cancel_left₀ (x - a) (ne_of_gt (div_pos hab (Nat.cast_pos'.mpr hNpos))))))\n              (add_sub_cancel a x)))\n          (eq_self x)))\n      (add_lt_add_left\n        (mul_lt_mul_of_pos_left (Nat.lt_floor_add_one ((x - a) / δ)) (div_pos hab (Nat.cast_pos'.mpr hNpos))) a)⟩","type":"x ∈ e j","name":["hxj"],"isProp":true,"id":["_uniq",79884]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"x ∈ e k","name":["hxJ"],"isProp":true,"id":["_uniq",133293],"binderInfo":"default"}]}],"start":2865},{"state":[{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","_@","_hyg",1132],"mvarId":["_uniq",133294],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"value":"Eq.mpr\n  (id\n    (Eq.trans (integ_of_monotone._simp_2 (Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))) x)\n      (Eq.trans\n        (congrArg (fun x_1 => x ∈ x_1) (set_Ico (a + δ * (↑⌊(x - a) / δ⌋₊ : ℝ)) (a + δ * ((↑⌊(x - a) / δ⌋₊ : ℝ) + 1))))\n        Set.mem_Ico._simp_1)))\n  ⟨Trans.trans\n      (add_le_add_left\n        (mul_le_mul_of_nonneg_left\n          (integ_of_monotone._proof_3 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb)\n          (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))\n        a)\n      (integ_of_monotone._proof_4 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ hxb),\n    Trans.trans\n      (of_eq_true\n        (Eq.trans\n          (congrArg (Eq x)\n            (Eq.trans\n              (congrArg (HAdd.hAdd a)\n                (Eq.trans (mul_div_assoc' δ (x - a) δ)\n                  (mul_div_cancel_left₀ (x - a) (ne_of_gt (div_pos hab (Nat.cast_pos'.mpr hNpos))))))\n              (add_sub_cancel a x)))\n          (eq_self x)))\n      (add_lt_add_left\n        (mul_lt_mul_of_pos_left (Nat.lt_floor_add_one ((x - a) / δ)) (div_pos hab (Nat.cast_pos'.mpr hNpos))) a)⟩","type":"x ∈ e j","name":["hxj"],"isProp":true,"id":["_uniq",79884]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"x ∈ e k","name":["hxJ"],"isProp":true,"id":["_uniq",133293],"binderInfo":"default"}]}],"start":2904},{"state":[{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","_@","_hyg",1132],"mvarId":["_uniq",167748],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"a + δ * (↑k : ℝ) ≤ x ∧ x < a + δ * ((↑k : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167743],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"}]}],"start":2941},{"state":[{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","inl","_@","_hyg",1132],"mvarId":["_uniq",167787],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"a + δ * (↑k : ℝ) ≤ x ∧ x < a + δ * ((↑k : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167743],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"},{"type":"j < k","name":["hjk"],"isProp":true,"id":["_uniq",167786],"binderInfo":"default"}]},{"type":"e j = e j","tag":["neg","h₂","intro","inr","intro","intro","inr","inl","_@","_hyg",1132],"mvarId":["_uniq",167830],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"},{"type":"j < N","name":["hk"],"isProp":true,"id":["_uniq",167828],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167829],"binderInfo":"default"}]},{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","inr","inr","_@","_hyg",1132],"mvarId":["_uniq",167815],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"a + δ * (↑k : ℝ) ≤ x ∧ x < a + δ * ((↑k : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167743],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"},{"type":"k < j","name":["hjk"],"isProp":true,"id":["_uniq",167814],"binderInfo":"default"}]}],"start":2993},{"state":[{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","inl","_@","_hyg",1132],"mvarId":["_uniq",169343],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"a + δ * (↑k : ℝ) ≤ x ∧ x < a + δ * ((↑k : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167743],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (mul_le_mul_iff_of_pos_left hδpos))))\n  (Eq.mpr\n    (id\n      (Eq.trans (congrArg (fun x => (↑j : ℝ) + x ≤ (↑k : ℝ)) (Eq.symm Nat.cast_one))\n        (Eq.trans (congrArg (fun x => x ≤ (↑k : ℝ)) (Nat.cast_add._simp_1 j 1)) Nat.cast_le._simp_1)))\n    _fvar.167786)","type":"δ * ((↑j : ℝ) + 1) ≤ δ * (↑k : ℝ)","name":["hjk"],"isProp":true,"id":["_uniq",168077]}]}],"start":3103},{"state":[{"type":"e j = e j","tag":["neg","h₂","intro","inr","intro","intro","inr","inl","_@","_hyg",1132],"mvarId":["_uniq",167830],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"},{"type":"j < N","name":["hk"],"isProp":true,"id":["_uniq",167828],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167829],"binderInfo":"default"}]},{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","inr","inr","_@","_hyg",1132],"mvarId":["_uniq",167815],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"a + δ * (↑k : ℝ) ≤ x ∧ x < a + δ * ((↑k : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167743],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"},{"type":"k < j","name":["hjk"],"isProp":true,"id":["_uniq",167814],"binderInfo":"default"}]}],"start":3122},{"state":[{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","inr","inr","_@","_hyg",1132],"mvarId":["_uniq",167815],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"a + δ * (↑k : ℝ) ≤ x ∧ x < a + δ * ((↑k : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167743],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"},{"type":"k < j","name":["hjk"],"isProp":true,"id":["_uniq",167814],"binderInfo":"default"}]}],"start":3136},{"state":[{"type":"e k = e j","tag":["neg","h₂","intro","inr","intro","intro","inr","inr","_@","_hyg",1132],"mvarId":["_uniq",173729],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",32148],"binderInfo":"default"},{"type":"¬x = b","name":["hb"],"isProp":true,"id":["_uniq",35687],"binderInfo":"default"},{"type":"a ≤ x ∧ x ≤ b","name":["hx"],"isProp":true,"id":["_uniq",66520],"binderInfo":"default"},{"value":"⌊(x - a) / δ⌋₊","type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",66819]},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf a) (Mathlib.Tactic.Ring.atom_pf x)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul x (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (a ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (x ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf x) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero\n                  (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (x ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero x (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_lt_of_le_of_neg (Mathlib.Tactic.Linarith.sub_nonpos_of_le hx.left)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"0 ≤ x - a","name":["hxa"],"isProp":true,"id":["_uniq",67104]},{"value":"Mathlib.Meta.Positivity.div_nonneg_of_nonneg_of_pos✝ hxa (div_pos hab (Nat.cast_pos'.mpr hNpos))","type":"0 ≤ (x - a) / δ","name":["hxaδ"],"isProp":true,"id":["_uniq",68948]},{"value":"integ_of_monotone._proof_2 hbound hf hab' ε hε N hN hNpos hδpos hbeq x hb hx hxa hxaδ","type":"x < b","name":["hxb"],"isProp":true,"id":["_uniq",77399]},{"type":"ℕ","name":["k"],"isProp":false,"id":["_uniq",133263],"binderInfo":"default"},{"type":"k < N","name":["hk"],"isProp":true,"id":["_uniq",133281],"binderInfo":"default"},{"type":"a + δ * (↑k : ℝ) ≤ x ∧ x < a + δ * ((↑k : ℝ) + 1)","name":["hxJ"],"isProp":true,"id":["_uniq",167743],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x ∧ x < a + δ * ((↑j : ℝ) + 1)","name":["hxj"],"isProp":true,"id":["_uniq",167744],"binderInfo":"default"},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (mul_le_mul_iff_of_pos_left hδpos))))\n  (Eq.mpr\n    (id\n      (Eq.trans (congrArg (fun x => (↑k : ℝ) + x ≤ (↑j : ℝ)) (Eq.symm Nat.cast_one))\n        (Eq.trans (congrArg (fun x => x ≤ (↑j : ℝ)) (Nat.cast_add._simp_1 k 1)) Nat.cast_le._simp_1)))\n    _fvar.167814)","type":"δ * ((↑k : ℝ) + 1) ≤ δ * (↑j : ℝ)","name":["hjk"],"isProp":true,"id":["_uniq",172714]}]}],"start":3244},{"state":[],"start":3261},{"state":[{"type":"J ⊆ I","tag":[],"mvarId":["_uniq",32142],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"BoundedInterval","name":["J"],"isProp":false,"id":["_uniq",32138],"binderInfo":"default"},{"type":"J ∈ insert (Icc b b) (Finset.map e (Finset.range N))","name":["hJ"],"isProp":true,"id":["_uniq",32141],"binderInfo":"default"}]}],"start":3287},{"state":[{"type":"a ≤ b","tag":["inl"],"mvarId":["_uniq",181423],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]}]},{"type":"Set.Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)) ⊆ Set.Icc a b","tag":["inr","intro","intro"],"mvarId":["_uniq",197355],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",179496],"binderInfo":"default"},{"type":"j < N","name":["hj"],"isProp":true,"id":["_uniq",179518],"binderInfo":"default"}]}],"start":3373},{"state":[{"type":"Set.Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)) ⊆ Set.Icc a b","tag":["inr","intro","intro"],"mvarId":["_uniq",197355],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",179496],"binderInfo":"default"},{"type":"j < N","name":["hj"],"isProp":true,"id":["_uniq",179518],"binderInfo":"default"}]}],"start":3392},{"state":[{"type":"a ≤ a + δ * (↑j : ℝ)","tag":[],"mvarId":["_uniq",199081],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",179496],"binderInfo":"default"},{"type":"j < N","name":["hj"],"isProp":true,"id":["_uniq",179518],"binderInfo":"default"}]},{"type":"a + δ * ((↑j : ℝ) + 1) ≤ b","tag":[],"mvarId":["_uniq",199082],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",179496],"binderInfo":"default"},{"type":"j < N","name":["hj"],"isProp":true,"id":["_uniq",179518],"binderInfo":"default"}]}],"start":3461},{"state":[{"type":"a + δ * ((↑j : ℝ) + 1) ≤ b","tag":[],"mvarId":["_uniq",199082],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",179496],"binderInfo":"default"},{"type":"j < N","name":["hj"],"isProp":true,"id":["_uniq",179518],"binderInfo":"default"}]}],"start":3488},{"state":[],"start":3527},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",227618],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]}]}],"start":3533},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",229520],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]}]}],"start":3554},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",229520],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]}]}],"start":3678},{"state":[],"start":3813},{"state":[{"type":"∑ j ∈ Finset.range N,\n    sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n      (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length ≤\n  ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","tag":[],"mvarId":["_uniq",229458],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]}]}],"start":3873},{"state":[{"type":"sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n    (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length ≤\n  f (a + δ * ((↑j : ℝ) + 1)) * δ","tag":["h"],"mvarId":["_uniq",327445],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"}]}],"start":3917},{"state":[{"type":"(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length = δ","tag":["h","e'_3","h","e'_6"],"mvarId":["_uniq",328381],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"}]},{"type":"sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) ≤ f (a + δ * ((↑j : ℝ) + 1))","tag":["h","convert_3"],"mvarId":["_uniq",327695],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"}]}],"start":3966},{"state":[{"type":"sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) ≤ f (a + δ * ((↑j : ℝ) + 1))","tag":["h","convert_3"],"mvarId":["_uniq",327695],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"}]}],"start":4023},{"state":[{"type":"(f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)).Nonempty","tag":["h","convert_3","h₁"],"mvarId":["_uniq",357187],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"}]},{"type":"∀ b ∈ f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ), b ≤ f (a + δ * ((↑j : ℝ) + 1))","tag":["h","convert_3","h₂"],"mvarId":["_uniq",357188],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"}]}],"start":4046},{"state":[{"type":"∀ b ∈ f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ), b ≤ f (a + δ * ((↑j : ℝ) + 1))","tag":["h","convert_3","h₂"],"mvarId":["_uniq",357188],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"}]}],"start":4068},{"state":[{"type":"f x ≤ f (a + δ * ((↑j : ℝ) + 1))","tag":["h","convert_3","h₂","intro","intro","intro"],"mvarId":["_uniq",394159],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",394107],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x","name":["hx1"],"isProp":true,"id":["_uniq",394147],"binderInfo":"default"},{"type":"x < a + δ * ((↑j : ℝ) + 1)","name":["hx2"],"isProp":true,"id":["_uniq",394148],"binderInfo":"default"}]}],"start":4146},{"state":[{"type":"f x ≤ f (a + δ * ((↑j : ℝ) + 1))","tag":["h","convert_3","h₂","intro","intro","intro"],"mvarId":["_uniq",394402],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",394107],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x","name":["hx1"],"isProp":true,"id":["_uniq",394147],"binderInfo":"default"},{"type":"x < a + δ * ((↑j : ℝ) + 1)","name":["hx2"],"isProp":true,"id":["_uniq",394148],"binderInfo":"default"},{"value":"Eq.mpr (id (Eq.trans (congrArg (LE.le (a + δ * ((↑j : ℝ) + 1))) hbeq) (mul_le_mul_iff_left._simp_4 a)))\n  (mul_le_mul_of_nonneg_left\n    (Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => (↑j : ℝ) + x ≤ (↑N : ℝ)) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (fun x => x ≤ (↑N : ℝ)) (Nat.cast_add._simp_1 j 1)) Nat.cast_le._simp_1)))\n      (integ_of_monotone._proof_8 hab hbound hf hab' ε hε N hN hNpos hδpos hbeq j hj x hx1 hx2))\n    (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))","type":"a + δ * ((↑j : ℝ) + 1) ≤ b","name":["this"],"isProp":true,"id":["_uniq",394401]}]}],"start":4224},{"state":[{"type":"f x ≤ f (a + δ * ((↑j : ℝ) + 1))","tag":["h","convert_3","h₂","intro","intro","intro"],"mvarId":["_uniq",411838],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",394107],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x","name":["hx1"],"isProp":true,"id":["_uniq",394147],"binderInfo":"default"},{"type":"x < a + δ * ((↑j : ℝ) + 1)","name":["hx2"],"isProp":true,"id":["_uniq",394148],"binderInfo":"default"},{"value":"Eq.mpr (id (Eq.trans (congrArg (LE.le (a + δ * ((↑j : ℝ) + 1))) hbeq) (mul_le_mul_iff_left._simp_4 a)))\n  (mul_le_mul_of_nonneg_left\n    (Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => (↑j : ℝ) + x ≤ (↑N : ℝ)) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (fun x => x ≤ (↑N : ℝ)) (Nat.cast_add._simp_1 j 1)) Nat.cast_le._simp_1)))\n      (integ_of_monotone._proof_8 hab hbound hf hab' ε hε N hN hNpos hδpos hbeq j hj x hx1 hx2))\n    (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))","type":"a + δ * ((↑j : ℝ) + 1) ≤ b","name":["this"],"isProp":true,"id":["_uniq",394401]},{"value":"mul_nonneg (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))) (Nat.cast_nonneg' j)","type":"0 ≤ δ * (↑j : ℝ)","name":["hδj"],"isProp":true,"id":["_uniq",411837]}]}],"start":4272},{"state":[{"type":"f x ≤ f (a + δ * ((↑j : ℝ) + 1))","tag":["h","convert_3","h₂","intro","intro","intro"],"mvarId":["_uniq",423617],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",327441],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",327444],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",394107],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x","name":["hx1"],"isProp":true,"id":["_uniq",394147],"binderInfo":"default"},{"type":"x < a + δ * ((↑j : ℝ) + 1)","name":["hx2"],"isProp":true,"id":["_uniq",394148],"binderInfo":"default"},{"value":"Eq.mpr (id (Eq.trans (congrArg (LE.le (a + δ * ((↑j : ℝ) + 1))) hbeq) (mul_le_mul_iff_left._simp_4 a)))\n  (mul_le_mul_of_nonneg_left\n    (Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => (↑j : ℝ) + x ≤ (↑N : ℝ)) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (fun x => x ≤ (↑N : ℝ)) (Nat.cast_add._simp_1 j 1)) Nat.cast_le._simp_1)))\n      (integ_of_monotone._proof_8 hab hbound hf hab' ε hε N hN hNpos hδpos hbeq j hj x hx1 hx2))\n    (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))","type":"a + δ * ((↑j : ℝ) + 1) ≤ b","name":["this"],"isProp":true,"id":["_uniq",394401]},{"value":"mul_nonneg (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))) (Nat.cast_nonneg' j)","type":"0 ≤ δ * (↑j : ℝ)","name":["hδj"],"isProp":true,"id":["_uniq",411837]},{"value":"le_of_lt\n  (mul_pos (div_pos hab (Nat.cast_pos'.mpr hNpos))\n    (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))","type":"0 ≤ δ * ((↑j : ℝ) + 1)","name":["hδj1"],"isProp":true,"id":["_uniq",423616]}]}],"start":4325},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",229520],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]}]}],"start":4390},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",446491],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]}]}],"start":4413},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",446491],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]}]}],"start":4503},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",446491],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]}]}],"start":4545},{"state":[],"start":4680},{"state":[{"type":"∑ j ∈ Finset.range N,\n    sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n      (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length ≥\n  ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","tag":[],"mvarId":["_uniq",446405],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]}]}],"start":4736},{"state":[{"type":"f (a + δ * (↑j : ℝ)) * δ ≤\n  sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n    (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length","tag":["h"],"mvarId":["_uniq",544454],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"}]}],"start":4780},{"state":[{"type":"(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length = δ","tag":["h","e'_4","h","e'_6"],"mvarId":["_uniq",545412],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"}]},{"type":"f (a + δ * (↑j : ℝ)) ≤ sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ))","tag":["h","convert_3"],"mvarId":["_uniq",544704],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"}]}],"start":4829},{"state":[{"type":"f (a + δ * (↑j : ℝ)) ≤ sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ))","tag":["h","convert_3"],"mvarId":["_uniq",544704],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"}]}],"start":4886},{"state":[{"type":"(f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)).Nonempty","tag":["h","convert_3","h₁"],"mvarId":["_uniq",574196],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"}]},{"type":"∀ b ∈ f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ), f (a + δ * (↑j : ℝ)) ≤ b","tag":["h","convert_3","h₂"],"mvarId":["_uniq",574197],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"}]}],"start":4909},{"state":[{"type":"∀ b ∈ f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ), f (a + δ * (↑j : ℝ)) ≤ b","tag":["h","convert_3","h₂"],"mvarId":["_uniq",574197],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"}]}],"start":4931},{"state":[{"type":"f (a + δ * (↑j : ℝ)) ≤ f x","tag":["h","convert_3","h₂","intro","intro","intro"],"mvarId":["_uniq",613917],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",613865],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x","name":["hx1"],"isProp":true,"id":["_uniq",613905],"binderInfo":"default"},{"type":"x < a + δ * ((↑j : ℝ) + 1)","name":["hx2"],"isProp":true,"id":["_uniq",613906],"binderInfo":"default"}]}],"start":5009},{"state":[{"type":"f (a + δ * (↑j : ℝ)) ≤ f x","tag":["h","convert_3","h₂","intro","intro","intro"],"mvarId":["_uniq",614160],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",613865],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x","name":["hx1"],"isProp":true,"id":["_uniq",613905],"binderInfo":"default"},{"type":"x < a + δ * ((↑j : ℝ) + 1)","name":["hx2"],"isProp":true,"id":["_uniq",613906],"binderInfo":"default"},{"value":"Eq.mpr (id (Eq.trans (congrArg (LE.le (a + δ * ((↑j : ℝ) + 1))) hbeq) (mul_le_mul_iff_left._simp_4 a)))\n  (mul_le_mul_of_nonneg_left\n    (Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => (↑j : ℝ) + x ≤ (↑N : ℝ)) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (fun x => x ≤ (↑N : ℝ)) (Nat.cast_add._simp_1 j 1)) Nat.cast_le._simp_1)))\n      (integ_of_monotone._proof_11 hab hbound hf hab' ε hε N hN hNpos hδpos hbeq hup j hj x hx1 hx2))\n    (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))","type":"a + δ * ((↑j : ℝ) + 1) ≤ b","name":["hajb'"],"isProp":true,"id":["_uniq",614159]}]}],"start":5092},{"state":[{"type":"f (a + δ * (↑j : ℝ)) ≤ f x","tag":["h","convert_3","h₂","intro","intro","intro"],"mvarId":["_uniq",634552],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",613865],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x","name":["hx1"],"isProp":true,"id":["_uniq",613905],"binderInfo":"default"},{"type":"x < a + δ * ((↑j : ℝ) + 1)","name":["hx2"],"isProp":true,"id":["_uniq",613906],"binderInfo":"default"},{"value":"Eq.mpr (id (Eq.trans (congrArg (LE.le (a + δ * ((↑j : ℝ) + 1))) hbeq) (mul_le_mul_iff_left._simp_4 a)))\n  (mul_le_mul_of_nonneg_left\n    (Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => (↑j : ℝ) + x ≤ (↑N : ℝ)) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (fun x => x ≤ (↑N : ℝ)) (Nat.cast_add._simp_1 j 1)) Nat.cast_le._simp_1)))\n      (integ_of_monotone._proof_11 hab hbound hf hab' ε hε N hN hNpos hδpos hbeq hup j hj x hx1 hx2))\n    (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))","type":"a + δ * ((↑j : ℝ) + 1) ≤ b","name":["hajb'"],"isProp":true,"id":["_uniq",614159]},{"value":"mul_nonneg (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))) (Nat.cast_nonneg' j)","type":"0 ≤ δ * (↑j : ℝ)","name":["hδj"],"isProp":true,"id":["_uniq",634551]}]}],"start":5140},{"state":[{"type":"f (a + δ * (↑j : ℝ)) ≤ f x","tag":["h","convert_3","h₂","intro","intro","intro"],"mvarId":["_uniq",646577],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"type":"ℕ","name":["j"],"isProp":false,"id":["_uniq",544450],"binderInfo":"default"},{"type":"j ∈ Finset.range N","name":["hj"],"isProp":true,"id":["_uniq",544453],"binderInfo":"default"},{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",613865],"binderInfo":"default"},{"type":"a + δ * (↑j : ℝ) ≤ x","name":["hx1"],"isProp":true,"id":["_uniq",613905],"binderInfo":"default"},{"type":"x < a + δ * ((↑j : ℝ) + 1)","name":["hx2"],"isProp":true,"id":["_uniq",613906],"binderInfo":"default"},{"value":"Eq.mpr (id (Eq.trans (congrArg (LE.le (a + δ * ((↑j : ℝ) + 1))) hbeq) (mul_le_mul_iff_left._simp_4 a)))\n  (mul_le_mul_of_nonneg_left\n    (Eq.mpr\n      (id\n        (Eq.trans (congrArg (fun x => (↑j : ℝ) + x ≤ (↑N : ℝ)) (Eq.symm Nat.cast_one))\n          (Eq.trans (congrArg (fun x => x ≤ (↑N : ℝ)) (Nat.cast_add._simp_1 j 1)) Nat.cast_le._simp_1)))\n      (integ_of_monotone._proof_11 hab hbound hf hab' ε hε N hN hNpos hδpos hbeq hup j hj x hx1 hx2))\n    (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))))","type":"a + δ * ((↑j : ℝ) + 1) ≤ b","name":["hajb'"],"isProp":true,"id":["_uniq",614159]},{"value":"mul_nonneg (le_of_lt (div_pos hab (Nat.cast_pos'.mpr hNpos))) (Nat.cast_nonneg' j)","type":"0 ≤ δ * (↑j : ℝ)","name":["hδj"],"isProp":true,"id":["_uniq",634551]},{"value":"le_of_lt\n  (mul_pos (div_pos hab (Nat.cast_pos'.mpr hNpos))\n    (Right.add_pos_of_nonneg_of_pos (Nat.cast_nonneg' j)\n      (Mathlib.Meta.Positivity.pos_of_isNat (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one) (Eq.refl (Nat.ble 1 1)))))","type":"0 ≤ δ * ((↑j : ℝ) + 1)","name":["hδj1"],"isProp":true,"id":["_uniq",646576]}]}],"start":5193},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",446491],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]}]}],"start":5247},{"state":[{"type":"upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",446491],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]}]}],"start":5256},{"state":[],"start":5365},{"state":[{"type":"∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ - ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ = (f b - f a) * δ","tag":[],"mvarId":["_uniq",674168],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]}]}],"start":5398},{"state":[{"type":"∑ x ∈ Finset.range N, (f (a + δ * ((↑x : ℝ) + 1)) * δ - f (a + δ * (↑x : ℝ)) * δ) = (f b - f a) * δ","tag":[],"mvarId":["_uniq",676154],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]}]}],"start":5437},{"state":[{"type":"∑ x ∈ Finset.range N, (f (a + δ * ((↑x : ℝ) + 1)) * δ - f (a + δ * (↑x : ℝ)) * δ) = (f b - f a) * δ","tag":[],"mvarId":["_uniq",676390],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Finset.sum_range_sub (fun n => f (a + δ * (↑n : ℝ)) * δ) N","type":"∑ i ∈ Finset.range N, (f (a + δ * (↑(i + 1) : ℝ)) * δ - f (a + δ * (↑i : ℝ)) * δ) =\n  f (a + δ * (↑N : ℝ)) * δ - f (a + δ * (↑0 : ℝ)) * δ","name":["this"],"isProp":true,"id":["_uniq",676389]}]}],"start":5506},{"state":[{"type":"∑ x ∈ Finset.range N, (f (a + δ * ((↑x : ℝ) + 1)) * δ - f (a + δ * (↑x : ℝ)) * δ) = (f b - f a) * δ","tag":[],"mvarId":["_uniq",676732],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"type":"∑ x ∈ Finset.range N, (f (a + δ * ((↑x : ℝ) + 1)) * δ - f (a + δ * (↑x : ℝ)) * δ) =\n  f (a + δ * (↑N : ℝ)) * δ - f (a + δ * (↑0 : ℝ)) * δ","name":["this"],"isProp":true,"id":["_uniq",676729],"binderInfo":"default"}]}],"start":5561},{"state":[],"start":5609},{"state":[{"type":"(f b - f a) * δ ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",674243],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]}]}],"start":5629},{"state":[{"type":"(f b - f a) * δ ≤ (f b - f a) * (b - a) * ε","tag":[],"mvarId":["_uniq",678404],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Eq.mpr (id one_le_div'._simp_4)\n  (hf\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => a ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true hab')) (and_self True))))\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => b ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (eq_true hab')) (le_refl._simp_1 b)) (and_self True))))\n    hab')","type":"0 ≤ f b - f a","name":["this"],"isProp":true,"id":["_uniq",678403]}]}],"start":5700},{"state":[{"type":"(b - a) / (↑N : ℝ) ≤ (b - a) * ε","tag":["h"],"mvarId":["_uniq",693893],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Eq.mpr (id one_le_div'._simp_4)\n  (hf\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => a ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true hab')) (and_self True))))\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => b ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (eq_true hab')) (le_refl._simp_1 b)) (and_self True))))\n    hab')","type":"0 ≤ f b - f a","name":["this"],"isProp":true,"id":["_uniq",678403]}]}],"start":5737},{"state":[{"type":"b - a ≤ (b - a) * (ε * (↑N : ℝ))","tag":["h"],"mvarId":["_uniq",699924],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Eq.mpr (id one_le_div'._simp_4)\n  (hf\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => a ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true hab')) (and_self True))))\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => b ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (eq_true hab')) (le_refl._simp_1 b)) (and_self True))))\n    hab')","type":"0 ≤ f b - f a","name":["this"],"isProp":true,"id":["_uniq",678403]}]},{"type":"0 < (↑N : ℝ)","tag":["h"],"mvarId":["_uniq",699130],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Eq.mpr (id one_le_div'._simp_4)\n  (hf\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => a ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true hab')) (and_self True))))\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => b ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (eq_true hab')) (le_refl._simp_1 b)) (and_self True))))\n    hab')","type":"0 ≤ f b - f a","name":["this"],"isProp":true,"id":["_uniq",678403]}]}],"start":5786},{"state":[{"type":"(b - a) * 1 ≤ (b - a) * (ε * (↑N : ℝ))","tag":["h"],"mvarId":["_uniq",700092],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Eq.mpr (id one_le_div'._simp_4)\n  (hf\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => a ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true hab')) (and_self True))))\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => b ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (eq_true hab')) (le_refl._simp_1 b)) (and_self True))))\n    hab')","type":"0 ≤ f b - f a","name":["this"],"isProp":true,"id":["_uniq",678403]}]},{"type":"0 < (↑N : ℝ)","tag":["h"],"mvarId":["_uniq",699130],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Eq.mpr (id one_le_div'._simp_4)\n  (hf\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => a ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true hab')) (and_self True))))\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => b ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (eq_true hab')) (le_refl._simp_1 b)) (and_self True))))\n    hab')","type":"0 ≤ f b - f a","name":["this"],"isProp":true,"id":["_uniq",678403]}]}],"start":5827},{"state":[{"type":"0 < ε","tag":["h","h"],"mvarId":["_uniq",706854],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Eq.mpr (id one_le_div'._simp_4)\n  (hf\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => a ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true hab')) (and_self True))))\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => b ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (eq_true hab')) (le_refl._simp_1 b)) (and_self True))))\n    hab')","type":"0 ≤ f b - f a","name":["this"],"isProp":true,"id":["_uniq",678403]}]},{"type":"0 < (↑N : ℝ)","tag":["h"],"mvarId":["_uniq",699130],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"type":"ℝ","name":["ε"],"isProp":false,"id":["_uniq",5294],"binderInfo":"default"},{"type":"0 < ε","name":["hε"],"isProp":true,"id":["_uniq",5349],"binderInfo":"default"},{"type":"ℕ","name":["N"],"isProp":false,"id":["_uniq",5658],"binderInfo":"default"},{"type":"1 / ε < (↑N : ℝ)","name":["hN"],"isProp":true,"id":["_uniq",5661],"binderInfo":"default"},{"value":"Eq.mpr\n  (id\n    (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n      (Eq.trans\n        (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero) (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n        (Eq.trans\n          (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n            (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n          (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n  (lt_of_not_ge fun a =>\n    Mathlib.Tactic.Linarith.lt_irrefl\n      (Eq.mp\n        (congrArg (fun _a => _a < 0)\n          (Mathlib.Tactic.Ring.of_eq\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.div_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                      (Mathlib.Tactic.Ring.atom_pf ε)\n                      (Mathlib.Tactic.Ring.div_pf\n                        (Mathlib.Tactic.Ring.inv_single\n                          (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                            (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                              (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                  (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                        (Mathlib.Tactic.Ring.add_mul\n                          (Mathlib.Tactic.Ring.mul_add\n                            (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                            (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                          (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                  (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                    (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                (Mathlib.Tactic.Ring.mul_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                  (Mathlib.Tactic.Ring.div_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                    (Mathlib.Tactic.Ring.atom_pf ε)\n                    (Mathlib.Tactic.Ring.div_pf\n                      (Mathlib.Tactic.Ring.inv_single\n                        (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                          (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                            (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                              (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                (Mathlib.Meta.NormNum.IsNat.to_isNNRat (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                      (Mathlib.Tactic.Ring.add_mul\n                        (Mathlib.Tactic.Ring.mul_add\n                          (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                          (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                          (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                        (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                  (Mathlib.Tactic.Ring.add_mul\n                    (Mathlib.Tactic.Ring.mul_add\n                      (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                      (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                    (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.sub_pf (Mathlib.Tactic.Ring.neg_add ⋯ ⋯) ⋯))\n              ⋯)\n            ⋯))\n        ⋯))","type":"0 < N","name":["hNpos"],"isProp":true,"id":["_uniq",5709]},{"value":"(b - a) / (↑N : ℝ)","type":"ℝ","name":["δ"],"isProp":false,"id":["_uniq",10036]},{"value":"div_pos hab (Nat.cast_pos'.mpr hNpos)","type":"0 < δ","name":["hδpos"],"isProp":true,"id":["_uniq",10241]},{"value":"id\n  (of_eq_true\n    (Eq.trans\n      (congrArg (Eq b)\n        (Eq.trans\n          (congrArg (HAdd.hAdd a)\n            (Eq.trans (div_mul_eq_mul_div (b - a) (↑N : ℝ) (↑N : ℝ))\n              (mul_div_cancel_right₀ (b - a) (ne_of_gt (Nat.cast_pos'.mpr hNpos)))))\n          (add_sub_cancel a b)))\n      (eq_self b)))","type":"b = a + δ * (↑N : ℝ)","name":["hbeq"],"isProp":true,"id":["_uniq",12901]},{"value":"{ toFun := fun j => Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1)), inj' := ⋯ }","type":"ℕ ↪ BoundedInterval","name":["e"],"isProp":false,"id":["_uniq",31845]},{"value":"{ intervals := insert (Icc b b) (Finset.map e (Finset.range N)), exists_unique := ⋯, contains := ⋯ }","type":"Partition I","name":["P"],"isProp":false,"id":["_uniq",227617]},{"value":"Trans.trans\n  (Trans.trans (upper_integ_le_upper_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sSup\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csSup_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sSup (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sSup (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sSup (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sSup (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sSup (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯)) ⋯ ⋯ ⋯))\n      ⋯)","type":"upper_integral f I ≤ ∑ j ∈ Finset.range N, f (a + δ * ((↑j : ℝ) + 1)) * δ","name":["hup"],"isProp":true,"id":["_uniq",229519]},{"value":"Trans.trans\n  (Trans.trans (lower_integ_ge_lower_sum hbound P)\n    (Eq.mpr\n      (id\n        (congr\n          (congrArg Eq\n            (Eq.trans\n              (Finset.sum_insert\n                (of_eq_true\n                  (Eq.trans\n                    (congrArg Not\n                      (Eq.trans Finset.mem_map._simp_1\n                        (Eq.trans\n                          (congrArg Exists\n                            (funext fun a =>\n                              Eq.trans\n                                (congr (congrArg And Finset.mem_range._simp_1)\n                                  (eq_false' fun h => BoundedInterval.noConfusion h))\n                                (and_false (a < N))))\n                          (exists_const._simp_1 ℕ))))\n                    not_false_eq_true)))\n              (Eq.trans\n                (congr\n                  (congrArg HAdd.hAdd\n                    (Eq.trans\n                      (congr\n                        (congrArg HMul.hMul\n                          (Eq.trans\n                            (congrArg sInf\n                              (Eq.trans (congrArg (Set.image f) (Eq.trans (set_Icc b b) (Set.Icc_self b)))\n                                Set.image_singleton))\n                            (csInf_singleton (f b))))\n                        (Eq.trans\n                          (sup_of_le_left\n                            (of_eq_true (Eq.trans (congrArg (LE.le 0) (sub_self (Icc b b).b)) (le_refl._simp_1 0))))\n                          (sub_self (Icc b b).b)))\n                      (mul_zero (f b))))\n                  (Finset.sum_map (Finset.range N) e fun x => sInf (f '' (↑x : Set ℝ)) * x.length))\n                (zero_add (∑ x ∈ Finset.range N, sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)))))\n          (Finset.sum_congr (Eq.refl (Finset.range N)) fun x a_1 =>\n            congrArg (fun x_1 => sInf (f '' x_1) * (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n              (set_Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))))))\n      ((fun {ι M} [AddCommMonoid M] s s_1 e_s =>\n          Eq.rec (motive := fun s_2 e_s => ∀ (f f_1 : ι → M), f = f_1 → s.sum f = s_2.sum f_1)\n            (fun f f_1 e_f => e_f ▸ Eq.refl (s.sum f)) e_s)\n        (Finset.range N) (Finset.range N) (Eq.refl (Finset.range N))\n        (fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length)\n        (fun x =>\n          sInf (f '' Set.Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))) *\n            (Ico (a + δ * (↑x : ℝ)) (a + δ * ((↑x : ℝ) + 1))).length)\n        (Eq.refl fun x => sInf (f '' (↑(e x) : Set ℝ)) * (e x).length))))\n  (Finset.sum_le_sum fun j hj =>\n    Eq.mpr\n      (eq_of_heq\n        ((fun α self a a' e'_3 a_1 a'_1 e'_4 =>\n            Eq.casesOn (motive := fun a_2 x => a' = a_2 → e'_3 ≍ x → (a ≤ a_1) ≍ (a' ≤ a'_1)) e'_3\n              (fun h =>\n                Eq.ndrec (motive := fun a' => ∀ (e_3 : a = a'), e_3 ≍ Eq.refl a → (a ≤ a_1) ≍ (a' ≤ a'_1))\n                  (fun e_3 h =>\n                    Eq.casesOn (motive := fun a_2 x => a'_1 = a_2 → e'_4 ≍ x → (a ≤ a_1) ≍ (a ≤ a'_1)) e'_4\n                      (fun h =>\n                        Eq.ndrec (motive := fun a' => ∀ (e_4 : a_1 = a'), e_4 ≍ Eq.refl a_1 → (a ≤ a_1) ≍ (a ≤ a'))\n                          (fun e_4 h => HEq.refl (a ≤ a_1)) (Eq.symm h) e'_4)\n                      (Eq.refl a'_1) (HEq.refl e'_4))\n                  (Eq.symm h) e'_3)\n              (Eq.refl a') (HEq.refl e'_3))\n          ℝ Real.partialOrder.toLE (f (a + δ * (↑j : ℝ)) * δ) (f (a + δ * (↑j : ℝ)) * δ)\n          (Eq.refl (f (a + δ * (↑j : ℝ)) * δ))\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) *\n            (Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))).length)\n          (sInf (f '' (↑(Ico (a + δ * (↑j : ℝ)) (a + δ * ((↑j : ℝ) + 1))) : Set ℝ)) * δ)\n          (eq_of_heq (⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯ ⋯))))\n      ⋯)","type":"lower_integral f I ≥ ∑ j ∈ Finset.range N, f (a + δ * (↑j : ℝ)) * δ","name":["hdown"],"isProp":true,"id":["_uniq",446490]},{"value":"Eq.mpr (id one_le_div'._simp_4)\n  (hf\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => a ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (le_refl._simp_1 a)) (eq_true hab')) (and_self True))))\n    (of_eq_true\n      (Eq.trans (Eq.trans (congrArg (fun x => b ∈ x) (set_Icc a b)) Set.mem_Icc._simp_1)\n        (Eq.trans (congr (congrArg And (eq_true hab')) (le_refl._simp_1 b)) (and_self True))))\n    hab')","type":"0 ≤ f b - f a","name":["this"],"isProp":true,"id":["_uniq",678403]}]}],"start":5876},{"state":[{"type":"IntegrableOn f I","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",5528],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"value":"fun ε hε =>\n  (fun N hN =>\n      have hNpos :=\n        Eq.mpr\n          (id\n            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                  (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                (Eq.trans\n                  (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                    (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                  (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.div_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf ε)\n                              (Mathlib.Tactic.Ring.div_pf\n                                (Mathlib.Tactic.Ring.inv_single\n                                  (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                                    (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.div_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.div_pf\n                              (Mathlib.Tactic.Ring.inv_single\n                                (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                                  (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                      ⋯)\n                    ⋯))\n                ⋯));\n      ⋯)\n    ⋯ ⋯","type":"∀ (ε : ℝ), 0 < ε → upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","name":["this"],"isProp":true,"id":["_uniq",5525]}]}],"start":5905},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",712902],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"value":"fun ε hε =>\n  (fun N hN =>\n      have hNpos :=\n        Eq.mpr\n          (id\n            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                  (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                (Eq.trans\n                  (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                    (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                  (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.div_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf ε)\n                              (Mathlib.Tactic.Ring.div_pf\n                                (Mathlib.Tactic.Ring.inv_single\n                                  (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                                    (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.div_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.div_pf\n                              (Mathlib.Tactic.Ring.inv_single\n                                (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                                  (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                      ⋯)\n                    ⋯))\n                ⋯));\n      ⋯)\n    ⋯ ⋯","type":"∀ (ε : ℝ), 0 < ε → upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","name":["this"],"isProp":true,"id":["_uniq",5525]}]}],"start":5933},{"state":[{"type":"lower_integral f I = upper_integral f I","tag":["pos","_@","_hyg",41],"mvarId":["_uniq",764212],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",219],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",220],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",221],"binderInfo":"implicit"},{"type":"0 < b - a","name":["hab"],"isProp":true,"id":["_uniq",340],"binderInfo":"default"},{"value":"BddOn.of_monotone _fvar.222","type":"BddOn f (Set.Icc a b)","name":["hbound"],"isProp":true,"id":["_uniq",4697]},{"value":"Icc a b","type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",4702]},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",4766],"binderInfo":"default"},{"value":"le_of_not_gt fun a_1 =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul b (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (b ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + (a ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf b) (Mathlib.Tactic.Ring.atom_pf a)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul a (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (b ^ Nat.rawCast 1 * Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_zero_add (a ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Tactic.Ring.add_overlap_pf_zero b (Nat.rawCast 1)\n                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                    (Eq.refl (Int.ofNat 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero a (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))))\n      (Mathlib.Tactic.Linarith.add_neg (Mathlib.Tactic.Linarith.sub_neg_of_lt hab)\n        (Mathlib.Tactic.Linarith.sub_neg_of_lt a_1)))","type":"a ≤ b","name":["hab'"],"isProp":true,"id":["_uniq",4804]},{"value":"fun ε hε =>\n  (fun N hN =>\n      have hNpos :=\n        Eq.mpr\n          (id\n            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 0 N)\n              (Eq.trans\n                (Eq.trans (congrArg (fun x => x < (↑N : ℤ)) Nat.cast_zero)\n                  (Mathlib.Tactic.Qify.intCast_lt._simp_1 0 (↑N : ℤ)))\n                (Eq.trans\n                  (Eq.trans (congr (congrArg LT.lt Int.cast_zero) (Int.cast_natCast N))\n                    (Mathlib.Tactic.Rify.ratCast_lt._simp_1 0 (↑N : ℚ)))\n                  (congr (congrArg LT.lt Rat.cast_zero) (Rat.cast_natCast N))))))\n          (lt_of_not_ge fun a =>\n            Mathlib.Tactic.Linarith.lt_irrefl\n              (Eq.mp\n                (congrArg (fun _a => _a < 0)\n                  (Mathlib.Tactic.Ring.of_eq\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr\n                        (Mathlib.Tactic.Ring.sub_congr\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.div_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                              (Mathlib.Tactic.Ring.atom_pf ε)\n                              (Mathlib.Tactic.Ring.div_pf\n                                (Mathlib.Tactic.Ring.inv_single\n                                  (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                                    (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                      (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                        (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                          (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                            (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                                    (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                                (Mathlib.Tactic.Ring.add_mul\n                                  (Mathlib.Tactic.Ring.mul_add\n                                    (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                      (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                    (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                  (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.mul_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                            (Mathlib.Tactic.Ring.add_mul\n                              (Mathlib.Tactic.Ring.mul_add\n                                (Mathlib.Tactic.Ring.mul_pf_right (↑N : ℝ) (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                              (Mathlib.Tactic.Ring.zero_mul ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                          (Mathlib.Tactic.Ring.sub_pf\n                            (Mathlib.Tactic.Ring.neg_add\n                              (Mathlib.Tactic.Ring.neg_mul (↑N : ℝ) (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                      (Eq.refl (Int.negOfNat 1))))))\n                              Mathlib.Tactic.Ring.neg_zero)\n                            (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                ((↑N : ℝ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                        (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑N : ℝ))\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑N : ℝ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑N : ℝ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℝ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1))\n                                  (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_zero))\n                          (Mathlib.Tactic.Ring.add_mul (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                            (Mathlib.Tactic.Ring.zero_mul 0) (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                        (Mathlib.Tactic.Ring.mul_congr\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                          (Mathlib.Tactic.Ring.div_congr\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℝ Nat.cast_one))\n                            (Mathlib.Tactic.Ring.atom_pf ε)\n                            (Mathlib.Tactic.Ring.div_pf\n                              (Mathlib.Tactic.Ring.inv_single\n                                (Mathlib.Tactic.Ring.inv_mul (Eq.refl ε⁻¹)\n                                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                    (Mathlib.Meta.NormNum.IsNNRat.to_isNat\n                                      (Mathlib.Meta.NormNum.isNNRat_inv_pos\n                                        (Mathlib.Meta.NormNum.IsNat.to_isNNRat\n                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℝ 1)))))\n                                  (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_mul\n                            (Mathlib.Tactic.Ring.mul_add\n                              (Mathlib.Tactic.Ring.mul_pf_right ε⁻¹ (Nat.rawCast 1)\n                                (Mathlib.Tactic.Ring.one_mul (Nat.rawCast 1)))\n                              (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 1))\n                              (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))\n                            (Mathlib.Tactic.Ring.zero_mul (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))\n                            (Mathlib.Tactic.Ring.add_pf_add_zero (ε⁻¹ ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                      ⋯)\n                    ⋯))\n                ⋯));\n      ⋯)\n    ⋯ ⋯","type":"∀ (ε : ℝ), 0 < ε → upper_integral f I - lower_integral f I ≤ (f b - f a) * (b - a) * ε","name":["this"],"isProp":true,"id":["_uniq",5525]},{"type":"lower_integral f I ≤ upper_integral f I","name":["low_le_up"],"isProp":true,"id":["_uniq",764211],"binderInfo":"default"}]}],"start":5997},{"state":[],"start":6042},{"state":[],"start":6043},{"state":[],"start":6044},{"state":[],"start":6070},{"state":[],"start":6153},{"state":[{"type":"IntegrableOn f (Icc a b)","tag":[],"mvarId":["_uniq",765157],"isProp":true,"context":[{"type":"ℝ","name":["a"],"isProp":false,"id":["_uniq",765153],"binderInfo":"implicit"},{"type":"ℝ","name":["b"],"isProp":false,"id":["_uniq",765154],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",765155],"binderInfo":"implicit"},{"type":"AntitoneOn f (↑(Icc a b) : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",765156],"binderInfo":"default"}]}],"start":6186},{"state":[],"start":6265},{"state":[],"start":6266},{"state":[],"start":6308},{"state":[],"start":6394},{"state":[{"type":"IntegrableOn f I","tag":[],"mvarId":["_uniq",766120],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",766116],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",766117],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",766118],"binderInfo":"default"},{"type":"MonotoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",766119],"binderInfo":"default"}]}],"start":6442},{"state":[],"start":6450},{"state":[],"start":6451},{"state":[],"start":6537},{"state":[{"type":"IntegrableOn f I","tag":[],"mvarId":["_uniq",766345],"isProp":true,"context":[{"type":"BoundedInterval","name":["I"],"isProp":false,"id":["_uniq",766341],"binderInfo":"implicit"},{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",766342],"binderInfo":"implicit"},{"type":"BddOn f (↑I : Set ℝ)","name":["hbound"],"isProp":true,"id":["_uniq",766343],"binderInfo":"default"},{"type":"AntitoneOn f (↑I : Set ℝ)","name":["hf"],"isProp":true,"id":["_uniq",766344],"binderInfo":"default"}]}],"start":6585},{"state":[],"start":6593},{"state":[],"start":6594},{"state":[],"start":6636},{"state":[],"start":6722},{"state":[],"start":6754},{"state":[{"type":"Summable f ↔ ∃ M, ∀ N ≥ 0, integ f (Icc 0 N) ≤ M","tag":[],"mvarId":["_uniq",767120],"isProp":true,"context":[{"type":"ℝ → ℝ","name":["f"],"isProp":false,"id":["_uniq",767115],"binderInfo":"implicit"},{"type":"∀ x ≥ 0, f x ≥ 0","name":["hnon"],"isProp":true,"id":["_uniq",767116],"binderInfo":"default"},{"type":"AntitoneOn f (Set.Ici 0)","name":["hf"],"isProp":true,"id":["_uniq",767117],"binderInfo":"default"}]}],"start":6821},{"state":[],"start":6829},{"state":[],"start":6830},{"state":[],"start":6923},{"state":[],"start":7001},{"state":[],"start":7002},{"state":[],"start":7025},{"state":[{"type":"∃ f, ∃ (_ : ∀ x ≥ 0, f x ≥ 0), Summable f ∧ ¬∃ M, ∀ N ≥ 0, integ f (Icc 0 N) ≤ M","tag":[],"mvarId":["_uniq",767768],"isProp":true,"context":[]}],"start":7155},{"state":[],"start":7163},{"state":[],"start":7164},{"state":[{"type":"∃ f, ∃ (_ : ∀ x ≥ 0, f x ≥ 0), ¬Summable f ∧ ∃ M, ∀ N ≥ 0, integ f (Icc 0 N) ≤ M","tag":[],"mvarId":["_uniq",768416],"isProp":true,"context":[]}],"start":7294},{"state":[],"start":7302},{"state":[],"start":7303},{"state":[],"start":7317},{"state":[],"start":7317}]
