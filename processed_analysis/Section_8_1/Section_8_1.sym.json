[{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Set","Elem"],["OfNat","ofNat"],["Set","univ"],["Chapter8","AtMostCountable"],["Set","image"],["Nat"],["instOfNatNat"],["Lean","Name","num"]],"typeReferences":[["Set","univ"],["Chapter8","AtMostCountable"],["Set","image"],["Chapter8","CountablyInfinite"],["Set","Elem"]],"type":"∀ {X : Type},\n  Chapter8.CountablyInfinite X → ∀ {Y : Type} (f : X → Y), Chapter8.AtMostCountable (Set.image f Set.univ).Elem","name":["Chapter8","AtMostCountable","image"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["sorryAx"],["Eq","trans"],["instInfiniteNat"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["Exists","intro"],["Subtype","val"],["Set","Elem"],["HDiv","hDiv"],["Chapter8","AtMostCountable"],["False","elim"],["Rat","instNatCast"],["Or"],["Eq","symm"],["Finite"],["Chapter8","CountablyInfinite"],["Function","Bijective"],["Rat","natCast_inj","_simp_1"],["Set","finite_coe_iff"],["Set","instMembership"],["Exists","casesOn"],["Prod"],["Nat"],["Set","image"],["Chapter8","AtMostCountable","image"],["instOfNat"],["not_infinite_iff_finite"],["Eq","refl"],["Rat"],["Chapter8","CountablyInfinite","prod"],["Set","Finite"],["setOf"],["Lean","Name","anonymous"],["Nat","cast"],["imp_self","_simp_1"],["Eq","mp"],["Finite","Set","finite_of_finite_image"],["Int","cast"],["instHDiv"],["congrArg"],["Rat","instIntCast"],["instOfNatNat"],["congr"],["Chapter8","Rat","countablyInfinite","match_1_1"],["Chapter8","EqualCard","univ"],["Eq"],["Chapter8","Int","countablyInfinite"],["Infinite"],["propext"],["Rat","instDiv"],["Not"],["True"],["Set"],["Chapter8","AtMostCountable","equiv"],["Subtype","finite"],["OfNat","ofNat"],["Int"],["Or","casesOn"],["Set","univ"],["of_eq_true"],["inferInstance"],["Ne"],["Set","finite_univ_iff"],["Lean","Name","num"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Rat"]],"type":"Chapter8.CountablyInfinite Rat","name":["Chapter8","Rat","countablyInfinite"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Prod","snd"],["Set","instMembership"],["Prod","fst"],["Prod"],["Prod","casesOn"],["Nat"],["LE","le"],["Subtype","casesOn"],["Subtype","mk"],["instLENat"],["setOf"]],"typeReferences":[["Set"],["Prod","mk"],["Membership","mem"],["Prod","snd"],["Set","Elem"],["Prod","fst"],["Set","instMembership"],["Prod"],["Nat"],["LE","le"],["Subtype","mk"],["instLENat"],["setOf"]],"type":"(motive : (setOf fun n => instLENat.le n.snd n.fst).Elem → Sort u_1) →\n  (x : (setOf fun n => instLENat.le n.snd n.fst).Elem) →\n    ((n m : Nat) →\n        (property : Set.instMembership.mem (setOf fun n => instLENat.le n.snd n.fst) { fst := n, snd := m }) →\n          motive ⟨{ fst := n, snd := m }, property⟩) →\n      motive x","name":["Chapter8","CountablyInfinite","prod_nat","match_1_1"],"kind":"definition","isProp":false},{"valueReferences":[["PartialOrder","toPreorder"],["sorryAx"],["Lean","Name","anonymous"],["Decidable"],["Lean","Name"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["instLinearOrderNNRat"],["instDistribLatticeOfLinearOrder"],["NNRat"],["instOfNatNat"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"],["Set","Nonempty"],["Lattice","toSemilatticeInf"],["Set"],["And"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["DistribLattice","toLattice"],["LE","le"],["ExistsUnique"],["Lean","Name","num"]],"typeReferences":[["Set","Nonempty"],["PartialOrder","toPreorder"],["Lattice","toSemilatticeInf"],["Decidable"],["Set"],["Membership","mem"],["And"],["instLinearOrderNNRat"],["Set","instMembership"],["instDistribLatticeOfLinearOrder"],["DistribLattice","toLattice"],["NNRat"],["LE","le"],["ExistsUnique"],["Preorder","toLE"],["SemilatticeInf","toPartialOrder"]],"type":"Decidable\n  (∀ (X : Set NNRat),\n    X.Nonempty →\n      ExistsUnique fun m =>\n        And (Set.instMembership.mem X m)\n          (∀ (n : NNRat), Set.instMembership.mem X n → instDistribLatticeOfLinearOrder.toSemilatticeInf.le m n))","name":["Chapter8","NNRat","exists_unique_min"],"kind":"definition","isProp":false},{"valueReferences":[["Nonempty"],["Cardinal","eq"],["Eq"],["Cardinal"],["Equiv"],["propext"],["Cardinal","mk"]],"typeReferences":[["Nonempty"],["Eq"],["Cardinal"],["Equiv"],["Cardinal","mk"]],"type":"∀ {α β : Type u}, Eq (Eq (Cardinal.mk α) (Cardinal.mk β)) (Nonempty (Equiv α β))","name":["Chapter8","EqualCard","iff'","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["Membership","mem"],["Classical","propDecidable"],["eq_true"],["Chapter8","Nat","min"],["ExistsUnique","exists"],["congrArg"],["instOfNatNat"],["congr"],["forall_congr"],["Chapter8","Nat","min","_proof_1"],["Eq"],["Chapter8","Nat","exists_unique_min"],["Set","Nonempty"],["Exists","choose_spec"],["Set"],["And"],["Exists","choose"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["of_eq_true"],["dite_cond_eq_true"],["Eq","refl"],["LE","le"],["id"],["Eq","mpr"],["dite"],["instLENat"]],"typeReferences":[["Set","Nonempty"],["Nat"],["Set"],["LE","le"],["Membership","mem"],["And"],["instLENat"],["Chapter8","Nat","min"],["Set","instMembership"]],"type":"∀ {X : Set Nat},\n  X.Nonempty →\n    And (Set.instMembership.mem X (Chapter8.Nat.min X))\n      (∀ (n : Nat), Set.instMembership.mem X n → instLENat.le (Chapter8.Nat.min X) n)","name":["Chapter8","Nat","min_spec"],"kind":"theorem","isProp":true},{"valueReferences":[["Prod","casesOn"],["Prod"],["Nat"],["Set"],["Membership","mem"],["Subtype","mk"],["Subtype","casesOn"],["Set","instMembership"]],"typeReferences":[["Prod"],["Nat"],["Prod","mk"],["Set"],["Membership","mem"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"(A : Set (Prod Nat Nat)) →\n  (motive : A.Elem → Sort u_1) →\n    (x : A.Elem) →\n      ((n m : Nat) →\n          (property : Set.instMembership.mem A { fst := n, snd := m }) → motive ⟨{ fst := n, snd := m }, property⟩) →\n        motive x","name":["Chapter8","CountablyInfinite","lower_diag","match_1_1"],"kind":"definition","isProp":false},{"valueReferences":[["Set","univ"],["Prod"],["Set","image"],["Nat"],["Set"],["Membership","mem"],["Subtype","casesOn"],["Set","Elem"],["Set","instMembership"]],"typeReferences":[["Set","univ"],["Prod"],["Set","image"],["Nat"],["Set"],["Membership","mem"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"∀ (A : Set (Prod Nat Nat)) (f : A.Elem → Nat) (motive : (Set.image f Set.univ).Elem → Prop)\n  (h : (Set.image f Set.univ).Elem),\n  (∀ (l : Nat) (hl : Set.instMembership.mem (Set.image f Set.univ) l), motive ⟨l, hl⟩) → motive h","name":["Chapter8","CountablyInfinite","lower_diag","match_1_4"],"kind":"definition","isProp":true},{"valueReferences":[["SubtractionMonoid","toSubNegZeroMonoid"],["Eq","trans"],["AddGroupWithOne","toAddMonoidWithOne"],["Exists","intro"],["eq_true"],["Union","union"],["AddGroup","toSubtractionMonoid"],["Set","Elem"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["Eq","symm"],["Set","instUnion"],["Function","instFunLikeEmbedding"],["Eq","ndrec"],["NonAssocSemiring","toAddCommMonoidWithOne"],["Int","instAddGroup"],["instLatticeInt"],["Exists"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Function","Embedding"],["Chapter8","CountablyInfinite","equiv"],["Function","Bijective"],["Set","instMembership"],["instOfNat"],["Eq","refl"],["Iff"],["HEq"],["Set","ext"],["Int","instCharZero"],["Eq","mpr"],["Int","decLe"],["setOf"],["Nat","cast_inj","_simp_1"],["Set","image_congr"],["Int","instRing"],["congr"],["Int","instIsStrictOrderedRing"],["Chapter8","EqualCard","univ"],["Int","instAddLeftMono"],["Eq"],["Preorder","toLE"],["ge_iff_le","_simp_1"],["propext"],["instNatCastInt"],["Function","Embedding","mk"],["IsStrictOrderedRing","toIsOrderedRing"],["Set"],["OfNat","ofNat"],["Int"],["Set","univ"],["eq_self"],["Max","max"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Int","instNormedCommRing"],["Chapter8","Int","countablyInfinite","_proof_1_3"],["Int","ofNat_toNat"],["Lattice","toSemilatticeSup"],["PartialOrder","toPreorder"],["Membership","mem"],["GE","ge"],["Nat","cast_nonneg","_simp_1"],["true_iff"],["Left","inv_le_one_iff","_simp_4"],["Semiring","toNonAssocSemiring"],["Or"],["Ring","toAddGroupWithOne"],["eq_of_heq"],["funext"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocRing"],["Int","instLEInt"],["Chapter8","CountablyInfinite","iff_image_inj"],["NonUnitalNonAssocRing","toHasDistribNeg"],["InvolutiveNeg","toNeg"],["Int","instMax"],["SemilatticeInf","toPartialOrder"],["Chapter8","CountablyInfinite"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["Set","mem_range","_simp_1"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Int","instNegInt"],["Exists","casesOn"],["Set","image_univ"],["Decidable","byContradiction"],["Nat"],["Set","image"],["sup_of_le_left"],["AddMonoidWithOne","toNatCast"],["NegZeroClass","toZero"],["id"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Int","zero_le_neg_iff","_simp_1"],["Int","toNat"],["Nat","cast"],["Subtype"],["Eq","mp"],["neg_neg"],["DFunLike","coe"],["inv_inj","_simp_4"],["SubNegZeroMonoid","toNegZeroClass"],["Set","range"],["congrArg"],["Iff","intro"],["Chapter8","CountablyInfinite","union"],["Zero","toOfNat0"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["instDecidableOr"],["Lattice","toSemilatticeInf"],["HEq","refl"],["True"],["Distrib","toMul"],["Set","mem_univ","_simp_1"],["Eq","casesOn"],["Set","mem_union","_simp_1"],["NegZeroClass","toNeg"],["of_eq_true"],["HasDistribNeg","toInvolutiveNeg"],["Int","instSemiring"],["LE","le"],["NormedCommRing","toNonUnitalNormedCommRing"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Int"]],"type":"Chapter8.CountablyInfinite Int","name":["Chapter8","Int","countablyInfinite"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","CountablyInfinite"],["Eq","trans"],["True"],["Chapter8","CountablyInfinite","equiv"],["congrArg"],["of_eq_true"],["Or"],["Chapter8","Finite","equiv"],["iff_self"],["Iff"],["congr"],["Finite"],["propext"]],"typeReferences":[["Chapter8","AtMostCountable"],["Iff"],["Chapter8","EqualCard"]],"type":"∀ {X Y : Type}, Chapter8.EqualCard X Y → Iff (Chapter8.AtMostCountable X) (Chapter8.AtMostCountable Y)","name":["Chapter8","AtMostCountable","equiv"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Chapter8","EqualCard"]],"typeReferences":[],"type":"Type → Prop","name":["Chapter8","CountablyInfinite"],"kind":"definition","isProp":false},{"valueReferences":[["Nat"],["Set"],["Membership","mem"],["Subtype","preorder"],["Function","Bijective"],["Set","Elem"],["Set","instMembership"],["Nat","instPreorder"],["StrictMono"],["And","casesOn"]],"typeReferences":[["And","intro"],["Nat"],["Set"],["Membership","mem"],["Subtype","preorder"],["And"],["Function","Bijective"],["Set","Elem"],["Set","instMembership"],["Nat","instPreorder"],["StrictMono"]],"type":"∀ (X : Set Nat) (g : Nat → X.Elem) (motive : And (Function.Bijective g) (StrictMono g) → Prop)\n  (h : And (Function.Bijective g) (StrictMono g)),\n  (∀ (hg_bijective : Function.Bijective g) (hg_mono : StrictMono g), motive ⋯) → motive h","name":["Chapter8","Nat","monotone_enum_of_infinite","match_1_3"],"kind":"definition","isProp":true},{"valueReferences":[["Int","instSub"],["Eq","trans"],["le_of_le_of_eq"],["Lean","Omega","tidy_sat"],["HSub","hSub"],["Int","instLEInt"],["Eq","symm"],["Lean","Omega","LinearCombo","add_eval"],["Lean","Omega","Int","lt_of_not_le"],["Int","add_one_le_of_lt"],["List","cons"],["Bool","true"],["And","left"],["Neg","neg"],["And","right"],["Lean","Omega","Constraint","addInequality_sat"],["Lean","Omega","LinearCombo","coordinate"],["Int","instNegInt"],["instDecidableEqBool"],["Nat"],["instOfNat"],["Eq","refl"],["id"],["Lean","Omega","LinearCombo","instAdd"],["Lean","Omega","Int","sub_congr"],["Bool"],["Lean","Omega","Constraint","combine_sat'"],["Option","some"],["Lean","Omega","LinearCombo","coordinate_eval_0"],["Decidable","decide"],["Lean","Omega","LinearCombo","mk"],["Lean","Omega","LinearCombo","instSub"],["Lean","Omega","Coeffs","ofList"],["instOfNatNat"],["Int","instAdd"],["Lean","Omega","Constraint","not_sat'_of_isImpossible"],["Eq"],["Lean","Omega","and_not_not_of_not_or"],["of_decide_eq_true"],["List","nil"],["Not"],["instHAdd"],["Lean","Omega","LinearCombo"],["Lean","Omega","Int","add_congr"],["Lean","Omega","Constraint","isImpossible"],["OfNat","ofNat"],["Int","sub_nonneg_of_le"],["Int"],["HAdd","hAdd"],["Lean","Omega","LinearCombo","sub_eval"],["Option","none"],["LE","le"],["Lean","Omega","Constraint","mk"],["Lean","Omega","LinearCombo","eval"],["instHSub"]],"typeReferences":[["Not"],["instOfNat"],["Or"],["LE","le"],["Int","instLEInt"],["False"],["OfNat","ofNat"],["Int"]],"type":"∀ (x : Int), Not (Or (Int.instLEInt.le 0 x) (Int.instLEInt.le x 0)) → False","name":["Chapter8","Int","countablyInfinite","_proof_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","CountablyInfinite","toCountable","_simp_1_1"],["Chapter8","CountablyInfinite"],["Eq","mp"],["And"],["id"],["Countable"],["Infinite"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Countable"]],"type":"∀ {X : Type}, Chapter8.CountablyInfinite X → Countable X","name":["Chapter8","CountablyInfinite","toCountable"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","CountablyInfinite"],["Eq","mp"],["Chapter8","CountablyInfinite","toInfinite","_simp_1_1"],["And"],["id"],["Countable"],["Infinite"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Infinite"]],"type":"∀ {X : Type}, Chapter8.CountablyInfinite X → Infinite X","name":["Chapter8","CountablyInfinite","toInfinite"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","choose_spec"],["Set"],["Membership","mem"],["And"],["Subtype","preorder"],["Exists","intro"],["Function","Bijective"],["Exists","choose"],["Chapter8","Nat","monotone_enum_of_infinite"],["Set","Elem"],["ExistsUnique","exists"],["Nat","instPreorder"],["Set","instMembership"],["Chapter8","EqualCard","symm"],["Nat"],["And","left"],["StrictMono"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Nat"],["Set"],["Infinite"],["Set","Elem"]],"type":"∀ (X : Set Nat) [Infinite X.Elem], Chapter8.CountablyInfinite X.Elem","name":["Chapter8","Nat","countable_of_infinite"],"kind":"theorem","isProp":true},{"valueReferences":[["instAddNat"],["implies_congr"],["Eq","trans"],["Membership","mem"],["Classical","propDecidable"],["eq_true"],["Classical","choose"],["Or"],["forall_congr"],["Eq","symm"],["Chapter8","Nat","min","_proof_1"],["Lean","Grind","not_eq_of_eq_true"],["instLTNat"],["Lean","Grind","rfl_true"],["And"],["True","intro"],["Set","instMembership"],["Exists","casesOn"],["Nat"],["Eq","refl"],["eq_false"],["Classical","byContradiction"],["Lean","Grind","eq_false_of_imp_eq_false"],["Lean","Grind","not_and"],["Eq","mp"],["congrArg"],["Lean","Grind","eq_false_of_not_eq_true"],["Lean","Grind","of_forall_eq_false"],["Lean","Grind","imp_eq_of_eq_true_left"],["Lean","Grind","Nat","lt_eq"],["Lean","Grind","nestedDecidable"],["instOfNatNat"],["Lean","Grind","or_eq_of_eq_false_left"],["Not"],["Set","Nonempty"],["True"],["Lean","Grind","Nat","le_eq_false_of_lo"],["instHAdd"],["Set"],["Lean","Grind","eq_true_of_not_eq_false"],["OfNat","ofNat"],["HAdd","hAdd"],["LT","lt"],["of_eq_true"],["LE","le"],["False"],["Lean","Grind","eq_true_of_imp_eq_false"],["Lean","Grind","intro_with_eq"],["dite"],["instLENat"],["And","casesOn"]],"typeReferences":[["Not"],["LT","lt"],["instLTNat"],["Nat"],["Set"],["LE","le"],["Membership","mem"],["And"],["instLENat"],["Chapter8","Nat","min"],["Set","instMembership"]],"type":"∀ {X : Set Nat},\n  And (Set.instMembership.mem X (Chapter8.Nat.min X))\n      (∀ (n : Nat), Set.instMembership.mem X n → instLENat.le (Chapter8.Nat.min X) n) →\n    And (Set.instMembership.mem X (Chapter8.Nat.min X))\n      (∀ (n : Nat), instLTNat.lt n (Chapter8.Nat.min X) → Not (Set.instMembership.mem X n))","name":["Chapter8","Nat","min_eq_find","_proof_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Prod","snd"],["Set","instMembership"],["Prod","fst"],["Prod"],["Prod","casesOn"],["Nat"],["LE","le"],["Subtype","casesOn"],["Subtype","mk"],["instLENat"],["setOf"]],"typeReferences":[["Set"],["Prod","mk"],["Membership","mem"],["Prod","snd"],["Set","Elem"],["Prod","fst"],["Set","instMembership"],["Prod"],["Nat"],["LE","le"],["Subtype","mk"],["instLENat"],["setOf"]],"type":"∀ (motive : (setOf fun n => instLENat.le n.fst n.snd).Elem → Prop) (h : (setOf fun n => instLENat.le n.fst n.snd).Elem),\n  (∀ (n m : Nat) (property : Set.instMembership.mem (setOf fun n => instLENat.le n.fst n.snd) { fst := n, snd := m }),\n      motive ⟨{ fst := n, snd := m }, property⟩) →\n    motive h","name":["Chapter8","CountablyInfinite","prod_nat","match_1_7"],"kind":"definition","isProp":true},{"valueReferences":[["Nonempty","casesOn"],["Equiv"]],"typeReferences":[["Nonempty","intro"],["Nonempty"],["Equiv"]],"type":"∀ {X Y : Type} (motive : Nonempty (Equiv X Y) → Prop) (h : Nonempty (Equiv X Y)),\n  (∀ (e : Equiv X Y), motive ⋯) → motive h","name":["Chapter8","EqualCard","iff","match_1_3"],"kind":"definition","isProp":true},{"valueReferences":[["Set","Nonempty"],["Set"],["Membership","mem"],["Classical","propDecidable"],["And"],["Exists","choose"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["instOfNatNat"],["LE","le"],["Chapter8","Nat","min","_proof_1"],["dite"],["instLENat"]],"typeReferences":[["Nat"],["Set"]],"type":"Set Nat → Nat","name":["Chapter8","Nat","min"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter8","CountablyInfinite"],["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Set"],["Bool","false"],["Lean","Name","str"],["Union","union"],["Set","Elem"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["Lean","Name","num"],["Set","instUnion"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Set"],["Set","instUnion"],["Union","union"],["Set","Elem"]],"type":"∀ {A : Type} {X Y : Set A},\n  Chapter8.CountablyInfinite X.Elem →\n    Chapter8.CountablyInfinite Y.Elem → Chapter8.CountablyInfinite (Set.instUnion.union X Y).Elem","name":["Chapter8","CountablyInfinite","union"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype","mk","injEq"],["Eq","trans"],["Prod","mk"],["Membership","mem"],["Iff","mp"],["Exists","intro"],["Union","union"],["Set","Elem"],["true_iff"],["And","intro"],["Or"],["eq_of_heq"],["Eq","symm"],["Chapter8","CountablyInfinite","prod_nat","match_1_1"],["Eq","ndrec"],["Eq","rec"],["Set","instUnion"],["Chapter8","CountablyInfinite"],["Exists"],["And"],["Chapter8","CountablyInfinite","equiv"],["Function","Bijective"],["Prod","snd"],["Set","instMembership"],["Prod"],["Decidable","byContradiction"],["Nat"],["Iff"],["Eq","refl"],["id"],["HEq"],["Set","ext"],["Eq","mpr"],["setOf"],["Subtype"],["Eq","mp"],["Chapter8","CountablyInfinite","prod_nat","match_1_4"],["Prod","fst"],["congrArg"],["Prod","casesOn"],["congr"],["Chapter8","CountablyInfinite","union"],["Chapter8","CountablyInfinite","lower_diag"],["Chapter8","EqualCard","univ"],["Prod","mk","injEq"],["Eq"],["instDecidableOr"],["Chapter8","CountablyInfinite","prod_nat","match_1_7"],["HEq","refl"],["True"],["Set"],["Nat","decLe"],["Set","mem_univ","_simp_1"],["Function","Surjective"],["Eq","casesOn"],["Set","mem_union","_simp_1"],["Set","univ"],["eq_self"],["Chapter8","CountablyInfinite","prod_nat","_proof_1_10"],["of_eq_true"],["LE","le"],["Subtype","mk"],["instLENat"],["Function","Injective"]],"typeReferences":[["Prod"],["Nat"],["Chapter8","CountablyInfinite"]],"type":"Chapter8.CountablyInfinite (Prod Nat Nat)","name":["Chapter8","CountablyInfinite","prod_nat"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","Nonempty"],["True"],["Eq","trans"],["Set"],["Membership","mem"],["Classical","propDecidable"],["And"],["EmptyCollection","emptyCollection"],["Set","instEmptyCollection"],["Exists","choose"],["Set","not_nonempty_empty","_simp_1"],["OfNat","ofNat"],["congrArg"],["Set","instMembership"],["eq_self"],["Nat"],["of_eq_true"],["instOfNatNat"],["LE","le"],["Chapter8","Nat","min","_proof_1"],["dite_cond_eq_false"],["Eq"],["dite"],["instLENat"]],"typeReferences":[["Nat"],["instOfNatNat"],["Set"],["Set","instEmptyCollection"],["EmptyCollection","emptyCollection"],["Eq"],["OfNat","ofNat"],["Chapter8","Nat","min"]],"type":"Eq (Chapter8.Nat.min Set.instEmptyCollection.emptyCollection) 0","name":["Chapter8","Nat","min_empty"],"kind":"theorem","isProp":true},{"valueReferences":[["instDecidableAnd"],["Classical","propDecidable"],["Iff","mp"],["Exists","intro"],["Iff","intro"],["Chapter8","AtMostCountable"],["False","elim"],["Or"],["Decidable","not_or_of_imp"],["Finite"],["Infinite"],["Not"],["not_imp_not"],["finite_or_infinite"],["Chapter8","CountablyInfinite"],["And"],["Finite","to_countable"],["Function","Bijective"],["Decidable","not_and_iff_not_or_not'"],["Chapter8","CountablyInfinite","iff'"],["Or","casesOn"],["Exists","casesOn"],["Classical","or_iff_not_imp_left"],["Nat"],["Iff","mpr"],["Iff"],["Countable"],["Decidable","iff_iff_and_or_not_and_not"],["And","casesOn"]],"typeReferences":[["Chapter8","AtMostCountable"],["Iff"],["Countable"]],"type":"∀ (X : Type), Iff (Chapter8.AtMostCountable X) (Countable X)","name":["Chapter8","AtMostCountable","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Lean","Name","anonymous"],["sorryAx"],["Lean","Name"],["Set"],["Membership","mem"],["Bool","false"],["Lean","Name","str"],["And"],["OfNat","ofNat"],["Set","instMembership"],["Nat"],["instOfNatNat"],["LE","le"],["ExistsUnique"],["Lean","Name","num"],["instLENat"]],"typeReferences":[["Set","Nonempty"],["Nat"],["Set"],["LE","le"],["Membership","mem"],["And"],["ExistsUnique"],["instLENat"],["Set","instMembership"]],"type":"∀ {X : Set Nat},\n  X.Nonempty →\n    ExistsUnique fun m => And (Set.instMembership.mem X m) (∀ (n : Nat), Set.instMembership.mem X n → instLENat.le m n)","name":["Chapter8","Nat","exists_unique_min"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Prod","snd"],["Set","instMembership"],["Prod","fst"],["Prod"],["Prod","casesOn"],["Nat"],["LE","le"],["Subtype","casesOn"],["Subtype","mk"],["instLENat"],["setOf"]],"typeReferences":[["Set"],["Prod","mk"],["Membership","mem"],["Prod","snd"],["Set","Elem"],["Prod","fst"],["Set","instMembership"],["Prod"],["Nat"],["LE","le"],["Subtype","mk"],["instLENat"],["setOf"]],"type":"∀ (motive : (setOf fun n => instLENat.le n.snd n.fst).Elem → Prop) (h : (setOf fun n => instLENat.le n.snd n.fst).Elem),\n  (∀ (fst snd : Nat)\n      (property : Set.instMembership.mem (setOf fun n => instLENat.le n.snd n.fst) { fst := fst, snd := snd }),\n      motive ⟨{ fst := fst, snd := snd }, property⟩) →\n    motive h","name":["Chapter8","CountablyInfinite","prod_nat","match_1_4"],"kind":"definition","isProp":true},{"valueReferences":[["Nat"],["Set"],["Membership","mem"],["Subtype","casesOn"],["Set","instMembership"]],"typeReferences":[["Nat"],["Set"],["Membership","mem"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"∀ (X : Set Nat) (motive : X.Elem → Prop) (h : X.Elem),\n  (∀ (x : Nat) (hx : Set.instMembership.mem X x), motive ⟨x, hx⟩) → motive h","name":["Chapter8","Nat","monotone_enum_of_infinite","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Subtype","mk","injEq"],["Subtype"],["Eq","trans"],["Eq","mp"],["Chapter8","AtMostCountable","subset'","match_1_1"],["Membership","mem"],["Iff","mp"],["Exists","intro"],["Subtype","val"],["Set","Elem"],["congrArg"],["Chapter8","AtMostCountable","subset'","match_1_3"],["Chapter8","AtMostCountable"],["And","intro"],["Subtype","property"],["Eq","rec"],["Eq"],["Eq","ndrec"],["Exists"],["True"],["Set"],["Chapter8","AtMostCountable","equiv"],["Function","Bijective"],["Function","Surjective"],["Set","instMembership"],["eq_self"],["of_eq_true"],["Eq","refl"],["id"],["Subtype","mk"],["Chapter8","AtMostCountable","subset"],["setOf"],["Function","Injective"]],"typeReferences":[["Set","instHasSubset"],["Chapter8","AtMostCountable"],["HasSubset","Subset"],["Set"],["Set","Elem"]],"type":"∀ {A : Type} {X Y : Set A},\n  Chapter8.AtMostCountable X.Elem → Set.instHasSubset.Subset Y X → Chapter8.AtMostCountable Y.Elem","name":["Chapter8","AtMostCountable","subset'"],"kind":"theorem","isProp":true},{"valueReferences":[["Not"],["instLTNat"],["Nat","find"],["Chapter8","Nat","min_eq_find","_proof_1_1"],["Set"],["Membership","mem"],["Classical","propDecidable"],["And"],["Chapter8","Nat","min"],["Chapter8","Nat","min_spec"],["congrArg"],["Set","instMembership"],["LT","lt"],["Nat"],["Nat","find_eq_iff"],["id"],["Eq","symm"],["Eq","mpr"],["Eq"],["propext"]],"typeReferences":[["Nat","find"],["Set","Nonempty"],["Nat"],["Set"],["Membership","mem"],["Classical","propDecidable"],["Eq"],["Chapter8","Nat","min"],["Set","instMembership"]],"type":"∀ {X : Set Nat} (hX : X.Nonempty), Eq (Chapter8.Nat.min X) (Nat.find hX)","name":["Chapter8","Nat","min_eq_find"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","EqualCard","iff'","_simp_1_1"],["Eq","trans"],["True"],["Chapter8","EqualCard"],["Nonempty"],["Cardinal"],["Equiv"],["Cardinal","mk"],["congrArg"],["Chapter8","EqualCard","iff'","_simp_1_2"],["iff_self"],["of_eq_true"],["Iff"],["congr"],["Eq"]],"typeReferences":[["Iff"],["Chapter8","EqualCard"],["Eq"],["Cardinal"],["Cardinal","mk"]],"type":"∀ {X Y : Type}, Iff (Chapter8.EqualCard X Y) (Eq (Cardinal.mk X) (Cardinal.mk Y))","name":["Chapter8","EqualCard","iff'"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter8","EqualCard"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Chapter8","EqualCard"]],"type":"∀ {X Y Z : Type}, Chapter8.EqualCard X Y → Chapter8.EqualCard Y Z → Chapter8.EqualCard X Z","name":["Chapter8","EqualCard","trans"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter8","EqualCard"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Chapter8","EqualCard"]],"type":"∀ (X : Type), Chapter8.EqualCard X X","name":["Chapter8","EqualCard","refl"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","Nonempty"],["Lean","Name","anonymous"],["sorryAx"],["Decidable"],["Lean","Name"],["Set"],["Lean","Name","str"],["Membership","mem"],["Bool","false"],["And"],["OfNat","ofNat"],["Int"],["Set","instMembership"],["Nat"],["instOfNatNat"],["LE","le"],["Int","instLEInt"],["ExistsUnique"],["Lean","Name","num"]],"typeReferences":[["Set","Nonempty"],["Decidable"],["Set"],["LE","le"],["Membership","mem"],["Int","instLEInt"],["And"],["ExistsUnique"],["Set","instMembership"],["Int"]],"type":"Decidable\n  (∀ (X : Set Int),\n    X.Nonempty →\n      ExistsUnique fun m =>\n        And (Set.instMembership.mem X m) (∀ (n : Int), Set.instMembership.mem X n → Int.instLEInt.le m n))","name":["Chapter8","Int","exists_unique_min"],"kind":"definition","isProp":false},{"valueReferences":[["Prod"],["Nat"],["Chapter8","CountablyInfinite"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Prod"],["Chapter8","CountablyInfinite"]],"type":"∀ {X Y : Type}, Chapter8.CountablyInfinite X → Chapter8.CountablyInfinite Y → Chapter8.CountablyInfinite (Prod X Y)","name":["Chapter8","CountablyInfinite","prod"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Nat","instInfSet"],["Chapter8","Nat","min"],["OfNat","ofNat"],["Nat"],["instOfNatNat"],["InfSet","sInf"],["Lean","Name","num"],["Eq"]],"typeReferences":[["Set","Nonempty"],["Nat"],["Set"],["InfSet","sInf"],["Eq"],["Nat","instInfSet"],["Chapter8","Nat","min"]],"type":"∀ {X : Set Nat}, X.Nonempty → Eq (Chapter8.Nat.min X) (Nat.instInfSet.sInf X)","name":["Chapter8","Nat","min_eq_sInf"],"kind":"theorem","isProp":true},{"valueReferences":[["implies_congr"],["instAddNat"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["SubtractionMonoid","toSubNegZeroMonoid"],["Subtype","mk","injEq"],["Ring","toNonAssocRing"],["sorryAx"],["Eq","trans"],["Bool","false"],["Lean","Name","str"],["AddGroupWithOne","toAddMonoidWithOne"],["Subtype","val"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["Chapter8","Nat","monotone_enum_of_infinite","match_1_1"],["Set","Elem"],["Int","instCommSemiring"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["False","elim"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["SubNegMonoid","toSub"],["Eq","symm"],["Int","instLTInt"],["Nat","strongRec"],["Chapter8","Nat","monotone_enum_of_infinite","match_1_3"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["instLTNat"],["Exists"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Function","Bijective"],["Ring","toSemiring"],["Set","instMembership"],["instOfNat"],["eq_false"],["Eq","refl"],["AddMonoid","toAddSemigroup"],["Classical","byContradiction"],["AddMonoidWithOne","toOne"],["Int","negOfNat"],["Eq","mpr"],["Nat","rawCast"],["ExistsUnique","intro"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["StrictMono"],["setOf"],["SubtractionCommMonoid","toSubtractionMonoid"],["EmptyCollection","emptyCollection"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Int","add_one_le_iff"],["Int","instRing"],["LE","le","trans"],["Nat","instPreorder"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["Int","instAdd"],["Int","instIsStrictOrderedRing"],["Mathlib","Tactic","Ring","neg_one_mul"],["Eq"],["Infinite"],["instNatCastInt"],["Subtype","val_injective"],["Distrib","toAdd"],["Mathlib","Tactic","Ring","neg_zero"],["IsStrictOrderedRing","toIsOrderedRing"],["Set"],["Int","instIsOrderedAddMonoid"],["Infinite","instNontrivial"],["ge_iff_le"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["HPow","hPow"],["Function","Surjective"],["OfNat","ofNat"],["Int"],["Nat","cast_add"],["HAdd","hAdd"],["AddGroupWithOne","toAddGroup"],["Monoid","toNatPow"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["instDecidableEqNat"],["Int","instNormedCommRing"],["Ne"],["Lean","Name","num"],["neg_neg_of_pos"],["instHSub"],["Function","Injective"],["Nat","cast_one"],["Decidable","not_not","_simp_1"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Lean","Name"],["Membership","mem"],["Subtype","preorder"],["Preorder","toLT"],["HMul","hMul"],["Int","rawCast"],["Mathlib","Tactic","PushNeg","not_ne_eq"],["AddMonoidWithOne","toAddMonoid"],["GE","ge"],["Chapter8","Nat","min"],["And","intro"],["not_false_eq_true"],["Semiring","toNonAssocSemiring"],["Ring","toAddGroupWithOne"],["forall_congr"],["funext"],["Int","instLEInt"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["AddGroup","toSubNegMonoid"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Int","ofNat"],["NonAssocRing","toNonUnitalNonAssocRing"],["And","left"],["SemilatticeInf","toPartialOrder"],["AddSemigroup","toAdd"],["instHPow"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["And","right"],["And"],["Chapter8","Nat","min_spec"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Decidable","byContradiction"],["Nat"],["Mathlib","Tactic","Ring","atom_pf"],["AddMonoidWithOne","toNatCast"],["Iff","mpr"],["id"],["instHMul"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Set","Nonempty","of_subtype"],["Subtype"],["Lean","Name","anonymous"],["Nat","cast"],["Eq","mp"],["Mathlib","Meta","NormNum","isInt_add"],["Mathlib","Tactic","Ring","neg_mul"],["Nat","strongRec","eq_def"],["Set","instEmptyCollection"],["SubNegZeroMonoid","toNegZeroClass"],["congrArg"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["MonoidWithZero","toMonoid"],["Mathlib","Tactic","Ring","sub_congr"],["Zero","toOfNat0"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Not"],["Set","Nonempty"],["Lattice","toSemilatticeInf"],["True"],["instHAdd"],["Distrib","toMul"],["CommSemiring","toSemiring"],["Nontrivial","to_nonempty"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Ring","cast_pos"],["Mathlib","Tactic","Ring","add_congr"],["Mathlib","Tactic","Contrapose","mtr"],["LT","lt"],["NegZeroClass","toNeg"],["of_eq_true"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["Mathlib","Tactic","Ring","neg_add"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_congr"],["Int","instSemiring"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["LE","le"],["Chapter8","Nat","monotone_enum_of_infinite","_simp_1_5"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["False"],["Subtype","instDecidableEq"],["Subtype","mk"],["Mathlib","Tactic","PushNeg","not_nonempty_eq"],["instLENat"],["Int","instAddMonoid"],["NormedCommRing","toNonUnitalNormedCommRing"]],"typeReferences":[["Nat"],["Set"],["Membership","mem"],["Subtype","preorder"],["And"],["ExistsUnique"],["Function","Bijective"],["Infinite"],["Set","Elem"],["Set","instMembership"],["Nat","instPreorder"],["StrictMono"]],"type":"∀ (X : Set Nat) [Infinite X.Elem], ExistsUnique fun f => And (Function.Bijective f) (StrictMono f)","name":["Chapter8","Nat","monotone_enum_of_infinite"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists"],["Function","Bijective"]],"typeReferences":[],"type":"Type → Type → Prop","name":["Chapter8","EqualCard"],"kind":"definition","isProp":false},{"valueReferences":[["Subtype"],["Eq","trans"],["Eq","mp"],["Membership","mem"],["eq_true"],["DFunLike","coe"],["Subtype","val"],["Function","instEmbeddingLikeEmbedding"],["Set","range"],["congrArg"],["funext"],["Eq","symm"],["exists_eq","_simp_1"],["Function","LeftInverse","eq_1"],["Eq"],["Function","instFunLikeEmbedding"],["Eq","rec"],["Not"],["Exists"],["True"],["Set"],["Set","mem_range","_simp_1"],["Function","Embedding"],["Function","comp_apply"],["Nonempty"],["True","intro"],["Function","comp"],["Lean","Grind","nestedProof"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Set","instMembership"],["Set","univ"],["Set","image_univ"],["Nat"],["Set","image"],["of_eq_true"],["instNonemptyOfInhabited"],["eq_false"],["Eq","refl"],["Classical","byContradiction"],["Function","LeftInverse"],["False"],["Function","invFun"],["instInhabitedNat"],["Lean","Grind","intro_with_eq"],["Subtype","mk"]],"typeReferences":[["Eq","trans"],["Membership","mem"],["DFunLike","coe"],["Subtype","val"],["Function","instEmbeddingLikeEmbedding"],["Set","Elem"],["Set","range"],["congrArg"],["funext"],["Eq","symm"],["exists_eq","_simp_1"],["Function","instFunLikeEmbedding"],["Eq"],["Eq","ndrec"],["Exists"],["True"],["Set"],["Set","mem_range","_simp_1"],["Function","Embedding"],["Function","comp"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Set","instMembership"],["Set","univ"],["Set","image_univ"],["Set","image"],["Nat"],["of_eq_true"],["instNonemptyOfInhabited"],["Function","LeftInverse"],["Function","invFun"],["instInhabitedNat"],["Subtype","mk"]],"type":"∀ {A : Type} (X : Set A) (f : Function.Embedding Nat A)\n  (hf : Eq X (Set.image (Function.instFunLikeEmbedding.coe f) Set.univ)),\n  Function.LeftInverse (Function.invFun (Function.instFunLikeEmbedding.coe f)) (Function.instFunLikeEmbedding.coe f) →\n    ∀ (n : Nat),\n      Eq\n        (Function.comp (Function.invFun (Function.instFunLikeEmbedding.coe f)) Subtype.val\n          ⟨Function.instFunLikeEmbedding.coe f n, ⋯⟩)\n        n","name":["Chapter8","CountablyInfinite","iff_image_inj","_proof_1_9"],"kind":"theorem","isProp":true},{"valueReferences":[["Eq","trans"],["Membership","mem"],["eq_true"],["heq_of_eq"],["Subtype","val"],["eq_of_heq"],["Eq","symm"],["Function","instFunLikeEmbedding"],["Eq","ndrec"],["FunLike"],["Exists"],["HEq","trans"],["Function","Embedding"],["And"],["Nonempty"],["True","intro"],["Set","mem_image"],["Lean","Grind","nestedProof"],["Set","instMembership"],["Exists","casesOn"],["Nat"],["Set","image"],["instNonemptyOfInhabited"],["eq_false"],["Iff"],["Eq","refl"],["Classical","byContradiction"],["HEq"],["Function","LeftInverse"],["Function","invFun"],["instInhabitedNat"],["Subtype"],["Eq","mp"],["Lean","Grind","nestedProof_congr"],["DFunLike","coe"],["congrArg"],["DFunLike","coe","hcongr_6"],["congr"],["Eq"],["Function","LeftInverse","eq_1"],["True"],["HEq","refl"],["Set"],["Function","comp_apply"],["Function","comp"],["Set","univ"],["of_eq_true"],["Lean","Grind","iff_eq"],["False"],["Subtype","mk"],["Lean","Grind","intro_with_eq"],["And","casesOn"]],"typeReferences":[["Set"],["Function","Embedding"],["Membership","mem"],["Function","comp"],["Subtype","val"],["DFunLike","coe"],["Set","Elem"],["Set","instMembership"],["Set","univ"],["Nat"],["Set","image"],["instNonemptyOfInhabited"],["Function","LeftInverse"],["Function","invFun"],["instInhabitedNat"],["Subtype","mk"],["Eq"],["Function","instFunLikeEmbedding"]],"type":"∀ {A : Type} (X : Set A) (f : Function.Embedding Nat A),\n  Eq X (Set.image (Function.instFunLikeEmbedding.coe f) Set.univ) →\n    Function.LeftInverse (Function.invFun (Function.instFunLikeEmbedding.coe f)) (Function.instFunLikeEmbedding.coe f) →\n      ∀ (x : A) (hx : Set.instMembership.mem X x) (y : A) (hy : Set.instMembership.mem X y),\n        Eq (Function.comp (Function.invFun (Function.instFunLikeEmbedding.coe f)) Subtype.val ⟨x, hx⟩)\n            (Function.comp (Function.invFun (Function.instFunLikeEmbedding.coe f)) Subtype.val ⟨y, hy⟩) →\n          Eq ⟨x, hx⟩ ⟨y, hy⟩","name":["Chapter8","CountablyInfinite","iff_image_inj","_proof_1_7"],"kind":"theorem","isProp":true},{"valueReferences":[["Function","leftInverse_invFun"],["Classical","choose_spec"],["Eq","trans"],["Chapter8","CountablyInfinite","iff_image_inj","_proof_1_7"],["Membership","mem"],["Iff","mp"],["Exists","intro"],["Subtype","val"],["Classical","choose"],["Function","instEmbeddingLikeEmbedding"],["Set","Elem"],["And","intro"],["Subtype","coe_prop","_simp_1"],["funext"],["Eq","symm"],["Function","instFunLikeEmbedding"],["Eq","ndrec"],["Function","bijective_iff_has_inverse"],["And","left"],["Chapter8","CountablyInfinite"],["Exists"],["Set","mem_range","_simp_1"],["And","right"],["Function","Embedding"],["And"],["Function","Bijective"],["Set","instMembership"],["Exists","casesOn"],["Function","RightInverse"],["Set","image_univ"],["Nat"],["Set","image"],["Function","Embedding","injective"],["instNonemptyOfInhabited"],["Iff"],["Eq","refl"],["Function","LeftInverse"],["id"],["Function","invFun"],["Set","ext"],["instInhabitedNat"],["Eq","mpr"],["Subtype"],["Eq","mp"],["DFunLike","coe"],["Set","image_congr"],["Set","range"],["Iff","intro"],["congrArg"],["Chapter8","CountablyInfinite","iff_image_inj","match_1_5"],["exists_eq","_simp_1"],["Chapter8","CountablyInfinite","iff_image_inj","_simp_1_3"],["Eq"],["Function","Embedding","mk"],["True"],["Set"],["Chapter8","CountablyInfinite","iff_image_inj","_proof_1_9"],["Function","comp"],["Function","Surjective"],["EmbeddingLike","apply_eq_iff_eq","_simp_1"],["Set","univ"],["eq_self"],["of_eq_true"],["Chapter8","CountablyInfinite","iff_image_inj","match_1_1"],["Subtype","casesOn"],["Subtype","mk"],["Function","RightInverse","injective"],["Function","Injective"]],"typeReferences":[["Set","univ"],["Set","image"],["Nat"],["Chapter8","CountablyInfinite"],["Exists"],["Set"],["Iff"],["Function","Embedding"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"],["Set","Elem"]],"type":"∀ {A : Type} (X : Set A),\n  Iff (Chapter8.CountablyInfinite X.Elem)\n    (Exists fun f => Eq X (Set.image (Function.instFunLikeEmbedding.coe f) Set.univ))","name":["Chapter8","CountablyInfinite","iff_image_inj"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","EqualCard"],["Chapter8","EqualCard","refl"],["Chapter8","EqualCard","trans"],["Chapter8","EqualCard","symm"],["Equivalence","mk"]],"typeReferences":[["Equivalence"],["Chapter8","EqualCard"]],"type":"Equivalence Chapter8.EqualCard","name":["Chapter8","EqualCard","instSetoid","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","CountablyInfinite"],["And"],["Countable"],["Chapter8","CountablyInfinite","iff'"],["Infinite"],["propext"]],"typeReferences":[["Chapter8","CountablyInfinite"],["And"],["Countable"],["Eq"],["Infinite"]],"type":"∀ (X : Type), Eq (Chapter8.CountablyInfinite X) (And (Countable X) (Infinite X))","name":["Chapter8","CountablyInfinite","toInfinite","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter8","explicit_bijection"],["Rat"],["Function","Bijective"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Nat"],["Chapter8","explicit_bijection"],["Rat"],["Function","Bijective"]],"type":"Function.Bijective Chapter8.explicit_bijection","name":["Chapter8","explicit_bijection_spec"],"kind":"theorem","isProp":true},{"valueReferences":[["sorryAx"],["Lean","Name","anonymous"],["Lean","Name"],["Bool","false"],["Lean","Name","str"],["Set","Elem"],["OfNat","ofNat"],["Set","univ"],["Chapter8","AtMostCountable"],["Set","image"],["Nat"],["instOfNatNat"],["Lean","Name","num"]],"typeReferences":[["Set","univ"],["Chapter8","AtMostCountable"],["Set","image"],["Nat"],["Set","Elem"]],"type":"∀ (Y : Type) (f : Nat → Y), Chapter8.AtMostCountable (Set.image f Set.univ).Elem","name":["Chapter8","AtMostCountable","image_nat"],"kind":"theorem","isProp":true},{"valueReferences":[["Equiv","bijective"],["Exists"],["Chapter8","EqualCard"],["Exists","intro"],["Nonempty"],["Function","Bijective"],["Equiv"],["Chapter8","EqualCard","iff","match_1_1"],["Iff","intro"],["Nonempty","intro"],["Iff"],["Chapter8","EqualCard","iff","match_1_3"],["Equiv","ofBijective"],["id"],["Equiv","toFun"]],"typeReferences":[["Iff"],["Chapter8","EqualCard"],["Nonempty"],["Equiv"]],"type":"∀ {X Y : Type}, Iff (Chapter8.EqualCard X Y) (Nonempty (Equiv X Y))","name":["Chapter8","EqualCard","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Subtype","casesOn"],["Set","instMembership"]],"typeReferences":[["Set"],["Membership","mem"],["Subtype","mk"],["Set","Elem"],["Set","instMembership"]],"type":"∀ {A : Type} {Y : Set A} (motive : Y.Elem → Prop) (h : Y.Elem),\n  (∀ (y : A) (hy : Set.instMembership.mem Y y), motive ⟨y, hy⟩) → motive h","name":["Chapter8","AtMostCountable","subset'","match_1_3"],"kind":"definition","isProp":true},{"valueReferences":[["Nonempty","casesOn"],["Denumerable"]],"typeReferences":[["Nonempty","intro"],["Nonempty"],["Denumerable"]],"type":"∀ (X : Type) (motive : Nonempty (Denumerable X) → Prop) (h : Nonempty (Denumerable X)),\n  (∀ (h : Denumerable X), motive ⋯) → motive h","name":["Chapter8","CountablyInfinite","iff","match_1_4"],"kind":"definition","isProp":true},{"valueReferences":[["Set","univ"],["Exists","casesOn"],["Set","image"],["Nat"],["Set"],["Function","Embedding"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"]],"typeReferences":[["Set","univ"],["Set","image"],["Nat"],["Exists"],["Set"],["Function","Embedding"],["Exists","intro"],["Function","instFunLikeEmbedding"],["Eq"],["DFunLike","coe"]],"type":"∀ {A : Type} (X : Set A)\n  (motive : (Exists fun f => Eq X (Set.image (Function.instFunLikeEmbedding.coe f) Set.univ)) → Prop)\n  (h : Exists fun f => Eq X (Set.image (Function.instFunLikeEmbedding.coe f) Set.univ)),\n  (∀ (f : Function.Embedding Nat A) (hf : Eq X (Set.image (Function.instFunLikeEmbedding.coe f) Set.univ)), motive ⋯) →\n    motive h","name":["Chapter8","CountablyInfinite","iff_image_inj","match_1_5"],"kind":"definition","isProp":true},{"valueReferences":[["Setoid","mk"],["Chapter8","EqualCard"],["Chapter8","EqualCard","instSetoid","_proof_1"]],"typeReferences":[["Setoid"]],"type":"Setoid Type","name":["Chapter8","EqualCard","instSetoid"],"kind":"definition","isProp":false},{"valueReferences":[["Nat"],["Chapter8","CountablyInfinite"],["Chapter8","EqualCard","trans"],["Chapter8","EqualCard","symm"],["Iff","intro"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Iff"],["Chapter8","EqualCard"]],"type":"∀ {X Y : Type}, Chapter8.EqualCard X Y → Iff (Chapter8.CountablyInfinite X) (Chapter8.CountablyInfinite Y)","name":["Chapter8","CountablyInfinite","equiv"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Nat"],["Function","Bijective"],["Set","Elem"]],"typeReferences":[["Nat"],["Chapter8","CountablyInfinite"],["Set"],["Exists","intro"],["Function","Bijective"],["Set","Elem"]],"type":"∀ {A : Type} (X : Set A) (motive : Chapter8.CountablyInfinite X.Elem → Prop) (h : Chapter8.CountablyInfinite X.Elem),\n  (∀ (g : X.Elem → Nat) (hg : Function.Bijective g), motive ⋯) → motive h","name":["Chapter8","CountablyInfinite","iff_image_inj","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Nat"],["Nonempty","casesOn"],["Equiv"]],"typeReferences":[["Nonempty","intro"],["Nat"],["Nonempty"],["Equiv"]],"type":"∀ (X : Type) (motive : Nonempty (Equiv X Nat) → Prop) (h : Nonempty (Equiv X Nat)),\n  (∀ (e : Equiv X Nat), motive ⋯) → motive h","name":["Chapter8","CountablyInfinite","iff","match_1_2"],"kind":"definition","isProp":true},{"valueReferences":[["Chapter8","Nat","exists_unique_min"],["Nat"],["Set"],["LE","le"],["Membership","mem"],["And"],["instLENat"],["Set","instMembership"],["ExistsUnique","exists"]],"typeReferences":[["Set","Nonempty"],["Nat"],["Exists"],["Set"],["LE","le"],["Membership","mem"],["And"],["instLENat"],["Set","instMembership"]],"type":"∀ (X : Set Nat),\n  X.Nonempty →\n    Exists fun x => And (Set.instMembership.mem X x) (∀ (n : Nat), Set.instMembership.mem X n → instLENat.le x n)","name":["Chapter8","Nat","min","_proof_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Equiv","finite_iff"],["Iff"],["Equiv","ofBijective"],["Function","Bijective"],["Finite"]],"typeReferences":[["Iff"],["Chapter8","EqualCard"],["Finite"]],"type":"∀ {X Y : Type}, Chapter8.EqualCard X Y → Iff (Finite X) (Finite Y)","name":["Chapter8","Finite","equiv"],"kind":"theorem","isProp":true},{"valueReferences":[["Ring","toNonAssocRing"],["Bool","false"],["AddGroupWithOne","toAddMonoidWithOne"],["Int","instCommSemiring"],["le_of_not_gt"],["Int","instLTInt"],["Finset","sum"],["NonAssocSemiring","toAddCommMonoidWithOne"],["instLatticeInt"],["instLTNat"],["Exists"],["Function","Bijective"],["true_and"],["Ring","toSemiring"],["instOfNat"],["AddMonoid","toAddSemigroup"],["Int","negOfNat"],["Eq","mpr"],["exists_apply_eq_apply","_simp_1"],["StrictMono"],["Mathlib","Tactic","Linarith","lt_irrefl"],["Set","image_congr"],["Prod","fst"],["Prod","exists","_simp_1"],["Chapter8","CountablyInfinite","lower_diag","match_1_1"],["Mathlib","Tactic","Ring","neg_one_mul"],["Int","instIsStrictOrderedRing"],["Eq"],["instNatCastInt"],["Mathlib","Tactic","Ring","neg_zero"],["Set"],["Int","instIsOrderedAddMonoid"],["HPow","hPow"],["Nat","cast_add"],["Set","univ"],["eq_self"],["Monoid","toNatPow"],["instHSub"],["Function","Injective"],["PartialOrder","toPreorder"],["Mathlib","Meta","NormNum","IsNat","of_raw"],["Mathlib","Meta","NormNum","IsInt","of_raw"],["Mathlib","Tactic","Ring","add_pf_zero_add"],["Membership","mem"],["Preorder","toLT"],["GT","gt"],["GE","ge"],["Nat","instAddCommMonoid"],["Semiring","toNonAssocSemiring"],["Or"],["Int","instLEInt"],["AddGroup","toSubNegMonoid"],["instTransGe_mathlib"],["Finite"],["Int","ofNat"],["SemilatticeInf","toPartialOrder"],["Chapter8","Nat","atMostCountable_subset"],["Nat","instPartialOrder"],["NonAssocSemiring","toNonUnitalNonAssocSemiring"],["Exists","casesOn"],["Set","image_univ"],["Nat"],["AddMonoidWithOne","toNatCast"],["Mathlib","Tactic","Ring","atom_pf"],["NonUnitalNormedCommRing","toNonUnitalCommRing"],["Chapter8","CountablyInfinite","lower_diag","match_1_4"],["Nat","cast"],["Eq","mp"],["Set","range"],["neg_eq_zero"],["Mathlib","Tactic","Ring","add_pf_add_lt"],["AddCommMonoidWithOne","toAddMonoidWithOne"],["Prod","mk","injEq"],["lt_trichotomy"],["Not"],["instHAdd"],["Chapter8","AtMostCountable","equiv"],["Distrib","toMul"],["Mathlib","Tactic","Ring","cast_pos"],["Mathlib","Tactic","Ring","add_congr"],["LT","lt"],["One","toOfNat1"],["Mathlib","Tactic","Ring","neg_add"],["Mathlib","Tactic","Ring","add_pf_add_zero"],["of_eq_true"],["Mathlib","Tactic","Ring","neg_congr"],["Mathlib","Tactic","Linarith","sub_nonpos_of_le"],["Subtype","mk"],["NormedCommRing","toNonUnitalNormedCommRing"],["instAddNat"],["SubtractionMonoid","toSubNegZeroMonoid"],["Mathlib","Tactic","Linarith","add_lt_of_neg_of_le"],["Subtype","mk","injEq"],["sorryAx"],["Eq","trans"],["Lean","Name","str"],["Exists","intro"],["Set","Elem"],["Mathlib","Meta","NormNum","IsInt","to_raw_eq"],["instTransGeGt_mathlib"],["NonUnitalNonAssocRing","toNonUnitalNonAssocSemiring"],["False","elim"],["sub_eq_zero_of_eq"],["SubNegMonoid","toSub"],["NonUnitalNonAssocCommRing","toNonUnitalNonAssocCommSemiring"],["Subtype","exists","_simp_1"],["Mathlib","Tactic","Ring","add_overlap_pf_zero"],["Mathlib","Tactic","Ring","sub_pf"],["Eq","ndrec"],["Int","instAddGroup"],["NonUnitalCommRing","toNonUnitalNonAssocCommRing"],["Prod","snd"],["Finset","sum_range_succ"],["Set","instMembership"],["Prod"],["Eq","refl"],["AddMonoidWithOne","toOne"],["Nat","rawCast"],["setOf"],["Mathlib","Meta","NormNum","IsNat","to_isInt"],["SubtractionCommMonoid","toSubtractionMonoid"],["Int","instRing"],["Int","add_one_le_iff"],["Nat","instPreorder"],["Prod","casesOn"],["Mathlib","Tactic","Ring","add_pf_add_overlap_zero"],["Int","instAddCommGroup"],["instOfNatNat"],["congr"],["Int","instAdd"],["Preorder","toLE"],["propext"],["lt_of_not_ge"],["Finset","range"],["Distrib","toAdd"],["IsStrictOrderedRing","toIsOrderedRing"],["Mathlib","Tactic","Zify","natCast_lt","_simp_1"],["Function","Surjective"],["OfNat","ofNat"],["Int"],["HAdd","hAdd"],["LinearOrder","toPartialOrder"],["AddGroupWithOne","toAddGroup"],["AddCommGroup","toDivisionAddCommMonoid"],["MulZeroClass","toZero"],["NonUnitalNonAssocSemiring","toMulZeroClass"],["Nat","add_left_cancel_iff","_simp_1"],["Int","instNormedCommRing"],["Subtype","casesOn"],["Lean","Name","num"],["neg_neg_of_pos"],["Nat","cast_one"],["Trans","trans"],["Mathlib","Meta","NormNum","IsNat","to_raw_eq"],["Mathlib","Tactic","Linarith","lt_of_lt_of_eq"],["Lean","Name"],["Prod","mk"],["Int","rawCast"],["HMul","hMul"],["AddMonoidWithOne","toAddMonoid"],["Chapter8","AtMostCountable"],["And","intro"],["Ring","toAddGroupWithOne"],["HSub","hSub"],["Mathlib","Meta","NormNum","IsInt","to_isNat"],["Mathlib","Tactic","Linarith","zero_lt_one"],["Nat","instLinearOrder"],["NonAssocRing","toNonUnitalNonAssocRing"],["AddSemigroup","toAdd"],["instHPow"],["Chapter8","CountablyInfinite"],["NonUnitalNonAssocSemiring","toDistrib"],["Neg","neg"],["Set","mem_range","_simp_1"],["And"],["Mathlib","Tactic","Linarith","natCast_nonneg"],["NonUnitalNonAssocCommSemiring","toNonUnitalNonAssocSemiring"],["Set","image"],["Iff","mpr"],["Mathlib","Meta","NormNum","instAddMonoidWithOne"],["id"],["NegZeroClass","toZero"],["instHMul"],["instTransEq_1"],["Mathlib","Meta","NormNum","isNat_ofNat"],["Lean","Name","anonymous"],["Subtype"],["Mathlib","Tactic","Zify","natCast_eq","_simp_1"],["Mathlib","Tactic","Ring","neg_mul"],["Mathlib","Meta","NormNum","isInt_add"],["SubNegZeroMonoid","toNegZeroClass"],["congrArg"],["Mathlib","Tactic","Ring","instCommSemiringNat"],["MonoidWithZero","toMonoid"],["Zero","toOfNat0"],["Mathlib","Tactic","Ring","sub_congr"],["Mathlib","Tactic","Ring","cast_zero"],["Mathlib","Meta","NormNum","isInt_mul"],["Mathlib","Tactic","Ring","of_eq"],["Lattice","toSemilatticeInf"],["True"],["CommSemiring","toSemiring"],["Semiring","toMonoidWithZero"],["Mathlib","Tactic","Zify","natCast_le","_simp_1"],["StrictMono","monotone"],["Or","casesOn"],["NegZeroClass","toNeg"],["Int","instSemiring"],["LE","le"],["Mathlib","Tactic","Ring","add_pf_add_gt"],["Int","instAddMonoid"],["instLENat"]],"typeReferences":[["Prod"],["Nat"],["Chapter8","CountablyInfinite"],["LE","le"],["Prod","snd"],["instLENat"],["Set","Elem"],["Prod","fst"],["setOf"]],"type":"Chapter8.CountablyInfinite (setOf fun n => instLENat.le n.snd n.fst).Elem","name":["Chapter8","CountablyInfinite","lower_diag"],"kind":"theorem","isProp":true},{"valueReferences":[["Exists","casesOn"],["Function","Bijective"]],"typeReferences":[["Exists"],["Exists","intro"],["Function","Bijective"]],"type":"∀ {X Y : Type} (motive : (Exists fun f => Function.Bijective f) → Prop) (h : Exists fun f => Function.Bijective f),\n  (∀ (f : X → Y) (hf : Function.Bijective f), motive ⋯) → motive h","name":["Chapter8","EqualCard","iff","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Chapter8","CountablyInfinite"],["Chapter8","CountablyInfinite","iff","match_1_4"],["Denumerable","mk'"],["Chapter8","EqualCard"],["Nonempty"],["Denumerable"],["Equiv"],["congrArg"],["Iff","intro"],["Nonempty","intro"],["Nat"],["Iff"],["Chapter8","CountablyInfinite","iff","_simp_1_1"],["id"],["Eq","mpr"],["Denumerable","eqv"],["Chapter8","CountablyInfinite","iff","match_1_2"],["Eq"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Iff"],["Nonempty"],["Denumerable"]],"type":"∀ (X : Type), Iff (Chapter8.CountablyInfinite X) (Nonempty (Denumerable X))","name":["Chapter8","CountablyInfinite","iff"],"kind":"theorem","isProp":true},{"valueReferences":[["Set"],["Membership","mem"],["Subtype","mk"],["Subtype","casesOn"],["Subtype","val"],["Set","Elem"],["setOf"],["Set","instMembership"]],"typeReferences":[["Set"],["Membership","mem"],["Subtype","mk"],["Subtype","val"],["Set","Elem"],["Set","instMembership"],["setOf"]],"type":"∀ {A : Type} {X Y : Set A} (motive : (setOf fun x => Set.instMembership.mem Y x.val).Elem → Prop)\n  (h : (setOf fun x => Set.instMembership.mem Y x.val).Elem),\n  (∀ (val : A) (property : Set.instMembership.mem X val)\n      (property_1 : Set.instMembership.mem (setOf fun x => Set.instMembership.mem Y x.val) ⟨val, property⟩),\n      motive ⟨⟨val, property⟩, property_1⟩) →\n    motive h","name":["Chapter8","AtMostCountable","subset'","match_1_1"],"kind":"definition","isProp":true},{"valueReferences":[["Subtype"],["Eq","trans"],["exists_const","_simp_1"],["Membership","mem"],["Exists","intro"],["Subtype","val"],["Set","Elem"],["congrArg"],["And","intro"],["funext"],["Subtype","exists","_simp_1"],["exists_eq","_simp_1"],["Eq"],["propext"],["Subtype","val_injective"],["Exists"],["True"],["Set"],["Set","mem_univ","_simp_1"],["Function","Bijective"],["Function","Surjective"],["Set","instMembership"],["exists_prop_congr"],["Set","univ"],["of_eq_true"],["Iff","of_eq"],["instNonemptyOfInhabited"],["Eq","refl"],["Subtype","mk"],["instInhabitedTrue"],["Function","Injective"]],"typeReferences":[["Set","univ"],["Chapter8","EqualCard"],["Set","Elem"]],"type":"∀ (X : Type), Chapter8.EqualCard Set.univ.Elem X","name":["Chapter8","EqualCard","univ"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","Nat","exists_unique_min"],["Nat"],["Set"],["LE","le"],["Membership","mem"],["And"],["ExistsUnique","unique"],["instLENat"],["Chapter8","Nat","min"],["Chapter8","Nat","min_spec"],["Set","instMembership"]],"typeReferences":[["Set","Nonempty"],["Nat"],["Set"],["LE","le"],["Membership","mem"],["And"],["Eq"],["instLENat"],["Chapter8","Nat","min"],["Set","instMembership"]],"type":"∀ {X : Set Nat},\n  X.Nonempty →\n    ∀ {a : Nat},\n      And (Set.instMembership.mem X a) (∀ (n : Nat), Set.instMembership.mem X n → instLENat.le a n) →\n        Eq (Chapter8.Nat.min X) a","name":["Chapter8","Nat","min_eq"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","EqualCard","iff"],["Chapter8","EqualCard"],["Nonempty"],["Equiv"],["propext"]],"typeReferences":[["Chapter8","EqualCard"],["Nonempty"],["Eq"],["Equiv"]],"type":"∀ {X Y : Type}, Eq (Chapter8.EqualCard X Y) (Nonempty (Equiv X Y))","name":["Chapter8","CountablyInfinite","iff","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Set","mem_image","_simp_1"],["Lean","Name","anonymous"],["sorryAx"],["Eq","trans"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Membership","mem"],["eq_true"],["Exists","intro"],["or_true"],["Subtype","val"],["Set","Elem"],["congrArg"],["Chapter8","AtMostCountable"],["And","intro"],["Or"],["instOfNatNat"],["Finite"],["Eq"],["propext"],["Chapter8","Nat","atMostCountable_subset"],["Chapter8","CountablyInfinite"],["Exists"],["True"],["Set"],["Chapter8","AtMostCountable","equiv"],["Subtype","finite"],["And"],["Function","Bijective"],["OfNat","ofNat"],["Set","instMembership"],["Exists","casesOn"],["Or","casesOn"],["Set","image"],["Nat"],["of_eq_true"],["Eq","refl"],["id"],["inferInstance"],["Eq","mpr"],["Lean","Name","num"],["Subtype","mk"],["Subtype","casesOn"]],"typeReferences":[["Chapter8","AtMostCountable"],["Set"],["Set","Elem"]],"type":"∀ {X : Type}, Chapter8.AtMostCountable X → ∀ (Y : Set X), Chapter8.AtMostCountable Y.Elem","name":["Chapter8","AtMostCountable","subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Subtype"],["Subtype","val_inj"],["Eq"],["Subtype","val"],["propext"]],"typeReferences":[["Subtype"],["Eq"],["Subtype","val"]],"type":"∀ {α : Sort u_1} {p : α → Prop} {a b : Subtype p}, Eq (Eq a.val b.val) (Eq a b)","name":["Chapter8","CountablyInfinite","iff_image_inj","_simp_1_3"],"kind":"theorem","isProp":true},{"valueReferences":[["Prod","casesOn"],["instOfNat"],["Ne"],["OfNat","ofNat"],["Set","Elem"],["setOf"],["Int"]],"typeReferences":[["Prod"],["instOfNat"],["Prod","mk"],["Ne"],["OfNat","ofNat"],["Set","Elem"],["setOf"],["Int"]],"type":"(motive : Prod Int (setOf fun n => Ne n 0).Elem → Sort u_1) →\n  (x : Prod Int (setOf fun n => Ne n 0).Elem) →\n    ((a : Int) → (b : (setOf fun n => Ne n 0).Elem) → motive { fst := a, snd := b }) → motive x","name":["Chapter8","Rat","countablyInfinite","match_1_1"],"kind":"definition","isProp":false},{"valueReferences":[["Not"],["finite_or_infinite"],["Chapter8","CountablyInfinite"],["Exists"],["true_or"],["True"],["Eq","trans"],["Function","Bijective"],["Set","Elem"],["congrArg"],["Or","casesOn"],["Chapter8","AtMostCountable"],["Classical","or_iff_not_imp_left"],["Nat"],["Or"],["of_eq_true"],["Chapter8","Nat","atMostCountable_subset","_simp_1_1"],["Iff","mpr"],["Finite"],["Infinite"]],"typeReferences":[["Chapter8","AtMostCountable"],["Nat"],["Set"],["Set","Elem"]],"type":"∀ (X : Set Nat), Chapter8.AtMostCountable X.Elem","name":["Chapter8","Nat","atMostCountable_subset"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Chapter8","CountablyInfinite"],["Chapter8","Nat","countable_of_infinite"],["eq_true"],["Set","Elem"]],"typeReferences":[["Nat"],["Exists"],["True"],["Set"],["Function","Bijective"],["Eq"],["Infinite"],["Set","Elem"]],"type":"∀ (X : Set Nat) [Infinite X.Elem], Eq (Exists fun f => Function.Bijective f) True","name":["Chapter8","Nat","atMostCountable_subset","_simp_1_1"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Chapter8","EqualCard"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Chapter8","EqualCard"]],"type":"∀ {X Y : Type}, Chapter8.EqualCard X Y → Chapter8.EqualCard Y X","name":["Chapter8","EqualCard","symm"],"kind":"theorem","isProp":true},{"valueReferences":[["Int","instSub"],["Eq","trans"],["le_of_le_of_eq"],["Eq","symm"],["Lean","Omega","tidy_sat"],["HSub","hSub"],["Int","instLEInt"],["Lean","Omega","LinearCombo","add_eval"],["Int","add_one_le_of_lt"],["List","cons"],["Bool","true"],["And","left"],["Neg","neg"],["And","right"],["Lean","Omega","Constraint","addInequality_sat"],["Lean","Omega","LinearCombo","coordinate"],["Int","instNegInt"],["instDecidableEqBool"],["Nat"],["instOfNat"],["Eq","refl"],["Nat","lt_of_not_le"],["id"],["Lean","Omega","Int","sub_congr"],["Lean","Omega","LinearCombo","instAdd"],["Nat","cast"],["Bool"],["Lean","Omega","LinearCombo","coordinate_eval_0"],["Lean","Omega","Constraint","combine_sat'"],["Option","some"],["Decidable","decide"],["Lean","Omega","LinearCombo","mk"],["Lean","Omega","LinearCombo","instSub"],["Lean","Omega","Coeffs","ofList"],["instOfNatNat"],["Int","instAdd"],["Lean","Omega","Constraint","not_sat'_of_isImpossible"],["Eq"],["Lean","Omega","and_not_not_of_not_or"],["instNatCastInt"],["of_decide_eq_true"],["List","nil"],["Not"],["instHAdd"],["Lean","Omega","LinearCombo"],["Lean","Omega","Int","add_congr"],["Lean","Omega","Constraint","isImpossible"],["OfNat","ofNat"],["Int","sub_nonneg_of_le"],["Int"],["Lean","Omega","LinearCombo","coordinate_eval_1"],["HAdd","hAdd"],["Lean","Omega","LinearCombo","sub_eval"],["Option","none"],["Lean","Omega","Int","ofNat_lt_of_lt"],["LE","le"],["Lean","Omega","Constraint","mk"],["Lean","Omega","LinearCombo","eval"],["instHSub"],["instLENat"]],"typeReferences":[["Not"],["Nat"],["Or"],["LE","le"],["False"],["instLENat"]],"type":"∀ (n m : Nat), Not (Or (instLENat.le m n) (instLENat.le n m)) → False","name":["Chapter8","CountablyInfinite","prod_nat","_proof_1_10"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","EqualCard","iff"],["Chapter8","EqualCard"],["Nonempty"],["Equiv"],["propext"]],"typeReferences":[["Chapter8","EqualCard"],["Nonempty"],["Eq"],["Equiv"]],"type":"∀ {X Y : Type}, Eq (Chapter8.EqualCard X Y) (Nonempty (Equiv X Y))","name":["Chapter8","EqualCard","iff'","_simp_1_2"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","CountablyInfinite"],["And"],["Nonempty"],["Iff","rfl"],["Denumerable"],["congrArg"],["nonempty_denumerable_iff"],["Iff"],["id"],["Eq","mpr"],["Countable"],["Eq"],["Chapter8","CountablyInfinite","iff"],["Infinite"],["propext"]],"typeReferences":[["Chapter8","CountablyInfinite"],["Iff"],["And"],["Countable"],["Infinite"]],"type":"∀ (X : Type), Iff (Chapter8.CountablyInfinite X) (And (Countable X) (Infinite X))","name":["Chapter8","CountablyInfinite","iff'"],"kind":"theorem","isProp":true},{"valueReferences":[["Nat"],["Lean","Name","anonymous"],["sorryAx"],["instOfNatNat"],["Lean","Name"],["Lean","Name","str"],["Bool","false"],["Rat"],["Lean","Name","num"],["OfNat","ofNat"]],"typeReferences":[["Nat"],["Rat"]],"type":"Nat → Rat","name":["Chapter8","explicit_bijection"],"kind":"definition","isProp":false},{"valueReferences":[["Set","eq_empty_iff_forall_notMem"],["Not"],["Set"],["Membership","mem"],["Set","instEmptyCollection"],["EmptyCollection","emptyCollection"],["Eq"],["propext"],["Set","instMembership"]],"typeReferences":[["Not"],["Set"],["Membership","mem"],["Set","instEmptyCollection"],["EmptyCollection","emptyCollection"],["Eq"],["Set","instMembership"]],"type":"∀ {α : Type u} {s : Set α},\n  Eq (Eq s Set.instEmptyCollection.emptyCollection) (∀ (x : α), Not (Set.instMembership.mem s x))","name":["Chapter8","Nat","monotone_enum_of_infinite","_simp_1_5"],"kind":"theorem","isProp":true},{"valueReferences":[["Chapter8","CountablyInfinite"],["Or"],["Finite"]],"typeReferences":[],"type":"Type → Prop","name":["Chapter8","AtMostCountable"],"kind":"definition","isProp":false},{"valueReferences":[["Chapter8","CountablyInfinite"],["And"],["Countable"],["Chapter8","CountablyInfinite","iff'"],["Infinite"],["propext"]],"typeReferences":[["Chapter8","CountablyInfinite"],["And"],["Countable"],["Eq"],["Infinite"]],"type":"∀ (X : Type), Eq (Chapter8.CountablyInfinite X) (And (Countable X) (Infinite X))","name":["Chapter8","CountablyInfinite","toCountable","_simp_1_1"],"kind":"theorem","isProp":true}]
