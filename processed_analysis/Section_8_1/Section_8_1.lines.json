[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":23},{"state":[],"start":27},{"state":[],"start":67},{"state":[],"start":68},{"state":[],"start":164},{"state":[],"start":252},{"state":[],"start":347},{"state":[],"start":440},{"state":[],"start":450},{"state":[],"start":451},{"state":[],"start":499},{"state":[],"start":500},{"state":[],"start":601},{"state":[],"start":685},{"state":[],"start":731},{"state":[],"start":732},{"state":[],"start":906},{"state":[],"start":907},{"state":[],"start":910},{"state":[],"start":911},{"state":[],"start":930},{"state":[],"start":931},{"state":[],"start":1033},{"state":[],"start":1128},{"state":[],"start":1171},{"state":[],"start":1249},{"state":[],"start":1250},{"state":[],"start":1297},{"state":[{"type":"EqualCard X Y ↔ Nonempty (X ≃ Y)","tag":[],"mvarId":["_uniq",40],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",38],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",39],"binderInfo":"implicit"}]}],"start":1377},{"state":[{"type":"(∃ f, Function.Bijective f) → Nonempty (X ≃ Y)","tag":["mp"],"mvarId":["_uniq",11668],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",38],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",39],"binderInfo":"implicit"}]},{"type":"Nonempty (X ≃ Y) → ∃ f, Function.Bijective f","tag":["mpr"],"mvarId":["_uniq",11669],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",38],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",39],"binderInfo":"implicit"}]}],"start":1409},{"state":[{"type":"Nonempty (X ≃ Y) → ∃ f, Function.Bijective f","tag":["mpr"],"mvarId":["_uniq",11669],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",38],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",39],"binderInfo":"implicit"}]}],"start":1466},{"state":[],"start":1520},{"state":[],"start":1521},{"state":[],"start":1577},{"state":[{"type":"EqualCard X Y ↔ Cardinal.mk X = Cardinal.mk Y","tag":[],"mvarId":["_uniq",11912],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",11910],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",11911],"binderInfo":"implicit"}]}],"start":1669},{"state":[],"start":1695},{"state":[],"start":1696},{"state":[],"start":1755},{"state":[],"start":1756},{"state":[{"type":"EqualCard Y X","tag":[],"mvarId":["_uniq",24337],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",24334],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",24335],"binderInfo":"implicit"},{"type":"EqualCard X Y","name":["hXY"],"isProp":true,"id":["_uniq",24336],"binderInfo":"default"}]}],"start":1836},{"state":[],"start":1844},{"state":[],"start":1845},{"state":[],"start":1930},{"state":[{"type":"EqualCard X Z","tag":[],"mvarId":["_uniq",24361],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",24356],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",24357],"binderInfo":"implicit"},{"type":"Type","name":["Z"],"isProp":false,"id":["_uniq",24358],"binderInfo":"implicit"},{"type":"EqualCard X Y","name":["hXY"],"isProp":true,"id":["_uniq",24359],"binderInfo":"default"},{"type":"EqualCard Y Z","name":["hYZ"],"isProp":true,"id":["_uniq",24360],"binderInfo":"default"}]}],"start":1952},{"state":[],"start":1960},{"state":[],"start":1961},{"state":[],"start":2053},{"state":[],"start":2054},{"state":[],"start":2121},{"state":[],"start":2185},{"state":[],"start":2186},{"state":[],"start":2248},{"state":[],"start":2249},{"state":[],"start":2326},{"state":[],"start":2327},{"state":[],"start":2395},{"state":[],"start":2478},{"state":[],"start":2479},{"state":[],"start":2536},{"state":[],"start":2637},{"state":[],"start":2638},{"state":[],"start":2704},{"state":[{"type":"AtMostCountable X ↔ AtMostCountable Y","tag":[],"mvarId":["_uniq",43603],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",43600],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",43601],"binderInfo":"implicit"},{"type":"EqualCard X Y","name":["hXY"],"isProp":true,"id":["_uniq",43602],"binderInfo":"default"}]}],"start":2752},{"state":[],"start":2824},{"state":[],"start":2825},{"state":[],"start":2900},{"state":[{"type":"CountablyInfinite X ↔ Nonempty (Denumerable X)","tag":[],"mvarId":["_uniq",44089],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",44088],"binderInfo":"default"}]}],"start":2998},{"state":[{"type":"Nonempty (X ≃ ℕ) → Nonempty (Denumerable X)","tag":["mp"],"mvarId":["_uniq",44360],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",44088],"binderInfo":"default"}]},{"type":"Nonempty (Denumerable X) → Nonempty (X ≃ ℕ)","tag":["mpr"],"mvarId":["_uniq",44361],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",44088],"binderInfo":"default"}]}],"start":3053},{"state":[{"type":"Nonempty (Denumerable X) → Nonempty (X ≃ ℕ)","tag":["mpr"],"mvarId":["_uniq",44361],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",44088],"binderInfo":"default"}]}],"start":3106},{"state":[],"start":3147},{"state":[],"start":3148},{"state":[],"start":3204},{"state":[{"type":"CountablyInfinite X ↔ Countable X ∧ Infinite X","tag":[],"mvarId":["_uniq",44522],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",44521],"binderInfo":"default"}]}],"start":3305},{"state":[],"start":3342},{"state":[],"start":3343},{"state":[{"type":"Countable X","tag":[],"mvarId":["_uniq",44548],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",44546],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",44547],"binderInfo":"default"}]}],"start":3438},{"state":[],"start":3456},{"state":[],"start":3457},{"state":[{"type":"Infinite X","tag":[],"mvarId":["_uniq",45617],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",45615],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",45616],"binderInfo":"default"}]}],"start":3550},{"state":[],"start":3568},{"state":[],"start":3569},{"state":[{"type":"AtMostCountable X ↔ Countable X","tag":[],"mvarId":["_uniq",46287],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",46286],"binderInfo":"default"}]}],"start":3650},{"state":[{"type":"AtMostCountable X ↔ Countable X","tag":[],"mvarId":["_uniq",111883],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",46286],"binderInfo":"default"},{"type":"CountablyInfinite X ↔ Countable X ∧ Infinite X","name":["h1"],"isProp":true,"id":["_uniq",111882],"binderInfo":"default"}]}],"start":3716},{"state":[{"type":"AtMostCountable X ↔ Countable X","tag":[],"mvarId":["_uniq",112040],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",46286],"binderInfo":"default"},{"type":"CountablyInfinite X ↔ Countable X ∧ Infinite X","name":["h1"],"isProp":true,"id":["_uniq",111882],"binderInfo":"default"},{"type":"Finite X ∨ Infinite X","name":["h2"],"isProp":true,"id":["_uniq",112039],"binderInfo":"default"}]}],"start":3755},{"state":[{"type":"AtMostCountable X ↔ Countable X","tag":[],"mvarId":["_uniq",114810],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",46286],"binderInfo":"default"},{"type":"CountablyInfinite X ↔ Countable X ∧ Infinite X","name":["h1"],"isProp":true,"id":["_uniq",111882],"binderInfo":"default"},{"type":"Finite X ∨ Infinite X","name":["h2"],"isProp":true,"id":["_uniq",112039],"binderInfo":"default"},{"type":"Finite X → Countable X","name":["h3"],"isProp":true,"id":["_uniq",114809],"binderInfo":"default"}]}],"start":3795},{"state":[],"start":3803},{"state":[],"start":3804},{"state":[{"type":"CountablyInfinite (↑X : Type) ↔ ∃ f, X = (⇑f : ℕ → A) '' Set.univ","tag":[],"mvarId":["_uniq",128780],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"}]}],"start":3930},{"state":[{"type":"CountablyInfinite (↑X : Type) → ∃ f, X = (⇑f : ℕ → A) '' Set.univ","tag":["mp"],"mvarId":["_uniq",128787],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"}]},{"type":"(∃ f, X = (⇑f : ℕ → A) '' Set.univ) → CountablyInfinite (↑X : Type)","tag":["mpr"],"mvarId":["_uniq",128788],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"}]}],"start":3944},{"state":[{"type":"∃ f, X = (⇑f : ℕ → A) '' Set.univ","tag":["mp"],"mvarId":["_uniq",128901],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"(↑X : Type) → ℕ","name":["g"],"isProp":false,"id":["_uniq",128829],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",128830],"binderInfo":"default"}]}],"start":3968},{"state":[{"type":"∃ f, X = (⇑f : ℕ → A) '' Set.univ","tag":["mp"],"mvarId":["_uniq",128932],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"(↑X : Type) → ℕ","name":["g"],"isProp":false,"id":["_uniq",128829],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",128830],"binderInfo":"default"},{"type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",128918],"binderInfo":"default"},{"type":"Function.LeftInverse f g","name":["hleft"],"isProp":true,"id":["_uniq",128927],"binderInfo":"default"},{"type":"Function.RightInverse f g","name":["hright"],"isProp":true,"id":["_uniq",128931],"binderInfo":"default"}]}],"start":4041},{"state":[{"type":"Function.Injective (Subtype.val ∘ f)","tag":["mp","refine_1"],"mvarId":["_uniq",128981],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"(↑X : Type) → ℕ","name":["g"],"isProp":false,"id":["_uniq",128829],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",128830],"binderInfo":"default"},{"type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",128918],"binderInfo":"default"},{"type":"Function.LeftInverse f g","name":["hleft"],"isProp":true,"id":["_uniq",128927],"binderInfo":"default"},{"type":"Function.RightInverse f g","name":["hright"],"isProp":true,"id":["_uniq",128931],"binderInfo":"default"}]},{"type":"X = (⇑{ toFun := Subtype.val ∘ f, inj' := ?mp.refine_1 } : ℕ → A) '' Set.univ","tag":["mp","refine_2"],"mvarId":["_uniq",128982],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"(↑X : Type) → ℕ","name":["g"],"isProp":false,"id":["_uniq",128829],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",128830],"binderInfo":"default"},{"type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",128918],"binderInfo":"default"},{"type":"Function.LeftInverse f g","name":["hleft"],"isProp":true,"id":["_uniq",128927],"binderInfo":"default"},{"type":"Function.RightInverse f g","name":["hright"],"isProp":true,"id":["_uniq",128931],"binderInfo":"default"}]}],"start":4094},{"state":[{"type":"X = (⇑{ toFun := Subtype.val ∘ f, inj' := ⋯ } : ℕ → A) '' Set.univ","tag":["mp","refine_2"],"mvarId":["_uniq",128982],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"(↑X : Type) → ℕ","name":["g"],"isProp":false,"id":["_uniq",128829],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",128830],"binderInfo":"default"},{"type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",128918],"binderInfo":"default"},{"type":"Function.LeftInverse f g","name":["hleft"],"isProp":true,"id":["_uniq",128927],"binderInfo":"default"},{"type":"Function.RightInverse f g","name":["hright"],"isProp":true,"id":["_uniq",128931],"binderInfo":"default"}]}],"start":4166},{"state":[{"type":"x✝ ∈ X → ∃ y, (↑(f y) : A) = x✝","tag":["mp","refine_2","h","mp"],"mvarId":["_uniq",131742],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"(↑X : Type) → ℕ","name":["g"],"isProp":false,"id":["_uniq",128829],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",128830],"binderInfo":"default"},{"type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",128918],"binderInfo":"default"},{"type":"Function.LeftInverse f g","name":["hleft"],"isProp":true,"id":["_uniq",128927],"binderInfo":"default"},{"type":"Function.RightInverse f g","name":["hright"],"isProp":true,"id":["_uniq",128931],"binderInfo":"default"},{"type":"A","name":["x✝"],"isProp":false,"id":["_uniq",130344],"binderInfo":"default"}]},{"type":"(∃ y, (↑(f y) : A) = x✝) → x✝ ∈ X","tag":["mp","refine_2","h","mpr"],"mvarId":["_uniq",131743],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"(↑X : Type) → ℕ","name":["g"],"isProp":false,"id":["_uniq",128829],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",128830],"binderInfo":"default"},{"type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",128918],"binderInfo":"default"},{"type":"Function.LeftInverse f g","name":["hleft"],"isProp":true,"id":["_uniq",128927],"binderInfo":"default"},{"type":"Function.RightInverse f g","name":["hright"],"isProp":true,"id":["_uniq",128931],"binderInfo":"default"},{"type":"A","name":["x✝"],"isProp":false,"id":["_uniq",130344],"binderInfo":"default"}]}],"start":4193},{"state":[{"type":"(∃ y, (↑(f y) : A) = x✝) → x✝ ∈ X","tag":["mp","refine_2","h","mpr"],"mvarId":["_uniq",131743],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"(↑X : Type) → ℕ","name":["g"],"isProp":false,"id":["_uniq",128829],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",128830],"binderInfo":"default"},{"type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",128918],"binderInfo":"default"},{"type":"Function.LeftInverse f g","name":["hleft"],"isProp":true,"id":["_uniq",128927],"binderInfo":"default"},{"type":"Function.RightInverse f g","name":["hright"],"isProp":true,"id":["_uniq",128931],"binderInfo":"default"},{"type":"A","name":["x✝"],"isProp":false,"id":["_uniq",130344],"binderInfo":"default"}]}],"start":4245},{"state":[{"type":"(∃ f, X = (⇑f : ℕ → A) '' Set.univ) → CountablyInfinite (↑X : Type)","tag":["mpr"],"mvarId":["_uniq",128788],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"}]}],"start":4278},{"state":[{"type":"CountablyInfinite (↑X : Type)","tag":["mpr"],"mvarId":["_uniq",133032],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"ℕ ↪ A","name":["f"],"isProp":false,"id":["_uniq",132963],"binderInfo":"default"},{"type":"X = (⇑f : ℕ → A) '' Set.univ","name":["hf"],"isProp":true,"id":["_uniq",132964],"binderInfo":"default"}]}],"start":4300},{"state":[{"type":"CountablyInfinite (↑X : Type)","tag":["mpr"],"mvarId":["_uniq",133225],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"ℕ ↪ A","name":["f"],"isProp":false,"id":["_uniq",132963],"binderInfo":"default"},{"type":"X = (⇑f : ℕ → A) '' Set.univ","name":["hf"],"isProp":true,"id":["_uniq",132964],"binderInfo":"default"},{"value":"Function.leftInverse_invFun (Function.Embedding.injective f)","type":"Function.LeftInverse (Function.invFun (⇑f : ℕ → A)) (⇑f : ℕ → A)","name":["this"],"isProp":true,"id":["_uniq",133224]}]}],"start":4371},{"state":[{"type":"Function.Injective (Function.invFun (⇑f : ℕ → A) ∘ Subtype.val)","tag":["h","refine_1"],"mvarId":["_uniq",133485],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"ℕ ↪ A","name":["f"],"isProp":false,"id":["_uniq",132963],"binderInfo":"default"},{"type":"X = (⇑f : ℕ → A) '' Set.univ","name":["hf"],"isProp":true,"id":["_uniq",132964],"binderInfo":"default"},{"value":"Function.leftInverse_invFun (Function.Embedding.injective f)","type":"Function.LeftInverse (Function.invFun (⇑f : ℕ → A)) (⇑f : ℕ → A)","name":["this"],"isProp":true,"id":["_uniq",133224]}]},{"type":"Function.Surjective (Function.invFun (⇑f : ℕ → A) ∘ Subtype.val)","tag":["h","refine_2"],"mvarId":["_uniq",133486],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"ℕ ↪ A","name":["f"],"isProp":false,"id":["_uniq",132963],"binderInfo":"default"},{"type":"X = (⇑f : ℕ → A) '' Set.univ","name":["hf"],"isProp":true,"id":["_uniq",132964],"binderInfo":"default"},{"value":"Function.leftInverse_invFun (Function.Embedding.injective f)","type":"Function.LeftInverse (Function.invFun (⇑f : ℕ → A)) (⇑f : ℕ → A)","name":["this"],"isProp":true,"id":["_uniq",133224]}]}],"start":4425},{"state":[{"type":"Function.Surjective (Function.invFun (⇑f : ℕ → A) ∘ Subtype.val)","tag":["h","refine_2"],"mvarId":["_uniq",133486],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",128778],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",128779],"binderInfo":"default"},{"type":"ℕ ↪ A","name":["f"],"isProp":false,"id":["_uniq",132963],"binderInfo":"default"},{"type":"X = (⇑f : ℕ → A) '' Set.univ","name":["hf"],"isProp":true,"id":["_uniq",132964],"binderInfo":"default"},{"value":"Function.leftInverse_invFun (Function.Embedding.injective f)","type":"Function.LeftInverse (Function.invFun (⇑f : ℕ → A)) (⇑f : ℕ → A)","name":["this"],"isProp":true,"id":["_uniq",133224]}]}],"start":4473},{"state":[],"start":4517},{"state":[],"start":4518},{"state":[],"start":4540},{"state":[],"start":4584},{"state":[],"start":4585},{"state":[],"start":4648},{"state":[],"start":4649},{"state":[],"start":4720},{"state":[],"start":4721},{"state":[],"start":4722},{"state":[],"start":4789},{"state":[],"start":4853},{"state":[{"type":"∃! m, m ∈ X ∧ ∀ n ∈ X, m ≤ n","tag":[],"mvarId":["_uniq",137458],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",137456],"binderInfo":"implicit"},{"type":"X.Nonempty","name":["hX"],"isProp":true,"id":["_uniq",137457],"binderInfo":"default"}]}],"start":4896},{"state":[],"start":4904},{"state":[],"start":4905},{"state":[{"type":"Decidable (∀ (X : Set ℤ), X.Nonempty → ∃! m, m ∈ X ∧ ∀ n ∈ X, m ≤ n)","tag":[],"mvarId":["_uniq",137592],"isProp":false,"context":[]}],"start":5023},{"state":[{"type":"Decidable (∀ (X : Set ℤ), X.Nonempty → ∃! m, m ∈ X ∧ ∀ n ∈ X, m ≤ n)","tag":[],"mvarId":["_uniq",137592],"isProp":false,"context":[]}],"start":5116},{"state":[],"start":5124},{"state":[],"start":5125},{"state":[{"type":"Decidable (∀ (X : Set ℚ≥0), X.Nonempty → ∃! m, m ∈ X ∧ ∀ n ∈ X, m ≤ n)","tag":[],"mvarId":["_uniq",138050],"isProp":false,"context":[]}],"start":5247},{"state":[{"type":"Decidable (∀ (X : Set ℚ≥0), X.Nonempty → ∃! m, m ∈ X ∧ ∀ n ∈ X, m ≤ n)","tag":[],"mvarId":["_uniq",138050],"isProp":false,"context":[]}],"start":5340},{"state":[],"start":5348},{"state":[],"start":5349},{"state":[],"start":5350},{"state":[],"start":5368},{"state":[],"start":5488},{"state":[],"start":5489},{"state":[{"type":"min X ∈ X ∧ ∀ n ∈ X, min X ≤ n","tag":[],"mvarId":["_uniq",138337],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",138335],"binderInfo":"implicit"},{"type":"X.Nonempty","name":["hX"],"isProp":true,"id":["_uniq",138336],"binderInfo":"default"}]}],"start":5591},{"state":[],"start":5657},{"state":[],"start":5658},{"state":[],"start":5772},{"state":[],"start":5821},{"state":[],"start":5822},{"state":[],"start":5830},{"state":[],"start":5887},{"state":[],"start":5888},{"state":[],"start":5952},{"state":[],"start":5953},{"state":[{"type":"min X = sInf X","tag":[],"mvarId":["_uniq",141811],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",141809],"binderInfo":"implicit"},{"type":"X.Nonempty","name":["hX"],"isProp":true,"id":["_uniq",141810],"binderInfo":"default"}]}],"start":6032},{"state":[],"start":6040},{"state":[],"start":6041},{"state":[],"start":6059},{"state":[],"start":6111},{"state":[{"type":"min X = Nat.find hX","tag":[],"mvarId":["_uniq",141847],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",141845],"binderInfo":"implicit"},{"type":"X.Nonempty","name":["hX"],"isProp":true,"id":["_uniq",141846],"binderInfo":"default"}]}],"start":6195},{"state":[],"start":6252},{"state":[],"start":6253},{"state":[],"start":6278},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",143693],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"}]}],"start":6409},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",143693],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"}]}],"start":6482},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",143714],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]}]}],"start":6588},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",143877],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]}]}],"start":6690},{"state":[{"type":"Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","tag":[],"mvarId":["_uniq",144151],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",143881],"binderInfo":"default"}]}],"start":6781},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",144154],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]}]}],"start":6791},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",148911],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]}]}],"start":6903},{"state":[{"type":"StrictMono a","tag":[],"mvarId":["_uniq",149030],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]}]}],"start":6939},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",149032],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]}]}],"start":6949},{"state":[{"type":"Function.Injective a","tag":[],"mvarId":["_uniq",149050],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]}]}],"start":6998},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",149052],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]}]}],"start":7008},{"state":[{"type":"a n ∈ X","tag":[],"mvarId":["_uniq",149134],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",149061],"binderInfo":"default"}]}],"start":7045},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",149138],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]}]}],"start":7055},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",149180],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]}]}],"start":7107},{"state":[{"type":"Function.Injective f","tag":[],"mvarId":["_uniq",149339],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]}]}],"start":7156},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",149341],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]}]}],"start":7206},{"state":[{"type":"Function.Surjective f","tag":[],"mvarId":["_uniq",150710],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]}]}],"start":7257},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",153265],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",150743],"binderInfo":"default"},{"type":"x ∈ X","name":["hx"],"isProp":true,"id":["_uniq",150744],"binderInfo":"default"},{"type":"¬∃ a_1, a a_1 = x","name":["x✝"],"isProp":true,"id":["_uniq",153264],"binderInfo":"default"}]}],"start":7302},{"state":[{"type":"x ∈ {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","tag":[],"mvarId":["_uniq",153391],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",150743],"binderInfo":"default"},{"type":"x ∈ X","name":["hx"],"isProp":true,"id":["_uniq",150744],"binderInfo":"default"},{"type":"¬∃ a_1, a a_1 = x","name":["x✝"],"isProp":true,"id":["_uniq",153264],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",153270],"binderInfo":"default"}]}],"start":7383},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",153395],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",150743],"binderInfo":"default"},{"type":"x ∈ X","name":["hx"],"isProp":true,"id":["_uniq",150744],"binderInfo":"default"},{"type":"¬∃ a_1, a a_1 = x","name":["x✝"],"isProp":true,"id":["_uniq",153264],"binderInfo":"default"},{"value":"fun n => sorry","type":"∀ (n : ℕ), x ∈ {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["h1"],"isProp":true,"id":["_uniq",153393]}]}],"start":7395},{"state":[{"type":"x ≥ a n","tag":[],"mvarId":["_uniq",153409],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",150743],"binderInfo":"default"},{"type":"x ∈ X","name":["hx"],"isProp":true,"id":["_uniq",150744],"binderInfo":"default"},{"type":"¬∃ a_1, a a_1 = x","name":["x✝"],"isProp":true,"id":["_uniq",153264],"binderInfo":"default"},{"value":"fun n => sorry","type":"∀ (n : ℕ), x ∈ {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["h1"],"isProp":true,"id":["_uniq",153393]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",153401],"binderInfo":"default"}]}],"start":7433},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",153413],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",150743],"binderInfo":"default"},{"type":"x ∈ X","name":["hx"],"isProp":true,"id":["_uniq",150744],"binderInfo":"default"},{"type":"¬∃ a_1, a a_1 = x","name":["x✝"],"isProp":true,"id":["_uniq",153264],"binderInfo":"default"},{"value":"fun n => sorry","type":"∀ (n : ℕ), x ∈ {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["h1"],"isProp":true,"id":["_uniq",153393]},{"value":"fun n => Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)))","type":"∀ (n : ℕ), x ≥ a n","name":["h2"],"isProp":true,"id":["_uniq",153411]}]}],"start":7510},{"state":[{"type":"a n ≥ n","tag":[],"mvarId":["_uniq",153519],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",150743],"binderInfo":"default"},{"type":"x ∈ X","name":["hx"],"isProp":true,"id":["_uniq",150744],"binderInfo":"default"},{"type":"¬∃ a_1, a a_1 = x","name":["x✝"],"isProp":true,"id":["_uniq",153264],"binderInfo":"default"},{"value":"fun n => sorry","type":"∀ (n : ℕ), x ∈ {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["h1"],"isProp":true,"id":["_uniq",153393]},{"value":"fun n => Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)))","type":"∀ (n : ℕ), x ≥ a n","name":["h2"],"isProp":true,"id":["_uniq",153411]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",153514],"binderInfo":"default"}]}],"start":7548},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",153523],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",150743],"binderInfo":"default"},{"type":"x ∈ X","name":["hx"],"isProp":true,"id":["_uniq",150744],"binderInfo":"default"},{"type":"¬∃ a_1, a a_1 = x","name":["x✝"],"isProp":true,"id":["_uniq",153264],"binderInfo":"default"},{"value":"fun n => sorry","type":"∀ (n : ℕ), x ∈ {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["h1"],"isProp":true,"id":["_uniq",153393]},{"value":"fun n => Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)))","type":"∀ (n : ℕ), x ≥ a n","name":["h2"],"isProp":true,"id":["_uniq",153411]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ≥ n","name":["h3"],"isProp":true,"id":["_uniq",153521]}]}],"start":7560},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",153557],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"type":"ℕ","name":["x"],"isProp":false,"id":["_uniq",150743],"binderInfo":"default"},{"type":"x ∈ X","name":["hx"],"isProp":true,"id":["_uniq",150744],"binderInfo":"default"},{"type":"¬∃ a_1, a a_1 = x","name":["x✝"],"isProp":true,"id":["_uniq",153264],"binderInfo":"default"},{"value":"fun n => sorry","type":"∀ (n : ℕ), x ∈ {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["h1"],"isProp":true,"id":["_uniq",153393]},{"value":"fun n => Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)))","type":"∀ (n : ℕ), x ≥ a n","name":["h2"],"isProp":true,"id":["_uniq",153411]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ≥ n","name":["h3"],"isProp":true,"id":["_uniq",153521]},{"value":"fun n => LE.le.trans (h3 n) (h2 n)","type":"∀ (n : ℕ), x ≥ n","name":["h4"],"isProp":true,"id":["_uniq",153555]}]}],"start":7613},{"state":[{"type":"∃! f, Function.Bijective f ∧ StrictMono f","tag":[],"mvarId":["_uniq",150712],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]}]}],"start":7637},{"state":[{"type":"∀ (y : ℕ → (↑X : Type)), Function.Bijective y ∧ StrictMono y → y = f","tag":[],"mvarId":["_uniq",155186],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]}]}],"start":7719},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",156267],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"type":"g ≠ f","name":["this"],"isProp":true,"id":["_uniq",156252],"binderInfo":"default"}]}],"start":7771},{"state":[{"type":"{n | g n ≠ f n}.Nonempty","tag":[],"mvarId":["_uniq",156284],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"type":"g ≠ f","name":["this"],"isProp":true,"id":["_uniq",156252],"binderInfo":"default"}]}],"start":7818},{"state":[{"type":"g = f","tag":[],"mvarId":["_uniq",156347],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"type":"{n | g n ≠ f n} = ∅","name":["this"],"isProp":true,"id":["_uniq",156346],"binderInfo":"default"}]}],"start":7839},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",157392],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq {n | g n ≠ f n}) (Mathlib.Tactic.PushNeg.not_ne_eq g f)))\n    fun this =>\n    funext (Eq.mp (Eq.trans monotone_enum_of_infinite._simp_2 (forall_congr fun x => Decidable.not_not._simp_1)) this))\n  _fvar.156252","type":"{n | g n ≠ f n}.Nonempty","name":["this"],"isProp":true,"id":["_uniq",156285]}]}],"start":7907},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",157406],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq {n | g n ≠ f n}) (Mathlib.Tactic.PushNeg.not_ne_eq g f)))\n    fun this =>\n    funext (Eq.mp (Eq.trans monotone_enum_of_infinite._simp_2 (forall_congr fun x => Decidable.not_not._simp_1)) this))\n  _fvar.156252","type":"{n | g n ≠ f n}.Nonempty","name":["this"],"isProp":true,"id":["_uniq",156285]},{"value":"min {n | g n ≠ f n}","type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",157405]}]}],"start":7942},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",157604],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq {n | g n ≠ f n}) (Mathlib.Tactic.PushNeg.not_ne_eq g f)))\n    fun this =>\n    funext (Eq.mp (Eq.trans monotone_enum_of_infinite._simp_2 (forall_congr fun x => Decidable.not_not._simp_1)) this))\n  _fvar.156252","type":"{n | g n ≠ f n}.Nonempty","name":["this"],"isProp":true,"id":["_uniq",156285]},{"value":"min {n | g n ≠ f n}","type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",157405]},{"value":"(min_spec this).left","type":"g m ≠ f m","name":["hm"],"isProp":true,"id":["_uniq",157603]}]}],"start":7987},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",157623],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq {n | g n ≠ f n}) (Mathlib.Tactic.PushNeg.not_ne_eq g f)))\n    fun this =>\n    funext (Eq.mp (Eq.trans monotone_enum_of_infinite._simp_2 (forall_congr fun x => Decidable.not_not._simp_1)) this))\n  _fvar.156252","type":"{n | g n ≠ f n}.Nonempty","name":["this"],"isProp":true,"id":["_uniq",156285]},{"value":"min {n | g n ≠ f n}","type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",157405]},{"value":"(min_spec this).left","type":"g m ≠ f m","name":["hm"],"isProp":true,"id":["_uniq",157603]},{"value":"fun {n} hn =>\n  Decidable.byContradiction fun hgfn =>\n    False.elim\n      (Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.atom_pf (↑m : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑m : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((↑m : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((↑m : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑(min {n | g n ≠ f n}) : ℤ))\n                  (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑m : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (Int.add_one_le_iff.mpr (id (Eq.mp (Mathlib.Tactic.Zify.natCast_lt._simp_1 n m) hn)))))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n              (id\n                (Eq.mp (Mathlib.Tactic.Zify.natCast_le._simp_1 (min {n | g n ≠ f n}) n)\n                  ((min_spec this).right n\n                    (of_eq_true (Eq.trans (congrArg Not (eq_false hgfn)) not_false_eq_true)))))))))","type":"∀ {n : ℕ}, n < m → g n = f n","name":["hm'"],"isProp":true,"id":["_uniq",157622]}]}],"start":8100},{"state":[{"type":"(↑(g m) : ℕ) = min {x | x ∈ X ∧ ∀ n < m, x ≠ a n}","tag":[],"mvarId":["_uniq",167409],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq {n | g n ≠ f n}) (Mathlib.Tactic.PushNeg.not_ne_eq g f)))\n    fun this =>\n    funext (Eq.mp (Eq.trans monotone_enum_of_infinite._simp_2 (forall_congr fun x => Decidable.not_not._simp_1)) this))\n  _fvar.156252","type":"{n | g n ≠ f n}.Nonempty","name":["this"],"isProp":true,"id":["_uniq",156285]},{"value":"min {n | g n ≠ f n}","type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",157405]},{"value":"(min_spec this).left","type":"g m ≠ f m","name":["hm"],"isProp":true,"id":["_uniq",157603]},{"value":"fun {n} hn =>\n  Decidable.byContradiction fun hgfn =>\n    False.elim\n      (Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.atom_pf (↑m : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑m : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((↑m : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((↑m : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑(min {n | g n ≠ f n}) : ℤ))\n                  (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑m : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (Int.add_one_le_iff.mpr (id (Eq.mp (Mathlib.Tactic.Zify.natCast_lt._simp_1 n m) hn)))))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n              (id\n                (Eq.mp (Mathlib.Tactic.Zify.natCast_le._simp_1 (min {n | g n ≠ f n}) n)\n                  ((min_spec this).right n\n                    (of_eq_true (Eq.trans (congrArg Not (eq_false hgfn)) not_false_eq_true)))))))))","type":"∀ {n : ℕ}, n < m → g n = f n","name":["hm'"],"isProp":true,"id":["_uniq",157622]}]}],"start":8176},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",167411],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",143691],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",143692],"binderInfo":"instImplicit"},{"value":"fun t => Nat.strongRec (fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}) t","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",143713]},{"value":"Nat.strongRec.eq_def fun n a => min {x | x ∈ X ∧ ∀ (m : ℕ) (h : m < n), x ≠ a m h}","type":"∀ (n : ℕ), a n = min {x | x ∈ X ∧ ∀ m < n, x ≠ a m}","name":["ha"],"isProp":true,"id":["_uniq",143876]},{"value":"fun n => sorry","type":"∀ (n : ℕ), Infinite (↑{x | x ∈ X ∧ ∀ m < n, x ≠ a m} : Type)","name":["ha_infinite"],"isProp":true,"id":["_uniq",144153]},{"value":"fun n => Set.Nonempty.of_subtype","type":"∀ (n : ℕ), {x | x ∈ X ∧ ∀ m < n, x ≠ a m}.Nonempty","name":["ha_nonempty"],"isProp":true,"id":["_uniq",148909]},{"value":"sorry","type":"StrictMono a","name":["ha_mono"],"isProp":true,"id":["_uniq",149031]},{"value":"sorry","type":"Function.Injective a","name":["ha_injective"],"isProp":true,"id":["_uniq",149051]},{"value":"fun n => sorry","type":"∀ (n : ℕ), a n ∈ X","name":["haX"],"isProp":true,"id":["_uniq",149136]},{"value":"fun n => ⟨a n, ⋯⟩","type":"ℕ → (↑X : Type)","name":["f"],"isProp":false,"id":["_uniq",149178]},{"value":"fun ⦃x y⦄ hxy => ha_injective (ha_injective (congrArg a (Eq.mp (Subtype.mk.injEq (a x) (haX x) (a y) (haX y)) hxy)))","type":"Function.Injective f","name":["hf_injective"],"isProp":true,"id":["_uniq",149340]},{"value":"fun h =>\n  match h with\n  | ⟨x, hx⟩ =>\n    Eq.mpr (id (congrArg Exists (funext fun a_1 => Subtype.mk.injEq (a a_1) (haX a_1) x hx)))\n      (Classical.byContradiction fun x_1 =>\n        have h1 := fun n => sorry;\n        have h2 := fun n =>\n          Eq.mpr (id (congrArg (fun _a => x ≥ _a) (ha n))) (ge_iff_le.mpr ((min_spec (ha_nonempty n)).right x (h1 n)));\n        have h3 := fun n => sorry;\n        have h4 := fun n => LE.le.trans (h3 n) (h2 n);\n        False.elim\n          (Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑x : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.atom_pf (↑x : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑x : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑x : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0)))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_le._simp_1 (x + 1) x)\n                        (congrArg (fun x_2 => x_2 ≤ (↑x : ℤ))\n                          (Eq.trans (Nat.cast_add x 1) (congrArg (HAdd.hAdd (↑x : ℤ)) Nat.cast_one))))\n                      (h4 (x + 1)))))))))","type":"Function.Surjective f","name":["hf_surjective"],"isProp":true,"id":["_uniq",150711]},{"type":"ℕ → (↑X : Type)","name":["g"],"isProp":false,"id":["_uniq",155250],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg_bijective"],"isProp":true,"id":["_uniq",155282],"binderInfo":"default"},{"type":"StrictMono g","name":["hg_mono"],"isProp":true,"id":["_uniq",155283],"binderInfo":"default"},{"value":"Mathlib.Tactic.Contrapose.mtr\n  (Eq.mpr\n    (id (implies_congr (Mathlib.Tactic.PushNeg.not_nonempty_eq {n | g n ≠ f n}) (Mathlib.Tactic.PushNeg.not_ne_eq g f)))\n    fun this =>\n    funext (Eq.mp (Eq.trans monotone_enum_of_infinite._simp_2 (forall_congr fun x => Decidable.not_not._simp_1)) this))\n  _fvar.156252","type":"{n | g n ≠ f n}.Nonempty","name":["this"],"isProp":true,"id":["_uniq",156285]},{"value":"min {n | g n ≠ f n}","type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",157405]},{"value":"(min_spec this).left","type":"g m ≠ f m","name":["hm"],"isProp":true,"id":["_uniq",157603]},{"value":"fun {n} hn =>\n  Decidable.byContradiction fun hgfn =>\n    False.elim\n      (Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.neg_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1)))))\n                      Mathlib.Tactic.Ring.neg_zero))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.atom_pf (↑m : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑m : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_zero_add\n                            ((↑m : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                        ((↑m : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf (↑(min {n | g n ≠ f n}) : ℤ))\n                  (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.sub_pf\n                    (Mathlib.Tactic.Ring.neg_add\n                      (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1))))))\n                      Mathlib.Tactic.Ring.neg_zero)\n                    (Mathlib.Tactic.Ring.add_pf_add_gt ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑m : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (Int.add_one_le_iff.mpr (id (Eq.mp (Mathlib.Tactic.Zify.natCast_lt._simp_1 n m) hn)))))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n              (id\n                (Eq.mp (Mathlib.Tactic.Zify.natCast_le._simp_1 (min {n | g n ≠ f n}) n)\n                  ((min_spec this).right n\n                    (of_eq_true (Eq.trans (congrArg Not (eq_false hgfn)) not_false_eq_true)))))))))","type":"∀ {n : ℕ}, n < m → g n = f n","name":["hm'"],"isProp":true,"id":["_uniq",157622]},{"value":"sorry","type":"(↑(g m) : ℕ) = min {x | x ∈ X ∧ ∀ n < m, x ≠ a n}","name":["hgm"],"isProp":true,"id":["_uniq",167410]}]}],"start":8186},{"state":[],"start":8257},{"state":[],"start":8258},{"state":[{"type":"CountablyInfinite (↑X : Type)","tag":[],"mvarId":["_uniq",167916],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",167914],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",167915],"binderInfo":"instImplicit"}]}],"start":8347},{"state":[{"type":"CountablyInfinite (↑X : Type)","tag":[],"mvarId":["_uniq",167949],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",167914],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["inst✝"],"isProp":true,"id":["_uniq",167915],"binderInfo":"instImplicit"},{"value":"ExistsUnique.exists (monotone_enum_of_infinite X)","type":"∃ x, Function.Bijective x ∧ StrictMono x","name":["this"],"isProp":true,"id":["_uniq",167948]}]}],"start":8394},{"state":[],"start":8457},{"state":[],"start":8458},{"state":[],"start":8481},{"state":[{"type":"AtMostCountable (↑X : Type)","tag":[],"mvarId":["_uniq",168198],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",168197],"binderInfo":"default"}]}],"start":8555},{"state":[{"type":"AtMostCountable (↑X : Type)","tag":["inl"],"mvarId":["_uniq",168449],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",168197],"binderInfo":"default"},{"type":"Finite (↑X : Type)","name":["h✝"],"isProp":true,"id":["_uniq",168448],"binderInfo":"default"}]},{"type":"AtMostCountable (↑X : Type)","tag":["inr"],"mvarId":["_uniq",168454],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",168197],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["h✝"],"isProp":true,"id":["_uniq",168453],"binderInfo":"default"}]}],"start":8594},{"state":[{"type":"AtMostCountable (↑X : Type)","tag":["inr"],"mvarId":["_uniq",168454],"isProp":true,"context":[{"type":"Set ℕ","name":["X"],"isProp":false,"id":["_uniq",168197],"binderInfo":"default"},{"type":"Infinite (↑X : Type)","name":["h✝"],"isProp":true,"id":["_uniq",168453],"binderInfo":"default"}]}],"start":8604},{"state":[],"start":8652},{"state":[],"start":8653},{"state":[],"start":8676},{"state":[{"type":"AtMostCountable (↑Y : Type)","tag":[],"mvarId":["_uniq",169061],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",169058],"binderInfo":"implicit"},{"type":"AtMostCountable X","name":["hX"],"isProp":true,"id":["_uniq",169059],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",169060],"binderInfo":"default"}]}],"start":8779},{"state":[{"type":"AtMostCountable (↑Y : Type)","tag":[],"mvarId":["_uniq",169061],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",169058],"binderInfo":"implicit"},{"type":"AtMostCountable X","name":["hX"],"isProp":true,"id":["_uniq",169059],"binderInfo":"default"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",169060],"binderInfo":"default"}]}],"start":8852},{"state":[{"type":"AtMostCountable (↑Y : Type)","tag":["inl","intro"],"mvarId":["_uniq",169113],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",169058],"binderInfo":"implicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",169060],"binderInfo":"default"},{"type":"X → ℕ","name":["f"],"isProp":false,"id":["_uniq",169111],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",169112],"binderInfo":"default"}]},{"type":"AtMostCountable (↑Y : Type)","tag":["inr"],"mvarId":["_uniq",169090],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",169058],"binderInfo":"implicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",169060],"binderInfo":"default"},{"type":"Finite X","name":["hX"],"isProp":true,"id":["_uniq",169089],"binderInfo":"default"}]}],"start":8886},{"state":[{"type":"AtMostCountable (↑Y : Type)","tag":["inl","intro"],"mvarId":["_uniq",169262],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",169058],"binderInfo":"implicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",169060],"binderInfo":"default"},{"type":"X → ℕ","name":["f"],"isProp":false,"id":["_uniq",169111],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",169112],"binderInfo":"default"},{"value":"fun y => ⟨f (↑y : X), ⋯⟩","type":"(↑Y : Type) → (↑(f '' Y) : Type)","name":["f'"],"isProp":false,"id":["_uniq",169260]}]}],"start":8947},{"state":[{"type":"Function.Bijective f'","tag":[],"mvarId":["_uniq",184590],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",169058],"binderInfo":"implicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",169060],"binderInfo":"default"},{"type":"X → ℕ","name":["f"],"isProp":false,"id":["_uniq",169111],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",169112],"binderInfo":"default"},{"value":"fun y => ⟨f (↑y : X), ⋯⟩","type":"(↑Y : Type) → (↑(f '' Y) : Type)","name":["f'"],"isProp":false,"id":["_uniq",169260]}]}],"start":8990},{"state":[{"type":"AtMostCountable (↑Y : Type)","tag":["inl","intro"],"mvarId":["_uniq",184592],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",169058],"binderInfo":"implicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",169060],"binderInfo":"default"},{"type":"X → ℕ","name":["f"],"isProp":false,"id":["_uniq",169111],"binderInfo":"default"},{"type":"Function.Bijective f","name":["hf"],"isProp":true,"id":["_uniq",169112],"binderInfo":"default"},{"value":"fun y => ⟨f (↑y : X), ⋯⟩","type":"(↑Y : Type) → (↑(f '' Y) : Type)","name":["f'"],"isProp":false,"id":["_uniq",169260]},{"value":"sorry","type":"Function.Bijective f'","name":["hf'"],"isProp":true,"id":["_uniq",184591]}]}],"start":9002},{"state":[{"type":"AtMostCountable (↑Y : Type)","tag":["inr"],"mvarId":["_uniq",169090],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",169058],"binderInfo":"implicit"},{"type":"Set X","name":["Y"],"isProp":false,"id":["_uniq",169060],"binderInfo":"default"},{"type":"Finite X","name":["hX"],"isProp":true,"id":["_uniq",169089],"binderInfo":"default"}]}],"start":9067},{"state":[],"start":9125},{"state":[],"start":9126},{"state":[{"type":"AtMostCountable (↑Y : Type)","tag":[],"mvarId":["_uniq",185548],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",185543],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",185544],"binderInfo":"implicit"},{"type":"Set A","name":["Y"],"isProp":false,"id":["_uniq",185545],"binderInfo":"implicit"},{"type":"AtMostCountable (↑X : Type)","name":["hX"],"isProp":true,"id":["_uniq",185546],"binderInfo":"default"},{"type":"Y ⊆ X","name":["hY"],"isProp":true,"id":["_uniq",185547],"binderInfo":"default"}]}],"start":9245},{"state":[{"type":"Function.Injective fun y => ⟨(↑(↑y : (↑X : Type)) : A), ⋯⟩","tag":["refine'_1"],"mvarId":["_uniq",185576],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",185543],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",185544],"binderInfo":"implicit"},{"type":"Set A","name":["Y"],"isProp":false,"id":["_uniq",185545],"binderInfo":"implicit"},{"type":"AtMostCountable (↑X : Type)","name":["hX"],"isProp":true,"id":["_uniq",185546],"binderInfo":"default"},{"type":"Y ⊆ X","name":["hY"],"isProp":true,"id":["_uniq",185547],"binderInfo":"default"}]},{"type":"Function.Surjective fun y => ⟨(↑(↑y : (↑X : Type)) : A), ⋯⟩","tag":["refine'_2"],"mvarId":["_uniq",185577],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",185543],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",185544],"binderInfo":"implicit"},{"type":"Set A","name":["Y"],"isProp":false,"id":["_uniq",185545],"binderInfo":"implicit"},{"type":"AtMostCountable (↑X : Type)","name":["hX"],"isProp":true,"id":["_uniq",185546],"binderInfo":"default"},{"type":"Y ⊆ X","name":["hY"],"isProp":true,"id":["_uniq",185547],"binderInfo":"default"}]}],"start":9353},{"state":[{"type":"Function.Surjective fun y => ⟨(↑(↑y : (↑X : Type)) : A), ⋯⟩","tag":["refine'_2"],"mvarId":["_uniq",185577],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",185543],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",185544],"binderInfo":"implicit"},{"type":"Set A","name":["Y"],"isProp":false,"id":["_uniq",185545],"binderInfo":"implicit"},{"type":"AtMostCountable (↑X : Type)","name":["hX"],"isProp":true,"id":["_uniq",185546],"binderInfo":"default"},{"type":"Y ⊆ X","name":["hY"],"isProp":true,"id":["_uniq",185547],"binderInfo":"default"}]}],"start":9423},{"state":[],"start":9485},{"state":[],"start":9486},{"state":[],"start":9528},{"state":[{"type":"AtMostCountable (↑(f '' Set.univ) : Type)","tag":[],"mvarId":["_uniq",187520],"isProp":true,"context":[{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",187518],"binderInfo":"default"},{"type":"ℕ → Y","name":["f"],"isProp":false,"id":["_uniq",187519],"binderInfo":"default"}]}],"start":9624},{"state":[],"start":9632},{"state":[],"start":9633},{"state":[],"start":9673},{"state":[{"type":"AtMostCountable (↑(f '' Set.univ) : Type)","tag":[],"mvarId":["_uniq",187749],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",187745],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",187746],"binderInfo":"default"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",187747],"binderInfo":"implicit"},{"type":"X → Y","name":["f"],"isProp":false,"id":["_uniq",187748],"binderInfo":"default"}]}],"start":9798},{"state":[],"start":9806},{"state":[],"start":9807},{"state":[],"start":9850},{"state":[],"start":9958},{"state":[{"type":"CountablyInfinite (↑(X ∪ Y) : Type)","tag":[],"mvarId":["_uniq",188337],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",188332],"binderInfo":"implicit"},{"type":"Set A","name":["X"],"isProp":false,"id":["_uniq",188333],"binderInfo":"implicit"},{"type":"Set A","name":["Y"],"isProp":false,"id":["_uniq",188334],"binderInfo":"implicit"},{"type":"CountablyInfinite (↑X : Type)","name":["hX"],"isProp":true,"id":["_uniq",188335],"binderInfo":"default"},{"type":"CountablyInfinite (↑Y : Type)","name":["hY"],"isProp":true,"id":["_uniq",188336],"binderInfo":"default"}]}],"start":10001},{"state":[],"start":10009},{"state":[],"start":10010},{"state":[],"start":10035},{"state":[{"type":"CountablyInfinite ℤ","tag":[],"mvarId":["_uniq",188341],"isProp":true,"context":[]}],"start":10095},{"state":[{"type":"CountablyInfinite ℤ","tag":[],"mvarId":["_uniq",188341],"isProp":true,"context":[]}],"start":10168},{"state":[{"type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","tag":[],"mvarId":["_uniq",188586],"isProp":true,"context":[]}],"start":10222},{"state":[{"type":"∃ f, {n | n ≥ 0} = (⇑f : ℕ → ℤ) '' Set.univ","tag":[],"mvarId":["_uniq",188601],"isProp":true,"context":[]}],"start":10263},{"state":[{"type":"{n | n ≥ 0} = (⇑{ toFun := fun x => (↑x : ℤ), inj' := ⋯ } : ℕ → ℤ) '' Set.univ","tag":["h"],"mvarId":["_uniq",188610],"isProp":true,"context":[]}],"start":10325},{"state":[{"type":"0 ≤ n → ∃ y, (↑y : ℤ) = n","tag":["h","h"],"mvarId":["_uniq",193471],"isProp":true,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",189133],"binderInfo":"default"}]}],"start":10370},{"state":[{"type":"CountablyInfinite ℤ","tag":[],"mvarId":["_uniq",188588],"isProp":true,"context":[{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≥ 0}))))\n  (Exists.intro\n    { toFun := fun x => (↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp Nat.cast_inj._simp_1 a))) (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congr (congrArg (fun x => Iff (n ∈ setOf x)) (funext fun n => ge_iff_le._simp_1))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (↑a : ℤ)) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro n.toNat\n              (of_eq_true\n                (Eq.trans (congrArg (fun x => x = n) (Eq.trans (Int.ofNat_toNat n) (sup_of_le_left h))) (eq_self n))),\n          mpr := fun a => Exists.casesOn a fun w h => h ▸ of_eq_true (Nat.cast_nonneg._simp_1 w) }))","type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","name":["h1"],"isProp":true,"id":["_uniq",188587]}]}],"start":10407},{"state":[{"type":"CountablyInfinite (↑{n | n ≤ 0} : Type)","tag":[],"mvarId":["_uniq",197742],"isProp":true,"context":[{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≥ 0}))))\n  (Exists.intro\n    { toFun := fun x => (↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp Nat.cast_inj._simp_1 a))) (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congr (congrArg (fun x => Iff (n ∈ setOf x)) (funext fun n => ge_iff_le._simp_1))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (↑a : ℤ)) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro n.toNat\n              (of_eq_true\n                (Eq.trans (congrArg (fun x => x = n) (Eq.trans (Int.ofNat_toNat n) (sup_of_le_left h))) (eq_self n))),\n          mpr := fun a => Exists.casesOn a fun w h => h ▸ of_eq_true (Nat.cast_nonneg._simp_1 w) }))","type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","name":["h1"],"isProp":true,"id":["_uniq",188587]}]}],"start":10461},{"state":[{"type":"∃ f, {n | n ≤ 0} = (⇑f : ℕ → ℤ) '' Set.univ","tag":[],"mvarId":["_uniq",197757],"isProp":true,"context":[{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≥ 0}))))\n  (Exists.intro\n    { toFun := fun x => (↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp Nat.cast_inj._simp_1 a))) (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congr (congrArg (fun x => Iff (n ∈ setOf x)) (funext fun n => ge_iff_le._simp_1))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (↑a : ℤ)) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro n.toNat\n              (of_eq_true\n                (Eq.trans (congrArg (fun x => x = n) (Eq.trans (Int.ofNat_toNat n) (sup_of_le_left h))) (eq_self n))),\n          mpr := fun a => Exists.casesOn a fun w h => h ▸ of_eq_true (Nat.cast_nonneg._simp_1 w) }))","type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","name":["h1"],"isProp":true,"id":["_uniq",188587]}]}],"start":10502},{"state":[{"type":"{n | n ≤ 0} = (⇑{ toFun := fun x => -(↑x : ℤ), inj' := ⋯ } : ℕ → ℤ) '' Set.univ","tag":["h"],"mvarId":["_uniq",197766],"isProp":true,"context":[{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≥ 0}))))\n  (Exists.intro\n    { toFun := fun x => (↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp Nat.cast_inj._simp_1 a))) (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congr (congrArg (fun x => Iff (n ∈ setOf x)) (funext fun n => ge_iff_le._simp_1))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (↑a : ℤ)) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro n.toNat\n              (of_eq_true\n                (Eq.trans (congrArg (fun x => x = n) (Eq.trans (Int.ofNat_toNat n) (sup_of_le_left h))) (eq_self n))),\n          mpr := fun a => Exists.casesOn a fun w h => h ▸ of_eq_true (Nat.cast_nonneg._simp_1 w) }))","type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","name":["h1"],"isProp":true,"id":["_uniq",188587]}]}],"start":10565},{"state":[{"type":"n ≤ 0 → ∃ y, -(↑y : ℤ) = n","tag":["h","h"],"mvarId":["_uniq",203639],"isProp":true,"context":[{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≥ 0}))))\n  (Exists.intro\n    { toFun := fun x => (↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp Nat.cast_inj._simp_1 a))) (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congr (congrArg (fun x => Iff (n ∈ setOf x)) (funext fun n => ge_iff_le._simp_1))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (↑a : ℤ)) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro n.toNat\n              (of_eq_true\n                (Eq.trans (congrArg (fun x => x = n) (Eq.trans (Int.ofNat_toNat n) (sup_of_le_left h))) (eq_self n))),\n          mpr := fun a => Exists.casesOn a fun w h => h ▸ of_eq_true (Nat.cast_nonneg._simp_1 w) }))","type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","name":["h1"],"isProp":true,"id":["_uniq",188587]},{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",200941],"binderInfo":"default"}]}],"start":10610},{"state":[{"type":"CountablyInfinite ℤ","tag":[],"mvarId":["_uniq",197744],"isProp":true,"context":[{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≥ 0}))))\n  (Exists.intro\n    { toFun := fun x => (↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp Nat.cast_inj._simp_1 a))) (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congr (congrArg (fun x => Iff (n ∈ setOf x)) (funext fun n => ge_iff_le._simp_1))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (↑a : ℤ)) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro n.toNat\n              (of_eq_true\n                (Eq.trans (congrArg (fun x => x = n) (Eq.trans (Int.ofNat_toNat n) (sup_of_le_left h))) (eq_self n))),\n          mpr := fun a => Exists.casesOn a fun w h => h ▸ of_eq_true (Nat.cast_nonneg._simp_1 w) }))","type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","name":["h1"],"isProp":true,"id":["_uniq",188587]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≤ 0}))))\n  (Exists.intro\n    { toFun := fun x => -(↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true\n          (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp (Eq.trans inv_inj._simp_4 Nat.cast_inj._simp_1) a)))\n            (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congrArg (Iff (n ≤ 0))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (-(↑a : ℤ))) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro (-n).toNat\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (fun x => x = n)\n                    (Eq.trans\n                      (congrArg Neg.neg\n                        (Eq.trans (Int.ofNat_toNat (-n))\n                          (sup_of_le_left (of_eq_true (Eq.trans Int.zero_le_neg_iff._simp_1 (eq_true h))))))\n                      (neg_neg n)))\n                  (eq_self n))),\n          mpr := fun a =>\n            Exists.casesOn\n              (Eq.mp (congrArg (fun x => CountablyInfinite (↑(setOf x) : Type)) (funext fun n => ge_iff_le._simp_1)) h1)\n              fun w h =>\n              Exists.casesOn a fun w_1 h_1 =>\n                h_1 ▸ of_eq_true (Eq.trans Left.inv_le_one_iff._simp_4 (Nat.cast_nonneg._simp_1 w_1)) }))","type":"CountablyInfinite (↑{n | n ≤ 0} : Type)","name":["h2"],"isProp":true,"id":["_uniq",197743]}]}],"start":10648},{"state":[{"type":"CountablyInfinite (↑Set.univ : Type)","tag":[],"mvarId":["_uniq",216738],"isProp":true,"context":[{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≥ 0}))))\n  (Exists.intro\n    { toFun := fun x => (↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp Nat.cast_inj._simp_1 a))) (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congr (congrArg (fun x => Iff (n ∈ setOf x)) (funext fun n => ge_iff_le._simp_1))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (↑a : ℤ)) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro n.toNat\n              (of_eq_true\n                (Eq.trans (congrArg (fun x => x = n) (Eq.trans (Int.ofNat_toNat n) (sup_of_le_left h))) (eq_self n))),\n          mpr := fun a => Exists.casesOn a fun w h => h ▸ of_eq_true (Nat.cast_nonneg._simp_1 w) }))","type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","name":["h1"],"isProp":true,"id":["_uniq",188587]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≤ 0}))))\n  (Exists.intro\n    { toFun := fun x => -(↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true\n          (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp (Eq.trans inv_inj._simp_4 Nat.cast_inj._simp_1) a)))\n            (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congrArg (Iff (n ≤ 0))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (-(↑a : ℤ))) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro (-n).toNat\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (fun x => x = n)\n                    (Eq.trans\n                      (congrArg Neg.neg\n                        (Eq.trans (Int.ofNat_toNat (-n))\n                          (sup_of_le_left (of_eq_true (Eq.trans Int.zero_le_neg_iff._simp_1 (eq_true h))))))\n                      (neg_neg n)))\n                  (eq_self n))),\n          mpr := fun a =>\n            Exists.casesOn\n              (Eq.mp (congrArg (fun x => CountablyInfinite (↑(setOf x) : Type)) (funext fun n => ge_iff_le._simp_1)) h1)\n              fun w h =>\n              Exists.casesOn a fun w_1 h_1 =>\n                h_1 ▸ of_eq_true (Eq.trans Left.inv_le_one_iff._simp_4 (Nat.cast_nonneg._simp_1 w_1)) }))","type":"CountablyInfinite (↑{n | n ≤ 0} : Type)","name":["h2"],"isProp":true,"id":["_uniq",197743]}]}],"start":10699},{"state":[{"type":"CountablyInfinite ℤ","tag":[],"mvarId":["_uniq",216740],"isProp":true,"context":[{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≥ 0}))))\n  (Exists.intro\n    { toFun := fun x => (↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp Nat.cast_inj._simp_1 a))) (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congr (congrArg (fun x => Iff (n ∈ setOf x)) (funext fun n => ge_iff_le._simp_1))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (↑a : ℤ)) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro n.toNat\n              (of_eq_true\n                (Eq.trans (congrArg (fun x => x = n) (Eq.trans (Int.ofNat_toNat n) (sup_of_le_left h))) (eq_self n))),\n          mpr := fun a => Exists.casesOn a fun w h => h ▸ of_eq_true (Nat.cast_nonneg._simp_1 w) }))","type":"CountablyInfinite (↑{n | n ≥ 0} : Type)","name":["h1"],"isProp":true,"id":["_uniq",188587]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (CountablyInfinite.iff_image_inj {n | n ≤ 0}))))\n  (Exists.intro\n    { toFun := fun x => -(↑x : ℤ),\n      inj' := fun ⦃a₁ a₂⦄ a =>\n        of_eq_true\n          (Eq.trans (congrArg (fun x => x = a₂) (id (Eq.mp (Eq.trans inv_inj._simp_4 Nat.cast_inj._simp_1) a)))\n            (eq_self a₂)) }\n    (Set.ext fun n =>\n      Eq.mpr\n        (id\n          (congrArg (Iff (n ≤ 0))\n            (Eq.trans\n              (congrArg (fun x => n ∈ x) (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (-(↑a : ℤ))) Set.image_univ))\n              Set.mem_range._simp_1)))\n        {\n          mp := fun h =>\n            Exists.intro (-n).toNat\n              (of_eq_true\n                (Eq.trans\n                  (congrArg (fun x => x = n)\n                    (Eq.trans\n                      (congrArg Neg.neg\n                        (Eq.trans (Int.ofNat_toNat (-n))\n                          (sup_of_le_left (of_eq_true (Eq.trans Int.zero_le_neg_iff._simp_1 (eq_true h))))))\n                      (neg_neg n)))\n                  (eq_self n))),\n          mpr := fun a =>\n            Exists.casesOn\n              (Eq.mp (congrArg (fun x => CountablyInfinite (↑(setOf x) : Type)) (funext fun n => ge_iff_le._simp_1)) h1)\n              fun w h =>\n              Exists.casesOn a fun w_1 h_1 =>\n                h_1 ▸ of_eq_true (Eq.trans Left.inv_le_one_iff._simp_4 (Nat.cast_nonneg._simp_1 w_1)) }))","type":"CountablyInfinite (↑{n | n ≤ 0} : Type)","name":["h2"],"isProp":true,"id":["_uniq",197743]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun X X' e'_1 =>\n        Eq.casesOn (motive := fun a x => X' = a → e'_1 ≍ x → CountablyInfinite X ≍ CountablyInfinite X') e'_1\n          (fun h =>\n            Eq.ndrec (motive := fun X' =>\n              ∀ (e_1 : X = X'), e_1 ≍ Eq.refl X → CountablyInfinite X ≍ CountablyInfinite X')\n              (fun e_1 h => HEq.refl (CountablyInfinite X)) (Eq.symm h) e'_1)\n          (Eq.refl X') (HEq.refl e'_1))\n      (↑Set.univ : Type) (↑({n | n ≥ 0} ∪ {n | n ≤ 0}) : Type)\n      (eq_of_heq\n        ((fun α s s' e'_2 =>\n            Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                  (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n              (Eq.refl s') (HEq.refl e'_2))\n          ℤ Set.univ ({n | n ≥ 0} ∪ {n | n ≤ 0})\n          (Set.ext fun x =>\n            Eq.mpr\n              (id\n                (Eq.trans\n                  (congr (congrArg Iff (Set.mem_univ._simp_1 x))\n                    (Eq.trans (congrArg (fun x_1 => x ∈ setOf x_1 ∪ {n | n ≤ 0}) (funext fun n => ge_iff_le._simp_1))\n                      (Set.mem_union._simp_1 x {n | 0 ≤ n} {n | n ≤ 0})))\n                  (true_iff (0 ≤ x ∨ x ≤ 0))))\n              (Decidable.byContradiction fun a => countablyInfinite._proof_3 x a))))))\n  (CountablyInfinite.union h1 h2)","type":"CountablyInfinite (↑Set.univ : Type)","name":["this"],"isProp":true,"id":["_uniq",216739]}]}],"start":10741},{"state":[],"start":10786},{"state":[],"start":10787},{"state":[],"start":10807},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",222248],"isProp":true,"context":[]}],"start":10903},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",222248],"isProp":true,"context":[]}],"start":10976},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",222279],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]}]}],"start":11020},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",222528],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]}]}],"start":11081},{"state":[{"type":"StrictMono a","tag":[],"mvarId":["_uniq",222657],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]}]}],"start":11112},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",222659],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]}]}],"start":11122},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",222875],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]}]}],"start":11179},{"state":[{"type":"Function.Injective f","tag":[],"mvarId":["_uniq",222886],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]}]}],"start":11218},{"state":[{"type":"⟨(n, m), hnm⟩ = ⟨(n', m'), hnm'⟩","tag":["mk","mk","mk","mk"],"mvarId":["_uniq",222993],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"(n, m) ∈ A","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"(n', m') ∈ A","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"f ⟨(n, m), hnm⟩ = f ⟨(n', m'), hnm'⟩","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"}]}],"start":11284},{"state":[{"type":"n = n' ∧ m = m'","tag":["mk","mk","mk","mk"],"mvarId":["_uniq",227183],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"}]}],"start":11317},{"state":[{"type":"n = n' ∧ m = m'","tag":["mk","mk","mk","mk","inl"],"mvarId":["_uniq",227220],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"},{"type":"n < n'","name":["hnn'"],"isProp":true,"id":["_uniq",227219],"binderInfo":"default"}]},{"type":"n = n ∧ m = m'","tag":["mk","mk","mk","mk","inr","inl"],"mvarId":["_uniq",227263],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n","name":["hnm'"],"isProp":true,"id":["_uniq",227261],"binderInfo":"default"},{"type":"a n + m = a n + m'","name":["h"],"isProp":true,"id":["_uniq",227262],"binderInfo":"default"}]},{"type":"n = n' ∧ m = m'","tag":["mk","mk","mk","mk","inr","inr"],"mvarId":["_uniq",227248],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"},{"type":"n' < n","name":["hnn'"],"isProp":true,"id":["_uniq",227247],"binderInfo":"default"}]}],"start":11368},{"state":[{"type":"a n' + m' > a n + m","tag":[],"mvarId":["_uniq",227348],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"},{"type":"n < n'","name":["hnn'"],"isProp":true,"id":["_uniq",227219],"binderInfo":"default"}]}],"start":11412},{"state":[],"start":11446},{"state":[],"start":11497},{"state":[],"start":11553},{"state":[{"type":"n = n' ∧ m = m'","tag":["mk","mk","mk","mk","inl"],"mvarId":["_uniq",227350],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"},{"type":"n < n'","name":["hnn'"],"isProp":true,"id":["_uniq",227219],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                        (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                            ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (Int.add_one_le_iff.mpr\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                        (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                      a_1)))))))\n      (StrictMono.monotone ha\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf (↑n' : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑n' : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯))))\n    ⋯)\n  ⋯","type":"a n' + m' > a n + m","name":["this"],"isProp":true,"id":["_uniq",227349]}]}],"start":11588},{"state":[{"type":"n = n ∧ m = m'","tag":["mk","mk","mk","mk","inr","inl"],"mvarId":["_uniq",227263],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n","name":["hnm'"],"isProp":true,"id":["_uniq",227261],"binderInfo":"default"},{"type":"a n + m = a n + m'","name":["h"],"isProp":true,"id":["_uniq",227262],"binderInfo":"default"}]},{"type":"n = n' ∧ m = m'","tag":["mk","mk","mk","mk","inr","inr"],"mvarId":["_uniq",227248],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"},{"type":"n' < n","name":["hnn'"],"isProp":true,"id":["_uniq",227247],"binderInfo":"default"}]}],"start":11603},{"state":[{"type":"n = n' ∧ m = m'","tag":["mk","mk","mk","mk","inr","inr"],"mvarId":["_uniq",227248],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"},{"type":"n' < n","name":["hnn'"],"isProp":true,"id":["_uniq",227247],"binderInfo":"default"}]}],"start":11623},{"state":[{"type":"a n + m > a n' + m'","tag":[],"mvarId":["_uniq",247501],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"},{"type":"n' < n","name":["hnn'"],"isProp":true,"id":["_uniq",227247],"binderInfo":"default"}]}],"start":11665},{"state":[],"start":11698},{"state":[],"start":11750},{"state":[],"start":11808},{"state":[{"type":"n = n' ∧ m = m'","tag":["mk","mk","mk","mk","inr","inr"],"mvarId":["_uniq",247503],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",222940],"binderInfo":"default"},{"type":"ℕ","name":["m"],"isProp":false,"id":["_uniq",222941],"binderInfo":"default"},{"type":"m ≤ n","name":["hnm"],"isProp":true,"id":["_uniq",222944],"binderInfo":"default"},{"type":"ℕ","name":["n'"],"isProp":false,"id":["_uniq",222985],"binderInfo":"default"},{"type":"ℕ","name":["m'"],"isProp":false,"id":["_uniq",222986],"binderInfo":"default"},{"type":"m' ≤ n'","name":["hnm'"],"isProp":true,"id":["_uniq",222989],"binderInfo":"default"},{"type":"a n + m = a n' + m'","name":["h"],"isProp":true,"id":["_uniq",222992],"binderInfo":"default"},{"type":"n' < n","name":["hnn'"],"isProp":true,"id":["_uniq",227247],"binderInfo":"default"},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (le_of_not_gt fun a_1 =>\n        Mathlib.Tactic.Linarith.lt_irrefl\n          (Eq.mp\n            (congrArg (fun _a => _a < 0)\n              (Mathlib.Tactic.Ring.of_eq\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.sub_congr\n                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                      (Mathlib.Tactic.Ring.atom_pf (↑m : ℤ))\n                      (Mathlib.Tactic.Ring.sub_pf\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_mul (↑m : ℤ) (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.neg_one_mul\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))))\n                          Mathlib.Tactic.Ring.neg_zero)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑m : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                      (Mathlib.Tactic.Ring.add_pf_zero_add ((↑m : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n) : ℤ))\n                        (Mathlib.Tactic.Ring.atom_pf (↑m : ℤ))\n                        (Mathlib.Tactic.Ring.add_pf_add_gt ((↑m : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_zero ((↑(a n) : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero\n                          ((↑m : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                            ((↑(a n) : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                    (Mathlib.Tactic.Ring.atom_pf (↑(a n) : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑(a n) : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_lt ((↑m : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n) : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0))))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                      (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m : ℤ) (Nat.rawCast 1)\n                        (Mathlib.Meta.NormNum.IsInt.to_isNat\n                          (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.ofNat 0)))))\n                      (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                (Int.add_one_le_iff.mpr\n                  (id\n                    (Eq.mp\n                      (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n + m) (a n))\n                        (congrArg (fun x => x < (↑(a n) : ℤ)) (Nat.cast_add (a n) m)))\n                      a_1)))))))\n      (StrictMono.monotone ha\n        (le_of_not_gt fun a =>\n          Mathlib.Tactic.Linarith.lt_irrefl\n            (Eq.mp\n              (congrArg (fun _a => _a < 0)\n                (Mathlib.Tactic.Ring.of_eq\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr\n                      (Mathlib.Tactic.Ring.neg_congr\n                        (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                        (Mathlib.Tactic.Ring.neg_add\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1)))))\n                          Mathlib.Tactic.Ring.neg_zero))\n                      (Mathlib.Tactic.Ring.sub_congr\n                        (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n' : ℤ))\n                          (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                          (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                            (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                        (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                        (Mathlib.Tactic.Ring.sub_pf\n                          (Mathlib.Tactic.Ring.neg_add\n                            (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                              (Mathlib.Tactic.Ring.neg_one_mul\n                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.negOfNat 1))))))\n                            Mathlib.Tactic.Ring.neg_zero)\n                          (Mathlib.Tactic.Ring.add_pf_add_lt ⋯ ⋯)))\n                      ⋯)\n                    ⋯ ⋯)\n                  ⋯))\n              ⋯))))\n    ⋯)\n  ⋯","type":"a n + m > a n' + m'","name":["this"],"isProp":true,"id":["_uniq",247502]}]}],"start":11845},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",222888],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]}]}],"start":11858},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",267544],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]}]}],"start":11921},{"state":[{"type":"Function.Bijective f'","tag":[],"mvarId":["_uniq",284854],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]}]}],"start":11962},{"state":[{"type":"Function.Injective f'","tag":["left"],"mvarId":["_uniq",284865],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]}]},{"type":"Function.Surjective f'","tag":["right"],"mvarId":["_uniq",284866],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]}]}],"start":11978},{"state":[{"type":"Function.Surjective f'","tag":["right"],"mvarId":["_uniq",284866],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]}]}],"start":12031},{"state":[{"type":"∃ a, f' a = ⟨l, hl⟩","tag":["right"],"mvarId":["_uniq",302753],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]},{"type":"ℕ","name":["l"],"isProp":false,"id":["_uniq",285203],"binderInfo":"default"},{"type":"l ∈ f '' Set.univ","name":["hl✝"],"isProp":true,"id":["_uniq",285204],"binderInfo":"default"},{"type":"∃ a b, ∃ (b_1 : (a, b) ∈ A), f ⟨(a, b), b_1⟩ = l","name":["hl"],"isProp":true,"id":["_uniq",302752],"binderInfo":"default"}]}],"start":12067},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",284856],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]},{"value":"⟨fun ⦃p q⦄ hpq =>\n  hf\n    (Eq.mp\n      (Subtype.mk.injEq (f p)\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => ∑ m ∈ Finset.range (p.1.1 + 1), m + p.1.2 ∈ x)\n                (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2))\n                  Set.image_univ))\n              Set.mem_range._simp_1)\n            (exists_apply_eq_apply._simp_1 (fun a => ∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2) p)))\n        (f q)\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => ∑ m ∈ Finset.range (q.1.1 + 1), m + q.1.2 ∈ x)\n                (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2))\n                  Set.image_univ))\n              Set.mem_range._simp_1)\n            (exists_apply_eq_apply._simp_1 (fun a => ∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2) q))))\n      hpq),\n  fun h =>\n  match h with\n  | ⟨l, hl⟩ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Eq.trans (congrArg (fun x => l ∈ x) Set.image_univ) Set.mem_range._simp_1)\n          (Eq.trans Subtype.exists._simp_1 Prod.exists._simp_1))\n        hl)\n      fun n h =>\n      Exists.casesOn h fun m h =>\n        Exists.casesOn h fun q h =>\n          Eq.ndrec (motive := fun l => ∀ (hl : l ∈ f '' Set.univ), ∃ a, f' a = ⟨l, hl⟩)\n            (fun hl => Exists.intro ⟨(n, m), q⟩ (Eq.refl (f' ⟨(n, m), q⟩))) h hl⟩","type":"Function.Bijective f'","name":["hf'"],"isProp":true,"id":["_uniq",284855]}]}],"start":12128},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",303060],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]},{"value":"⟨fun ⦃p q⦄ hpq =>\n  hf\n    (Eq.mp\n      (Subtype.mk.injEq (f p)\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => ∑ m ∈ Finset.range (p.1.1 + 1), m + p.1.2 ∈ x)\n                (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2))\n                  Set.image_univ))\n              Set.mem_range._simp_1)\n            (exists_apply_eq_apply._simp_1 (fun a => ∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2) p)))\n        (f q)\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => ∑ m ∈ Finset.range (q.1.1 + 1), m + q.1.2 ∈ x)\n                (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2))\n                  Set.image_univ))\n              Set.mem_range._simp_1)\n            (exists_apply_eq_apply._simp_1 (fun a => ∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2) q))))\n      hpq),\n  fun h =>\n  match h with\n  | ⟨l, hl⟩ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Eq.trans (congrArg (fun x => l ∈ x) Set.image_univ) Set.mem_range._simp_1)\n          (Eq.trans Subtype.exists._simp_1 Prod.exists._simp_1))\n        hl)\n      fun n h =>\n      Exists.casesOn h fun m h =>\n        Exists.casesOn h fun q h =>\n          Eq.ndrec (motive := fun l => ∀ (hl : l ∈ f '' Set.univ), ∃ a, f' a = ⟨l, hl⟩)\n            (fun hl => Exists.intro ⟨(n, m), q⟩ (Eq.refl (f' ⟨(n, m), q⟩))) h hl⟩","type":"Function.Bijective f'","name":["hf'"],"isProp":true,"id":["_uniq",284855]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (AtMostCountable.equiv (Exists.intro f' hf')))))\n  (Nat.atMostCountable_subset (f '' Set.univ))","type":"AtMostCountable (↑A : Type)","name":["this"],"isProp":true,"id":["_uniq",303059]}]}],"start":12237},{"state":[{"type":"¬Finite (↑A : Type)","tag":[],"mvarId":["_uniq",303318],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]},{"value":"⟨fun ⦃p q⦄ hpq =>\n  hf\n    (Eq.mp\n      (Subtype.mk.injEq (f p)\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => ∑ m ∈ Finset.range (p.1.1 + 1), m + p.1.2 ∈ x)\n                (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2))\n                  Set.image_univ))\n              Set.mem_range._simp_1)\n            (exists_apply_eq_apply._simp_1 (fun a => ∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2) p)))\n        (f q)\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => ∑ m ∈ Finset.range (q.1.1 + 1), m + q.1.2 ∈ x)\n                (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2))\n                  Set.image_univ))\n              Set.mem_range._simp_1)\n            (exists_apply_eq_apply._simp_1 (fun a => ∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2) q))))\n      hpq),\n  fun h =>\n  match h with\n  | ⟨l, hl⟩ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Eq.trans (congrArg (fun x => l ∈ x) Set.image_univ) Set.mem_range._simp_1)\n          (Eq.trans Subtype.exists._simp_1 Prod.exists._simp_1))\n        hl)\n      fun n h =>\n      Exists.casesOn h fun m h =>\n        Exists.casesOn h fun q h =>\n          Eq.ndrec (motive := fun l => ∀ (hl : l ∈ f '' Set.univ), ∃ a, f' a = ⟨l, hl⟩)\n            (fun hl => Exists.intro ⟨(n, m), q⟩ (Eq.refl (f' ⟨(n, m), q⟩))) h hl⟩","type":"Function.Bijective f'","name":["hf'"],"isProp":true,"id":["_uniq",284855]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (AtMostCountable.equiv (Exists.intro f' hf')))))\n  (Nat.atMostCountable_subset (f '' Set.univ))","type":"AtMostCountable (↑A : Type)","name":["this"],"isProp":true,"id":["_uniq",303059]}]}],"start":12269},{"state":[{"type":"CountablyInfinite (↑{n | n.2 ≤ n.1} : Type)","tag":[],"mvarId":["_uniq",303320],"isProp":true,"context":[{"value":"{n | n.2 ≤ n.1}","type":"Set (ℕ × ℕ)","name":["A"],"isProp":false,"id":["_uniq",222278]},{"value":"fun n => ∑ m ∈ Finset.range (n + 1), m","type":"ℕ → ℕ","name":["a"],"isProp":false,"id":["_uniq",222527]},{"value":"sorry","type":"StrictMono a","name":["ha"],"isProp":true,"id":["_uniq",222658]},{"value":"fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => a n + m","type":"(↑A : Type) → ℕ","name":["f"],"isProp":false,"id":["_uniq",222874]},{"value":"fun ⦃a₁⦄ =>\n  Subtype.casesOn (motive := fun x => ∀ ⦃a₂ : (↑A : Type)⦄, f x = f a₂ → x = a₂) a₁ fun val hnm =>\n    Prod.casesOn (motive := fun x => ∀ (hnm : x ∈ A) ⦃a₂ : (↑A : Type)⦄, f ⟨x, hnm⟩ = f a₂ → ⟨x, hnm⟩ = a₂) val\n      (fun n m hnm ⦃a₂⦄ =>\n        Subtype.casesOn (motive := fun x => f ⟨(n, m), hnm⟩ = f x → ⟨(n, m), hnm⟩ = x) a₂ fun val hnm' =>\n          Prod.casesOn (motive := fun x => ∀ (hnm' : x ∈ A), f ⟨(n, m), hnm⟩ = f ⟨x, hnm'⟩ → ⟨(n, m), hnm⟩ = ⟨x, hnm'⟩)\n            val\n            (fun n' m' hnm' h =>\n              Eq.mpr (id (Eq.trans (Subtype.mk.injEq (n, m) hnm (n', m') hnm') (Prod.mk.injEq n m n' m')))\n                (Or.casesOn (lt_trichotomy n n')\n                  (fun hnn' =>\n                    have this :=\n                      Trans.trans\n                        (Trans.trans\n                          (Trans.trans\n                            (le_of_not_gt fun a_1 =>\n                              Mathlib.Tactic.Linarith.lt_irrefl\n                                (Eq.mp\n                                  (congrArg (fun _a => _a < 0)\n                                    (Mathlib.Tactic.Ring.of_eq\n                                      (Mathlib.Tactic.Ring.add_congr\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.neg_congr\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_one_mul\n                                                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                  (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                    (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                    (Eq.refl (Int.negOfNat 1)))))\n                                              Mathlib.Tactic.Ring.neg_zero))\n                                          (Mathlib.Tactic.Ring.sub_congr\n                                            (Mathlib.Tactic.Ring.cast_zero\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                                            (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                            (Mathlib.Tactic.Ring.sub_pf\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_mul (↑m' : ℤ) (Nat.rawCast 1)\n                                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Eq.refl (Int.negOfNat 1))))))\n                                                Mathlib.Tactic.Ring.neg_zero)\n                                              (Mathlib.Tactic.Ring.add_pf_zero_add\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 1).rawCast\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add\n                                              ((↑m' : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                                        (Mathlib.Tactic.Ring.sub_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                              (Mathlib.Tactic.Ring.atom_pf (↑m' : ℤ))\n                                              (Mathlib.Tactic.Ring.add_pf_add_gt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                                            (Mathlib.Tactic.Ring.cast_pos\n                                              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                            (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_zero\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 +\n                                                  ((↑(a n') : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                                          (Mathlib.Tactic.Ring.atom_pf (↑(a n') : ℤ))\n                                          (Mathlib.Tactic.Ring.sub_pf\n                                            (Mathlib.Tactic.Ring.neg_add\n                                              (Mathlib.Tactic.Ring.neg_mul (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                      (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                        (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                      (Eq.refl (Int.negOfNat 1))))))\n                                              Mathlib.Tactic.Ring.neg_zero)\n                                            (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                              (Mathlib.Tactic.Ring.add_pf_add_lt\n                                                ((↑m' : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1)\n                                                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑(a n') : ℤ) (Nat.rawCast 1)\n                                                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                        (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                        (Eq.refl (Int.ofNat 0)))))\n                                                  (Mathlib.Tactic.Ring.add_pf_zero_add 0))))))\n                                        (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                          (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                            (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                              (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                              (Eq.refl (Int.ofNat 0))))\n                                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                                            (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑m' : ℤ) (Nat.rawCast 1)\n                                              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                                  (Mathlib.Meta.NormNum.IsNat.to_isInt\n                                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                                  (Eq.refl (Int.ofNat 0)))))\n                                            (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                                      (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                                  (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                                      (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                        (Mathlib.Tactic.Linarith.natCast_nonneg ℤ m')))\n                                    (Mathlib.Tactic.Linarith.sub_nonpos_of_le\n                                      (Int.add_one_le_iff.mpr\n                                        (id\n                                          (Eq.mp\n                                            (Eq.trans (Mathlib.Tactic.Zify.natCast_lt._simp_1 (a n' + m') (a n'))\n                                              (congrArg (fun x => x < (↑(a n') : ℤ)) (Nat.cast_add (a n') m')))\n                                            a_1)))))))\n                            (StrictMono.monotone ha\n                              (le_of_not_gt fun a =>\n                                Mathlib.Tactic.Linarith.lt_irrefl\n                                  (Eq.mp\n                                    (congrArg (fun _a => _a < 0)\n                                      (Mathlib.Tactic.Ring.of_eq\n                                        (Mathlib.Tactic.Ring.add_congr\n                                          (Mathlib.Tactic.Ring.add_congr\n                                            (Mathlib.Tactic.Ring.neg_congr\n                                              (Mathlib.Tactic.Ring.cast_pos\n                                                (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                              (Mathlib.Tactic.Ring.neg_add\n                                                (Mathlib.Tactic.Ring.neg_one_mul\n                                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq ⋯))\n                                                ⋯))\n                                            ⋯ ⋯)\n                                          ⋯ ⋯)\n                                        ⋯))\n                                    ⋯))))\n                          ⋯)\n                        ⋯;\n                    ⋯)\n                  ⋯))\n            ⋯)\n      ⋯","type":"Function.Injective f","name":["hf"],"isProp":true,"id":["_uniq",222887]},{"value":"fun p => ⟨f p, ⋯⟩","type":"(↑A : Type) → (↑(f '' Set.univ) : Type)","name":["f'"],"isProp":false,"id":["_uniq",267542]},{"value":"⟨fun ⦃p q⦄ hpq =>\n  hf\n    (Eq.mp\n      (Subtype.mk.injEq (f p)\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => ∑ m ∈ Finset.range (p.1.1 + 1), m + p.1.2 ∈ x)\n                (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2))\n                  Set.image_univ))\n              Set.mem_range._simp_1)\n            (exists_apply_eq_apply._simp_1 (fun a => ∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2) p)))\n        (f q)\n        (of_eq_true\n          (Eq.trans\n            (Eq.trans\n              (congrArg (fun x => ∑ m ∈ Finset.range (q.1.1 + 1), m + q.1.2 ∈ x)\n                (Eq.trans (Set.image_congr fun a a_1 => Eq.refl (∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2))\n                  Set.image_univ))\n              Set.mem_range._simp_1)\n            (exists_apply_eq_apply._simp_1 (fun a => ∑ m ∈ Finset.range (a.1.1 + 1), m + a.1.2) q))))\n      hpq),\n  fun h =>\n  match h with\n  | ⟨l, hl⟩ =>\n    Exists.casesOn\n      (Eq.mp\n        (Eq.trans (Eq.trans (congrArg (fun x => l ∈ x) Set.image_univ) Set.mem_range._simp_1)\n          (Eq.trans Subtype.exists._simp_1 Prod.exists._simp_1))\n        hl)\n      fun n h =>\n      Exists.casesOn h fun m h =>\n        Exists.casesOn h fun q h =>\n          Eq.ndrec (motive := fun l => ∀ (hl : l ∈ f '' Set.univ), ∃ a, f' a = ⟨l, hl⟩)\n            (fun hl => Exists.intro ⟨(n, m), q⟩ (Eq.refl (f' ⟨(n, m), q⟩))) h hl⟩","type":"Function.Bijective f'","name":["hf'"],"isProp":true,"id":["_uniq",284855]},{"value":"Eq.mpr (id (congrArg (fun _a => _a) (propext (AtMostCountable.equiv (Exists.intro f' hf')))))\n  (Nat.atMostCountable_subset (f '' Set.univ))","type":"AtMostCountable (↑A : Type)","name":["this"],"isProp":true,"id":["_uniq",303059]},{"value":"sorry","type":"¬Finite (↑A : Type)","name":["hfin"],"isProp":true,"id":["_uniq",303319]}]}],"start":12279},{"state":[],"start":12319},{"state":[],"start":12320},{"state":[],"start":12344},{"state":[{"type":"CountablyInfinite (ℕ × ℕ)","tag":[],"mvarId":["_uniq",305560],"isProp":true,"context":[]}],"start":12418},{"state":[{"type":"CountablyInfinite (↑{n | n.1 ≤ n.2} : Type)","tag":[],"mvarId":["_uniq",305784],"isProp":true,"context":[]}],"start":12495},{"state":[{"type":"Function.Injective fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => ⟨(m, n), ⋯⟩","tag":["refine_1"],"mvarId":["_uniq",305816],"isProp":true,"context":[]},{"type":"Function.Surjective fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => ⟨(m, n), ⋯⟩","tag":["refine_2"],"mvarId":["_uniq",305817],"isProp":true,"context":[]}],"start":12595},{"state":[{"type":"Function.Surjective fun x =>\n  match x with\n  | ⟨(n, m), property⟩ => ⟨(m, n), ⋯⟩","tag":["refine_2"],"mvarId":["_uniq",305817],"isProp":true,"context":[]}],"start":12652},{"state":[{"type":"CountablyInfinite (ℕ × ℕ)","tag":[],"mvarId":["_uniq",305786],"isProp":true,"context":[{"value":"(equiv\n      (Exists.intro\n        (fun x =>\n          match x with\n          | ⟨(n, m), property⟩ => ⟨(m, n), id (id property)⟩)\n        ⟨fun ⦃h⦄ =>\n          match h with\n          | ⋯ => fun ⦃h⦄ =>\n            match h with\n            | ⋯ => fun a =>\n              of_eq_true\n                (Eq.trans\n                  (congrArg (fun x => x = ⟨(fst_1, snd_1), property_1⟩)\n                    ((fun {α} {p} val val_1 e_val =>\n                        Eq.rec (motive := fun val_2 e_val =>\n                          ∀ (property : p val), ⟨val, property⟩ = ⟨val_2, e_val ▸ property⟩)\n                          (fun property => Eq.refl ⟨val, property⟩) e_val)\n                      (fst, snd) (fst_1, snd_1)\n                      (congr (congrArg Prod.mk (id (Eq.mp (Eq.trans (Subtype.mk.injEq ⋯ ⋯ ⋯ ⋯) ⋯) ⋯)).2) ⋯) ⋯))\n                  ⋯),\n          ⋯⟩)).mp\n  ⋯","type":"CountablyInfinite (↑{n | n.1 ≤ n.2} : Type)","name":["upper_diag"],"isProp":true,"id":["_uniq",305785]}]}],"start":12710},{"state":[{"type":"CountablyInfinite (↑Set.univ : Type)","tag":[],"mvarId":["_uniq",312615],"isProp":true,"context":[{"value":"(equiv\n      (Exists.intro\n        (fun x =>\n          match x with\n          | ⟨(n, m), property⟩ => ⟨(m, n), id (id property)⟩)\n        ⟨fun ⦃h⦄ =>\n          match h with\n          | ⋯ => fun ⦃h⦄ =>\n            match h with\n            | ⋯ => fun a =>\n              of_eq_true\n                (Eq.trans\n                  (congrArg (fun x => x = ⟨(fst_1, snd_1), property_1⟩)\n                    ((fun {α} {p} val val_1 e_val =>\n                        Eq.rec (motive := fun val_2 e_val =>\n                          ∀ (property : p val), ⟨val, property⟩ = ⟨val_2, e_val ▸ property⟩)\n                          (fun property => Eq.refl ⟨val, property⟩) e_val)\n                      (fst, snd) (fst_1, snd_1)\n                      (congr (congrArg Prod.mk (id (Eq.mp (Eq.trans (Subtype.mk.injEq ⋯ ⋯ ⋯ ⋯) ⋯) ⋯)).2) ⋯) ⋯))\n                  ⋯),\n          ⋯⟩)).mp\n  ⋯","type":"CountablyInfinite (↑{n | n.1 ≤ n.2} : Type)","name":["upper_diag"],"isProp":true,"id":["_uniq",305785]}]}],"start":12770},{"state":[{"type":"CountablyInfinite (ℕ × ℕ)","tag":[],"mvarId":["_uniq",312617],"isProp":true,"context":[{"value":"(equiv\n      (Exists.intro\n        (fun x =>\n          match x with\n          | ⟨(n, m), property⟩ => ⟨(m, n), id (id property)⟩)\n        ⟨fun ⦃h⦄ =>\n          match h with\n          | ⋯ => fun ⦃h⦄ =>\n            match h with\n            | ⋯ => fun a =>\n              of_eq_true\n                (Eq.trans\n                  (congrArg (fun x => x = ⟨(fst_1, snd_1), property_1⟩)\n                    ((fun {α} {p} val val_1 e_val =>\n                        Eq.rec (motive := fun val_2 e_val =>\n                          ∀ (property : p val), ⟨val, property⟩ = ⟨val_2, e_val ▸ property⟩)\n                          (fun property => Eq.refl ⟨val, property⟩) e_val)\n                      (fst, snd) (fst_1, snd_1)\n                      (congr (congrArg Prod.mk (id (Eq.mp (Eq.trans (Subtype.mk.injEq ⋯ ⋯ ⋯ ⋯) ⋯) ⋯)).2) ⋯) ⋯))\n                  ⋯),\n          ⋯⟩)).mp\n  ⋯","type":"CountablyInfinite (↑{n | n.1 ≤ n.2} : Type)","name":["upper_diag"],"isProp":true,"id":["_uniq",305785]},{"value":"Eq.mpr\n  (eq_of_heq\n    ((fun X X' e'_1 =>\n        Eq.casesOn (motive := fun a x => X' = a → e'_1 ≍ x → CountablyInfinite X ≍ CountablyInfinite X') e'_1\n          (fun h =>\n            Eq.ndrec (motive := fun X' =>\n              ∀ (e_1 : X = X'), e_1 ≍ Eq.refl X → CountablyInfinite X ≍ CountablyInfinite X')\n              (fun e_1 h => HEq.refl (CountablyInfinite X)) (Eq.symm h) e'_1)\n          (Eq.refl X') (HEq.refl e'_1))\n      (↑Set.univ : Type) (↑({n | n.2 ≤ n.1} ∪ {n | n.1 ≤ n.2}) : Type)\n      (eq_of_heq\n        ((fun α s s' e'_2 =>\n            Eq.casesOn (motive := fun a x => s' = a → e'_2 ≍ x → (↑s : Type) ≍ (↑s' : Type)) e'_2\n              (fun h =>\n                Eq.ndrec (motive := fun s' => ∀ (e_2 : s = s'), e_2 ≍ Eq.refl s → (↑s : Type) ≍ (↑s' : Type))\n                  (fun e_2 h => HEq.refl (↑s : Type)) (Eq.symm h) e'_2)\n              (Eq.refl s') (HEq.refl e'_2))\n          (ℕ × ℕ) Set.univ ({n | n.2 ≤ n.1} ∪ {n | n.1 ≤ n.2})\n          (Set.ext fun x =>\n            Prod.casesOn x fun n m =>\n              Eq.mpr\n                (id\n                  (Eq.trans\n                    (congr (congrArg Iff (Set.mem_univ._simp_1 (n, m)))\n                      (Set.mem_union._simp_1 (n, m) {n | n.2 ≤ n.1} {n | n.1 ≤ n.2}))\n                    (true_iff (m ≤ n ∨ n ≤ m))))\n                (Decidable.byContradiction fun a => prod_nat._proof_5 n m a))))))\n  (union lower_diag upper_diag)","type":"CountablyInfinite (↑Set.univ : Type)","name":["this"],"isProp":true,"id":["_uniq",312616]}]}],"start":12841},{"state":[],"start":12875},{"state":[],"start":12876},{"state":[],"start":12917},{"state":[],"start":13013},{"state":[{"type":"CountablyInfinite (X × Y)","tag":[],"mvarId":["_uniq",316489],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",316485],"binderInfo":"implicit"},{"type":"Type","name":["Y"],"isProp":false,"id":["_uniq",316486],"binderInfo":"implicit"},{"type":"CountablyInfinite X","name":["hX"],"isProp":true,"id":["_uniq",316487],"binderInfo":"default"},{"type":"CountablyInfinite Y","name":["hY"],"isProp":true,"id":["_uniq",316488],"binderInfo":"default"}]}],"start":13048},{"state":[],"start":13056},{"state":[],"start":13057},{"state":[],"start":13081},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",316493],"isProp":true,"context":[]}],"start":13141},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",316493],"isProp":true,"context":[]}],"start":13214},{"state":[{"type":"CountablyInfinite (↑{n | n ≠ 0} : Type)","tag":[],"mvarId":["_uniq",316734],"isProp":true,"context":[]}],"start":13267},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",316736],"isProp":true,"context":[{"value":"sorry","type":"CountablyInfinite (↑{n | n ≠ 0} : Type)","name":["this"],"isProp":true,"id":["_uniq",316735]}]}],"start":13277},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",316753],"isProp":true,"context":[{"type":"CountablyInfinite (ℤ × (↑{n | n ≠ 0} : Type))","name":["this"],"isProp":true,"id":["_uniq",316750],"binderInfo":"default"}]}],"start":13320},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",318930],"isProp":true,"context":[{"type":"CountablyInfinite (ℤ × (↑{n | n ≠ 0} : Type))","name":["this"],"isProp":true,"id":["_uniq",316750],"binderInfo":"default"},{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]}]}],"start":13392},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",318945],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"AtMostCountable.image _fvar.316750 f","type":"AtMostCountable (↑(f '' Set.univ) : Type)","name":["this"],"isProp":true,"id":["_uniq",318941]}]}],"start":13434},{"state":[{"type":"f '' Set.univ = Set.univ","tag":[],"mvarId":["_uniq",318967],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"AtMostCountable.image _fvar.316750 f","type":"AtMostCountable (↑(f '' Set.univ) : Type)","name":["this"],"isProp":true,"id":["_uniq",318941]}]}],"start":13470},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",318969],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"AtMostCountable.image _fvar.316750 f","type":"AtMostCountable (↑(f '' Set.univ) : Type)","name":["this"],"isProp":true,"id":["_uniq",318941]},{"value":"sorry","type":"f '' Set.univ = Set.univ","name":["h"],"isProp":true,"id":["_uniq",318968]}]}],"start":13480},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",319789],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"sorry","type":"f '' Set.univ = Set.univ","name":["h"],"isProp":true,"id":["_uniq",318968]},{"type":"CountablyInfinite ℚ ∨ Finite ℚ","name":["this"],"isProp":true,"id":["_uniq",319786],"binderInfo":"default"}]}],"start":13558},{"state":[{"type":"¬Finite ℚ","tag":[],"mvarId":["_uniq",319792],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"sorry","type":"f '' Set.univ = Set.univ","name":["h"],"isProp":true,"id":["_uniq",318968]},{"type":"CountablyInfinite ℚ ∨ Finite ℚ","name":["this"],"isProp":true,"id":["_uniq",319786],"binderInfo":"default"}]}],"start":13592},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",319800],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"sorry","type":"f '' Set.univ = Set.univ","name":["h"],"isProp":true,"id":["_uniq",318968]},{"type":"CountablyInfinite ℚ ∨ Finite ℚ","name":["this✝"],"isProp":true,"id":["_uniq",319786],"binderInfo":"default"},{"type":"Finite ℚ","name":["this"],"isProp":true,"id":["_uniq",319799],"binderInfo":"default"}]}],"start":13607},{"state":[{"type":"Finite (↑Set.univ : Type)","tag":[],"mvarId":["_uniq",320030],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"sorry","type":"f '' Set.univ = Set.univ","name":["h"],"isProp":true,"id":["_uniq",318968]},{"type":"CountablyInfinite ℚ ∨ Finite ℚ","name":["this✝"],"isProp":true,"id":["_uniq",319786],"binderInfo":"default"},{"type":"Finite ℚ","name":["this"],"isProp":true,"id":["_uniq",319799],"binderInfo":"default"}]}],"start":13652},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",321641],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"sorry","type":"f '' Set.univ = Set.univ","name":["h"],"isProp":true,"id":["_uniq",318968]},{"type":"CountablyInfinite ℚ ∨ Finite ℚ","name":["this✝"],"isProp":true,"id":["_uniq",319786],"binderInfo":"default"},{"value":"Finite.Set.finite_of_finite_image Set.univ fun ⦃x₁⦄ a ⦃x₂⦄ a =>\n  of_eq_true (Eq.trans (implies_congr Rat.natCast_inj._simp_1 (Eq.refl (x₁ = x₂))) imp_self._simp_1)","type":"Finite (↑Set.univ : Type)","name":["this"],"isProp":true,"id":["_uniq",320031]}]}],"start":13738},{"state":[{"type":"False","tag":[],"mvarId":["_uniq",321690],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"sorry","type":"f '' Set.univ = Set.univ","name":["h"],"isProp":true,"id":["_uniq",318968]},{"type":"CountablyInfinite ℚ ∨ Finite ℚ","name":["this✝"],"isProp":true,"id":["_uniq",319786],"binderInfo":"default"},{"type":"¬Infinite ℕ","name":["this"],"isProp":true,"id":["_uniq",321687],"binderInfo":"default"}]}],"start":13822},{"state":[{"type":"CountablyInfinite ℚ","tag":[],"mvarId":["_uniq",319794],"isProp":true,"context":[{"value":"fun x =>\n  match x with\n  | (a, b) => (↑a : ℚ) / (↑(↑b : ℤ) : ℚ)","type":"ℤ × (↑{n | n ≠ 0} : Type) → ℚ","name":["f"],"isProp":false,"id":["_uniq",318929]},{"value":"sorry","type":"f '' Set.univ = Set.univ","name":["h"],"isProp":true,"id":["_uniq",318968]},{"type":"CountablyInfinite ℚ ∨ Finite ℚ","name":["this"],"isProp":true,"id":["_uniq",319786],"binderInfo":"default"},{"value":"fun this =>\n  have this :=\n    Finite.Set.finite_of_finite_image Set.univ fun ⦃x₁⦄ a ⦃x₂⦄ a =>\n      of_eq_true (Eq.trans (implies_congr Rat.natCast_inj._simp_1 (Eq.refl (x₁ = x₂))) imp_self._simp_1);\n  Eq.mp (congrArg (fun _a => _a) (Eq.symm (propext not_infinite_iff_finite)))\n    (Eq.mp (congrArg (fun _a => _a) (propext Set.finite_univ_iff))\n      (Eq.mp (congrArg (fun _a => _a) (propext Set.finite_coe_iff)) this))\n    inferInstance","type":"¬Finite ℚ","name":["hfin"],"isProp":true,"id":["_uniq",319793]}]}],"start":13853},{"state":[],"start":13861},{"state":[],"start":13862},{"state":[],"start":13884},{"state":[{"type":"Infinite X ↔ ∃ Y, Y ≠ Set.univ ∧ EqualCard (↑Y : Type) X","tag":[],"mvarId":["_uniq",323822],"isProp":true,"context":[{"type":"Type","name":["X"],"isProp":false,"id":["_uniq",323821],"binderInfo":"default"}]}],"start":13970},{"state":[],"start":13978},{"state":[],"start":13979},{"state":[],"start":14001},{"state":[{"type":"AtMostCountable A ↔ ∃ f, Function.Injective f","tag":[],"mvarId":["_uniq",323845],"isProp":true,"context":[{"type":"Type","name":["A"],"isProp":false,"id":["_uniq",323844],"binderInfo":"default"}]}],"start":14089},{"state":[],"start":14097},{"state":[],"start":14098},{"state":[],"start":14120},{"state":[],"start":14217},{"state":[],"start":14260},{"state":[],"start":14261},{"state":[],"start":14348},{"state":[],"start":14397},{"state":[],"start":14398},{"state":[],"start":14482},{"state":[],"start":14483},{"state":[],"start":14496},{"state":[],"start":14496}]
