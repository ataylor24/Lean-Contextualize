[{"value":{"range":[1609,1666],"original":true},"type":{"range":[1605,1608],"original":true},"signature":{"range":{"stop":1608,"start":1584},"pp":" (n : Chapter2.Nat) : ℕ","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":1666,"start":1484},"pp":"/-- Converting a Chapter 2 natural number to a Mathlib natural number. -/\nabbrev toNat (n : Chapter2.Nat) : ℕ :=\n  match n with\n  | zero => 0\n  | succ n' => n'.toNat + 1","original":true},"params":[{"type":[1589,1601],"ref":[1585,1586],"id":[1585,1586],"bi":"default"}],"name":["Chapter2","Nat","toNat"],"modifiers":null,"kind":"abbrev","id":{"range":[1565,1583],"original":true}},{"value":{"range":[1729,1735],"original":true},"type":{"range":[1700,1728],"original":true},"signature":{"range":{"stop":1728,"start":1698},"pp":" : (0 : Chapter2.Nat).toNat = 0","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":1735,"start":1668},"pp":"theorem zero_toNat : (0 : Chapter2.Nat).toNat = 0 :=\n  rfl","original":false},"params":[],"name":["Chapter2","Nat","zero_toNat"],"modifiers":null,"kind":"theorem","id":{"range":[1674,1697],"original":true}},{"value":{"range":[1814,1820],"original":true},"type":{"range":[1788,1813],"original":true},"signature":{"range":{"stop":1813,"start":1767},"pp":" (n : Chapter2.Nat) : (n++).toNat = n.toNat + 1","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":1820,"start":1737},"pp":"theorem succ_toNat (n : Chapter2.Nat) : (n++).toNat = n.toNat + 1 :=\n  rfl","original":false},"params":[{"type":[1772,1784],"ref":[1768,1769],"id":[1768,1769],"bi":"default"}],"name":["Chapter2","Nat","succ_toNat"],"modifiers":null,"kind":"theorem","id":{"range":[1743,1766],"original":true}},{"value":{"range":[2036,2265],"original":true},"type":{"range":[2015,2035],"original":true},"signature":{"range":{"stop":2035,"start":2013},"pp":" : Chapter2.Nat ≃ ℕ","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":2265,"start":1822},"pp":"/-- The conversion is a bijection. Here we use the existing capability (from Section 2.1) to map\nthe Mathlib natural numbers to the Chapter 2 natural numbers. -/\nabbrev equivNat : Chapter2.Nat ≃ ℕ where\n  toFun := toNat\n  invFun n := (n : Chapter2.Nat)\n  left_inv\n    n := by\n    induction' n with n hn; rfl\n    simp [hn]\n    rw [succ_eq_add_one]\n  right_inv\n    n := by\n    induction' n with n hn; rfl\n    simp [← succ_eq_add_one, hn]","original":true},"params":[],"name":["Chapter2","Nat","equivNat"],"modifiers":null,"kind":"abbrev","id":{"range":[1991,2012],"original":true}},{"value":{"range":[2390,2504],"original":true},"type":{"range":[2339,2389],"original":true},"signature":{"range":{"stop":2389,"start":2337},"pp":" : ∀ (n m : Nat), (n + m).toNat = n.toNat + m.toNat","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":2504,"start":2267},"pp":"/-- The conversion preserves addition. -/\nabbrev map_add : ∀ (n m : Nat), (n + m).toNat = n.toNat + m.toNat :=\n  by\n  intro n m\n  induction' n with n hn\n  · rw [show zero = 0 from rfl, zero_add, _root_.Nat.zero_add]\n  sorry","original":true},"params":[],"name":["Chapter2","Nat","map_add"],"modifiers":null,"kind":"abbrev","id":{"range":[2316,2336],"original":true}},{"value":{"range":[2635,2660],"original":true},"type":{"range":[2584,2634],"original":true},"signature":{"range":{"stop":2634,"start":2582},"pp":" : ∀ (n m : Nat), (n * m).toNat = n.toNat * m.toNat","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":2660,"start":2506},"pp":"/-- The conversion preserves multiplication. -/\nabbrev map_mul : ∀ (n m : Nat), (n * m).toNat = n.toNat * m.toNat :=\n  by\n  intro n m\n  sorry","original":true},"params":[],"name":["Chapter2","Nat","map_mul"],"modifiers":null,"kind":"abbrev","id":{"range":[2561,2581],"original":true}},{"value":{"range":[2787,2812],"original":true},"type":{"range":[2738,2786],"original":true},"signature":{"range":{"stop":2786,"start":2736},"pp":" : ∀ {n m : Nat}, n.toNat ≤ m.toNat ↔ n ≤ m","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":2812,"start":2662},"pp":"/-- The conversion preserves order. -/\nabbrev map_le_map_iff : ∀ {n m : Nat}, n.toNat ≤ m.toNat ↔ n ≤ m :=\n  by\n  intro n m\n  sorry","original":true},"params":[],"name":["Chapter2","Nat","map_le_map_iff"],"modifiers":null,"kind":"abbrev","id":{"range":[2708,2735],"original":true}},{"value":{"range":[2882,2989],"original":true},"type":{"range":[2858,2881],"original":true},"signature":{"range":{"stop":2881,"start":2856},"pp":" : Chapter2.Nat ≃+*o ℕ","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":2989,"start":2814},"pp":"abbrev equivNat_ordered_ring : Chapter2.Nat ≃+*o ℕ\n    where\n  toEquiv := equivNat\n  map_add' := map_add\n  map_mul' := map_mul\n  map_le_map_iff' := map_le_map_iff","original":true},"params":[],"name":["Chapter2","Nat","equivNat_ordered_ring"],"modifiers":null,"kind":"abbrev","id":{"range":[2821,2855],"original":true}},{"value":{"range":[3128,3141],"original":true},"type":{"range":[3096,3127],"original":true},"signature":{"range":{"stop":3127,"start":3069},"pp":" (n m : Chapter2.Nat) : n.toNat ^ m.toNat = (n ^ m).toNat","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["Chapter2","Nat"],["Chapter2"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["Chapter2","Nat"]},"ref":{"range":{"stop":3141,"start":2991},"pp":"/-- The conversion preserves exponentiation. -/\ntheorem pow_eq_pow (n m : Chapter2.Nat) : n.toNat ^ m.toNat = (n ^ m).toNat := by sorry","original":true},"params":[{"type":[3076,3088],"ref":[3070,3071],"id":[3070,3071],"bi":"default"},{"type":[3076,3088],"ref":[3072,3073],"id":[3072,3073],"bi":"default"}],"name":["Chapter2","Nat","pow_eq_pow"],"modifiers":null,"kind":"theorem","id":{"range":[3045,3068],"original":true}},{"value":null,"type":null,"signature":{"range":null,"pp":"","original":false},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":[]},"ref":{"range":{"stop":3536,"start":3144},"pp":"/-- The Peano axioms for an abstract type `Nat` -/\n@[ext]\nstructure PeanoAxioms where\n  Nat : Type\n  zero : Nat\n  succ : Nat → Nat\n  succ_ne : ∀ n : Nat, succ n ≠ zero\n  succ_cancel : ∀ {n m : Nat}, succ n = succ m → n = m\n  induction : ∀ (P : Nat → Prop), P zero → (∀ n : Nat, P n → P (succ n)) → ∀ n : Nat, P n","original":true},"params":[],"name":["PeanoAxioms"],"modifiers":null,"kind":"structure","id":{"range":[3212,3223],"original":true},"fields":[{"type":{"range":{"stop":3242,"start":3236},"pp":" : Type","original":true},"name":["PeanoAxioms","Nat"],"implicit":false,"binderInfo":"default"},{"type":{"range":{"stop":3255,"start":3250},"pp":" : Nat","original":true},"name":["PeanoAxioms","zero"],"implicit":false,"binderInfo":"default"},{"type":{"range":{"stop":3289,"start":3276},"pp":" : Nat → Nat","original":true},"name":["PeanoAxioms","succ"],"implicit":false,"binderInfo":"default"},{"type":{"range":{"stop":3343,"start":3313},"pp":" : ∀ n : Nat, succ n ≠ zero","original":true},"name":["PeanoAxioms","succ_ne"],"implicit":false,"binderInfo":"default"},{"type":{"range":{"stop":3415,"start":3371},"pp":" : ∀ {n m : Nat}, succ n = succ m → n = m","original":true},"name":["PeanoAxioms","succ_cancel"],"implicit":false,"binderInfo":"default"},{"type":{"range":{"stop":3536,"start":3441},"pp":" : ∀ (P : Nat → Prop), P zero → (∀ n : Nat, P n → P (succ n)) → ∀ n : Nat, P n","original":true},"name":["PeanoAxioms","induction"],"implicit":false,"binderInfo":"default"}],"constructors":[]},{"value":{"range":[3665,3862],"original":true},"type":{"range":[3653,3664],"original":true},"signature":{"range":{"stop":3664,"start":3651},"pp":" : PeanoAxioms","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":{"stop":3862,"start":3574},"pp":"/-- The Chapter 2 natural numbers obey the Peano axioms. -/\ndef Chapter2_Nat : PeanoAxioms where\n  Nat := Chapter2.Nat\n  zero := Chapter2.Nat.zero\n  succ := Chapter2.Nat.succ\n  succ_ne := Chapter2.Nat.succ_ne\n  succ_cancel := Chapter2.Nat.succ_cancel\n  induction := Chapter2.Nat.induction","original":true},"params":[],"name":["PeanoAxioms","Chapter2_Nat"],"modifiers":null,"kind":"definition","id":{"range":[3638,3650],"original":true}},{"value":{"range":[3952,4089],"original":true},"type":{"range":[3940,3951],"original":true},"signature":{"range":{"stop":3951,"start":3938},"pp":" : PeanoAxioms","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":{"stop":4089,"start":3864},"pp":"/-- The Mathlib natural numbers obey the Peano axioms. -/\ndef Mathlib_Nat : PeanoAxioms where\n  Nat := ℕ\n  zero := 0\n  succ := Nat.succ\n  succ_ne := Nat.succ_ne_zero\n  succ_cancel := Nat.succ_inj.mp\n  induction _ := Nat.rec","original":true},"params":[],"name":["PeanoAxioms","Mathlib_Nat"],"modifiers":null,"kind":"definition","id":{"range":[3926,3937],"original":true}},{"value":{"range":[4238,4325],"original":true},"type":{"range":[4224,4237],"original":true},"signature":{"range":{"stop":4237,"start":4204},"pp":" (P : PeanoAxioms) : ℕ → P.Nat","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":{"stop":4325,"start":4091},"pp":"/-- One can map the Mathlib natural numbers into any other structure obeying the Peano axioms. -/\nabbrev natCast (P : PeanoAxioms) : ℕ → P.Nat := fun n ↦\n  match n with\n  | Nat.zero => P.zero\n  | Nat.succ n => P.succ (natCast P n)","original":true},"params":[{"type":[4209,4220],"ref":[4205,4206],"id":[4205,4206],"bi":"default"}],"name":["PeanoAxioms","natCast"],"modifiers":null,"kind":"abbrev","id":{"range":[4196,4203],"original":true}},{"value":{"range":[4512,4525],"original":true},"type":{"range":[4482,4510],"original":true},"signature":{"range":{"stop":4510,"start":4462},"pp":" (P : PeanoAxioms) : Function.Injective P.natCast","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":{"stop":4525,"start":4327},"pp":"/-- One can start the proof here with `unfold Function.Injective`, although it is not strictly necessary. -/\ntheorem natCast_injective (P : PeanoAxioms) : Function.Injective P.natCast := by sorry","original":true},"params":[{"type":[4467,4478],"ref":[4463,4464],"id":[4463,4464],"bi":"default"}],"name":["PeanoAxioms","natCast_injective"],"modifiers":null,"kind":"theorem","id":{"range":[4444,4461],"original":true}},{"value":{"range":[4714,4727],"original":true},"type":{"range":[4684,4713],"original":true},"signature":{"range":{"stop":4713,"start":4664},"pp":" (P : PeanoAxioms) : Function.Surjective P.natCast","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":{"stop":4727,"start":4527},"pp":"/-- One can start the proof here with `unfold Function.Surjective`, although it is not strictly necessary. -/\ntheorem natCast_surjective (P : PeanoAxioms) : Function.Surjective P.natCast := by sorry","original":true},"params":[{"type":[4669,4680],"ref":[4665,4666],"id":[4665,4666],"bi":"default"}],"name":["PeanoAxioms","natCast_surjective"],"modifiers":null,"kind":"theorem","id":{"range":[4645,4663],"original":true}},{"value":null,"type":null,"signature":{"range":{"stop":4986,"start":4967},"pp":" (P Q : PeanoAxioms)","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms"]},"ref":{"range":{"stop":5121,"start":4729},"pp":"/-- The notion of an equivalence between two structures obeying the Peano axioms.\n    The symbol `≃` is an alias for Mathlib's `Equiv` class; for instance `P.Nat ≃ Q.Nat` is\n    an alias for `_root_.Equiv P.Nat Q.Nat`. -/\nclass Equiv (P Q : PeanoAxioms) where\n  equiv : P.Nat ≃ Q.Nat\n  equiv_zero : equiv P.zero = Q.zero\n  equiv_succ : ∀ n : P.Nat, equiv (P.succ n) = Q.succ (equiv n)","original":true},"params":[{"type":[4974,4985],"ref":[4968,4969],"id":[4968,4969],"bi":"default"},{"type":[4974,4985],"ref":[4970,4971],"id":[4970,4971],"bi":"default"}],"name":["PeanoAxioms","Equiv"],"modifiers":null,"kind":"structure","id":{"range":[4961,4966],"original":true},"fields":[{"type":{"range":{"stop":5018,"start":5001},"pp":" : P.Nat ≃ Q.Nat","original":true},"name":["PeanoAxioms","Equiv","equiv"],"implicit":false,"binderInfo":"default"},{"type":{"range":{"stop":5055,"start":5032},"pp":" : equiv P.zero = Q.zero","original":true},"name":["PeanoAxioms","Equiv","equiv_zero"],"implicit":false,"binderInfo":"default"},{"type":{"range":{"stop":5121,"start":5069},"pp":" : ∀ n : P.Nat, equiv (P.succ n) = Q.succ (equiv n)","original":true},"name":["PeanoAxioms","Equiv","equiv_succ"],"implicit":false,"binderInfo":"default"}],"constructors":[]},{"value":{"range":[5351,5436],"original":true},"type":{"range":[5341,5350],"original":true},"signature":{"range":{"stop":5350,"start":5300},"pp":" {P Q : PeanoAxioms} (equiv : Equiv P Q) : Equiv Q P","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":{"stop":5436,"start":5123},"pp":"/-- This exercise will require application of Mathlib's API for the `Equiv` class.\n    Some of this API can be invoked automatically via the `simp` tactic. -/\nabbrev symm {P Q : PeanoAxioms} (equiv : Equiv P Q) : Equiv Q P\n    where\n  equiv := equiv.equiv.symm\n  equiv_zero := by sorry\n  equiv_succ n := by sorry","original":true},"params":[{"type":[5306,5317],"ref":[5301,5302],"id":[5301,5302],"bi":"implicit"},{"type":[5306,5317],"ref":[5303,5304],"id":[5303,5304],"bi":"implicit"},{"type":[5328,5337],"ref":[5320,5325],"id":[5320,5325],"bi":"default"}],"name":["PeanoAxioms","Equiv","symm"],"modifiers":null,"kind":"abbrev","id":{"range":[5289,5299],"original":true}},{"value":{"range":[5691,5791],"original":true},"type":{"range":[5681,5690],"original":true},"signature":{"range":{"stop":5690,"start":5616},"pp":" {P Q R : PeanoAxioms} (equiv1 : Equiv P Q) (equiv2 : Equiv Q R) : Equiv P R","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":{"stop":5791,"start":5438},"pp":"/-- This exercise will require application of Mathlib's API for the `Equiv` class.\n    Some of this API can be invoked automatically via the `simp` tactic. -/\nabbrev trans {P Q R : PeanoAxioms} (equiv1 : Equiv P Q) (equiv2 : Equiv Q R) : Equiv P R\n    where\n  equiv := equiv1.equiv.trans equiv2.equiv\n  equiv_zero := by sorry\n  equiv_succ n := by sorry","original":true},"params":[{"type":[5624,5635],"ref":[5617,5618],"id":[5617,5618],"bi":"implicit"},{"type":[5624,5635],"ref":[5619,5620],"id":[5619,5620],"bi":"implicit"},{"type":[5624,5635],"ref":[5621,5622],"id":[5621,5622],"bi":"implicit"},{"type":[5647,5656],"ref":[5638,5644],"id":[5638,5644],"bi":"default"},{"type":[5668,5677],"ref":[5659,5665],"id":[5659,5665],"bi":"default"}],"name":["PeanoAxioms","Equiv","trans"],"modifiers":null,"kind":"abbrev","id":{"range":[5604,5615],"original":true}},{"value":{"range":[5971,6142],"original":true},"type":{"range":[5951,5970],"original":true},"signature":{"range":{"stop":5970,"start":5931},"pp":" (P : PeanoAxioms) : Equiv Mathlib_Nat P","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":{"stop":6142,"start":5793},"pp":"/-- Useful Mathlib tools for inverting bijections include `Function.surjInv` and `Function.invFun`. -/\nnoncomputable abbrev fromNat (P : PeanoAxioms) : Equiv Mathlib_Nat P\n    where\n  equiv :=\n    { toFun := P.natCast\n      invFun := by sorry\n      left_inv := by sorry\n      right_inv := by sorry }\n  equiv_zero := by sorry\n  equiv_succ n := by sorry","original":true},"params":[{"type":[5936,5947],"ref":[5932,5933],"id":[5932,5933],"bi":"default"}],"name":["PeanoAxioms","Equiv","fromNat"],"modifiers":null,"kind":"abbrev","id":{"range":[5917,5930],"original":true}},{"value":{"range":[6309,6320],"original":true},"type":{"range":[6299,6308],"original":true},"signature":{"range":{"stop":6308,"start":6277},"pp":" (P Q : PeanoAxioms) : Equiv P Q","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":{"stop":6320,"start":6144},"pp":"/-- The task here is to establish that any two structures obeying the Peano axioms are equivalent. -/\nnoncomputable abbrev mk' (P Q : PeanoAxioms) : Equiv P Q := by sorry","original":true},"params":[{"type":[6284,6295],"ref":[6278,6279],"id":[6278,6279],"bi":"default"},{"type":[6284,6295],"ref":[6280,6281],"id":[6280,6281],"bi":"default"}],"name":["PeanoAxioms","Equiv","mk'"],"modifiers":null,"kind":"abbrev","id":{"range":[6267,6276],"original":true}},{"value":{"range":[6513,6658],"original":true},"type":{"range":[6497,6512],"original":true},"signature":{"range":{"stop":6512,"start":6431},"pp":" {P Q : PeanoAxioms} (equiv1 equiv2 : PeanoAxioms.Equiv P Q) : equiv1 = equiv2","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Equiv"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Equiv"]},"ref":{"range":{"stop":6658,"start":6322},"pp":"/-- There is only one equivalence between any two structures obeying the Peano axioms. -/\ntheorem uniq {P Q : PeanoAxioms} (equiv1 equiv2 : PeanoAxioms.Equiv P Q) : equiv1 = equiv2 :=\n  by\n  obtain ⟨equiv1, equiv_zero1, equiv_succ1⟩ := equiv1\n  obtain ⟨equiv2, equiv_zero2, equiv_succ2⟩ := equiv2\n  congr\n  ext n\n  sorry","original":true},"params":[{"type":[6438,6449],"ref":[6432,6433],"id":[6432,6433],"bi":"implicit"},{"type":[6438,6449],"ref":[6434,6435],"id":[6434,6435],"bi":"implicit"},{"type":[6468,6489],"ref":[6452,6458],"id":[6452,6458],"bi":"default"},{"type":[6468,6489],"ref":[6459,6465],"id":[6459,6465],"bi":"default"}],"name":["PeanoAxioms","Equiv","uniq"],"modifiers":null,"kind":"theorem","id":{"range":[6420,6430],"original":true}},{"value":{"range":[6918,6931],"original":true},"type":{"range":[6842,6917],"original":true},"signature":{"range":{"stop":6917,"start":6776},"pp":" {P : PeanoAxioms} (f : P.Nat → P.Nat → P.Nat) (c : P.Nat) :\n  ∃! (a : P.Nat → P.Nat), a P.zero = c ∧ ∀ n, a (P.succ n) = f n (a n)","original":true},"scopeInfo":{"varDecls":[],"scopedOpenDecl":[["PeanoAxioms"],["PeanoAxioms","Nat"]],"openDecl":[],"omitVars":[],"levelNames":[],"includeVars":[],"currNamespace":["PeanoAxioms","Nat"]},"ref":{"range":{"stop":6931,"start":6660},"pp":"/-- A sample result: recursion is well-defined on any structure obeying the Peano axioms-/\ntheorem recurse_uniq {P : PeanoAxioms} (f : P.Nat → P.Nat → P.Nat) (c : P.Nat) :\n    ∃! (a : P.Nat → P.Nat), a P.zero = c ∧ ∀ n, a (P.succ n) = f n (a n) := by sorry","original":true},"params":[{"type":[6781,6792],"ref":[6777,6778],"id":[6777,6778],"bi":"implicit"},{"type":[6798,6823],"ref":[6795,6796],"id":[6795,6796],"bi":"default"},{"type":[6829,6834],"ref":[6826,6827],"id":[6826,6827],"bi":"default"}],"name":["PeanoAxioms","Nat","recurse_uniq"],"modifiers":null,"kind":"theorem","id":{"range":[6759,6775],"original":true}}]
