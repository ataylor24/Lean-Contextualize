[{"state":[],"start":0},{"state":[],"start":22},{"state":[],"start":23},{"state":[],"start":27},{"state":[],"start":68},{"state":[],"start":69},{"state":[],"start":165},{"state":[],"start":253},{"state":[],"start":348},{"state":[],"start":441},{"state":[],"start":451},{"state":[],"start":452},{"state":[],"start":544},{"state":[],"start":578},{"state":[],"start":579},{"state":[],"start":627},{"state":[],"start":630},{"state":[],"start":631},{"state":[],"start":731},{"state":[],"start":769},{"state":[],"start":787},{"state":[],"start":788},{"state":[],"start":792},{"state":[],"start":880},{"state":[],"start":939},{"state":[],"start":976},{"state":[],"start":977},{"state":[],"start":1074},{"state":[],"start":1110},{"state":[],"start":1111},{"state":[],"start":1114},{"state":[],"start":1115},{"state":[],"start":1214},{"state":[],"start":1229},{"state":[],"start":1230},{"state":[],"start":1247},{"state":[],"start":1248},{"state":[],"start":1341},{"state":[],"start":1409},{"state":[],"start":1424},{"state":[],"start":1425},{"state":[],"start":1449},{"state":[{"type":"∑ i ∈ Icc m n, a i = 0","tag":[],"mvarId":["_uniq",267],"isProp":true,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",263],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",264],"binderInfo":"implicit"},{"type":"n < m","name":["h"],"isProp":true,"id":["_uniq",265],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",266],"binderInfo":"default"}]}],"start":1543},{"state":[],"start":1592},{"state":[],"start":1593},{"state":[],"start":1597},{"state":[],"start":1688},{"state":[],"start":1763},{"state":[],"start":1766},{"state":[],"start":1834},{"state":[{"type":"∑ i ∈ Icc m (n + 1), a i = ∑ i ∈ Icc m n, a i + a (n + 1)","tag":[],"mvarId":["_uniq",3327],"isProp":true,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",3323],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",3324],"binderInfo":"implicit"},{"type":"n ≥ m - 1","name":["h"],"isProp":true,"id":["_uniq",3325],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",3326],"binderInfo":"default"}]}],"start":1906},{"state":[{"type":"∑ i ∈ Icc m (n + 1), a i = a (n + 1) + ∑ i ∈ Icc m n, a i","tag":[],"mvarId":["_uniq",3467],"isProp":true,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",3323],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",3324],"binderInfo":"implicit"},{"type":"n ≥ m - 1","name":["h"],"isProp":true,"id":["_uniq",3325],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",3326],"binderInfo":"default"}]}],"start":1934},{"state":[{"type":"Icc m (n + 1) = insert (n + 1) (Icc m n)","tag":["h","e'_2","h"],"mvarId":["_uniq",5659],"isProp":true,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",3323],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",3324],"binderInfo":"implicit"},{"type":"n ≥ m - 1","name":["h"],"isProp":true,"id":["_uniq",3325],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",3326],"binderInfo":"default"}]},{"type":"DecidableEq ℤ","tag":["convert_7"],"mvarId":["_uniq",3493],"isProp":false,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",3323],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",3324],"binderInfo":"implicit"},{"type":"n ≥ m - 1","name":["h"],"isProp":true,"id":["_uniq",3325],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",3326],"binderInfo":"default"}]},{"type":"n + 1 ∉ Icc m n","tag":["convert_8"],"mvarId":["_uniq",3494],"isProp":true,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",3323],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",3324],"binderInfo":"implicit"},{"type":"n ≥ m - 1","name":["h"],"isProp":true,"id":["_uniq",3325],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",3326],"binderInfo":"default"}]}],"start":1957},{"state":[{"type":"DecidableEq ℤ","tag":["convert_7"],"mvarId":["_uniq",3493],"isProp":false,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",3323],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",3324],"binderInfo":"implicit"},{"type":"n ≥ m - 1","name":["h"],"isProp":true,"id":["_uniq",3325],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",3326],"binderInfo":"default"}]},{"type":"n + 1 ∉ Icc m n","tag":["convert_8"],"mvarId":["_uniq",3494],"isProp":true,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",3323],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",3324],"binderInfo":"implicit"},{"type":"n ≥ m - 1","name":["h"],"isProp":true,"id":["_uniq",3325],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",3326],"binderInfo":"default"}]}],"start":1978},{"state":[{"type":"n + 1 ∉ Icc m n","tag":["convert_8"],"mvarId":["_uniq",3494],"isProp":true,"context":[{"type":"ℤ","name":["n"],"isProp":false,"id":["_uniq",3323],"binderInfo":"implicit"},{"type":"ℤ","name":["m"],"isProp":false,"id":["_uniq",3324],"binderInfo":"implicit"},{"type":"n ≥ m - 1","name":["h"],"isProp":true,"id":["_uniq",3325],"binderInfo":"default"},{"type":"ℤ → ℝ","name":["a"],"isProp":false,"id":["_uniq",3326],"binderInfo":"default"}]}],"start":1997},{"state":[],"start":2004},{"state":[],"start":2005},{"state":[],"start":2083},{"state":[],"start":2084},{"state":[],"start":2162},{"state":[],"start":2163},{"state":[],"start":2239},{"state":[],"start":2240},{"state":[],"start":2330},{"state":[],"start":2331},{"state":[],"start":2431},{"state":[],"start":2432},{"state":[],"start":2452},{"state":[],"start":2544},{"state":[],"start":2545},{"state":[],"start":2584},{"state":[],"start":2677},{"state":[],"start":2768},{"state":[],"start":2769},{"state":[],"start":2808},{"state":[],"start":2867},{"state":[],"start":2941},{"state":[],"start":2942},{"state":[],"start":2981},{"state":[],"start":3038},{"state":[],"start":3133},{"state":[],"start":3134},{"state":[],"start":3173},{"state":[],"start":3243},{"state":[],"start":3313},{"state":[],"start":3314},{"state":[],"start":3353},{"state":[],"start":3421},{"state":[],"start":3489},{"state":[],"start":3490},{"state":[],"start":3529},{"state":[],"start":3637},{"state":[],"start":3701},{"state":[],"start":3702},{"state":[],"start":3719},{"state":[],"start":3720},{"state":[],"start":3724},{"state":[],"start":3745},{"state":[],"start":3748},{"state":[],"start":3837},{"state":[],"start":3938},{"state":[],"start":4027},{"state":[{"type":"(∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":[],"mvarId":["_uniq",21843],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21834],"binderInfo":"implicit"},{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",21836],"binderInfo":"default"},{"type":"#X = n","name":["hcard"],"isProp":true,"id":["_uniq",21837],"binderInfo":"default"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",21839],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",21840],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",21841],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",21842],"binderInfo":"default"}]}],"start":4125},{"state":[{"type":"(∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":[],"mvarId":["_uniq",21843],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21834],"binderInfo":"implicit"},{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",21836],"binderInfo":"default"},{"type":"#X = n","name":["hcard"],"isProp":true,"id":["_uniq",21837],"binderInfo":"default"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",21839],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",21840],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",21841],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",21842],"binderInfo":"default"}]}],"start":4206},{"state":[{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":[],"mvarId":["_uniq",21846],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21845],"binderInfo":"implicit"}]}],"start":4228},{"state":[{"type":"∀ (X : Finset X'),\n  #X = 0 →\n    ∀ (g h : { x // x ∈ Icc 1 (↑0 : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑0 : ℤ), if hi : i ∈ Icc 1 (↑0 : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑0 : ℤ), if hi : i ∈ Icc 1 (↑0 : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["zero"],"mvarId":["_uniq",21870],"isProp":false,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"}]},{"type":"∀ (X : Finset X'),\n  #X = n + 1 →\n    ∀ (g h : { x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",21881],"isProp":false,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"}]}],"start":4253},{"state":[{"type":"∀ (X : Finset X'),\n  #X = n + 1 →\n    ∀ (g h : { x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",21881],"isProp":false,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"}]}],"start":4262},{"state":[{"type":"(∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",35798],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"}]}],"start":4285},{"state":[{"type":"(∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",35798],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"}]}],"start":4381},{"state":[{"type":"(∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",39755],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]}]}],"start":4421},{"state":[{"type":"(∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",39755],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]}]}],"start":4509},{"state":[{"type":"(∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",39755],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]}]}],"start":4552},{"state":[{"type":"(∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",39755],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]}]}],"start":4651},{"state":[{"type":"(∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","tag":[],"mvarId":["_uniq",41154],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g✝"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g✝","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"type":"{ x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",40301],"binderInfo":"default"}]}],"start":4707},{"state":[{"type":"∀ x ∈ Icc 1 ((↑n : ℤ) + 1), (if hi : x ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨x, hi⟩) : X') else 0) = f (↑(g (π x)) : X')","tag":[],"mvarId":["_uniq",41175],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g✝"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g✝","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"type":"{ x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",40301],"binderInfo":"default"}]}],"start":4733},{"state":[{"type":"(∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n  ∑ i ∈ Icc 1 (↑(n + 1) : ℤ), if hi : i ∈ Icc 1 (↑(n + 1) : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","tag":["succ"],"mvarId":["_uniq",41157],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]}]}],"start":4773},{"state":[{"type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ"],"mvarId":["_uniq",48466],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]}]}],"start":4796},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑(g (π ((↑n : ℤ) + 1))) : X') =\n  ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ"],"mvarId":["_uniq",48505],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]}]}],"start":4835},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑x : X') = ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ"],"mvarId":["_uniq",50480],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]}]}],"start":4859},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑x : X') = ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ"],"mvarId":["_uniq",50685],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"}]}],"start":4908},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑x : X') = ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ","intro"],"mvarId":["_uniq",54979],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"}]}],"start":4954},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑x : X') = ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ","intro"],"mvarId":["_uniq",55167],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]}],"start":5035},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑x : X') = ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ","intro"],"mvarId":["_uniq",59510],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]}]}],"start":5138},{"state":[{"type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') =\n  ∑ i ∈ Icc 1 j, f (↑(h (π i)) : X') + ∑ i ∈ Icc (j + 1) ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":[],"mvarId":["_uniq",56768],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]}],"start":5238},{"state":[],"start":5290},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑x : X') = ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ","intro"],"mvarId":["_uniq",59510],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]}]}],"start":5357},{"state":[{"type":"∑ i ∈ Icc 1 j, f (↑(h (π i)) : X') + ∑ i ∈ Icc (j + 1) ((↑n : ℤ) + 1), f (↑(h (π i)) : X') =\n  ∑ i ∈ Icc 1 (j - 1), f (↑(h (π i)) : X') + f (↑(h (π j)) : X') + ∑ i ∈ Icc (j + 1) ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":[],"mvarId":["_uniq",57577],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]}],"start":5419},{"state":[],"start":5475},{"state":[{"type":"∑ i ∈ Icc 1 (j - 1), f (↑(h (π i)) : X') + f (↑(h (π j)) : X') + ∑ i ∈ Icc (j + 1) ((↑n : ℤ) + 1), f (↑(h (π i)) : X') =\n  ∑ i ∈ Icc 1 (j - 1), f (↑(h (π i)) : X') + f (↑x : X') + ∑ i ∈ Icc j (↑n : ℤ), f (↑(h (π (i + 1))) : X')","tag":[],"mvarId":["_uniq",58230],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]}],"start":5581},{"state":[{"type":"∑ i ∈ Icc 1 (j - 1), f (↑(h (π i)) : X') + f (↑(h (π j)) : X') = ∑ i ∈ Icc 1 (j - 1), f (↑(h (π i)) : X') + f (↑x : X')","tag":["e_a","_@","Init","Prelude","_hyg",2136],"mvarId":["_uniq",76035],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]},{"type":"∑ i ∈ Icc (j + 1) ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc j (↑n : ℤ), f (↑(h (π (i + 1))) : X')","tag":["e_a","_@","Init","Prelude","_hyg",2138],"mvarId":["_uniq",76036],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]}],"start":5595},{"state":[{"type":"∑ i ∈ Icc (j + 1) ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc j (↑n : ℤ), f (↑(h (π (i + 1))) : X')","tag":["e_a","_@","Init","Prelude","_hyg",2138],"mvarId":["_uniq",76036],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]}],"start":5629},{"state":[],"start":5677},{"state":[],"start":5788},{"state":[{"type":"∑ i ∈ Icc 1 (j - 1), f (↑(h (π i)) : X') + ∑ i ∈ Icc j (↑n : ℤ), f (↑(h (π (i + 1))) : X') + f (↑x : X') =\n  ∑ i ∈ Icc 1 (j - 1), f (↑(h' i) : X') + ∑ i ∈ Icc j (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","tag":[],"mvarId":["_uniq",59391],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]}],"start":5882},{"state":[{"type":"∑ i ∈ Icc 1 (j - 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (j - 1), f (↑(h' i) : X')","tag":["e_a","e_a","_@","Init","Prelude","_hyg",2136],"mvarId":["_uniq",102806],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]},{"type":"∑ i ∈ Icc j (↑n : ℤ), f (↑(h (π (i + 1))) : X') = ∑ i ∈ Icc j (↑n : ℤ), f (↑(h' i) : X')","tag":["e_a","e_a","_@","Init","Prelude","_hyg",2136],"mvarId":["_uniq",102807],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]}]}],"start":5896},{"state":[{"type":"f (↑(h (π i)) : X') = f (↑(if i < j then h (π i) else h (π (i + 1))) : X')","tag":[],"mvarId":["_uniq",359851],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",106078],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Multiset.map g (Icc 1 (↑n : ℤ)).val.attach = X.val.attach →\n        Multiset.map h (Icc 1 (↑n : ℤ)).val.attach = X.val.attach →\n          (∑ x ∈ Icc 1 (↑n : ℤ), if h : 1 ≤ x ∧ x ≤ (↑n : ℤ) then f (↑(g ⟨x, ⋯⟩) : X') else 0) =\n            ∑ x ∈ Icc 1 (↑n : ℤ), if h_1 : 1 ≤ x ∧ x ≤ (↑n : ℤ) then f (↑(h ⟨x, ⋯⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",359840],"binderInfo":"default"},{"type":"Multiset.map g (Icc 1 ((↑n : ℤ) + 1)).val.attach = X.val.attach","name":["hg"],"isProp":true,"id":["_uniq",359841],"binderInfo":"default"},{"type":"Multiset.map h (Icc 1 ((↑n : ℤ) + 1)).val.attach = X.val.attach","name":["hh"],"isProp":true,"id":["_uniq",359842],"binderInfo":"default"},{"type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ x ∈ Icc 1 ((↑n : ℤ) + 1), if h : 1 ≤ x ∧ x ≤ (↑n : ℤ) + 1 then f (↑(g ⟨x, ⋯⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",359843],"binderInfo":"default"},{"type":"1 ≤ i ∧ i ≤ j - 1","name":["hi"],"isProp":true,"id":["_uniq",359844],"binderInfo":"default"}]},{"type":"f (↑(h (π (i + 1))) : X') = f (↑(if i < j then h (π i) else h (π (i + 1))) : X')","tag":[],"mvarId":["_uniq",613606],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",360159],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Multiset.map g (Icc 1 (↑n : ℤ)).val.attach = X.val.attach →\n        Multiset.map h (Icc 1 (↑n : ℤ)).val.attach = X.val.attach →\n          (∑ x ∈ Icc 1 (↑n : ℤ), if h : 1 ≤ x ∧ x ≤ (↑n : ℤ) then f (↑(g ⟨x, ⋯⟩) : X') else 0) =\n            ∑ x ∈ Icc 1 (↑n : ℤ), if h_1 : 1 ≤ x ∧ x ≤ (↑n : ℤ) then f (↑(h ⟨x, ⋯⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",613595],"binderInfo":"default"},{"type":"Multiset.map g (Icc 1 ((↑n : ℤ) + 1)).val.attach = X.val.attach","name":["hg"],"isProp":true,"id":["_uniq",613596],"binderInfo":"default"},{"type":"Multiset.map h (Icc 1 ((↑n : ℤ) + 1)).val.attach = X.val.attach","name":["hh"],"isProp":true,"id":["_uniq",613597],"binderInfo":"default"},{"type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ x ∈ Icc 1 ((↑n : ℤ) + 1), if h : 1 ≤ x ∧ x ≤ (↑n : ℤ) + 1 then f (↑(g ⟨x, ⋯⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",613598],"binderInfo":"default"},{"type":"j ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",613599],"binderInfo":"default"}]}],"start":5962},{"state":[{"type":"f (↑(h (π (i + 1))) : X') = f (↑(if i < j then h (π i) else h (π (i + 1))) : X')","tag":[],"mvarId":["_uniq",613606],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",360159],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Multiset.map g (Icc 1 (↑n : ℤ)).val.attach = X.val.attach →\n        Multiset.map h (Icc 1 (↑n : ℤ)).val.attach = X.val.attach →\n          (∑ x ∈ Icc 1 (↑n : ℤ), if h : 1 ≤ x ∧ x ≤ (↑n : ℤ) then f (↑(g ⟨x, ⋯⟩) : X') else 0) =\n            ∑ x ∈ Icc 1 (↑n : ℤ), if h_1 : 1 ≤ x ∧ x ≤ (↑n : ℤ) then f (↑(h ⟨x, ⋯⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",613595],"binderInfo":"default"},{"type":"Multiset.map g (Icc 1 ((↑n : ℤ) + 1)).val.attach = X.val.attach","name":["hg"],"isProp":true,"id":["_uniq",613596],"binderInfo":"default"},{"type":"Multiset.map h (Icc 1 ((↑n : ℤ) + 1)).val.attach = X.val.attach","name":["hh"],"isProp":true,"id":["_uniq",613597],"binderInfo":"default"},{"type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ x ∈ Icc 1 ((↑n : ℤ) + 1), if h : 1 ≤ x ∧ x ≤ (↑n : ℤ) + 1 then f (↑(g ⟨x, ⋯⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",613598],"binderInfo":"default"},{"type":"j ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",613599],"binderInfo":"default"}]}],"start":6000},{"state":[],"start":6039},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑x : X') = ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X')","tag":["succ","intro"],"mvarId":["_uniq",59510],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]}]}],"start":6110},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') + f (↑x : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","tag":["succ","intro"],"mvarId":["_uniq",650846],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]}]}],"start":6122},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",651006],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]}]}],"start":6132},{"state":[{"type":"g (π i) ≠ x","tag":[],"mvarId":["_uniq",658107],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",657773],"binderInfo":"implicit"},{"type":"i ∈ Icc 1 (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",658078],"binderInfo":"default"}]}],"start":6204},{"state":[{"type":"g (π i) ≠ x","tag":[],"mvarId":["_uniq",660526],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",657773],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",660523],"binderInfo":"default"}]}],"start":6219},{"state":[{"type":"¬i = (↑n : ℤ) + 1","tag":[],"mvarId":["_uniq",673827],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",657773],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",660523],"binderInfo":"default"}]}],"start":6291},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",658112],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]}]}],"start":6304},{"state":[{"type":"h' i ≠ x","tag":[],"mvarId":["_uniq",679003],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"i ∈ Icc 1 (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",678999],"binderInfo":"default"}]}],"start":6373},{"state":[{"type":"h' i ≠ x","tag":[],"mvarId":["_uniq",681163],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"}]}],"start":6388},{"state":[{"type":"h' i ≠ x","tag":[],"mvarId":["_uniq",681210],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]}]}],"start":6426},{"state":[{"type":"h' i ≠ x","tag":[],"mvarId":["_uniq",686502],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.atom_pf i)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.right))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"i ≤ (↑n : ℤ) + 1","name":["hi''"],"isProp":true,"id":["_uniq",686501]}]}],"start":6467},{"state":[{"type":"False","tag":["pos","_@","_hyg",3481],"mvarId":["_uniq",691714],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.atom_pf i)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.right))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"i ≤ (↑n : ℤ) + 1","name":["hi''"],"isProp":true,"id":["_uniq",686501]},{"type":"i < j","name":["hlt"],"isProp":true,"id":["_uniq",691697],"binderInfo":"default"},{"type":"h' i = x","name":["heq"],"isProp":true,"id":["_uniq",691713],"binderInfo":"default"}]},{"type":"False","tag":["neg","_@","_hyg",3481],"mvarId":["_uniq",691727],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.atom_pf i)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.right))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"i ≤ (↑n : ℤ) + 1","name":["hi''"],"isProp":true,"id":["_uniq",686501]},{"type":"¬i < j","name":["hlt"],"isProp":true,"id":["_uniq",691704],"binderInfo":"default"},{"type":"h' i = x","name":["heq"],"isProp":true,"id":["_uniq",691726],"binderInfo":"default"}]}],"start":6510},{"state":[{"type":"False","tag":["pos","_@","_hyg",3481],"mvarId":["_uniq",707504],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.atom_pf i)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.right))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"i ≤ (↑n : ℤ) + 1","name":["hi''"],"isProp":true,"id":["_uniq",686501]},{"type":"i < j","name":["hlt"],"isProp":true,"id":["_uniq",691697],"binderInfo":"default"},{"type":"i = j","name":["heq"],"isProp":true,"id":["_uniq",707501],"binderInfo":"default"}]},{"type":"False","tag":["neg","_@","_hyg",3481],"mvarId":["_uniq",723474],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.atom_pf i)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.right))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"i ≤ (↑n : ℤ) + 1","name":["hi''"],"isProp":true,"id":["_uniq",686501]},{"type":"¬i < j","name":["hlt"],"isProp":true,"id":["_uniq",691704],"binderInfo":"default"},{"type":"i + 1 = j","name":["heq"],"isProp":true,"id":["_uniq",723471],"binderInfo":"default"}]}],"start":6587},{"state":[{"type":"False","tag":["pos","_@","_hyg",3481],"mvarId":["_uniq",707504],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.atom_pf i)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.right))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"i ≤ (↑n : ℤ) + 1","name":["hi''"],"isProp":true,"id":["_uniq",686501]},{"type":"i < j","name":["hlt"],"isProp":true,"id":["_uniq",691697],"binderInfo":"default"},{"type":"i = j","name":["heq"],"isProp":true,"id":["_uniq",707501],"binderInfo":"default"}]},{"type":"False","tag":["neg","_@","_hyg",3481],"mvarId":["_uniq",723474],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.atom_pf i)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.right))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"i ≤ (↑n : ℤ) + 1","name":["hi''"],"isProp":true,"id":["_uniq",686501]},{"type":"¬i < j","name":["hlt"],"isProp":true,"id":["_uniq",691704],"binderInfo":"default"},{"type":"i + 1 = j","name":["heq"],"isProp":true,"id":["_uniq",723471],"binderInfo":"default"}]}],"start":6640},{"state":[{"type":"False","tag":["neg","_@","_hyg",3481],"mvarId":["_uniq",723474],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"type":"ℤ","name":["i"],"isProp":false,"id":["_uniq",678801],"binderInfo":"implicit"},{"type":"1 ≤ i ∧ i ≤ (↑n : ℤ)","name":["hi"],"isProp":true,"id":["_uniq",681160],"binderInfo":"default"},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                    (Eq.refl (Int.negOfNat 1))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                  (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n              (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.left))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"0 ≤ i","name":["hi'"],"isProp":true,"id":["_uniq",681209]},{"value":"le_of_not_gt fun a =>\n  Mathlib.Tactic.Linarith.lt_irrefl\n    (Eq.mp\n      (congrArg (fun _a => _a < 0)\n        (Mathlib.Tactic.Ring.of_eq\n          (Mathlib.Tactic.Ring.add_congr\n            (Mathlib.Tactic.Ring.add_congr\n              (Mathlib.Tactic.Ring.mul_congr\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                (Mathlib.Tactic.Ring.neg_congr\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1)))))\n                    Mathlib.Tactic.Ring.neg_zero))\n                (Mathlib.Tactic.Ring.add_mul\n                  (Mathlib.Tactic.Ring.mul_add\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                    (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                  (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n              (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                (Mathlib.Tactic.Ring.sub_pf\n                  (Mathlib.Tactic.Ring.neg_add\n                    (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.neg_one_mul\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                            (Eq.refl (Int.negOfNat 1))))))\n                    Mathlib.Tactic.Ring.neg_zero)\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_zero_add ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n              (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                (Mathlib.Tactic.Ring.add_pf_zero_add\n                  (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n            (Mathlib.Tactic.Ring.sub_congr\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                  (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap\n                  (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                    (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                      (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                  (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n              (Mathlib.Tactic.Ring.atom_pf i)\n              (Mathlib.Tactic.Ring.sub_pf\n                (Mathlib.Tactic.Ring.neg_add\n                  (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                    (Mathlib.Tactic.Ring.neg_one_mul\n                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.negOfNat 1))))))\n                  Mathlib.Tactic.Ring.neg_zero)\n                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 2)\n                  (Mathlib.Tactic.Ring.add_pf_add_gt (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast)\n                    (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))))\n            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n              (Mathlib.Meta.NormNum.IsInt.to_isNat\n                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                  (Eq.refl (Int.ofNat 0))))\n              (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Tactic.Ring.add_overlap_pf_zero (↑n : ℤ) (Nat.rawCast 1)\n                    (Mathlib.Meta.NormNum.IsInt.to_isNat\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.ofNat 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_zero_add 0)))))\n          (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n        (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n          (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n            (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n              (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n          (Mathlib.Tactic.Linarith.sub_nonpos_of_le hi.right))\n        (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))))","type":"i ≤ (↑n : ℤ) + 1","name":["hi''"],"isProp":true,"id":["_uniq",686501]},{"type":"¬i < j","name":["hlt"],"isProp":true,"id":["_uniq",691704],"binderInfo":"default"},{"type":"i + 1 = j","name":["heq"],"isProp":true,"id":["_uniq",723471],"binderInfo":"default"}]}],"start":6655},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",679008],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]}]}],"start":6685},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",736140],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]}]}],"start":6729},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",736140],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]}]}],"start":6812},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",739098],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]}]}],"start":6856},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",739098],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]}]}],"start":6936},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",739694],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]},{"value":"fun y => f (↑y : X')","type":"{ x_1 // x_1 ∈ X.erase (↑x : X') } → ℝ","name":["ftil"],"isProp":false,"id":["_uniq",739693]}]}],"start":6988},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",740041],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]},{"value":"fun y => f (↑y : X')","type":"{ x_1 // x_1 ∈ X.erase (↑x : X') } → ℝ","name":["ftil"],"isProp":false,"id":["_uniq",739693]},{"value":"sorry","type":"Function.Bijective gtil","name":["why"],"isProp":true,"id":["_uniq",740040]}]}],"start":7037},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",740059],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]},{"value":"fun y => f (↑y : X')","type":"{ x_1 // x_1 ∈ X.erase (↑x : X') } → ℝ","name":["ftil"],"isProp":false,"id":["_uniq",739693]},{"value":"sorry","type":"Function.Bijective gtil","name":["why"],"isProp":true,"id":["_uniq",740040]},{"value":"sorry","type":"Function.Bijective htil","name":["why2"],"isProp":true,"id":["_uniq",740058]}]}],"start":7087},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X')","tag":["succ","intro","e_a"],"mvarId":["_uniq",740059],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]},{"value":"fun y => f (↑y : X')","type":"{ x_1 // x_1 ∈ X.erase (↑x : X') } → ℝ","name":["ftil"],"isProp":false,"id":["_uniq",739693]},{"value":"sorry","type":"Function.Bijective gtil","name":["why"],"isProp":true,"id":["_uniq",740040]},{"value":"sorry","type":"Function.Bijective htil","name":["why2"],"isProp":true,"id":["_uniq",740058]}]}],"start":7094},{"state":[{"type":"∑ i ∈ Icc 1 (↑n : ℤ), f (↑(g (π i)) : X') =\n  ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then ftil (gtil ⟨i, hi⟩) else 0","tag":[],"mvarId":["_uniq",740479],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]},{"value":"fun y => f (↑y : X')","type":"{ x_1 // x_1 ∈ X.erase (↑x : X') } → ℝ","name":["ftil"],"isProp":false,"id":["_uniq",739693]},{"value":"sorry","type":"Function.Bijective gtil","name":["why"],"isProp":true,"id":["_uniq",740040]},{"value":"sorry","type":"Function.Bijective htil","name":["why2"],"isProp":true,"id":["_uniq",740058]}]}],"start":7199},{"state":[],"start":7232},{"state":[{"type":"(∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then ftil (gtil ⟨i, hi⟩) else 0) =\n  ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then ftil (htil ⟨i, hi⟩) else 0","tag":[],"mvarId":["_uniq",740689],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]},{"value":"fun y => f (↑y : X')","type":"{ x_1 // x_1 ∈ X.erase (↑x : X') } → ℝ","name":["ftil"],"isProp":false,"id":["_uniq",739693]},{"value":"sorry","type":"Function.Bijective gtil","name":["why"],"isProp":true,"id":["_uniq",740040]},{"value":"sorry","type":"Function.Bijective htil","name":["why2"],"isProp":true,"id":["_uniq",740058]}]}],"start":7337},{"state":[{"type":"#(X.erase (↑x : X')) = n","tag":[],"mvarId":["_uniq",782728],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",21835],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",21838],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",21871],"binderInfo":"default"},{"type":"∀ (X : Finset X'),\n  #X = n →\n    ∀ (g h : { x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }),\n      Function.Bijective g →\n        Function.Bijective h →\n          (∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n            ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(h ⟨i, hi⟩) : X') else 0","name":["hn"],"isProp":true,"id":["_uniq",21872],"binderInfo":"default"},{"type":"Finset X'","name":["X"],"isProp":false,"id":["_uniq",35782],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",35785],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",35788],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑(n + 1) : ℤ) } → { x // x ∈ X }","name":["h"],"isProp":false,"id":["_uniq",35791],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",35794],"binderInfo":"default"},{"type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",35797],"binderInfo":"default"},{"value":"fun i => if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then ⟨i, hi⟩ else ⟨1, ⋯⟩","type":"ℤ → { x // x ∈ Icc 1 ((↑n : ℤ) + 1) }","name":["π"],"isProp":false,"id":["_uniq",39754]},{"value":"fun g =>\n  sum_congr rfl fun i hi =>\n    of_eq_true\n      (Eq.trans\n        (congr (congrArg Eq (dite_cond_eq_true (eq_true hi)))\n          (congrArg (fun x => f (↑(g x) : X')) (dite_cond_eq_true (eq_true hi))))\n        (eq_self (f (↑(g ⟨i, of_eq_true (eq_true hi)⟩) : X'))))","type":"∀ (g : { x // x ∈ Icc 1 ((↑n : ℤ) + 1) } → { x // x ∈ X }),\n  (∑ i ∈ Icc 1 ((↑n : ℤ) + 1), if hi : i ∈ Icc 1 ((↑n : ℤ) + 1) then f (↑(g ⟨i, hi⟩) : X') else 0) =\n    ∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(g (π i)) : X')","name":["hπ"],"isProp":true,"id":["_uniq",41156]},{"value":"g (π ((↑n : ℤ) + 1))","type":"{ x // x ∈ X }","name":["x"],"isProp":false,"id":["_uniq",50426]},{"type":"ℤ","name":["j"],"isProp":false,"id":["_uniq",50677],"binderInfo":"default"},{"type":"j ∈ Icc 1 (↑(n + 1) : ℤ)","name":["hj'"],"isProp":true,"id":["_uniq",50678],"binderInfo":"default"},{"type":"h ⟨j, hj'⟩ = x","name":["hj"],"isProp":true,"id":["_uniq",50679],"binderInfo":"default"},{"type":"1 ≤ j","name":["hj1"],"isProp":true,"id":["_uniq",54977],"binderInfo":"default"},{"type":"j ≤ (↑n : ℤ) + 1","name":["hj2"],"isProp":true,"id":["_uniq",54978],"binderInfo":"default"},{"value":"fun i => if i < j then h (π i) else h (π (i + 1))","type":"ℤ → { x // x ∈ X }","name":["h'"],"isProp":false,"id":["_uniq",55166]},{"value":"Trans.trans\n  (Trans.trans\n    (Trans.trans\n      (Trans.trans\n        (Trans.trans\n          (Eq.symm\n            (concat_finite_series\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.mul_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                              (Mathlib.Tactic.Ring.neg_congr\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_one_mul\n                                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                      (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                        (Eq.refl (Int.negOfNat 1)))))\n                                  Mathlib.Tactic.Ring.neg_zero))\n                              (Mathlib.Tactic.Ring.add_mul\n                                (Mathlib.Tactic.Ring.mul_add\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Eq.refl (Int.negOfNat 2))))\n                                  (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                                (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                            (Mathlib.Tactic.Ring.sub_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.sub_pf\n                                (Mathlib.Tactic.Ring.neg_add\n                                  (Mathlib.Tactic.Ring.neg_mul j (Nat.rawCast 1)\n                                    (Mathlib.Tactic.Ring.neg_one_mul\n                                      (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                        (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                          (Eq.refl (Int.negOfNat 1))))))\n                                  Mathlib.Tactic.Ring.neg_zero)\n                                (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_zero_add\n                                    (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap\n                              (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                  (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                                  (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                  (Eq.refl (Int.negOfNat 1))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add (j ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                          (Mathlib.Tactic.Ring.sub_congr\n                            (Mathlib.Tactic.Ring.add_congr\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf j)\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                                  (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                                    (Eq.refl 2)))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                            (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                            (Mathlib.Tactic.Ring.sub_pf\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero)\n                              (Mathlib.Tactic.Ring.add_pf_add_overlap\n                                (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.ofNat 1)))))\n                                (Mathlib.Tactic.Ring.add_pf_add_zero (j ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                          (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                            (Mathlib.Meta.NormNum.IsInt.to_isNat\n                              (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.ofNat 0))))\n                            (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                              (Mathlib.Tactic.Ring.add_overlap_pf_zero j (Nat.rawCast 1)\n                                (Mathlib.Meta.NormNum.IsInt.to_isNat\n                                  (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                                    (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                    (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                    (Eq.refl (Int.ofNat 0)))))\n                              (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n                        (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n                    (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                      (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n                        (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                          (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                            (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n                        (Mathlib.Tactic.Linarith.sub_nonpos_of_le hj1))\n                      (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a)))))\n              (le_of_not_gt fun a =>\n                Mathlib.Tactic.Linarith.lt_irrefl\n                  (Eq.mp\n                    (congrArg (fun _a => _a < 0)\n                      (Mathlib.Tactic.Ring.of_eq\n                        (Mathlib.Tactic.Ring.add_congr\n                          (Mathlib.Tactic.Ring.add_congr\n                            (Mathlib.Tactic.Ring.neg_congr\n                              (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                              (Mathlib.Tactic.Ring.neg_add\n                                (Mathlib.Tactic.Ring.neg_one_mul\n                                  (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                                    (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                      (Eq.refl (Int.negOfNat 1)))))\n                                Mathlib.Tactic.Ring.neg_zero))\n                            (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf j)\n                              (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                                (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                                (Mathlib.Tactic.Ring.add_pf_add_gt ⋯ ⋯))\n                              ⋯)\n                            ⋯)\n                          ⋯ ⋯)\n                        ⋯))\n                    ⋯))\n              ⋯))\n          ⋯)\n        ⋯)\n      ⋯)\n    ⋯)\n  ⋯","type":"∑ i ∈ Icc 1 ((↑n : ℤ) + 1), f (↑(h (π i)) : X') = ∑ i ∈ Icc 1 (↑n : ℤ), f (↑(h' i) : X') + f (↑x : X')","name":["this"],"isProp":true,"id":["_uniq",59509]},{"value":"fun {i} hi => Eq.mpr (id (Eq.trans (congr ⋯ ⋯) ⋯)) ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → g (π i) ≠ x","name":["g_ne_x"],"isProp":true,"id":["_uniq",658109]},{"value":"fun {i} hi =>\n  have hi' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul i (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap\n                    (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                      (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                        (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 2))\n                        (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                        (Eq.refl (Int.negOfNat 1))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add (i ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf i)\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                      (Mathlib.Tactic.Ring.add_pf_add_zero (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))\n                  (Mathlib.Tactic.Ring.sub_pf Mathlib.Tactic.Ring.neg_zero\n                    (Mathlib.Tactic.Ring.add_pf_add_zero (Nat.rawCast 1 + (i ^ Nat.rawCast 1 * Nat.rawCast 1 + 0)))))\n                (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                  (Mathlib.Meta.NormNum.IsInt.to_isNat\n                    (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                      (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                      (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                      (Eq.refl (Int.ofNat 0))))\n                  (Mathlib.Tactic.Ring.add_pf_add_overlap_zero\n                    (Mathlib.Tactic.Ring.add_overlap_pf_zero i (Nat.rawCast 1)\n                      (Mathlib.Meta.NormNum.IsInt.to_isNat\n                        (Mathlib.Meta.NormNum.isInt_add (Eq.refl HAdd.hAdd)\n                          (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                          (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                          (Eq.refl (Int.ofNat 0)))))\n                    (Mathlib.Tactic.Ring.add_pf_zero_add 0))))\n              (Mathlib.Tactic.Ring.cast_zero (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0)))))\n          (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n            (Mathlib.Tactic.Linarith.add_lt_of_neg_of_le\n              (Mathlib.Tactic.Linarith.mul_neg (neg_neg_of_pos Mathlib.Tactic.Linarith.zero_lt_one)\n                (Mathlib.Meta.NormNum.isNat_lt_true (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 0))\n                  (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)) (Eq.refl false)))\n              (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Eq.mp mem_Icc._simp_1 hi).left))\n            (Mathlib.Tactic.Linarith.sub_nonpos_of_le (Int.add_one_le_iff.mpr a))));\n  have hi'' :=\n    le_of_not_gt fun a =>\n      Mathlib.Tactic.Linarith.lt_irrefl\n        (Eq.mp\n          (congrArg (fun _a => _a < 0)\n            (Mathlib.Tactic.Ring.of_eq\n              (Mathlib.Tactic.Ring.add_congr\n                (Mathlib.Tactic.Ring.add_congr\n                  (Mathlib.Tactic.Ring.mul_congr\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 2)))\n                    (Mathlib.Tactic.Ring.neg_congr\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_one_mul\n                          (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                            (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                              (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                              (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                              (Eq.refl (Int.negOfNat 1)))))\n                        Mathlib.Tactic.Ring.neg_zero))\n                    (Mathlib.Tactic.Ring.add_mul\n                      (Mathlib.Tactic.Ring.mul_add\n                        (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                          (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                            (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 2))\n                            (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1)) (Eq.refl (Int.negOfNat 2))))\n                        (Mathlib.Tactic.Ring.mul_zero (Nat.rawCast 2))\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0)))\n                      (Mathlib.Tactic.Ring.zero_mul ((Int.negOfNat 1).rawCast + 0))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((Int.negOfNat 2).rawCast + 0))))\n                  (Mathlib.Tactic.Ring.sub_congr (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                    (Mathlib.Tactic.Ring.sub_pf\n                      (Mathlib.Tactic.Ring.neg_add\n                        (Mathlib.Tactic.Ring.neg_mul (↑n : ℤ) (Nat.rawCast 1)\n                          (Mathlib.Tactic.Ring.neg_one_mul\n                            (Mathlib.Meta.NormNum.IsInt.to_raw_eq\n                              (Mathlib.Meta.NormNum.isInt_mul (Eq.refl HMul.hMul)\n                                (Mathlib.Meta.NormNum.IsInt.of_raw ℤ (Int.negOfNat 1))\n                                (Mathlib.Meta.NormNum.IsNat.to_isInt (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1))\n                                (Eq.refl (Int.negOfNat 1))))))\n                        Mathlib.Tactic.Ring.neg_zero)\n                      (Mathlib.Tactic.Ring.add_pf_add_lt (i ^ Nat.rawCast 1 * Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_zero_add\n                          ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                  (Mathlib.Tactic.Ring.add_pf_add_lt (Int.negOfNat 2).rawCast\n                    (Mathlib.Tactic.Ring.add_pf_zero_add\n                      (i ^ Nat.rawCast 1 * Nat.rawCast 1 + ((↑n : ℤ) ^ Nat.rawCast 1 * (Int.negOfNat 1).rawCast + 0)))))\n                (Mathlib.Tactic.Ring.sub_congr\n                  (Mathlib.Tactic.Ring.add_congr\n                    (Mathlib.Tactic.Ring.add_congr (Mathlib.Tactic.Ring.atom_pf (↑n : ℤ))\n                      (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                      (Mathlib.Tactic.Ring.add_pf_add_gt (Nat.rawCast 1)\n                        (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                    (Mathlib.Tactic.Ring.cast_pos (Mathlib.Meta.NormNum.isNat_ofNat ℤ (Eq.refl 1)))\n                    (Mathlib.Tactic.Ring.add_pf_add_overlap\n                      (Mathlib.Meta.NormNum.IsNat.to_raw_eq\n                        (Mathlib.Meta.NormNum.isNat_add (Eq.refl HAdd.hAdd) (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1)\n                          (Mathlib.Meta.NormNum.IsNat.of_raw ℤ 1) (Eq.refl 2)))\n                      (Mathlib.Tactic.Ring.add_pf_add_zero ((↑n : ℤ) ^ Nat.rawCast 1 * Nat.rawCast 1 + 0))))\n                  (Mathlib.Tactic.Ring.atom_pf i) (Mathlib.Tactic.Ring.sub_pf ⋯ ⋯))\n                ⋯)\n              ⋯))\n          ⋯);\n  ⋯","type":"∀ {i : ℤ}, i ∈ Icc 1 (↑n : ℤ) → h' i ≠ x","name":["h'_ne_x"],"isProp":true,"id":["_uniq",679005]},{"value":"fun i => ⟨(↑(g (π (↑i : ℤ))) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["gtil"],"isProp":false,"id":["_uniq",736139]},{"value":"fun i => ⟨(↑(h' (↑i : ℤ)) : X'), ⋯⟩","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x_1 // x_1 ∈ X.erase (↑x : X') }","name":["htil"],"isProp":false,"id":["_uniq",739097]},{"value":"fun y => f (↑y : X')","type":"{ x_1 // x_1 ∈ X.erase (↑x : X') } → ℝ","name":["ftil"],"isProp":false,"id":["_uniq",739693]},{"value":"sorry","type":"Function.Bijective gtil","name":["why"],"isProp":true,"id":["_uniq",740040]},{"value":"sorry","type":"Function.Bijective htil","name":["why2"],"isProp":true,"id":["_uniq",740058]}]}],"start":7377},{"state":[],"start":7428},{"state":[],"start":7471},{"state":[],"start":7472},{"state":[],"start":7476},{"state":[],"start":7573},{"state":[],"start":7605},{"state":[],"start":7608},{"state":[],"start":7686},{"state":[{"type":"∃ g, Function.Bijective g","tag":[],"mvarId":["_uniq",868616],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",868612],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",868613],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",868614],"binderInfo":"default"},{"type":"#X = n","name":["hcard"],"isProp":true,"id":["_uniq",868615],"binderInfo":"default"}]}],"start":7745},{"state":[{"type":"∃ g, Function.Bijective g","tag":[],"mvarId":["_uniq",868814],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",868612],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",868613],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",868614],"binderInfo":"default"},{"type":"#X = n","name":["hcard"],"isProp":true,"id":["_uniq",868615],"binderInfo":"default"},{"value":"equivOfCardEq ⋯","type":"{ x // x ∈ Icc 1 (↑n : ℤ) } ≃ { x // x ∈ X }","name":["this"],"isProp":false,"id":["_uniq",868813]}]}],"start":7829},{"state":[],"start":7866},{"state":[],"start":7867},{"state":[],"start":7891},{"state":[],"start":7988},{"state":[],"start":8019},{"state":[{"type":"∑ i ∈ X, f i = ∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : Y) else 0","tag":[],"mvarId":["_uniq",870818],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]}],"start":8133},{"state":[{"type":"(∑ i ∈ Icc 1 (↑n : ℤ), if hi : i ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨i, hi⟩) : Y) else 0) = ∑ i ∈ X, f i","tag":[],"mvarId":["_uniq",870823],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]}],"start":8140},{"state":[{"type":"∀ (a : ℤ) (ha : a ∈ Icc 1 (↑n : ℤ)), (fun i hi => (↑(g ⟨i, hi⟩) : Y)) a ha ∈ X","tag":["convert_5"],"mvarId":["_uniq",871136],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]},{"type":"∀ (a₁ : ℤ) (ha₁ : a₁ ∈ Icc 1 (↑n : ℤ)) (a₂ : ℤ) (ha₂ : a₂ ∈ Icc 1 (↑n : ℤ)),\n  (fun i hi => (↑(g ⟨i, hi⟩) : Y)) a₁ ha₁ = (fun i hi => (↑(g ⟨i, hi⟩) : Y)) a₂ ha₂ → a₁ = a₂","tag":["convert_6"],"mvarId":["_uniq",871137],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]},{"type":"∀ b ∈ X, ∃ a, ∃ (ha : a ∈ Icc 1 (↑n : ℤ)), (fun i hi => (↑(g ⟨i, hi⟩) : Y)) a ha = b","tag":["convert_7"],"mvarId":["_uniq",871138],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]},{"type":"∀ (a : ℤ) (ha : a ∈ Icc 1 (↑n : ℤ)),\n  (if hi : a ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨a, hi⟩) : Y) else 0) = f ((fun i hi => (↑(g ⟨i, hi⟩) : Y)) a ha)","tag":["convert_8"],"mvarId":["_uniq",871139],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]}],"start":8205},{"state":[{"type":"∀ (a₁ : ℤ) (ha₁ : a₁ ∈ Icc 1 (↑n : ℤ)) (a₂ : ℤ) (ha₂ : a₂ ∈ Icc 1 (↑n : ℤ)),\n  (fun i hi => (↑(g ⟨i, hi⟩) : Y)) a₁ ha₁ = (fun i hi => (↑(g ⟨i, hi⟩) : Y)) a₂ ha₂ → a₁ = a₂","tag":["convert_6"],"mvarId":["_uniq",871137],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]},{"type":"∀ b ∈ X, ∃ a, ∃ (ha : a ∈ Icc 1 (↑n : ℤ)), (fun i hi => (↑(g ⟨i, hi⟩) : Y)) a ha = b","tag":["convert_7"],"mvarId":["_uniq",871138],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]},{"type":"∀ (a : ℤ) (ha : a ∈ Icc 1 (↑n : ℤ)),\n  (if hi : a ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨a, hi⟩) : Y) else 0) = f ((fun i hi => (↑(g ⟨i, hi⟩) : Y)) a ha)","tag":["convert_8"],"mvarId":["_uniq",871139],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]}],"start":8215},{"state":[{"type":"∀ b ∈ X, ∃ a, ∃ (ha : a ∈ Icc 1 (↑n : ℤ)), (fun i hi => (↑(g ⟨i, hi⟩) : Y)) a ha = b","tag":["convert_7"],"mvarId":["_uniq",871138],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]},{"type":"∀ (a : ℤ) (ha : a ∈ Icc 1 (↑n : ℤ)),\n  (if hi : a ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨a, hi⟩) : Y) else 0) = f ((fun i hi => (↑(g ⟨i, hi⟩) : Y)) a ha)","tag":["convert_8"],"mvarId":["_uniq",871139],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]}],"start":8289},{"state":[{"type":"∀ (a : ℤ) (ha : a ∈ Icc 1 (↑n : ℤ)),\n  (if hi : a ∈ Icc 1 (↑n : ℤ) then f (↑(g ⟨a, hi⟩) : Y) else 0) = f ((fun i hi => (↑(g ⟨i, hi⟩) : Y)) a ha)","tag":["convert_8"],"mvarId":["_uniq",871139],"isProp":true,"context":[{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",870812],"binderInfo":"implicit"},{"type":"Type u_1","name":["Y"],"isProp":false,"id":["_uniq",870813],"binderInfo":"implicit"},{"type":"Finset Y","name":["X"],"isProp":false,"id":["_uniq",870814],"binderInfo":"default"},{"type":"Y → ℝ","name":["f"],"isProp":false,"id":["_uniq",870815],"binderInfo":"default"},{"type":"{ x // x ∈ Icc 1 (↑n : ℤ) } → { x // x ∈ X }","name":["g"],"isProp":false,"id":["_uniq",870816],"binderInfo":"default"},{"type":"Function.Bijective g","name":["hg"],"isProp":true,"id":["_uniq",870817],"binderInfo":"default"}]}],"start":8348},{"state":[],"start":8367},{"state":[],"start":8368},{"state":[],"start":8414},{"state":[],"start":8509},{"state":[],"start":8510},{"state":[],"start":8556},{"state":[{"type":"∑ i ∈ {x₀}, f i = f x₀","tag":[],"mvarId":["_uniq",922666],"isProp":true,"context":[{"type":"Type u_1","name":["X'"],"isProp":false,"id":["_uniq",922663],"binderInfo":"implicit"},{"type":"X' → ℝ","name":["f"],"isProp":false,"id":["_uniq",922664],"binderInfo":"default"},{"type":"X'","name":["x₀"],"isProp":false,"id":["_uniq",922665],"binderInfo":"default"}]}],"start":8667},{"state":[],"start":8675},{"state":[],"start":8676},{"state":[],"start":8680},{"state":[],"start":8775},{"state":[],"start":8818},{"state":[],"start":8821},{"state":[],"start":8898},{"state":[],"start":8965},{"state":[],"start":8966},{"state":[],"start":9012},{"state":[],"start":9099},{"state":[],"start":9130},{"state":[],"start":9174},{"state":[],"start":9175},{"state":[],"start":9252},{"state":[],"start":9253},{"state":[],"start":9299},{"state":[],"start":9404},{"state":[],"start":9481},{"state":[],"start":9482},{"state":[],"start":9528},{"state":[],"start":9603},{"state":[],"start":9680},{"state":[],"start":9681},{"state":[],"start":9727},{"state":[],"start":9814},{"state":[],"start":9874},{"state":[],"start":9875},{"state":[],"start":9921},{"state":[],"start":10026},{"state":[],"start":10080},{"state":[],"start":10081},{"state":[],"start":10127},{"state":[],"start":10201},{"state":[],"start":10259},{"state":[],"start":10260},{"state":[],"start":10281},{"state":[],"start":10364},{"state":[],"start":10390},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":[],"mvarId":["_uniq",925607],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925604],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"}]}],"start":10464},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":[],"mvarId":["_uniq",925625],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925604],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925623],"binderInfo":"default"},{"type":"#X = n","name":["h"],"isProp":true,"id":["_uniq",925624],"binderInfo":"default"}]}],"start":10491},{"state":[{"type":"∀ (X : Finset XX), #X = 0 → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["zero"],"mvarId":["_uniq",925644],"isProp":false,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"}]},{"type":"∀ (X : Finset XX), #X = n + 1 → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",925651],"isProp":false,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"}]}],"start":10526},{"state":[{"type":"∀ (X : Finset XX), #X = n + 1 → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",925651],"isProp":false,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"}]}],"start":10536},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",925657],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"}]}],"start":10549},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",925666],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]}]}],"start":10601},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",927673],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"}]}],"start":10643},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",927782],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]}]}],"start":10668},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",927915],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]}]}],"start":10740},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",929545],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]}]}],"start":10815},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",933713],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":10865},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","tag":["succ"],"mvarId":["_uniq",933713],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":10872},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ x ∈ X', ∑ y ∈ Y, f (x, y) + ∑ x ∈ {x₀}, ∑ y ∈ Y, f (x, y)","tag":[],"mvarId":["_uniq",934544],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":10964},{"state":[],"start":11018},{"state":[{"type":"∑ x ∈ X', ∑ y ∈ Y, f (x, y) + ∑ x ∈ {x₀}, ∑ y ∈ Y, f (x, y) = ∑ x ∈ X', ∑ y ∈ Y, f (x, y) + ∑ y ∈ Y, f (x₀, y)","tag":[],"mvarId":["_uniq",934766],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":11095},{"state":[],"start":11133},{"state":[],"start":11219},{"state":[{"type":"∑ z ∈ X'.product Y, f z + ∑ y ∈ Y, f (x₀, y) = ∑ z ∈ X'.product Y, f z + ∑ z ∈ {x₀}.product Y, f z","tag":[],"mvarId":["_uniq",935081],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":11296},{"state":[{"type":"∑ y ∈ Y, f (x₀, y) = ∑ z ∈ {x₀}.product Y, f z","tag":["e_a","_@","Init","Prelude","_hyg",2138],"mvarId":["_uniq",936045],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":11310},{"state":[{"type":"∑ x, f (x₀, (↑x : YY)) = ∑ x, f (↑x : XX × YY)","tag":["e_a","_@","Init","Prelude","_hyg",2138],"mvarId":["_uniq",936278],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":11374},{"state":[{"type":"∑ x, f (x₀, (↑x : YY)) = ∑ x, f (↑x : XX × YY)","tag":["e_a","_@","Init","Prelude","_hyg",2138],"mvarId":["_uniq",941253],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]}]}],"start":11422},{"state":[{"type":"∑ x, f (x₀, (↑x : YY)) = ∑ x, f (↑x : XX × YY)","tag":["e_a","_@","Init","Prelude","_hyg",2138],"mvarId":["_uniq",941253],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]}]}],"start":11509},{"state":[{"type":"Function.Bijective π","tag":[],"mvarId":["_uniq",941478],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]}]}],"start":11554},{"state":[{"type":"Function.Injective π","tag":["left"],"mvarId":["_uniq",941489],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]}]},{"type":"Function.Surjective π","tag":["right"],"mvarId":["_uniq",941490],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]}]}],"start":11574},{"state":[{"type":"Function.Surjective π","tag":["right"],"mvarId":["_uniq",941490],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]}]}],"start":11685},{"state":[{"type":"∑ x, f (x₀, (↑x : YY)) = ∑ x, f (↑x : XX × YY)","tag":["e_a","_@","Init","Prelude","_hyg",2138],"mvarId":["_uniq",941480],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨(x, y), hz⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨(x', y'), hz'⟩ => fun hzz' =>\n      Eq.mpr (id (Eq.trans (Subtype.mk.injEq (x, y) hz (x', y') hz') (Prod.mk.injEq x y x' y')))\n        (finite_series_of_finite_series._proof_5 Y x₀ x y x' y'\n          (Eq.mp\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => (x, y) ∈ x_1) singleton_product) mem_map._simp_1)\n              (Eq.trans (congrArg Exists (funext fun a => congrArg (And (a ∈ Y)) (Prod.mk.injEq x₀ a x y)))\n                exists_eq_right_right._simp_1))\n            hz)\n          (Eq.mp\n            (Eq.trans (Eq.trans (congrArg (fun x => (x', y') ∈ x) singleton_product) mem_map._simp_1)\n              (Eq.trans (congrArg Exists (funext fun a => congrArg (And (a ∈ Y)) (Prod.mk.injEq x₀ a x' y')))\n                exists_eq_right_right._simp_1))\n            hz')\n          (Eq.mp\n            (Subtype.mk.injEq y\n              (Subtype.casesOn ⟨(x, y), hz⟩ fun z hz =>\n                id\n                  (finite_series_of_finite_series._proof_4 Y x₀ z\n                    (Eq.mp (Eq.trans (congrArg (fun x => z ∈ x) singleton_product) mem_map._simp_1) hz)))\n              y'\n              (Subtype.casesOn ⟨(x', y'), hz'⟩ fun z hz =>\n                id\n                  (finite_series_of_finite_series._proof_4 Y x₀ z\n                    (Eq.mp (Eq.trans (congrArg (fun x => z ∈ x) singleton_product) mem_map._simp_1) hz))))\n            hzz')),\n  fun h =>\n  match h with\n  | ⋯ =>\n    Exists.intro\n      ⟨(x₀, y),\n        of_eq_true\n          (Eq.trans\n            (Eq.trans (congrArg (fun x => (x₀, y) ∈ x) singleton_product)\n              (mem_map_mk._simp_1 (Prod.mk x₀) (Prod.mk_right_injective x₀)))\n            (eq_true hy))⟩\n      (Eq.refl ⋯)⟩","type":"Function.Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",941479]}]}],"start":11750},{"state":[{"type":"z.1.1 = x₀","tag":["h","e'_3","a","h","e'_1","h","e'_3"],"mvarId":["_uniq",952144],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨(x, y), hz⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨(x', y'), hz'⟩ => fun hzz' =>\n      Eq.mpr (id (Eq.trans (Subtype.mk.injEq (x, y) hz (x', y') hz') (Prod.mk.injEq x y x' y')))\n        (finite_series_of_finite_series._proof_5 Y x₀ x y x' y'\n          (Eq.mp\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => (x, y) ∈ x_1) singleton_product) mem_map._simp_1)\n              (Eq.trans (congrArg Exists (funext fun a => congrArg (And (a ∈ Y)) (Prod.mk.injEq x₀ a x y)))\n                exists_eq_right_right._simp_1))\n            hz)\n          (Eq.mp\n            (Eq.trans (Eq.trans (congrArg (fun x => (x', y') ∈ x) singleton_product) mem_map._simp_1)\n              (Eq.trans (congrArg Exists (funext fun a => congrArg (And (a ∈ Y)) (Prod.mk.injEq x₀ a x' y')))\n                exists_eq_right_right._simp_1))\n            hz')\n          (Eq.mp\n            (Subtype.mk.injEq y\n              (Subtype.casesOn ⟨(x, y), hz⟩ fun z hz =>\n                id\n                  (finite_series_of_finite_series._proof_4 Y x₀ z\n                    (Eq.mp (Eq.trans (congrArg (fun x => z ∈ x) singleton_product) mem_map._simp_1) hz)))\n              y'\n              (Subtype.casesOn ⟨(x', y'), hz'⟩ fun z hz =>\n                id\n                  (finite_series_of_finite_series._proof_4 Y x₀ z\n                    (Eq.mp (Eq.trans (congrArg (fun x => z ∈ x) singleton_product) mem_map._simp_1) hz))))\n            hzz')),\n  fun h =>\n  match h with\n  | ⋯ =>\n    Exists.intro\n      ⟨(x₀, y),\n        of_eq_true\n          (Eq.trans\n            (Eq.trans (congrArg (fun x => (x₀, y) ∈ x) singleton_product)\n              (mem_map_mk._simp_1 (Prod.mk x₀) (Prod.mk_right_injective x₀)))\n            (eq_true hy))⟩\n      (Eq.refl ⋯)⟩","type":"Function.Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",941479]},{"type":"{ x // x ∈ {x₀}.product Y }","name":["z"],"isProp":false,"id":["_uniq",950813],"binderInfo":"default"},{"type":"z ∈ univ","name":["a✝"],"isProp":true,"id":["_uniq",950861],"binderInfo":"default"}]}],"start":11795},{"state":[{"type":"⟨(x, y), hz⟩.1.1 = x₀","tag":["h","e'_3","a","h","e'_1","h","e'_3","mk","mk"],"mvarId":["_uniq",953577],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]},{"value":"fun z => ⟨(↑z : XX × YY).2, ⋯⟩","type":"{ x // x ∈ {x₀}.product Y } → { x // x ∈ Y }","name":["π"],"isProp":false,"id":["_uniq",941252]},{"value":"⟨fun ⦃h⦄ =>\n  match h with\n  | ⟨(x, y), hz⟩ => fun ⦃h⦄ =>\n    match h with\n    | ⟨(x', y'), hz'⟩ => fun hzz' =>\n      Eq.mpr (id (Eq.trans (Subtype.mk.injEq (x, y) hz (x', y') hz') (Prod.mk.injEq x y x' y')))\n        (finite_series_of_finite_series._proof_5 Y x₀ x y x' y'\n          (Eq.mp\n            (Eq.trans (Eq.trans (congrArg (fun x_1 => (x, y) ∈ x_1) singleton_product) mem_map._simp_1)\n              (Eq.trans (congrArg Exists (funext fun a => congrArg (And (a ∈ Y)) (Prod.mk.injEq x₀ a x y)))\n                exists_eq_right_right._simp_1))\n            hz)\n          (Eq.mp\n            (Eq.trans (Eq.trans (congrArg (fun x => (x', y') ∈ x) singleton_product) mem_map._simp_1)\n              (Eq.trans (congrArg Exists (funext fun a => congrArg (And (a ∈ Y)) (Prod.mk.injEq x₀ a x' y')))\n                exists_eq_right_right._simp_1))\n            hz')\n          (Eq.mp\n            (Subtype.mk.injEq y\n              (Subtype.casesOn ⟨(x, y), hz⟩ fun z hz =>\n                id\n                  (finite_series_of_finite_series._proof_4 Y x₀ z\n                    (Eq.mp (Eq.trans (congrArg (fun x => z ∈ x) singleton_product) mem_map._simp_1) hz)))\n              y'\n              (Subtype.casesOn ⟨(x', y'), hz'⟩ fun z hz =>\n                id\n                  (finite_series_of_finite_series._proof_4 Y x₀ z\n                    (Eq.mp (Eq.trans (congrArg (fun x => z ∈ x) singleton_product) mem_map._simp_1) hz))))\n            hzz')),\n  fun h =>\n  match h with\n  | ⋯ =>\n    Exists.intro\n      ⟨(x₀, y),\n        of_eq_true\n          (Eq.trans\n            (Eq.trans (congrArg (fun x => (x₀, y) ∈ x) singleton_product)\n              (mem_map_mk._simp_1 (Prod.mk x₀) (Prod.mk_right_injective x₀)))\n            (eq_true hy))⟩\n      (Eq.refl ⋯)⟩","type":"Function.Bijective π","name":["hπ"],"isProp":true,"id":["_uniq",941479]},{"type":"XX","name":["x"],"isProp":false,"id":["_uniq",953571],"binderInfo":"default"},{"type":"YY","name":["y"],"isProp":false,"id":["_uniq",953572],"binderInfo":"default"},{"type":"(x, y) ∈ {x₀}.product Y","name":["hz"],"isProp":true,"id":["_uniq",953575],"binderInfo":"default"},{"type":"⟨(x, y), hz⟩ ∈ univ","name":["a✝"],"isProp":true,"id":["_uniq",953576],"binderInfo":"default"}]}],"start":11835},{"state":[],"start":11863},{"state":[{"type":"∑ z ∈ X'.product Y, f z + ∑ z ∈ {x₀}.product Y, f z = ∑ z ∈ X.product Y, f z","tag":[],"mvarId":["_uniq",935143],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":11879},{"state":[{"type":"X.product Y = X'.product Y ∪ {x₀}.product Y","tag":["h","e'_2","h"],"mvarId":["_uniq",958429],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]},{"type":"Disjoint (X'.product Y) ({x₀}.product Y)","tag":["convert_4"],"mvarId":["_uniq",957992],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":11935},{"state":[{"type":"Disjoint (X'.product Y) ({x₀}.product Y)","tag":["convert_4"],"mvarId":["_uniq",957992],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",925602],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",925603],"binderInfo":"implicit"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",925605],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",925606],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",925645],"binderInfo":"default"},{"type":"∀ (X : Finset XX), #X = n → ∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ z ∈ X.product Y, f z","name":["hn"],"isProp":true,"id":["_uniq",925646],"binderInfo":"default"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",925653],"binderInfo":"default"},{"type":"#X = n + 1","name":["hX"],"isProp":true,"id":["_uniq",925656],"binderInfo":"default"},{"value":"finite_series_of_finite_series._proof_1 n X hX","type":"X.Nonempty","name":["hnon"],"isProp":true,"id":["_uniq",925665]},{"type":"XX","name":["x₀"],"isProp":false,"id":["_uniq",927669],"binderInfo":"default"},{"type":"x₀ ∈ X","name":["hx₀"],"isProp":true,"id":["_uniq",927672],"binderInfo":"default"},{"value":"X.erase x₀","type":"Finset XX","name":["X'"],"isProp":false,"id":["_uniq",927781]},{"value":"of_eq_true\n  (Eq.trans\n    (congrArg (fun x => x = n)\n      (Eq.trans (card_erase_of_mem hx₀) (Eq.trans (congrArg (fun x => x - 1) hX) (add_tsub_cancel_right n 1))))\n    (eq_self n))","type":"#X' = n","name":["hcard"],"isProp":true,"id":["_uniq",927914]},{"value":"ext fun x =>\n  if h : x = x₀ then finite_series_of_finite_series._proof_2 X x₀ hx₀ x h\n  else finite_series_of_finite_series._proof_3 X x₀ x h","type":"X = X' ∪ {x₀}","name":["hunion"],"isProp":true,"id":["_uniq",929544]},{"value":"of_eq_true\n  (Eq.trans disjoint_singleton_right._simp_1\n    (Eq.trans\n      (congrArg Not\n        (Eq.trans mem_erase._simp_1\n          (Eq.trans (congrArg (fun x => x ∧ x₀ ∈ X) (Eq.trans (congrArg Not (eq_self x₀)) not_true_eq_false))\n            (false_and (x₀ ∈ X)))))\n      not_false_eq_true))","type":"Disjoint X' {x₀}","name":["hdisj"],"isProp":true,"id":["_uniq",933712]}]}],"start":11949},{"state":[],"start":11961},{"state":[],"start":11962},{"state":[],"start":12022},{"state":[],"start":12117},{"state":[{"type":"∑ z ∈ X.product Y, f z = ∑ z ∈ Y.product X, f (z.2, z.1)","tag":[],"mvarId":["_uniq",959856],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"}]}],"start":12192},{"state":[{"type":"∑ z ∈ X.product Y, f z = ∑ z ∈ Y.product X, f (z.2, z.1)","tag":[],"mvarId":["_uniq",960725],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]}]}],"start":12233},{"state":[{"type":"∑ z ∈ X.product Y, f z = ∑ z ∈ Y.product X, f (z.2, z.1)","tag":[],"mvarId":["_uniq",960725],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]}]}],"start":12327},{"state":[{"type":"Function.Bijective h","tag":[],"mvarId":["_uniq",960845],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]}]}],"start":12366},{"state":[{"type":"Function.Injective h","tag":["left"],"mvarId":["_uniq",960856],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]}]},{"type":"Function.Surjective h","tag":["right"],"mvarId":["_uniq",960857],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]}]}],"start":12382},{"state":[{"type":"⟨(fst✝, snd✝), property✝⟩ = ⟨(fst✝¹, snd✝¹), property✝¹⟩","tag":["left"],"mvarId":["_uniq",961244],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]},{"type":"YY","name":["fst✝¹"],"isProp":false,"id":["_uniq",960928],"binderInfo":"default"},{"type":"XX","name":["snd✝¹"],"isProp":false,"id":["_uniq",960929],"binderInfo":"default"},{"type":"(fst✝¹, snd✝¹) ∈ Y.product X","name":["property✝¹"],"isProp":true,"id":["_uniq",960930],"binderInfo":"default"},{"type":"YY","name":["fst✝"],"isProp":false,"id":["_uniq",961127],"binderInfo":"default"},{"type":"XX","name":["snd✝"],"isProp":false,"id":["_uniq",961128],"binderInfo":"default"},{"type":"(fst✝, snd✝) ∈ Y.product X","name":["property✝"],"isProp":true,"id":["_uniq",961129],"binderInfo":"default"},{"type":"h ⟨(fst✝¹, snd✝¹), property✝¹⟩ = h ⟨(fst✝, snd✝), property✝⟩","name":["a✝"],"isProp":true,"id":["_uniq",961243],"binderInfo":"default"}]}],"start":12444},{"state":[{"type":"Function.Surjective h","tag":["right"],"mvarId":["_uniq",960857],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]}]}],"start":12463},{"state":[{"type":"∃ a, h a = ⟨z, hz⟩","tag":["right"],"mvarId":["_uniq",962211],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]},{"type":"XX × YY","name":["z"],"isProp":false,"id":["_uniq",961889],"binderInfo":"default"},{"type":"z ∈ X.product Y","name":["hz✝"],"isProp":true,"id":["_uniq",961890],"binderInfo":"default"},{"type":"z.1 ∈ X ∧ z.2 ∈ Y","name":["hz"],"isProp":true,"id":["_uniq",962210],"binderInfo":"default"}]}],"start":12499},{"state":[{"type":"∑ z ∈ X.product Y, f z = ∑ z ∈ Y.product X, f (z.2, z.1)","tag":[],"mvarId":["_uniq",960847],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]},{"value":"⟨fun ⦃h_1⦄ =>\n  match h_1 with\n  | ⋯ => fun ⦃h_2⦄ =>\n    match h_2 with\n    | ⋯ => fun a => of_eq_true (Eq.trans (congrArg ⋯ ⋯) ⋯),\n  ⋯⟩","type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",960846]}]}],"start":12540},{"state":[{"type":"∑ x, f (↑x : XX × YY) = ∑ z ∈ Y.product X, f (z.2, z.1)","tag":[],"mvarId":["_uniq",962553],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]},{"value":"⟨fun ⦃h_1⦄ =>\n  match h_1 with\n  | ⋯ => fun ⦃h_2⦄ =>\n    match h_2 with\n    | ⋯ => fun a => of_eq_true (Eq.trans (congrArg ⋯ ⋯) ⋯),\n  ⋯⟩","type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",960846]}]}],"start":12572},{"state":[{"type":"∑ x, f (↑x : XX × YY) = ∑ x, f ((↑x : YY × XX).2, (↑x : YY × XX).1)","tag":[],"mvarId":["_uniq",962667],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",959851],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",959852],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",959853],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",959854],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",959855],"binderInfo":"default"},{"value":"fun z => ⟨((↑z : YY × XX).2, (↑z : YY × XX).1), ⋯⟩","type":"{ x // x ∈ Y.product X } → { x // x ∈ X.product Y }","name":["h"],"isProp":false,"id":["_uniq",960724]},{"value":"⟨fun ⦃h_1⦄ =>\n  match h_1 with\n  | ⋯ => fun ⦃h_2⦄ =>\n    match h_2 with\n    | ⋯ => fun a => of_eq_true (Eq.trans (congrArg ⋯ ⋯) ⋯),\n  ⋯⟩","type":"Function.Bijective h","name":["hh"],"isProp":true,"id":["_uniq",960846]}]}],"start":12615},{"state":[],"start":12655},{"state":[],"start":12656},{"state":[],"start":12751},{"state":[{"type":"∑ x ∈ X, ∑ y ∈ Y, f (x, y) = ∑ y ∈ Y, ∑ x ∈ X, f (x, y)","tag":[],"mvarId":["_uniq",963532],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",963527],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",963528],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",963529],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",963530],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",963531],"binderInfo":"default"}]}],"start":12833},{"state":[{"type":"∑ z ∈ Y.product X, f (z.2, z.1) = ∑ y ∈ Y, ∑ x ∈ X, f (x, y)","tag":[],"mvarId":["_uniq",963602],"isProp":true,"context":[{"type":"Type u_1","name":["XX"],"isProp":false,"id":["_uniq",963527],"binderInfo":"implicit"},{"type":"Type u_2","name":["YY"],"isProp":false,"id":["_uniq",963528],"binderInfo":"implicit"},{"type":"Finset XX","name":["X"],"isProp":false,"id":["_uniq",963529],"binderInfo":"default"},{"type":"Finset YY","name":["Y"],"isProp":false,"id":["_uniq",963530],"binderInfo":"default"},{"type":"XX × YY → ℝ","name":["f"],"isProp":false,"id":["_uniq",963531],"binderInfo":"default"}]}],"start":12891},{"state":[],"start":12958},{"state":[],"start":12959},{"state":[],"start":12960},{"state":[],"start":13057},{"state":[],"start":13084},{"state":[],"start":13085},{"state":[],"start":13111},{"state":[],"start":13137},{"state":[],"start":13138},{"state":[],"start":13142},{"state":[],"start":13238},{"state":[],"start":13317},{"state":[],"start":13320},{"state":[],"start":13365},{"state":[],"start":13379},{"state":[],"start":13410},{"state":[{"type":"(x + y) ^ n =\n  ∑ j ∈ Icc 0 (↑n : ℤ),\n    (↑n.factorial : ℝ) / ((↑j.toNat.factorial : ℝ) * (↑((↑n : ℤ) - j).toNat.factorial : ℝ)) * x ^ j * y ^ ((↑n : ℤ) - j)","tag":[],"mvarId":["_uniq",966810],"isProp":true,"context":[{"type":"ℝ","name":["x"],"isProp":false,"id":["_uniq",966807],"binderInfo":"default"},{"type":"ℝ","name":["y"],"isProp":false,"id":["_uniq",966808],"binderInfo":"default"},{"type":"ℕ","name":["n"],"isProp":false,"id":["_uniq",966809],"binderInfo":"default"}]}],"start":13496},{"state":[],"start":13504},{"state":[],"start":13505},{"state":[],"start":13527},{"state":[],"start":13617},{"state":[],"start":13673},{"state":[{"type":"Filter.Tendsto (fun n => ∑ x, a x n) Filter.atTop (nhds (∑ x, L x))","tag":[],"mvarId":["_uniq",968227],"isProp":true,"context":[{"type":"Type u_1","name":["X"],"isProp":false,"id":["_uniq",968221],"binderInfo":"implicit"},{"type":"Fintype X","name":["inst✝"],"isProp":false,"id":["_uniq",968222],"binderInfo":"instImplicit"},{"type":"X → ℕ → ℝ","name":["a"],"isProp":false,"id":["_uniq",968223],"binderInfo":"default"},{"type":"X → ℝ","name":["L"],"isProp":false,"id":["_uniq",968224],"binderInfo":"default"},{"type":"∀ (x : X), Filter.Tendsto (a x) Filter.atTop (nhds (L x))","name":["h"],"isProp":true,"id":["_uniq",968225],"binderInfo":"default"}]}],"start":13749},{"state":[],"start":13757},{"state":[],"start":13758},{"state":[],"start":13759},{"state":[],"start":13760},{"state":[],"start":13771},{"state":[],"start":13771}]
