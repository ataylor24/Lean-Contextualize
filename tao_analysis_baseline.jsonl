{"chapter_name": "Section_10_1", "line_number": 191, "content": "\ntheorem _root_.HasDerivWithinAt.of_pow (n:ℕ) (x₀:ℝ) : HasDerivWithinAt (fun x ↦ x^n)\n(n * x₀^((n:ℤ)-1)) .univ x₀ := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable (x₀ : ℝ)", "line_number": 25, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_10_1_6 : ℝ → ℝ := abs", "line_number": 88, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_10_1", "line_number": 196, "content": "\ntheorem _root_.HasDerivWithinAt.of_zpow (n:ℤ) (x₀:ℝ) (hx₀: x₀ ≠ 0) :\n  HasDerivWithinAt (fun x ↦ x^n) (n * x₀^(n-1)) (.univ \\ {0}) x₀ := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable (x₀ : ℝ)", "line_number": 25, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_10_1_6 : ℝ → ℝ := abs", "line_number": 88, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_10_2", "line_number": 121, "content": "\ntheorem _root_.UniformContinuousOn.of_lipschitz {f:ℝ → ℝ}\n  (hcont: ContinuousOn f .univ)\n  (hderiv: DifferentiableOn ℝ f .univ)\n  (hlip: BddOn (deriv f) .univ) :\n  UniformContinuousOn f (.univ) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev f_10_2_3 : ℝ → ℝ := fun x ↦ x^2 - x^4", "line_number": 45, "declaration_attribute": "", "comment": "/-- Example 10.2.3 -/"}]}
{"chapter_name": "Section_10_2", "line_number": 112, "content": "\ntheorem lipschitz_bound {M a b:ℝ} (hM: M > 0) (hab: a < b) {f:ℝ → ℝ}\n  (hcont: ContinuousOn f (.Icc a b))\n  (hderiv: DifferentiableOn ℝ f (.Ioo a b))\n  (hlip: ∀ x ∈ Set.Ioo a b, |derivWithin f (.Ioo a b) x| ≤ M)\n  {x y:ℝ} (hx: x ∈ Set.Ioo a b) (hy: y ∈ Set.Ioo a b) :\n  |f x - f y| ≤ M * |x - y| := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev f_10_2_3 : ℝ → ℝ := fun x ↦ x^2 - x^4", "line_number": 45, "declaration_attribute": "", "comment": "/-- Example 10.2.3 -/"}]}
{"chapter_name": "Section_11_1", "line_number": 350, "content": "\ntheorem Partition.exist_right {I: BoundedInterval} (hI: I.a < I.b) (hI': I.b ∉ I)\n  {P: Partition I}\n  : ∃ c ∈ Set.Ico I.a I.b, Ioo c I.b ∈ P ∨ Ico c I.b ∈ P := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "inductive BoundedInterval where\n  | Ioo (a b:ℝ) : BoundedInterval\n  | Icc (a b:ℝ) : BoundedInterval\n  | Ioc (a b:ℝ) : BoundedInterval\n  | Ico (a b:ℝ) : BoundedInterval", "line_number": 21, "declaration_attribute": "", "comment": ""}, {"content": "def BoundedInterval.toSet (I: BoundedInterval) : Set ℝ := match I with\n  | Ioo a b => .Ioo a b\n  | Icc a b => .Icc a b\n  | Ioc a b => .Ioc a b\n  | Ico a b => .Ico a b", "line_number": 31, "declaration_attribute": "@[coe]", "comment": "/-- There is a technical issue in that this coercion is not injective: the empty set is represented by multiple bounded intervals.  This causes some of the statements in this section to be a little uglier than necessary.-/"}, {"content": "instance BoundedInterval.inst_coeSet : Coe BoundedInterval (Set ℝ) where\n  coe := toSet", "line_number": 37, "declaration_attribute": "", "comment": ""}, {"content": "instance BoundedInterval.instEmpty : EmptyCollection BoundedInterval where\n  emptyCollection := Ioo 0 0", "line_number": 40, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance BoundedInterval.decidableEq : DecidableEq BoundedInterval := instDecidableEqOfLawfulBEq", "line_number": 49, "declaration_attribute": "", "comment": "/-- This is to make Finsets of BoundedIntervals work properly -/"}, {"content": "noncomputable instance BoundedInterval.instInter : Inter BoundedInterval where\n  inter I J := (inter I J).choose", "line_number": 88, "declaration_attribute": "", "comment": ""}, {"content": "instance BoundedInterval.instMembership : Membership ℝ BoundedInterval where\n  mem I x := x ∈ (I:Set ℝ)", "line_number": 99, "declaration_attribute": "", "comment": ""}, {"content": "instance BoundedInterval.instSubset : HasSubset BoundedInterval where\n  Subset I J := ∀ x, x ∈ I → x ∈ J", "line_number": 105, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedInterval.a (I: BoundedInterval) : ℝ := match I with\n  | Ioo a _ => a\n  | Icc a _ => a\n  | Ioc a _ => a\n  | Ico a _ => a", "line_number": 111, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedInterval.b (I: BoundedInterval) : ℝ := match I with\n  | Ioo _ b => b\n  | Icc _ b => b\n  | Ioc _ b => b\n  | Ico _ b => b", "line_number": 117, "declaration_attribute": "", "comment": ""}, {"content": "instance BoundedInterval.instTrans : IsTrans BoundedInterval (· ⊆ ·) where\n  trans I J K hIJ hJK := by simp_all [subset_iff]; exact hIJ.trans hJK", "line_number": 135, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedInterval.length (I: BoundedInterval) : ℝ := max (I.b - I.a) 0", "line_number": 142, "declaration_attribute": "", "comment": ""}, {"content": "macro:max atomic(\"|\" noWs) a:term noWs \"|ₗ\" : term => `(BoundedInterval.length $a)", "line_number": 145, "declaration_attribute": "", "comment": "/-- Using ||ₗ subscript here to not override || -/"}, {"content": "abbrev BoundedInterval.joins (K I J: BoundedInterval) : Prop := (I:Set ℝ) ∩ (J:Set ℝ) = ∅\n  ∧ (K:Set ℝ) = (I:Set ℝ) ∪ (J:Set ℝ) ∧ |K|ₗ = |I|ₗ + |J|ₗ", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "structure Partition (I: BoundedInterval) where\n  intervals : Finset BoundedInterval\n  exists_unique (x:ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J\n  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I", "line_number": 246, "declaration_attribute": "@[ext]", "comment": ""}, {"content": "instance Partition.instMembership (I: BoundedInterval) : Membership BoundedInterval (Partition I) where\n  mem P J := J ∈ P.intervals", "line_number": 253, "declaration_attribute": "", "comment": ""}, {"content": "instance Partition.instBot (I: BoundedInterval) : Bot (Partition I) where\n  bot := {\n    intervals := {I}\n    exists_unique x hx := by apply ExistsUnique.intro I <;> simp [hx]\n    contains J hJ := by simp_all [subset_iff]\n    }", "line_number": 256, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Partition.join {I J K:BoundedInterval} (P: Partition I) (Q: Partition J) (h: K.joins I J) : Partition K\n:=\n{\n  intervals := P.intervals ∪ Q.intervals\n  exists_unique x hx := by\n    simp [mem_iff, h.2] at hx; rcases hx with hx | hx\n    . obtain ⟨ L, hLP, hxL ⟩ := (P.exists_unique _ hx).exists\n      apply ExistsUnique.intro L (by aesop)\n      intro K ⟨hK, hxK⟩; simp at hK; rcases hK with hKP | hKQ\n      . exact (P.exists_unique _ hx).unique ⟨ hKP, hxK ⟩ ⟨ hLP, hxL ⟩\n      replace hxK := (K.subset_iff _).mp (Q.contains _ hKQ) hxK\n      have := congr(x ∈ $(h.1)); simp [hx, hxK] at this\n    obtain ⟨ L, hLQ, hxL ⟩ := (Q.exists_unique _ hx).exists\n    apply ExistsUnique.intro L (by aesop)\n    intro K ⟨hK, hxK⟩; simp at hK; rcases hK with hKP | hKQ\n    . replace hxK := (K.subset_iff _).mp (P.contains _ hKP) hxK\n      have := congr(x ∈ $(h.1)); simp [hx, hxK] at this\n    exact (Q.exists_unique x hx).unique ⟨ hKQ, hxK ⟩ ⟨ hLQ, hxL ⟩\n  contains L hL := by\n    simp at hL; rcases hL with hLP | hLQ\n    . apply (P.contains _ hLP).trans; simp [h, subset_iff]\n    apply (Q.contains _ hLQ).trans; simp [h, subset_iff]\n}", "line_number": 267, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Partition.add_empty {I:BoundedInterval} (P: Partition I) : Partition I := {\n  intervals := P.intervals ∪ {∅}\n  exists_unique x hx := by\n    obtain ⟨ J, hJP, hxJ ⟩ := (P.exists_unique x hx).exists\n    apply ExistsUnique.intro J (by aesop)\n    intro K ⟨ hK, hxK ⟩\n    simp at hK; rcases hK with hK | rfl\n    . exact (P.exists_unique x hx).unique ⟨ hK, hxK ⟩ ⟨ hJP, hxJ ⟩\n    simp [mem_iff] at hxK\n  contains L hL := by\n    simp at hL; rcases hL with hL | rfl\n    . exact P.contains _ hL\n    simp [subset_iff]\n}", "line_number": 295, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Partition.remove_empty {I:BoundedInterval} (P: Partition I) : Partition I := {\n  intervals := P.intervals.filter (fun J ↦ (J:Set ℝ).Nonempty)\n  exists_unique x hx := by\n    obtain ⟨ J, hJP, hxJ ⟩ := (P.exists_unique x hx).exists\n    apply ExistsUnique.intro J (by simp_all [mem_iff]; exact Set.nonempty_of_mem hxJ )\n    intro K ⟨ hK, hxK ⟩; simp at hK\n    exact (P.exists_unique x hx).unique ⟨ hK.1, hxK ⟩ ⟨ hJP, hxJ ⟩\n  contains L hL := by simp at hL; exact P.contains _ hL.1\n}", "line_number": 311, "declaration_attribute": "", "comment": ""}, {"content": "instance Partition.instLE (I: BoundedInterval) : LE (Partition I) where\n  le P P' := ∀ J ∈ P'.intervals, ∃ K ∈ P, J ⊆ K", "line_number": 443, "declaration_attribute": "", "comment": "/-- Definition 11.1.14 (Finer and coarser partitions) -/"}, {"content": "instance Partition.instPreOrder (I: BoundedInterval) : Preorder (Partition I) where\n  le_refl P := by\n    sorry\n  le_trans P P' P'' hP hP' := by\n    sorry", "line_number": 446, "declaration_attribute": "", "comment": ""}, {"content": "instance Partition.instOrderBot (I: BoundedInterval) : OrderBot (Partition I) where\n  bot_le := by\n    sorry", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Partition.instMax (I: BoundedInterval) : Max (Partition I) where\n  max P P' := {\n    intervals := Finset.image₂ (fun J K ↦ J ∩ K) P.intervals P'.intervals\n    exists_unique x hx := by\n      obtain ⟨ J, ⟨ hJ1, hJ2⟩, hxJ ⟩ := P.exists_unique _ hx\n      obtain ⟨ K, ⟨ hK1, hK2⟩, hxK ⟩ := P'.exists_unique _ hx\n      simp [hx] at hxJ hxK\n      apply ExistsUnique.intro (J ∩ K)\n      . simp_all; exact ⟨ _, hJ1, _, hK1, rfl ⟩\n      simp; rintro _ J' hJ' K' hK' rfl hx'; simp at hx'\n      simp [hxJ _ hJ' hx'.1, hxK _ hK' hx'.2]\n    contains L hL := by\n      simp at hL\n      obtain ⟨ J, hJ, K, hK, rfl ⟩ := hL\n      replace hJ := P.contains _ hJ\n      replace hK := P'.contains _ hK\n      simp [subset_iff] at hJ hK ⊢\n      exact Set.inter_subset_left.trans hJ\n    }", "line_number": 465, "declaration_attribute": "", "comment": "/-- Definition 11.1.16 (Common refinement)-/"}]}
{"chapter_name": "Section_11_2", "line_number": 121, "content": "\ntheorem ConstantOn.piecewiseConstantOn {f:ℝ → ℝ} {I: BoundedInterval} (h: ConstantOn f (I:Set ℝ)) :\n  PiecewiseConstantOn f I := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "abbrev Constant {X Y:Type} (f: X → Y) : Prop := ∃ c, ∀ x, f x = c", "line_number": 23, "declaration_attribute": "", "comment": "/-- Definition 11.2.1 -/"}, {"content": "noncomputable abbrev constant_value {X Y:Type} [hY: Nonempty Y] (f:X → Y) : Y :=\n  if h: Constant f then h.choose else hY.some", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev ConstantOn (f: ℝ → ℝ) (X: Set ℝ) : Prop := Constant (fun x : X ↦ f ↑x)", "line_number": 44, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev constant_value_on (f:ℝ → ℝ) (X: Set ℝ) : ℝ := constant_value (fun x : X ↦ f ↑x)", "line_number": 46, "declaration_attribute": "", "comment": ""}, {"content": "abbrev PiecewiseConstantWith (f:ℝ → ℝ) {I: BoundedInterval} (P: Partition I) : Prop := ∀ J ∈ P, ConstantOn f (J:Set ℝ)", "line_number": 75, "declaration_attribute": "", "comment": "/-- Definition 11.2.3 (Piecewise constant functions I) -/"}, {"content": "abbrev PiecewiseConstantOn (f:ℝ → ℝ) (I: BoundedInterval) : Prop := ∃ P : Partition I, PiecewiseConstantWith f P", "line_number": 88, "declaration_attribute": "", "comment": "/-- Definition 11.2.5 (Piecewise constant functions I) -/"}, {"content": "noncomputable abbrev f_11_2_4 : ℝ → ℝ := fun x ↦\n  if x < 1 then 0 else  -- junk value\n    if x < 3 then 7 else\n      if x = 3 then 4 else\n        if x < 6 then 5 else\n          if x = 6 then 2 else\n            0 -- junk value", "line_number": 100, "declaration_attribute": "", "comment": "/-- Example 11.2.4 / Example 11.2.6 -/"}, {"content": "noncomputable abbrev PiecewiseConstantWith.integ (f:ℝ → ℝ) {I: BoundedInterval} (P: Partition I)  :\n  ℝ := ∑ J ∈ P.intervals, constant_value_on f (J:Set ℝ) * |J|ₗ", "line_number": 165, "declaration_attribute": "", "comment": "/-- Definition 11.2.9 (Piecewise constant integral I)-/"}, {"content": "noncomputable abbrev f_11_2_12 : ℝ → ℝ := fun x ↦\n    if x < 3 then 2 else\n      if x = 3 then 4 else\n        6", "line_number": 176, "declaration_attribute": "", "comment": "/-- Example 11.2.12 -/"}, {"content": "noncomputable abbrev P_11_2_12 : Partition (Icc 1 4) :=\n  ((⊥: Partition (Ico 1 3)).join (⊥ : Partition (Icc 3 3))\n  (join_Ico_Icc (by norm_num) (by norm_num) )).join\n  (⊥: Partition (Ioc 3 4))\n  (join_Icc_Ioc (by norm_num) (by norm_num))", "line_number": 181, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev P_11_2_12' : Partition (Icc 1 4) :=\n  ((((⊥: Partition (Ico 1 2)).join (⊥ : Partition (Ico 2 3))\n  (join_Ico_Ico (by norm_num) (by norm_num) )).join\n  (⊥: Partition (Icc 3 3))\n  (join_Ico_Icc (by norm_num) (by norm_num))).join\n  (⊥: Partition (Ioc 3 4))\n  (join_Icc_Ioc (by norm_num) (by norm_num))).add_empty", "line_number": 193, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev PiecewiseConstantOn.integ (f:ℝ → ℝ) (I: BoundedInterval) :\n  ℝ := if h: PiecewiseConstantOn f I then PiecewiseConstantWith.integ f h.choose else 0", "line_number": 214, "declaration_attribute": "", "comment": "/-- Definition 11.2.14 (Piecewise constant integral II)  -/"}, {"content": "noncomputable abbrev PiecewiseConstantOn.integ' {f:ℝ → ℝ} {I: BoundedInterval} (_:PiecewiseConstantOn f I) := integ f I", "line_number": 217, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_11_3", "line_number": 184, "content": "\ntheorem MajorizesOn.trans {f g h: ℝ → ℝ} {I: BoundedInterval}\n  (hfg: MajorizesOn f g I) (hgh: MajorizesOn g h I) : MajorizesOn f h I := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev MajorizesOn (g f:ℝ → ℝ) (I: BoundedInterval) : Prop := ∀ x ∈ (I:Set ℝ), f x ≤ g x", "line_number": 24, "declaration_attribute": "", "comment": "/-- Definition 11.3.1 (Majorization of functions) -/"}, {"content": "abbrev MinorizesOn (g f:ℝ → ℝ) (I: BoundedInterval) : Prop := ∀ x ∈ (I:Set ℝ), g x ≤ f x", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev upper_integral (f:ℝ → ℝ) (I: BoundedInterval) : ℝ :=\n  sInf ((PiecewiseConstantOn.integ · I) '' {g | MajorizesOn g f I ∧ PiecewiseConstantOn g I})", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 11.3.2 (Uppper and lower Riemann integrals )-/"}, {"content": "noncomputable abbrev lower_integral (f:ℝ → ℝ) (I: BoundedInterval) : ℝ :=\n  sSup ((PiecewiseConstantOn.integ · I) '' {g | MinorizesOn g f I ∧ PiecewiseConstantOn g I})", "line_number": 34, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev integ (f:ℝ → ℝ) (I: BoundedInterval) : ℝ := upper_integral f I", "line_number": 127, "declaration_attribute": "", "comment": "/-- Definition 11.3.4 (Riemann integral)\nAs we permit junk values, the simplest definition for the Riemann integral is the upper integral.-/"}, {"content": "noncomputable abbrev IntegrableOn (f:ℝ → ℝ) (I: BoundedInterval) : Prop :=\n  BddOn f I ∧ lower_integral f I = upper_integral f I", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev upper_riemann_sum (f:ℝ → ℝ) {I: BoundedInterval} (P: Partition I) : ℝ :=\n  ∑ J ∈ P.intervals, (sSup (f '' (J:Set ℝ))) * |J|ₗ", "line_number": 149, "declaration_attribute": "", "comment": "/-- Definition 11.3.9 (Riemann sums).  The restriction to positive length J is not needed thanks to various junk value conventions. -/"}, {"content": "noncomputable abbrev lower_riemann_sum (f:ℝ → ℝ) {I: BoundedInterval} (P: Partition I) : ℝ :=\n  ∑ J ∈ P.intervals, (sInf (f '' (J:Set ℝ))) * |J|ₗ", "line_number": 152, "declaration_attribute": "", "comment": ""}, {"content": "def MajorizesOn.of_add : Decidable ( ∀ (f g h:ℝ → ℝ) (I:BoundedInterval) (hfg: MajorizesOn f g I),\n MajorizesOn (f+h) (g+h) I) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 194, "declaration_attribute": "", "comment": "/-- Exercise 11.3.2 -/"}, {"content": "def MajorizesOn.of_mul : Decidable ( ∀ (f g h:ℝ → ℝ) (I:BoundedInterval) (hfg: MajorizesOn f g I),\n MajorizesOn (f*h) (g*h) I) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 199, "declaration_attribute": "", "comment": ""}, {"content": "def MajorizesOn.of_smul : Decidable ( ∀ (f g:ℝ → ℝ) (c:ℝ) (I:BoundedInterval) (hfg: MajorizesOn f g I),\n MajorizesOn (c • f) (c • g) I) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 204, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_11_4", "line_number": 297, "content": "\ntheorem IntegrableOn.split {I: BoundedInterval} {f: ℝ → ℝ} (hf: IntegrableOn f I) (P: Partition I) :\n  integ f I = ∑ J ∈ P.intervals, integ f J := by\n    sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": []}
{"chapter_name": "Section_11_5", "line_number": 254, "content": "\ntheorem integ_zero {a b:ℝ} (hab: a ≤ b) (f: ℝ → ℝ) (hf: ContinuousOn f (Icc a b))\n  (hnonneg: MajorizesOn f (fun _ ↦ 0) (Icc a b)) (hinteg : integ f (Icc a b) = 0) :\n  ∀ x ∈ Icc a b, f x = 0 := by\n    sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev PiecewiseContinuousOn (f:ℝ → ℝ) (I:BoundedInterval) : Prop :=\n  ∃ P: Partition I, ∀ J ∈ P.intervals, ContinuousOn f J", "line_number": 229, "declaration_attribute": "", "comment": "/-- Definition 11.5.4 -/"}, {"content": "noncomputable abbrev f_11_5_5 : ℝ → ℝ := fun x ↦\n  if x < 2 then x^2\n  else if x = 2 then 7\n  else x^3", "line_number": 233, "declaration_attribute": "", "comment": "/-- Example 11.5.5 -/"}]}
{"chapter_name": "Section_11_8", "line_number": 199, "content": "@[simp]\ntheorem α_len_of_id (I: BoundedInterval) : (fun x ↦ x)[I]ₗ = |I|ₗ := by\n  sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "noncomputable abbrev right_lim (f: ℝ → ℝ) (x₀:ℝ) : ℝ := lim ((nhdsWithin x₀ (.Ioi x₀)).map f)", "line_number": 42, "declaration_attribute": "", "comment": "/-- Left and right limits. A junk value is assigned if the limit does not exist. -/"}, {"content": "noncomputable abbrev left_lim (f: ℝ → ℝ) (x₀:ℝ) : ℝ := lim ((nhdsWithin x₀ (.Iio x₀)).map f)", "line_number": 44, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev jump (f: ℝ → ℝ) (x₀:ℝ) : ℝ :=\n  right_lim f x₀ - left_lim f x₀", "line_number": 54, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev α_length (α: ℝ → ℝ) (I: BoundedInterval) : ℝ := match I with\n| Icc a b => if a ≤ b then (right_lim α b) - (left_lim α a) else 0\n| Ico a b => if a ≤ b then (left_lim α b) - (left_lim α a) else 0\n| Ioc a b => if a ≤ b then (right_lim α b) - (right_lim α a) else 0\n| Ioo a b => if a < b then (left_lim α b) - (right_lim α a) else 0", "line_number": 147, "declaration_attribute": "", "comment": "/-- Definition 11.8.1 -/"}, {"content": "notation3:max α\"[\"I\"]ₗ\" => α_length α I", "line_number": 153, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedInterval.joins' (K I J: BoundedInterval) : Prop :=  K.joins I J ∧ ∀ α:ℝ → ℝ, α[K]ₗ = α[I]ₗ + α[J]ₗ", "line_number": 203, "declaration_attribute": "", "comment": "/-- An improved version of BoundedInterval.joins that also controls α-length. -/"}, {"content": "noncomputable abbrev PiecewiseConstantWith.RS_integ (f:ℝ → ℝ) {I: BoundedInterval} (P: Partition I) (α: ℝ → ℝ)   :\n  ℝ := ∑ J ∈ P.intervals, constant_value_on f (J:Set ℝ) * α[J]ₗ", "line_number": 243, "declaration_attribute": "", "comment": "/-- Definition 11.8.5 (Piecewise constant RS integral)-/"}, {"content": "noncomputable abbrev f_11_8_6 (x:ℝ) : ℝ := if x < 2 then 4 else 2", "line_number": 247, "declaration_attribute": "", "comment": "/-- Example 11.8.6 -/"}, {"content": "noncomputable abbrev P_11_8_6 : Partition (Icc 1 3) :=\n  (⊥: Partition (Ico 1 2)).join (⊥ : Partition (Icc 2 3))\n  (join_Ico_Icc (by norm_num) (by norm_num) )", "line_number": 249, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev PiecewiseConstantOn.RS_integ (f:ℝ → ℝ) (I: BoundedInterval) (α:ℝ → ℝ):\n  ℝ := if h: PiecewiseConstantOn f I then PiecewiseConstantWith.RS_integ f h.choose α else 0", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev upper_RS_integral (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ): ℝ :=\n  sInf ((PiecewiseConstantOn.RS_integ · I α) '' {g | MajorizesOn g f I ∧ PiecewiseConstantOn g I})", "line_number": 345, "declaration_attribute": "", "comment": "/-- Analogue of Definition 11.3.2 (Uppper and lower Riemann integrals )-/"}, {"content": "noncomputable abbrev lower_RS_integral (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ): ℝ :=\n  sSup ((PiecewiseConstantOn.RS_integ · I α) '' {g | MinorizesOn g f I ∧ PiecewiseConstantOn g I})", "line_number": 348, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev RS_integ (f:ℝ → ℝ) (I: BoundedInterval) (α:ℝ → ℝ) : ℝ := upper_RS_integral f I α", "line_number": 444, "declaration_attribute": "", "comment": "/-- Analogue of Definition 11.3.4 -/"}, {"content": "noncomputable abbrev RS_IntegrableOn (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ) : Prop :=\n  BddOn f I ∧ lower_RS_integral f I α = upper_RS_integral f I α", "line_number": 446, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_11_8", "line_number": 257, "content": "\ntheorem PiecewiseConstantWith.RS_integ_eq_integ {f:ℝ → ℝ} {I: BoundedInterval} (P: Partition I) :RS_integ f P (fun x ↦ x) = integ f P := by\n  sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "noncomputable abbrev right_lim (f: ℝ → ℝ) (x₀:ℝ) : ℝ := lim ((nhdsWithin x₀ (.Ioi x₀)).map f)", "line_number": 42, "declaration_attribute": "", "comment": "/-- Left and right limits. A junk value is assigned if the limit does not exist. -/"}, {"content": "noncomputable abbrev left_lim (f: ℝ → ℝ) (x₀:ℝ) : ℝ := lim ((nhdsWithin x₀ (.Iio x₀)).map f)", "line_number": 44, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev jump (f: ℝ → ℝ) (x₀:ℝ) : ℝ :=\n  right_lim f x₀ - left_lim f x₀", "line_number": 54, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev α_length (α: ℝ → ℝ) (I: BoundedInterval) : ℝ := match I with\n| Icc a b => if a ≤ b then (right_lim α b) - (left_lim α a) else 0\n| Ico a b => if a ≤ b then (left_lim α b) - (left_lim α a) else 0\n| Ioc a b => if a ≤ b then (right_lim α b) - (right_lim α a) else 0\n| Ioo a b => if a < b then (left_lim α b) - (right_lim α a) else 0", "line_number": 147, "declaration_attribute": "", "comment": "/-- Definition 11.8.1 -/"}, {"content": "notation3:max α\"[\"I\"]ₗ\" => α_length α I", "line_number": 153, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedInterval.joins' (K I J: BoundedInterval) : Prop :=  K.joins I J ∧ ∀ α:ℝ → ℝ, α[K]ₗ = α[I]ₗ + α[J]ₗ", "line_number": 203, "declaration_attribute": "", "comment": "/-- An improved version of BoundedInterval.joins that also controls α-length. -/"}, {"content": "noncomputable abbrev PiecewiseConstantWith.RS_integ (f:ℝ → ℝ) {I: BoundedInterval} (P: Partition I) (α: ℝ → ℝ)   :\n  ℝ := ∑ J ∈ P.intervals, constant_value_on f (J:Set ℝ) * α[J]ₗ", "line_number": 243, "declaration_attribute": "", "comment": "/-- Definition 11.8.5 (Piecewise constant RS integral)-/"}, {"content": "noncomputable abbrev f_11_8_6 (x:ℝ) : ℝ := if x < 2 then 4 else 2", "line_number": 247, "declaration_attribute": "", "comment": "/-- Example 11.8.6 -/"}, {"content": "noncomputable abbrev P_11_8_6 : Partition (Icc 1 3) :=\n  (⊥: Partition (Ico 1 2)).join (⊥ : Partition (Icc 2 3))\n  (join_Ico_Icc (by norm_num) (by norm_num) )", "line_number": 249, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev PiecewiseConstantOn.RS_integ (f:ℝ → ℝ) (I: BoundedInterval) (α:ℝ → ℝ):\n  ℝ := if h: PiecewiseConstantOn f I then PiecewiseConstantWith.RS_integ f h.choose α else 0", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev upper_RS_integral (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ): ℝ :=\n  sInf ((PiecewiseConstantOn.RS_integ · I α) '' {g | MajorizesOn g f I ∧ PiecewiseConstantOn g I})", "line_number": 345, "declaration_attribute": "", "comment": "/-- Analogue of Definition 11.3.2 (Uppper and lower Riemann integrals )-/"}, {"content": "noncomputable abbrev lower_RS_integral (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ): ℝ :=\n  sSup ((PiecewiseConstantOn.RS_integ · I α) '' {g | MinorizesOn g f I ∧ PiecewiseConstantOn g I})", "line_number": 348, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev RS_integ (f:ℝ → ℝ) (I: BoundedInterval) (α:ℝ → ℝ) : ℝ := upper_RS_integral f I α", "line_number": 444, "declaration_attribute": "", "comment": "/-- Analogue of Definition 11.3.4 -/"}, {"content": "noncomputable abbrev RS_IntegrableOn (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ) : Prop :=\n  BddOn f I ∧ lower_RS_integral f I α = upper_RS_integral f I α", "line_number": 446, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_11_8", "line_number": 467, "content": "\ntheorem RS_integ_of_uniform_cts {I: BoundedInterval} {f:ℝ → ℝ} (hf: UniformContinuousOn f I)\n {α:ℝ → ℝ} (hα: Monotone α):\n  RS_IntegrableOn f I α := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "noncomputable abbrev right_lim (f: ℝ → ℝ) (x₀:ℝ) : ℝ := lim ((nhdsWithin x₀ (.Ioi x₀)).map f)", "line_number": 42, "declaration_attribute": "", "comment": "/-- Left and right limits. A junk value is assigned if the limit does not exist. -/"}, {"content": "noncomputable abbrev left_lim (f: ℝ → ℝ) (x₀:ℝ) : ℝ := lim ((nhdsWithin x₀ (.Iio x₀)).map f)", "line_number": 44, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev jump (f: ℝ → ℝ) (x₀:ℝ) : ℝ :=\n  right_lim f x₀ - left_lim f x₀", "line_number": 54, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev α_length (α: ℝ → ℝ) (I: BoundedInterval) : ℝ := match I with\n| Icc a b => if a ≤ b then (right_lim α b) - (left_lim α a) else 0\n| Ico a b => if a ≤ b then (left_lim α b) - (left_lim α a) else 0\n| Ioc a b => if a ≤ b then (right_lim α b) - (right_lim α a) else 0\n| Ioo a b => if a < b then (left_lim α b) - (right_lim α a) else 0", "line_number": 147, "declaration_attribute": "", "comment": "/-- Definition 11.8.1 -/"}, {"content": "notation3:max α\"[\"I\"]ₗ\" => α_length α I", "line_number": 153, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedInterval.joins' (K I J: BoundedInterval) : Prop :=  K.joins I J ∧ ∀ α:ℝ → ℝ, α[K]ₗ = α[I]ₗ + α[J]ₗ", "line_number": 203, "declaration_attribute": "", "comment": "/-- An improved version of BoundedInterval.joins that also controls α-length. -/"}, {"content": "noncomputable abbrev PiecewiseConstantWith.RS_integ (f:ℝ → ℝ) {I: BoundedInterval} (P: Partition I) (α: ℝ → ℝ)   :\n  ℝ := ∑ J ∈ P.intervals, constant_value_on f (J:Set ℝ) * α[J]ₗ", "line_number": 243, "declaration_attribute": "", "comment": "/-- Definition 11.8.5 (Piecewise constant RS integral)-/"}, {"content": "noncomputable abbrev f_11_8_6 (x:ℝ) : ℝ := if x < 2 then 4 else 2", "line_number": 247, "declaration_attribute": "", "comment": "/-- Example 11.8.6 -/"}, {"content": "noncomputable abbrev P_11_8_6 : Partition (Icc 1 3) :=\n  (⊥: Partition (Ico 1 2)).join (⊥ : Partition (Icc 2 3))\n  (join_Ico_Icc (by norm_num) (by norm_num) )", "line_number": 249, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev PiecewiseConstantOn.RS_integ (f:ℝ → ℝ) (I: BoundedInterval) (α:ℝ → ℝ):\n  ℝ := if h: PiecewiseConstantOn f I then PiecewiseConstantWith.RS_integ f h.choose α else 0", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev upper_RS_integral (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ): ℝ :=\n  sInf ((PiecewiseConstantOn.RS_integ · I α) '' {g | MajorizesOn g f I ∧ PiecewiseConstantOn g I})", "line_number": 345, "declaration_attribute": "", "comment": "/-- Analogue of Definition 11.3.2 (Uppper and lower Riemann integrals )-/"}, {"content": "noncomputable abbrev lower_RS_integral (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ): ℝ :=\n  sSup ((PiecewiseConstantOn.RS_integ · I α) '' {g | MinorizesOn g f I ∧ PiecewiseConstantOn g I})", "line_number": 348, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev RS_integ (f:ℝ → ℝ) (I: BoundedInterval) (α:ℝ → ℝ) : ℝ := upper_RS_integral f I α", "line_number": 444, "declaration_attribute": "", "comment": "/-- Analogue of Definition 11.3.4 -/"}, {"content": "noncomputable abbrev RS_IntegrableOn (f:ℝ → ℝ) (I: BoundedInterval) (α: ℝ → ℝ) : Prop :=\n  BddOn f I ∧ lower_RS_integral f I α = upper_RS_integral f I α", "line_number": 446, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_11_9", "line_number": 107, "content": "\ntheorem DifferentiableOn.of_F_11_9_2' {q:ℚ} (hq: (q:ℝ) ∈ Set.Icc 0 1) : ¬ DifferentiableWithinAt ℝ F_11_9_2 (.Icc 0 1) q := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "noncomputable abbrev F_11_9_2 := fun x ↦ integ f_9_8_5 (Icc 0 x)", "line_number": 96, "declaration_attribute": "", "comment": ""}, {"content": "abbrev AntiderivOn (F f: ℝ → ℝ) (I: BoundedInterval) :=\n  DifferentiableOn ℝ F I ∧ ∀ x ∈ I, HasDerivWithinAt F (f x) I x", "line_number": 111, "declaration_attribute": "", "comment": "/-- Definition 11.9.3.  We drop the requirement that x be a limit point as this makes\n    the Lean arguments slightly cleaner -/"}, {"content": "noncomputable abbrev F_11_9 : ℝ → ℝ := fun x ↦ if x = 0 then 0 else x^2 * sin (1 / x^3)", "line_number": 219, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_2_2", "line_number": 413, "content": "\ntheorem Nat.backwards_induction {n:Nat} {P: Nat → Prop}\n  (hind: ∀ m, P (m++) → P m) (hn: P n) :\n    ∀ m, m ≤ n → P m := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Nat.add (n m : Nat) : Nat := Nat.recurse (fun _ sum ↦ sum++) m n", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 2.2.1. (Addition of natural numbers).\n    Compare with Mathlib's `Nat.add` -/"}, {"content": "instance Nat.instAdd : Add Nat where\n  add := add", "line_number": 33, "declaration_attribute": "", "comment": "/-- This instance allows for the `+` notation to be used for natural number addition. -/"}, {"content": "instance Nat.addCommMonoid : AddCommMonoid Nat where\n  add_assoc := add_assoc\n  add_comm := add_comm\n  zero_add := zero_add\n  add_zero := add_zero\n  nsmul := nsmulRec", "line_number": 111, "declaration_attribute": "", "comment": "/-- (Not from textbook) Nat can be given the structure of a commutative additive monoid.\nThis permits tactics such as `abel` to apply to the Chapter 2 natural numbers. -/"}, {"content": "def Nat.IsPos (n:Nat) : Prop := n ≠ 0", "line_number": 123, "declaration_attribute": "", "comment": "/-- Definition 2.2.7 (Positive natural numbers).-/"}, {"content": "instance Nat.instLE : LE Nat where\n  le n m := ∃ a:Nat, m = n + a", "line_number": 172, "declaration_attribute": "", "comment": "/-- Definition 2.2.11 (Ordering of the natural numbers).\n    This defines the `≤` notation on the natural numbers. -/"}, {"content": "instance Nat.instLT : LT Nat where\n  lt n m := n ≤ m ∧ n ≠ m", "line_number": 177, "declaration_attribute": "", "comment": "/-- Definition 2.2.11 (Ordering of the natural numbers).\n    This defines the `<` notation on the natural numbers. -/"}, {"content": "def Nat.decLe : (a b : Nat) → Decidable (a ≤ b)\n  | 0, b => by\n    apply isTrue\n    sorry\n  | a++, b => by\n    cases decLe a b with\n    | isTrue h =>\n      cases decEq a b with\n      | isTrue h =>\n        apply isFalse\n        sorry\n      | isFalse h =>\n        apply isTrue\n        sorry\n    | isFalse h =>\n      apply isFalse\n      sorry", "line_number": 323, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Establish the decidability of this order computably.  The portion of the\n  proof involving decidability has been provided; the remaining sorries involve claims about the\n  natural numbers.  One could also have established this result by the `classical` tactic\n  followed by `exact Classical.decRel _`, but this would make this definition (as well as some\n  instances below) noncomputable.\n\n  Compare with Mathlib's `Nat.decLe`.\n-/"}, {"content": "instance Nat.decidableRel : DecidableRel (· ≤ · : Nat → Nat → Prop) := Nat.decLe", "line_number": 341, "declaration_attribute": "", "comment": ""}, {"content": "instance Nat.instLinearOrder : LinearOrder Nat where\n  le_refl := ge_refl\n  le_trans a b c hab hbc := ge_trans hbc hab\n  lt_iff_le_not_le := by\n    intro a b\n    constructor\n    intro h\n    constructor\n    . exact le_of_lt h\n    . by_contra h'\n      exact not_lt_self (lt_of_le_of_lt h' h)\n    rintro ⟨ h1, h2 ⟩\n    rw [lt_iff, ← le_iff]\n    constructor\n    exact h1\n    by_contra h\n    rw [h] at h2\n    apply h2\n    exact ge_refl b\n  le_antisymm a b hab hba := ge_antisymm hba hab\n  le_total := by\n    intro a b\n    obtain h | h | h := trichotomous a b\n    . left; exact le_of_lt h\n    . simp [h, ge_refl]\n    . right; exact le_of_lt h\n  toDecidableLE := decidableRel", "line_number": 345, "declaration_attribute": "", "comment": "/-- (Not from textbook) Nat has the structure of a linear ordering. This allows for tactics\nsuch as `order` and `calc` to be applicable to the Chapter 2 natural numbers. -/"}, {"content": "instance Nat.isOrderedAddMonoid : IsOrderedAddMonoid Nat where\n  add_le_add_left := by\n    intro a b hab c\n    exact (add_le_add_left a b c).mp hab", "line_number": 391, "declaration_attribute": "", "comment": "/-- (Not from textbook) Nat has the structure of an ordered monoid. This allows for tactics\nsuch as `gcongr` to be applicable to the Chapter 2 natural numbers. -/"}]}
{"chapter_name": "Section_2_3", "line_number": 206, "content": "\ntheorem Nat.sq_add_eq (a b: Nat) :\n    (a + b) ^ (2 : Nat) = a ^ (2 : Nat) + 2 * a * b + b ^ (2 : Nat) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Nat.mul (n m : Nat) : Nat := Nat.recurse (fun _ prod ↦ prod + m) 0 n", "line_number": 29, "declaration_attribute": "", "comment": "/-- Definition 2.3.1 (Multiplication of natural numbers) -/"}, {"content": "instance Nat.instMul : Mul Nat where\n  mul := mul", "line_number": 32, "declaration_attribute": "", "comment": "/-- This instance allows for the `*` notation to be used for natural number multiplication. -/"}, {"content": "instance Nat.instCommSemiring : CommSemiring Nat where\n  left_distrib := mul_add\n  right_distrib := add_mul\n  zero_mul := zero_mul\n  mul_zero := mul_zero\n  mul_assoc := mul_assoc\n  one_mul := one_mul\n  mul_one := mul_one\n  mul_comm := mul_comm", "line_number": 105, "declaration_attribute": "", "comment": "/-- (Not from textbook)  Nat is a commutative semiring.\n    This allows tactics such as `ring` to apply to the Chapter 2 natural numbers. -/"}, {"content": "instance Nat.isOrderedRing : IsOrderedRing Nat where\n  zero_le_one := by sorry\n  mul_le_mul_of_nonneg_left := by sorry\n  mul_le_mul_of_nonneg_right := by sorry", "line_number": 162, "declaration_attribute": "", "comment": "/-- (Not from textbook) Nat is an ordered semiring.\nThis allows tactics such as `gcongr` to apply to the Chapter 2 natural numbers. -/"}, {"content": "abbrev Nat.pow (m n: Nat) : Nat := Nat.recurse (fun _ prod ↦ prod * m) 1 n", "line_number": 181, "declaration_attribute": "", "comment": "/-- Definition 2.3.11 (Exponentiation for natural numbers) -/"}, {"content": "instance Nat.instPow : HomogeneousPow Nat where\n  pow := Nat.pow", "line_number": 183, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 743, "content": "\ntheorem SetTheory.Set.subset_union_right (A B:Set) : B ⊆ A ∪ B := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 748, "content": "@[simp]\ntheorem SetTheory.Set.union_subset_iff (A B C:Set) : A ∪ B ⊆ C ↔ A ⊆ C ∧ B ⊆ C := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 784, "content": "\ntheorem SetTheory.Set.specification_from_replacement {A:Set} {P: A → Prop} :\n    ∃ B, B ⊆ A ∧ ∀ x, x.val ∈ B ↔ P x := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 776, "content": "\ntheorem SetTheory.Set.union_eq_partition (A B:Set) : A ∪ B = (A \\ B) ∪ (A ∩ B) ∪ (B \\ A) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 739, "content": "\ntheorem SetTheory.Set.subset_union_left (A B:Set) : A ⊆ A ∪ B := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 735, "content": "@[simp]\ntheorem SetTheory.Set.subset_inter_iff (A B C:Set) : C ⊆ A ∩ B ↔ C ⊆ A ∧ C ⊆ B := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 792, "content": "\ntheorem SetTheory.Set.subset_inter_subset {A B A' B':Set} (hA'A: A' ⊆ A) (hB'B: B' ⊆ B) :\n    A' ∩ B' ⊆ A ∩ B := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 248, "content": "\ntheorem SetTheory.Set.emptyset_neq_singleton : empty ≠ singleton_empty := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 726, "content": "\ntheorem SetTheory.Set.inter_subset_left (A B:Set) : A ∩ B ⊆ A := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 239, "content": "\ntheorem SetTheory.Set.pair_eq_pair {a b c d:Object} (h: ({a,b}:Set) = {c,d}) :\n    a = c ∧ b = d ∨ a = d ∧ b = c := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 723, "content": "\ntheorem SetTheory.Set.subset_tfae (A B:Set) : [A ⊆ B, A ∪ B = B, A ∩ B = A].TFAE := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 772, "content": "\ntheorem SetTheory.Set.pairwise_disjoint (A B:Set) :\n    Pairwise (Function.onFun Disjoint ![A \\ B, A ∩ B, B \\ A]) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 788, "content": "\ntheorem SetTheory.Set.subset_union_subset {A B A' B':Set} (hA'A: A' ⊆ A) (hB'B: B' ⊆ B) :\n    A' ∪ B' ⊆ A ∪ B := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 805, "content": "\ntheorem SetTheory.Set.singleton_iff (A:Set) (hA: A ≠ ∅) : (¬∃ B ⊂ A, B ≠ ∅) ↔ ∃ x, A = {x} := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 764, "content": "\ntheorem SetTheory.Set.partition_right {A B X:Set} (h_union: A ∪ B = X) (h_inter: A ∩ B = ∅) :\n    B = X \\ A := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 796, "content": "\ntheorem SetTheory.Set.subset_diff_subset_counter :\n    ∃ (A B A' B':Set), (A' ⊆ A) ∧ (B' ⊆ B) ∧ ¬ (A' \\ B') ⊆ (A \\ B) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_1", "line_number": 252, "content": "\ntheorem SetTheory.Set.emptyset_neq_pair : empty ≠ pair_empty := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "universe u v", "line_number": 68, "declaration_attribute": "", "comment": "/- The ability to work in multiple universe is not relevant immediately, but\nbecomes relevant when constructing models of set theory in the Chapter 3 epilogue. -/"}, {"content": "class SetTheory where\n  Set : Type u -- Axiom 3.1\n  Object : Type v -- Axiom 3.1\n  set_to_object : Set ↪ Object -- Axiom 3.1\n  mem : Object → Set → Prop -- Axiom 3.1\n  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y -- Axiom 3.2\n  emptyset: Set -- Axiom 3.3\n  emptyset_mem x : ¬ mem x emptyset -- Axiom 3.3\n  singleton : Object → Set -- Axiom 3.4\n  singleton_axiom x y : mem x (singleton y) ↔ x = y -- Axiom 3.4\n  union_pair : Set → Set → Set -- Axiom 3.5\n  union_pair_axiom X Y x : mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y) -- Axiom 3.5\n  specify A (P: Subtype (mem . A) → Prop) : Set -- Axiom 3.6\n  specification_axiom A (P: Subtype (mem . A) → Prop) :\n    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x -- Axiom 3.6\n  replace A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : Set -- Axiom 3.7\n  replacement_axiom A (P: Subtype (mem . A) → Object → Prop)\n    (hP: ∀ x y y', P x y ∧ P x y' → y = y') : ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y -- Axiom 3.7\n  nat : Set -- Axiom 3.8\n  nat_equiv : ℕ ≃ Subtype (mem . nat) -- Axiom 3.8\n  regularity_axiom A (hA : ∃ x, mem x A) :\n    ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬ ∃ y, mem y A ∧ mem y S -- Axiom 3.9\n  pow : Set → Set → Set -- Axiom 3.11\n  function_to_object (X: Set) (Y: Set) :\n    (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object -- Axiom 3.11\n  powerset_axiom (X: Set) (Y: Set) (F:Object) :\n    mem F (pow X Y) ↔ ∃ f: Subtype (mem . Y) → Subtype (mem . X),\n    function_to_object Y X f = F -- Axiom 3.11\n  union : Set → Set -- Axiom 3.12\n  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A -- Axiom 3.12", "line_number": 71, "declaration_attribute": "", "comment": "/-- The axioms of Zermelo-Frankel theory with atoms.  -/"}, {"content": "variable [SetTheory]", "line_number": 107, "declaration_attribute": "", "comment": "-- This instance implicitly imposes the axioms of Zermelo-Frankel set theory with atoms."}, {"content": "instance SetTheory.objects_mem_sets : Membership Object Set where\n  mem X x := mem x X", "line_number": 110, "declaration_attribute": "", "comment": "/-- Definition 3.1.1 (objects can be elements of sets) -/"}, {"content": "instance SetTheory.sets_are_objects : Coe Set Object where\n  coe X := set_to_object X", "line_number": 117, "declaration_attribute": "", "comment": "/-- Axiom 3.1 (Sets are objects)-/"}, {"content": "instance SetTheory.Set.instEmpty : EmptyCollection Set where\n  emptyCollection := emptyset", "line_number": 139, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSingleton : Singleton Object Set where\n  singleton := singleton", "line_number": 177, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instUnion : Union Set where\n  union := union_pair", "line_number": 192, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instInsert : Insert Object Set where\n  insert x X := {x} ∪ X", "line_number": 203, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.empty : Set := ∅", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.singleton_empty : Set := {(empty: Object)}", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.pair_empty : Set := {(empty: Object), (singleton_empty: Object)}", "line_number": 245, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSubset : HasSubset Set where\n  Subset X Y := ∀ x, x ∈ X → x ∈ Y", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.1.14.   -/"}, {"content": "instance SetTheory.Set.instSSubset : HasSSubset Set where\n  SSubset X Y := X ⊆ Y ∧ X ≠ Y", "line_number": 329, "declaration_attribute": "", "comment": "/--\n  Definition 3.1.14.\n  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.\n-/"}, {"content": "abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)", "line_number": 383, "declaration_attribute": "", "comment": "/--\n  This defines the subtype `A.toSubtype` for any `A:Set`.\n  Note that `A.toSubtype` gives you a type, similar to how `Object` or `Set` are types.\n  A value `x'` of type `A.toSubtype` combines some `x: Object` with a proof that `hx: x ∈ A`.\n\n  To produce an element `x'` of this subtype, use `⟨ x, hx ⟩`, where `x: Object` and `hx: x ∈ A`.\n  The object `x` associated to a subtype element `x'` is recovered as `x'.val`, and\n  the property `hx` that `x` belongs to `A` is recovered as `x'.property`.\n-/"}, {"content": "instance : CoeSort (Set) (Type v) where\n  coe A := A.toSubtype", "line_number": 394, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.subtype_mk (A:Set) {x:Object} (hx:x ∈ A) : A := ⟨ x, hx ⟩", "line_number": 417, "declaration_attribute": "", "comment": "/--\n  If one has a proof `hx` of `x ∈ A`, then `A.subtype_mk hx` will then make the element of `A`\n  (viewed as a subtype) corresponding to `x`.\n-/"}, {"content": "abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instIntersection : Inter Set where\n  inter X Y := X.specify (fun x ↦ x.val ∈ Y)", "line_number": 452, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instSDiff : SDiff Set where\n  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)", "line_number": 466, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.instDistribLattice : DistribLattice Set where\n  le := (· ⊆ ·)\n  le_refl := subset_self\n  le_trans := fun _ _ _ ↦ subset_trans\n  le_antisymm := subset_antisymm\n  inf := (· ∩ ·)\n  sup := (· ∪ ·)\n  le_sup_left := by sorry\n  le_sup_right := by sorry\n  sup_le := by sorry\n  inf_le_left := by sorry\n  inf_le_right := by sorry\n  le_inf := by sorry\n  le_sup_inf := by\n    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)\n    rw [←union_inter_distrib_left]", "line_number": 522, "declaration_attribute": "", "comment": "/-- Not from textbook: sets form a distributive lattice. -/"}, {"content": "instance SetTheory.Set.instOrderBot : OrderBot Set where\n  bot := ∅\n  bot_le := empty_subset", "line_number": 540, "declaration_attribute": "", "comment": "/-- Sets have a minimal element.  -/"}, {"content": "abbrev SetTheory.Set.replace (A:Set) {P: A → Object → Prop}\n  (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set := SetTheory.replace A P hP", "line_number": 554, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Nat := SetTheory.nat", "line_number": 563, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.nat_equiv : ℕ ≃ Nat := SetTheory.nat_equiv", "line_number": 576, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Axiom of infinity) -/"}, {"content": "instance SetTheory.Set.instOfNat {n:ℕ} : OfNat Nat n where\n  ofNat := nat_equiv n", "line_number": 579, "declaration_attribute": "", "comment": "-- Below are some API for handling coercions. This may not be the optimal way to set things up."}, {"content": "instance SetTheory.Set.instNatCast : NatCast Nat where\n  natCast n := nat_equiv n", "line_number": 586, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.toNat : Coe Nat ℕ where\n  coe n := nat_equiv.symm n", "line_number": 593, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instNatCast : NatCast Object where\n  natCast n := (n:Nat).val", "line_number": 599, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Object.instOfNat {n:ℕ} : OfNat Object n where\n  ofNat := ((n:Nat):Object)", "line_number": 606, "declaration_attribute": "", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_set : Coe Set (_root_.Set Object) where\n  coe X := { x | x ∈ X }", "line_number": 813, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_2", "line_number": 77, "content": "\ntheorem SetTheory.Set.pair_exists (h: axiom_of_universal_specification) (x₁ x₂:Object):\n    ∃ (X:Set), ∀ y, y ∈ X ↔ y = x₁ ∨ y = x₂ := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev axiom_of_universal_specification : Prop :=\n  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x", "line_number": 29, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Universal specification) -/"}]}
{"chapter_name": "Section_3_2", "line_number": 69, "content": "\ntheorem SetTheory.Set.singleton_exists (h: axiom_of_universal_specification) (x:Object):\n    ∃ (X:Set), ∀ y, y ∈ X ↔ y = x := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev axiom_of_universal_specification : Prop :=\n  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x", "line_number": 29, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Universal specification) -/"}]}
{"chapter_name": "Section_3_2", "line_number": 110, "content": "\ntheorem SetTheory.Set.not_mem_mem (A B:Set) : (A:Object) ∉ B ∨ (B:Object) ∉ A := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev axiom_of_universal_specification : Prop :=\n  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x", "line_number": 29, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Universal specification) -/"}]}
{"chapter_name": "Section_3_2", "line_number": 101, "content": "\ntheorem SetTheory.Set.replace_exists (h: axiom_of_universal_specification) (A:Set)\n  (P: A → Object → Prop) (hP: ∀ x y y', P x y ∧ P x y' → y = y') :\n    ∃ (Z:Set), ∀ y, y ∈ Z ↔ ∃ a : A, P a y := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev axiom_of_universal_specification : Prop :=\n  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x", "line_number": 29, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Universal specification) -/"}]}
{"chapter_name": "Section_3_2", "line_number": 107, "content": "\ntheorem SetTheory.Set.not_mem_self (A:Set) : (A:Object) ∉ A := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev axiom_of_universal_specification : Prop :=\n  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x", "line_number": 29, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Universal specification) -/"}]}
{"chapter_name": "Section_3_2", "line_number": 61, "content": "\ntheorem SetTheory.Set.emptyset_exists (h: axiom_of_universal_specification):\n    ∃ (X:Set), ∀ x, x ∉ X := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev axiom_of_universal_specification : Prop :=\n  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x", "line_number": 29, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Universal specification) -/"}]}
{"chapter_name": "Section_3_2", "line_number": 113, "content": "\ntheorem SetTheory.Set.univ_iff : axiom_of_universal_specification ↔\n  ∃ (U:Set), ∀ x, x ∈ U := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev axiom_of_universal_specification : Prop :=\n  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x", "line_number": 29, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Universal specification) -/"}]}
{"chapter_name": "Section_3_2", "line_number": 85, "content": "\ntheorem SetTheory.Set.union_exists (h: axiom_of_universal_specification) (A B:Set):\n    ∃ (Z:Set), ∀ z, z ∈ Z ↔ z ∈ A ∨ z ∈ B := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "abbrev axiom_of_universal_specification : Prop :=\n  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x", "line_number": 29, "declaration_attribute": "", "comment": "/-- Axiom 3.8 (Universal specification) -/"}]}
{"chapter_name": "Section_3_3", "line_number": 422, "content": "\ntheorem Function.comp_of_inj {X Y Z:Set} {f: Function X Y} {g : Function Y Z} (hf: f.one_to_one)\n  (hg: g.one_to_one) : (g ○ f).one_to_one := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 38, "declaration_attribute": "", "comment": ""}, {"content": "structure Function (X Y: Set) where\n  P : X → Y → Prop\n  unique : ∀ x: X, ∃! y: Y, P x y", "line_number": 45, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 3.3.1. `Function X Y` is the structure of functions from `X` to `Y`.\n  Analogous to the Mathlib type `X → Y`.\n-/"}, {"content": "noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=\n  fun x ↦ (f.unique x).choose", "line_number": 56, "declaration_attribute": "", "comment": "/--\n  Converting a Chapter 3 function `f: Function X Y` to a Mathlib function `f: X → Y`.\n  The Chapter 3 definition of a function was nonconstructive, so we have to use the\n  axiom of choice here.\n-/"}, {"content": "noncomputable instance Function.inst_coefn (X Y: Set) : CoeFun (Function X Y) (fun _ ↦ X → Y) where\n  coe := Function.to_fn", "line_number": 59, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.mk_fn {X Y: Set} (f: X → Y) : Function X Y :=\n  Function.mk (fun x y ↦ y = f x) (by simp)", "line_number": 65, "declaration_attribute": "", "comment": "/-- Converting a Mathlib function to a Chapter 3 `Function` -/"}, {"content": "abbrev P_3_3_3a : Nat → Nat → Prop := fun x y ↦ (y:ℕ) = (x:ℕ)+1", "line_number": 78, "declaration_attribute": "", "comment": "/-- Example 3.3.3.   -/"}, {"content": "abbrev SetTheory.Set.f_3_3_3a : Function Nat Nat := Function.mk P_3_3_3a P_3_3_3a_existsUnique", "line_number": 86, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3b : Nat → Nat → Prop := fun x y ↦ (y+1:ℕ) = (x:ℕ)", "line_number": 101, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3c : (Nat \\ {(0:Object)}: Set) → Nat → Prop :=\n  fun x y ↦ ((y+1:ℕ):Object) = x", "line_number": 109, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_3c : Function (Nat \\ {(0:Object)}: Set) Nat :=\n  Function.mk P_3_3_3c P_3_3_3c_existsUnique", "line_number": 125, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.coe_nonzero (n:ℕ) (h: n ≠ 0): (Nat \\ {(0:Object)}: Set) :=\n  ⟨((n:ℕ):Object), by\n    simp [SetTheory.Object.ofnat_eq',h]\n    rw [←SetTheory.Object.ofnat_eq]\n    exact Subtype.property _\n  ⟩", "line_number": 132, "declaration_attribute": "", "comment": "/-- Create a version of a non-zero `n` inside `Nat \\ {0}` for any natural number n. -/"}, {"content": "abbrev SetTheory.Set.P_3_3_5 : Nat → Nat → Prop := fun _x y ↦ y = 7", "line_number": 175, "declaration_attribute": "", "comment": "/-- Example 3.3.5. The unused variable `_x` is underscored to avoid triggering a linter. -/"}, {"content": "abbrev SetTheory.Set.f_3_3_5 : Function Nat Nat := Function.mk P_3_3_5 P_3_3_5_existsUnique", "line_number": 180, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_10a : Function Nat Nat := Function.mk_fn (fun x ↦ (x^2 + 2*x + 1:ℕ))", "line_number": 197, "declaration_attribute": "", "comment": "/--\n  Example 3.3.10 (simplified).  The second part of the example is tricky to replicate in this\n  formalism, so a Mathlib substitute is offered instead.\n-/"}, {"content": "abbrev SetTheory.Set.f_3_3_10b : Function Nat Nat := Function.mk_fn (fun x ↦ ((x+1)^2:ℕ))", "line_number": 199, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_11 (X:Set) : Function (∅:Set) X :=\n  Function.mk (fun _ _ ↦ True) (by intro ⟨ x,hx ⟩; simp at hx)", "line_number": 216, "declaration_attribute": "", "comment": "/-- Example 3.3.11 -/"}, {"content": "noncomputable abbrev Function.comp {X Y Z: Set} (g: Function Y Z) (f: Function X Y) :\n    Function X Z :=\n  Function.mk_fn (fun x ↦ g (f x))", "line_number": 222, "declaration_attribute": "", "comment": "/-- Definition 3.3.13 (Composition) -/"}, {"content": "infix:90 \"○\" => Function.comp", "line_number": 228, "declaration_attribute": "", "comment": "-- `∘` is already taken in Mathlib for the composition of Mathlib functions,\n-- so we use `○` here instead to avoid ambiguity."}, {"content": "abbrev SetTheory.Set.f_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (2*x:ℕ))", "line_number": 241, "declaration_attribute": "", "comment": "/-- Example 3.3.14 -/"}, {"content": "abbrev SetTheory.Set.g_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (x+3:ℕ))", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.one_to_one {X Y: Set} (f: Function X Y) : Prop := ∀ x x': X, x ≠ x' → f x ≠ f x'", "line_number": 260, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.onto {X Y: Set} (f: Function X Y) : Prop := ∀ y: Y, ∃ x: X, f x = y", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 3.3.20 (Onto functions) -/"}, {"content": "abbrev A_3_3_21 := { m:ℤ // ∃ n:ℤ, m = n^2 }", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.bijective {X Y: Set} (f: Function X Y) : Prop := f.one_to_one ∧ f.onto", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.3.23 (Bijective functions) -/"}, {"content": "abbrev f_3_3_24 : Fin 3 → ({3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩\n| 2 => ⟨ 4, by norm_num ⟩", "line_number": 327, "declaration_attribute": "", "comment": "/-- Example 3.3.24 (using Mathlib) -/"}, {"content": "abbrev g_3_3_24 : Fin 2 → ({2,3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 2, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩", "line_number": 335, "declaration_attribute": "", "comment": ""}, {"content": "abbrev h_3_3_24 : Fin 3 → ({3,4,5}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 4, by norm_num ⟩\n| 2 => ⟨ 5, by norm_num ⟩", "line_number": 342, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inverse {X Y: Set} (f: Function X Y) (h: f.bijective) :\n    Function Y X :=\n  Function.mk (fun y x ↦ f x = y) (by\n    intros\n    apply existsUnique_of_exists_of_unique\n    . aesop\n    intro _ _ hx hx'; simp at hx hx'\n    rw [←hx'] at hx\n    apply f.one_to_one_iff.mp h.1\n    simp [hx]\n  )", "line_number": 386, "declaration_attribute": "", "comment": "/--\n  We cannot use the notation `f⁻¹` for the inverse because in Mathlib's `Inv` class, the inverse\n  of `f` must be exactly of the same type of `f`, and `Function Y X` is a different type from\n  `Function X Y`.\n-/"}, {"content": "def Function.comp_cancel_left_without_hg : Decidable (∀ (X Y Z:Set) (f f': Function X Y) (g : Function Y Z) (heq : g ○ f = g ○ f'), f = f') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 446, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_cancel_right_without_hg : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g g': Function Y Z) (heq : g ○ f = g' ○ f), g = g') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 450, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_injective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).one_to_one), g.one_to_one) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 463, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_surjective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).onto), f.onto) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 468, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inclusion {X Y:Set} (h: X ⊆ Y) :\n    Function X Y := Function.mk_fn (fun x ↦ ⟨ x.val, h x.val x.property ⟩ )", "line_number": 495, "declaration_attribute": "", "comment": "/-- Exercise 3.3.8 -/"}, {"content": "abbrev Function.id (X:Set) : Function X X := Function.mk_fn (fun x ↦ x)", "line_number": 498, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_3", "line_number": 457, "content": "\ntheorem Function.comp_injective {X Y Z:Set} {f: Function X Y} {g : Function Y Z} (hinj :\n    (g ○ f).one_to_one) : f.one_to_one := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 38, "declaration_attribute": "", "comment": ""}, {"content": "structure Function (X Y: Set) where\n  P : X → Y → Prop\n  unique : ∀ x: X, ∃! y: Y, P x y", "line_number": 45, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 3.3.1. `Function X Y` is the structure of functions from `X` to `Y`.\n  Analogous to the Mathlib type `X → Y`.\n-/"}, {"content": "noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=\n  fun x ↦ (f.unique x).choose", "line_number": 56, "declaration_attribute": "", "comment": "/--\n  Converting a Chapter 3 function `f: Function X Y` to a Mathlib function `f: X → Y`.\n  The Chapter 3 definition of a function was nonconstructive, so we have to use the\n  axiom of choice here.\n-/"}, {"content": "noncomputable instance Function.inst_coefn (X Y: Set) : CoeFun (Function X Y) (fun _ ↦ X → Y) where\n  coe := Function.to_fn", "line_number": 59, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.mk_fn {X Y: Set} (f: X → Y) : Function X Y :=\n  Function.mk (fun x y ↦ y = f x) (by simp)", "line_number": 65, "declaration_attribute": "", "comment": "/-- Converting a Mathlib function to a Chapter 3 `Function` -/"}, {"content": "abbrev P_3_3_3a : Nat → Nat → Prop := fun x y ↦ (y:ℕ) = (x:ℕ)+1", "line_number": 78, "declaration_attribute": "", "comment": "/-- Example 3.3.3.   -/"}, {"content": "abbrev SetTheory.Set.f_3_3_3a : Function Nat Nat := Function.mk P_3_3_3a P_3_3_3a_existsUnique", "line_number": 86, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3b : Nat → Nat → Prop := fun x y ↦ (y+1:ℕ) = (x:ℕ)", "line_number": 101, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3c : (Nat \\ {(0:Object)}: Set) → Nat → Prop :=\n  fun x y ↦ ((y+1:ℕ):Object) = x", "line_number": 109, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_3c : Function (Nat \\ {(0:Object)}: Set) Nat :=\n  Function.mk P_3_3_3c P_3_3_3c_existsUnique", "line_number": 125, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.coe_nonzero (n:ℕ) (h: n ≠ 0): (Nat \\ {(0:Object)}: Set) :=\n  ⟨((n:ℕ):Object), by\n    simp [SetTheory.Object.ofnat_eq',h]\n    rw [←SetTheory.Object.ofnat_eq]\n    exact Subtype.property _\n  ⟩", "line_number": 132, "declaration_attribute": "", "comment": "/-- Create a version of a non-zero `n` inside `Nat \\ {0}` for any natural number n. -/"}, {"content": "abbrev SetTheory.Set.P_3_3_5 : Nat → Nat → Prop := fun _x y ↦ y = 7", "line_number": 175, "declaration_attribute": "", "comment": "/-- Example 3.3.5. The unused variable `_x` is underscored to avoid triggering a linter. -/"}, {"content": "abbrev SetTheory.Set.f_3_3_5 : Function Nat Nat := Function.mk P_3_3_5 P_3_3_5_existsUnique", "line_number": 180, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_10a : Function Nat Nat := Function.mk_fn (fun x ↦ (x^2 + 2*x + 1:ℕ))", "line_number": 197, "declaration_attribute": "", "comment": "/--\n  Example 3.3.10 (simplified).  The second part of the example is tricky to replicate in this\n  formalism, so a Mathlib substitute is offered instead.\n-/"}, {"content": "abbrev SetTheory.Set.f_3_3_10b : Function Nat Nat := Function.mk_fn (fun x ↦ ((x+1)^2:ℕ))", "line_number": 199, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_11 (X:Set) : Function (∅:Set) X :=\n  Function.mk (fun _ _ ↦ True) (by intro ⟨ x,hx ⟩; simp at hx)", "line_number": 216, "declaration_attribute": "", "comment": "/-- Example 3.3.11 -/"}, {"content": "noncomputable abbrev Function.comp {X Y Z: Set} (g: Function Y Z) (f: Function X Y) :\n    Function X Z :=\n  Function.mk_fn (fun x ↦ g (f x))", "line_number": 222, "declaration_attribute": "", "comment": "/-- Definition 3.3.13 (Composition) -/"}, {"content": "infix:90 \"○\" => Function.comp", "line_number": 228, "declaration_attribute": "", "comment": "-- `∘` is already taken in Mathlib for the composition of Mathlib functions,\n-- so we use `○` here instead to avoid ambiguity."}, {"content": "abbrev SetTheory.Set.f_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (2*x:ℕ))", "line_number": 241, "declaration_attribute": "", "comment": "/-- Example 3.3.14 -/"}, {"content": "abbrev SetTheory.Set.g_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (x+3:ℕ))", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.one_to_one {X Y: Set} (f: Function X Y) : Prop := ∀ x x': X, x ≠ x' → f x ≠ f x'", "line_number": 260, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.onto {X Y: Set} (f: Function X Y) : Prop := ∀ y: Y, ∃ x: X, f x = y", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 3.3.20 (Onto functions) -/"}, {"content": "abbrev A_3_3_21 := { m:ℤ // ∃ n:ℤ, m = n^2 }", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.bijective {X Y: Set} (f: Function X Y) : Prop := f.one_to_one ∧ f.onto", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.3.23 (Bijective functions) -/"}, {"content": "abbrev f_3_3_24 : Fin 3 → ({3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩\n| 2 => ⟨ 4, by norm_num ⟩", "line_number": 327, "declaration_attribute": "", "comment": "/-- Example 3.3.24 (using Mathlib) -/"}, {"content": "abbrev g_3_3_24 : Fin 2 → ({2,3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 2, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩", "line_number": 335, "declaration_attribute": "", "comment": ""}, {"content": "abbrev h_3_3_24 : Fin 3 → ({3,4,5}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 4, by norm_num ⟩\n| 2 => ⟨ 5, by norm_num ⟩", "line_number": 342, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inverse {X Y: Set} (f: Function X Y) (h: f.bijective) :\n    Function Y X :=\n  Function.mk (fun y x ↦ f x = y) (by\n    intros\n    apply existsUnique_of_exists_of_unique\n    . aesop\n    intro _ _ hx hx'; simp at hx hx'\n    rw [←hx'] at hx\n    apply f.one_to_one_iff.mp h.1\n    simp [hx]\n  )", "line_number": 386, "declaration_attribute": "", "comment": "/--\n  We cannot use the notation `f⁻¹` for the inverse because in Mathlib's `Inv` class, the inverse\n  of `f` must be exactly of the same type of `f`, and `Function Y X` is a different type from\n  `Function X Y`.\n-/"}, {"content": "def Function.comp_cancel_left_without_hg : Decidable (∀ (X Y Z:Set) (f f': Function X Y) (g : Function Y Z) (heq : g ○ f = g ○ f'), f = f') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 446, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_cancel_right_without_hg : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g g': Function Y Z) (heq : g ○ f = g' ○ f), g = g') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 450, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_injective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).one_to_one), g.one_to_one) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 463, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_surjective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).onto), f.onto) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 468, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inclusion {X Y:Set} (h: X ⊆ Y) :\n    Function X Y := Function.mk_fn (fun x ↦ ⟨ x.val, h x.val x.property ⟩ )", "line_number": 495, "declaration_attribute": "", "comment": "/-- Exercise 3.3.8 -/"}, {"content": "abbrev Function.id (X:Set) : Function X X := Function.mk_fn (fun x ↦ x)", "line_number": 498, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_3", "line_number": 440, "content": "\ntheorem Function.comp_cancel_left {X Y Z:Set} {f f': Function X Y} {g : Function Y Z}\n  (heq : g ○ f = g ○ f') (hg: g.one_to_one) : f = f' := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 38, "declaration_attribute": "", "comment": ""}, {"content": "structure Function (X Y: Set) where\n  P : X → Y → Prop\n  unique : ∀ x: X, ∃! y: Y, P x y", "line_number": 45, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 3.3.1. `Function X Y` is the structure of functions from `X` to `Y`.\n  Analogous to the Mathlib type `X → Y`.\n-/"}, {"content": "noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=\n  fun x ↦ (f.unique x).choose", "line_number": 56, "declaration_attribute": "", "comment": "/--\n  Converting a Chapter 3 function `f: Function X Y` to a Mathlib function `f: X → Y`.\n  The Chapter 3 definition of a function was nonconstructive, so we have to use the\n  axiom of choice here.\n-/"}, {"content": "noncomputable instance Function.inst_coefn (X Y: Set) : CoeFun (Function X Y) (fun _ ↦ X → Y) where\n  coe := Function.to_fn", "line_number": 59, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.mk_fn {X Y: Set} (f: X → Y) : Function X Y :=\n  Function.mk (fun x y ↦ y = f x) (by simp)", "line_number": 65, "declaration_attribute": "", "comment": "/-- Converting a Mathlib function to a Chapter 3 `Function` -/"}, {"content": "abbrev P_3_3_3a : Nat → Nat → Prop := fun x y ↦ (y:ℕ) = (x:ℕ)+1", "line_number": 78, "declaration_attribute": "", "comment": "/-- Example 3.3.3.   -/"}, {"content": "abbrev SetTheory.Set.f_3_3_3a : Function Nat Nat := Function.mk P_3_3_3a P_3_3_3a_existsUnique", "line_number": 86, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3b : Nat → Nat → Prop := fun x y ↦ (y+1:ℕ) = (x:ℕ)", "line_number": 101, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3c : (Nat \\ {(0:Object)}: Set) → Nat → Prop :=\n  fun x y ↦ ((y+1:ℕ):Object) = x", "line_number": 109, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_3c : Function (Nat \\ {(0:Object)}: Set) Nat :=\n  Function.mk P_3_3_3c P_3_3_3c_existsUnique", "line_number": 125, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.coe_nonzero (n:ℕ) (h: n ≠ 0): (Nat \\ {(0:Object)}: Set) :=\n  ⟨((n:ℕ):Object), by\n    simp [SetTheory.Object.ofnat_eq',h]\n    rw [←SetTheory.Object.ofnat_eq]\n    exact Subtype.property _\n  ⟩", "line_number": 132, "declaration_attribute": "", "comment": "/-- Create a version of a non-zero `n` inside `Nat \\ {0}` for any natural number n. -/"}, {"content": "abbrev SetTheory.Set.P_3_3_5 : Nat → Nat → Prop := fun _x y ↦ y = 7", "line_number": 175, "declaration_attribute": "", "comment": "/-- Example 3.3.5. The unused variable `_x` is underscored to avoid triggering a linter. -/"}, {"content": "abbrev SetTheory.Set.f_3_3_5 : Function Nat Nat := Function.mk P_3_3_5 P_3_3_5_existsUnique", "line_number": 180, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_10a : Function Nat Nat := Function.mk_fn (fun x ↦ (x^2 + 2*x + 1:ℕ))", "line_number": 197, "declaration_attribute": "", "comment": "/--\n  Example 3.3.10 (simplified).  The second part of the example is tricky to replicate in this\n  formalism, so a Mathlib substitute is offered instead.\n-/"}, {"content": "abbrev SetTheory.Set.f_3_3_10b : Function Nat Nat := Function.mk_fn (fun x ↦ ((x+1)^2:ℕ))", "line_number": 199, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_11 (X:Set) : Function (∅:Set) X :=\n  Function.mk (fun _ _ ↦ True) (by intro ⟨ x,hx ⟩; simp at hx)", "line_number": 216, "declaration_attribute": "", "comment": "/-- Example 3.3.11 -/"}, {"content": "noncomputable abbrev Function.comp {X Y Z: Set} (g: Function Y Z) (f: Function X Y) :\n    Function X Z :=\n  Function.mk_fn (fun x ↦ g (f x))", "line_number": 222, "declaration_attribute": "", "comment": "/-- Definition 3.3.13 (Composition) -/"}, {"content": "infix:90 \"○\" => Function.comp", "line_number": 228, "declaration_attribute": "", "comment": "-- `∘` is already taken in Mathlib for the composition of Mathlib functions,\n-- so we use `○` here instead to avoid ambiguity."}, {"content": "abbrev SetTheory.Set.f_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (2*x:ℕ))", "line_number": 241, "declaration_attribute": "", "comment": "/-- Example 3.3.14 -/"}, {"content": "abbrev SetTheory.Set.g_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (x+3:ℕ))", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.one_to_one {X Y: Set} (f: Function X Y) : Prop := ∀ x x': X, x ≠ x' → f x ≠ f x'", "line_number": 260, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.onto {X Y: Set} (f: Function X Y) : Prop := ∀ y: Y, ∃ x: X, f x = y", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 3.3.20 (Onto functions) -/"}, {"content": "abbrev A_3_3_21 := { m:ℤ // ∃ n:ℤ, m = n^2 }", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.bijective {X Y: Set} (f: Function X Y) : Prop := f.one_to_one ∧ f.onto", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.3.23 (Bijective functions) -/"}, {"content": "abbrev f_3_3_24 : Fin 3 → ({3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩\n| 2 => ⟨ 4, by norm_num ⟩", "line_number": 327, "declaration_attribute": "", "comment": "/-- Example 3.3.24 (using Mathlib) -/"}, {"content": "abbrev g_3_3_24 : Fin 2 → ({2,3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 2, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩", "line_number": 335, "declaration_attribute": "", "comment": ""}, {"content": "abbrev h_3_3_24 : Fin 3 → ({3,4,5}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 4, by norm_num ⟩\n| 2 => ⟨ 5, by norm_num ⟩", "line_number": 342, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inverse {X Y: Set} (f: Function X Y) (h: f.bijective) :\n    Function Y X :=\n  Function.mk (fun y x ↦ f x = y) (by\n    intros\n    apply existsUnique_of_exists_of_unique\n    . aesop\n    intro _ _ hx hx'; simp at hx hx'\n    rw [←hx'] at hx\n    apply f.one_to_one_iff.mp h.1\n    simp [hx]\n  )", "line_number": 386, "declaration_attribute": "", "comment": "/--\n  We cannot use the notation `f⁻¹` for the inverse because in Mathlib's `Inv` class, the inverse\n  of `f` must be exactly of the same type of `f`, and `Function Y X` is a different type from\n  `Function X Y`.\n-/"}, {"content": "def Function.comp_cancel_left_without_hg : Decidable (∀ (X Y Z:Set) (f f': Function X Y) (g : Function Y Z) (heq : g ○ f = g ○ f'), f = f') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 446, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_cancel_right_without_hg : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g g': Function Y Z) (heq : g ○ f = g' ○ f), g = g') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 450, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_injective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).one_to_one), g.one_to_one) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 463, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_surjective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).onto), f.onto) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 468, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inclusion {X Y:Set} (h: X ⊆ Y) :\n    Function X Y := Function.mk_fn (fun x ↦ ⟨ x.val, h x.val x.property ⟩ )", "line_number": 495, "declaration_attribute": "", "comment": "/-- Exercise 3.3.8 -/"}, {"content": "abbrev Function.id (X:Set) : Function X X := Function.mk_fn (fun x ↦ x)", "line_number": 498, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_3", "line_number": 412, "content": "\ntheorem Function.refl {X Y:Set} (f: Function X Y) : f = f := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 38, "declaration_attribute": "", "comment": ""}, {"content": "structure Function (X Y: Set) where\n  P : X → Y → Prop\n  unique : ∀ x: X, ∃! y: Y, P x y", "line_number": 45, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 3.3.1. `Function X Y` is the structure of functions from `X` to `Y`.\n  Analogous to the Mathlib type `X → Y`.\n-/"}, {"content": "noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=\n  fun x ↦ (f.unique x).choose", "line_number": 56, "declaration_attribute": "", "comment": "/--\n  Converting a Chapter 3 function `f: Function X Y` to a Mathlib function `f: X → Y`.\n  The Chapter 3 definition of a function was nonconstructive, so we have to use the\n  axiom of choice here.\n-/"}, {"content": "noncomputable instance Function.inst_coefn (X Y: Set) : CoeFun (Function X Y) (fun _ ↦ X → Y) where\n  coe := Function.to_fn", "line_number": 59, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.mk_fn {X Y: Set} (f: X → Y) : Function X Y :=\n  Function.mk (fun x y ↦ y = f x) (by simp)", "line_number": 65, "declaration_attribute": "", "comment": "/-- Converting a Mathlib function to a Chapter 3 `Function` -/"}, {"content": "abbrev P_3_3_3a : Nat → Nat → Prop := fun x y ↦ (y:ℕ) = (x:ℕ)+1", "line_number": 78, "declaration_attribute": "", "comment": "/-- Example 3.3.3.   -/"}, {"content": "abbrev SetTheory.Set.f_3_3_3a : Function Nat Nat := Function.mk P_3_3_3a P_3_3_3a_existsUnique", "line_number": 86, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3b : Nat → Nat → Prop := fun x y ↦ (y+1:ℕ) = (x:ℕ)", "line_number": 101, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3c : (Nat \\ {(0:Object)}: Set) → Nat → Prop :=\n  fun x y ↦ ((y+1:ℕ):Object) = x", "line_number": 109, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_3c : Function (Nat \\ {(0:Object)}: Set) Nat :=\n  Function.mk P_3_3_3c P_3_3_3c_existsUnique", "line_number": 125, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.coe_nonzero (n:ℕ) (h: n ≠ 0): (Nat \\ {(0:Object)}: Set) :=\n  ⟨((n:ℕ):Object), by\n    simp [SetTheory.Object.ofnat_eq',h]\n    rw [←SetTheory.Object.ofnat_eq]\n    exact Subtype.property _\n  ⟩", "line_number": 132, "declaration_attribute": "", "comment": "/-- Create a version of a non-zero `n` inside `Nat \\ {0}` for any natural number n. -/"}, {"content": "abbrev SetTheory.Set.P_3_3_5 : Nat → Nat → Prop := fun _x y ↦ y = 7", "line_number": 175, "declaration_attribute": "", "comment": "/-- Example 3.3.5. The unused variable `_x` is underscored to avoid triggering a linter. -/"}, {"content": "abbrev SetTheory.Set.f_3_3_5 : Function Nat Nat := Function.mk P_3_3_5 P_3_3_5_existsUnique", "line_number": 180, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_10a : Function Nat Nat := Function.mk_fn (fun x ↦ (x^2 + 2*x + 1:ℕ))", "line_number": 197, "declaration_attribute": "", "comment": "/--\n  Example 3.3.10 (simplified).  The second part of the example is tricky to replicate in this\n  formalism, so a Mathlib substitute is offered instead.\n-/"}, {"content": "abbrev SetTheory.Set.f_3_3_10b : Function Nat Nat := Function.mk_fn (fun x ↦ ((x+1)^2:ℕ))", "line_number": 199, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_11 (X:Set) : Function (∅:Set) X :=\n  Function.mk (fun _ _ ↦ True) (by intro ⟨ x,hx ⟩; simp at hx)", "line_number": 216, "declaration_attribute": "", "comment": "/-- Example 3.3.11 -/"}, {"content": "noncomputable abbrev Function.comp {X Y Z: Set} (g: Function Y Z) (f: Function X Y) :\n    Function X Z :=\n  Function.mk_fn (fun x ↦ g (f x))", "line_number": 222, "declaration_attribute": "", "comment": "/-- Definition 3.3.13 (Composition) -/"}, {"content": "infix:90 \"○\" => Function.comp", "line_number": 228, "declaration_attribute": "", "comment": "-- `∘` is already taken in Mathlib for the composition of Mathlib functions,\n-- so we use `○` here instead to avoid ambiguity."}, {"content": "abbrev SetTheory.Set.f_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (2*x:ℕ))", "line_number": 241, "declaration_attribute": "", "comment": "/-- Example 3.3.14 -/"}, {"content": "abbrev SetTheory.Set.g_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (x+3:ℕ))", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.one_to_one {X Y: Set} (f: Function X Y) : Prop := ∀ x x': X, x ≠ x' → f x ≠ f x'", "line_number": 260, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.onto {X Y: Set} (f: Function X Y) : Prop := ∀ y: Y, ∃ x: X, f x = y", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 3.3.20 (Onto functions) -/"}, {"content": "abbrev A_3_3_21 := { m:ℤ // ∃ n:ℤ, m = n^2 }", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.bijective {X Y: Set} (f: Function X Y) : Prop := f.one_to_one ∧ f.onto", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.3.23 (Bijective functions) -/"}, {"content": "abbrev f_3_3_24 : Fin 3 → ({3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩\n| 2 => ⟨ 4, by norm_num ⟩", "line_number": 327, "declaration_attribute": "", "comment": "/-- Example 3.3.24 (using Mathlib) -/"}, {"content": "abbrev g_3_3_24 : Fin 2 → ({2,3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 2, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩", "line_number": 335, "declaration_attribute": "", "comment": ""}, {"content": "abbrev h_3_3_24 : Fin 3 → ({3,4,5}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 4, by norm_num ⟩\n| 2 => ⟨ 5, by norm_num ⟩", "line_number": 342, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inverse {X Y: Set} (f: Function X Y) (h: f.bijective) :\n    Function Y X :=\n  Function.mk (fun y x ↦ f x = y) (by\n    intros\n    apply existsUnique_of_exists_of_unique\n    . aesop\n    intro _ _ hx hx'; simp at hx hx'\n    rw [←hx'] at hx\n    apply f.one_to_one_iff.mp h.1\n    simp [hx]\n  )", "line_number": 386, "declaration_attribute": "", "comment": "/--\n  We cannot use the notation `f⁻¹` for the inverse because in Mathlib's `Inv` class, the inverse\n  of `f` must be exactly of the same type of `f`, and `Function Y X` is a different type from\n  `Function X Y`.\n-/"}, {"content": "def Function.comp_cancel_left_without_hg : Decidable (∀ (X Y Z:Set) (f f': Function X Y) (g : Function Y Z) (heq : g ○ f = g ○ f'), f = f') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 446, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_cancel_right_without_hg : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g g': Function Y Z) (heq : g ○ f = g' ○ f), g = g') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 450, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_injective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).one_to_one), g.one_to_one) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 463, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_surjective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).onto), f.onto) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 468, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inclusion {X Y:Set} (h: X ⊆ Y) :\n    Function X Y := Function.mk_fn (fun x ↦ ⟨ x.val, h x.val x.property ⟩ )", "line_number": 495, "declaration_attribute": "", "comment": "/-- Exercise 3.3.8 -/"}, {"content": "abbrev Function.id (X:Set) : Function X X := Function.mk_fn (fun x ↦ x)", "line_number": 498, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_3", "line_number": 474, "content": "\ntheorem Function.inverse_comp_self {X Y: Set} {f: Function X Y} (h: f.bijective) (x: X) :\n    (f.inverse h) (f x) = x := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 38, "declaration_attribute": "", "comment": ""}, {"content": "structure Function (X Y: Set) where\n  P : X → Y → Prop\n  unique : ∀ x: X, ∃! y: Y, P x y", "line_number": 45, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 3.3.1. `Function X Y` is the structure of functions from `X` to `Y`.\n  Analogous to the Mathlib type `X → Y`.\n-/"}, {"content": "noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=\n  fun x ↦ (f.unique x).choose", "line_number": 56, "declaration_attribute": "", "comment": "/--\n  Converting a Chapter 3 function `f: Function X Y` to a Mathlib function `f: X → Y`.\n  The Chapter 3 definition of a function was nonconstructive, so we have to use the\n  axiom of choice here.\n-/"}, {"content": "noncomputable instance Function.inst_coefn (X Y: Set) : CoeFun (Function X Y) (fun _ ↦ X → Y) where\n  coe := Function.to_fn", "line_number": 59, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.mk_fn {X Y: Set} (f: X → Y) : Function X Y :=\n  Function.mk (fun x y ↦ y = f x) (by simp)", "line_number": 65, "declaration_attribute": "", "comment": "/-- Converting a Mathlib function to a Chapter 3 `Function` -/"}, {"content": "abbrev P_3_3_3a : Nat → Nat → Prop := fun x y ↦ (y:ℕ) = (x:ℕ)+1", "line_number": 78, "declaration_attribute": "", "comment": "/-- Example 3.3.3.   -/"}, {"content": "abbrev SetTheory.Set.f_3_3_3a : Function Nat Nat := Function.mk P_3_3_3a P_3_3_3a_existsUnique", "line_number": 86, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3b : Nat → Nat → Prop := fun x y ↦ (y+1:ℕ) = (x:ℕ)", "line_number": 101, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.P_3_3_3c : (Nat \\ {(0:Object)}: Set) → Nat → Prop :=\n  fun x y ↦ ((y+1:ℕ):Object) = x", "line_number": 109, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_3c : Function (Nat \\ {(0:Object)}: Set) Nat :=\n  Function.mk P_3_3_3c P_3_3_3c_existsUnique", "line_number": 125, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.coe_nonzero (n:ℕ) (h: n ≠ 0): (Nat \\ {(0:Object)}: Set) :=\n  ⟨((n:ℕ):Object), by\n    simp [SetTheory.Object.ofnat_eq',h]\n    rw [←SetTheory.Object.ofnat_eq]\n    exact Subtype.property _\n  ⟩", "line_number": 132, "declaration_attribute": "", "comment": "/-- Create a version of a non-zero `n` inside `Nat \\ {0}` for any natural number n. -/"}, {"content": "abbrev SetTheory.Set.P_3_3_5 : Nat → Nat → Prop := fun _x y ↦ y = 7", "line_number": 175, "declaration_attribute": "", "comment": "/-- Example 3.3.5. The unused variable `_x` is underscored to avoid triggering a linter. -/"}, {"content": "abbrev SetTheory.Set.f_3_3_5 : Function Nat Nat := Function.mk P_3_3_5 P_3_3_5_existsUnique", "line_number": 180, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_10a : Function Nat Nat := Function.mk_fn (fun x ↦ (x^2 + 2*x + 1:ℕ))", "line_number": 197, "declaration_attribute": "", "comment": "/--\n  Example 3.3.10 (simplified).  The second part of the example is tricky to replicate in this\n  formalism, so a Mathlib substitute is offered instead.\n-/"}, {"content": "abbrev SetTheory.Set.f_3_3_10b : Function Nat Nat := Function.mk_fn (fun x ↦ ((x+1)^2:ℕ))", "line_number": 199, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.f_3_3_11 (X:Set) : Function (∅:Set) X :=\n  Function.mk (fun _ _ ↦ True) (by intro ⟨ x,hx ⟩; simp at hx)", "line_number": 216, "declaration_attribute": "", "comment": "/-- Example 3.3.11 -/"}, {"content": "noncomputable abbrev Function.comp {X Y Z: Set} (g: Function Y Z) (f: Function X Y) :\n    Function X Z :=\n  Function.mk_fn (fun x ↦ g (f x))", "line_number": 222, "declaration_attribute": "", "comment": "/-- Definition 3.3.13 (Composition) -/"}, {"content": "infix:90 \"○\" => Function.comp", "line_number": 228, "declaration_attribute": "", "comment": "-- `∘` is already taken in Mathlib for the composition of Mathlib functions,\n-- so we use `○` here instead to avoid ambiguity."}, {"content": "abbrev SetTheory.Set.f_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (2*x:ℕ))", "line_number": 241, "declaration_attribute": "", "comment": "/-- Example 3.3.14 -/"}, {"content": "abbrev SetTheory.Set.g_3_3_14 : Function Nat Nat := Function.mk_fn (fun x ↦ (x+3:ℕ))", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.one_to_one {X Y: Set} (f: Function X Y) : Prop := ∀ x x': X, x ≠ x' → f x ≠ f x'", "line_number": 260, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.onto {X Y: Set} (f: Function X Y) : Prop := ∀ y: Y, ∃ x: X, f x = y", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 3.3.20 (Onto functions) -/"}, {"content": "abbrev A_3_3_21 := { m:ℤ // ∃ n:ℤ, m = n^2 }", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.bijective {X Y: Set} (f: Function X Y) : Prop := f.one_to_one ∧ f.onto", "line_number": 319, "declaration_attribute": "", "comment": "/-- Definition 3.3.23 (Bijective functions) -/"}, {"content": "abbrev f_3_3_24 : Fin 3 → ({3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩\n| 2 => ⟨ 4, by norm_num ⟩", "line_number": 327, "declaration_attribute": "", "comment": "/-- Example 3.3.24 (using Mathlib) -/"}, {"content": "abbrev g_3_3_24 : Fin 2 → ({2,3,4}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 2, by norm_num ⟩\n| 1 => ⟨ 3, by norm_num ⟩", "line_number": 335, "declaration_attribute": "", "comment": ""}, {"content": "abbrev h_3_3_24 : Fin 3 → ({3,4,5}:_root_.Set ℕ) := fun x ↦ match x with\n| 0 => ⟨ 3, by norm_num ⟩\n| 1 => ⟨ 4, by norm_num ⟩\n| 2 => ⟨ 5, by norm_num ⟩", "line_number": 342, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inverse {X Y: Set} (f: Function X Y) (h: f.bijective) :\n    Function Y X :=\n  Function.mk (fun y x ↦ f x = y) (by\n    intros\n    apply existsUnique_of_exists_of_unique\n    . aesop\n    intro _ _ hx hx'; simp at hx hx'\n    rw [←hx'] at hx\n    apply f.one_to_one_iff.mp h.1\n    simp [hx]\n  )", "line_number": 386, "declaration_attribute": "", "comment": "/--\n  We cannot use the notation `f⁻¹` for the inverse because in Mathlib's `Inv` class, the inverse\n  of `f` must be exactly of the same type of `f`, and `Function Y X` is a different type from\n  `Function X Y`.\n-/"}, {"content": "def Function.comp_cancel_left_without_hg : Decidable (∀ (X Y Z:Set) (f f': Function X Y) (g : Function Y Z) (heq : g ○ f = g ○ f'), f = f') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 446, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_cancel_right_without_hg : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g g': Function Y Z) (heq : g ○ f = g' ○ f), g = g') := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 450, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_injective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).one_to_one), g.one_to_one) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 463, "declaration_attribute": "", "comment": ""}, {"content": "def Function.comp_surjective' : Decidable (∀ (X Y Z:Set) (f: Function X Y) (g : Function Y Z) (hinj :\n    (g ○ f).onto), f.onto) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 468, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Function.inclusion {X Y:Set} (h: X ⊆ Y) :\n    Function X Y := Function.mk_fn (fun x ↦ ⟨ x.val, h x.val x.property ⟩ )", "line_number": 495, "declaration_attribute": "", "comment": "/-- Exercise 3.3.8 -/"}, {"content": "abbrev Function.id (X:Set) : Function X X := Function.mk_fn (fun x ↦ x)", "line_number": 498, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 372, "content": "\ntheorem SetTheory.Set.union_of_nonempty {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) : I ∪ J ≠ ∅ := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 335, "content": "\ntheorem SetTheory.Set.preimage_image_of_inj {X Y:Set} (f:X → Y) :\n    (∀ S, S ⊆ X → preimage f (image f S) = S) ↔ Function.Injective f := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 358, "content": "\ntheorem SetTheory.Set.union_pair_exists (X Y:Set) : ∃ Z:Set, ∀ x, x ∈ Z ↔ (x ∈ X ∨ x ∈ Y) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 362, "content": "\ntheorem SetTheory.Set.iInter'_insensitive {I:Set} (β β':I) (A: I → Set) :\n    iInter' I β A = iInter' I β' A := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 285, "content": "\ntheorem SetTheory.Set.preimage_eq_image_of_inv {X Y V:Set} (f:X → Y) (f_inv: Y → X)\n  (hf: Function.LeftInverse f_inv f ∧ Function.RightInverse f_inv f) (hV: V ⊆ Y) :\n    image f_inv V = preimage f V := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 385, "content": "\ntheorem SetTheory.Set.compl_iInter {X I: Set} (hI: I ≠ ∅) (A: I → Set) :\n    X \\ iInter I hI A = iUnion I (fun α ↦ X \\ A α) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 189, "content": "@[simp]\ntheorem SetTheory.Set.mem_powerset {X:Set} (x:Object) :\n    x ∈ powerset X ↔ ∃ Y:Set, x = Y ∧ Y ⊆ X := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 331, "content": "\ntheorem SetTheory.Set.image_preimage_of_surj {X Y:Set} (f:X → Y) :\n    (∀ S, S ⊆ Y → image f (preimage f S) = S) ↔ Function.Surjective f := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 350, "content": "\ntheorem SetTheory.Set.partial_functions {X Y:Set} :\n    ∃ Z:Set, ∀ F:Object, F ∈ Z ↔ ∃ X' Y':Set, X' ⊆ X ∧ Y' ⊆ Y ∧ ∃ f: X' → Y', F = f := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 375, "content": "\ntheorem SetTheory.Set.inter_iInter {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) (A: (I ∪ J:Set) → Set) :\n    iInter I hI (fun α ↦ A ⟨ α.val, by simp [α.property]⟩)\n    ∩ iInter J hJ (fun α ↦ A ⟨ α.val, by simp [α.property]⟩)\n    = iInter (I ∪ J) (union_of_nonempty hI hJ) A := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_4", "line_number": 321, "content": "\ntheorem SetTheory.Set.preimage_of_inter {X Y:Set} (f:X → Y) (A B: Set) :\n    preimage f (A ∩ B) = (preimage f A) ∩ (preimage f B) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=\n  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/"}, {"content": "abbrev f_3_4_2 : nat → nat := fun n ↦ (2*n:ℕ)", "line_number": 56, "declaration_attribute": "", "comment": "/-- Example 3.4.2 -/"}, {"content": "abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set := X.specify (P := fun x ↦ (f x).val ∈ U)", "line_number": 81, "declaration_attribute": "", "comment": "/--\n  Definition 3.4.4 (inverse images).\n  Again, it is not required that U be a subset of Y.\n-/"}, {"content": "instance SetTheory.Set.inst_pow : Pow Set Set where\n  pow := SetTheory.pow", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object := function_to_object X Y f", "line_number": 138, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where\n  coe := coe_of_fun", "line_number": 143, "declaration_attribute": "", "comment": "/-- This coercion has to be a `CoeOut` rather than a\n`Coe` because the input type `X → Y` contains\nparameters not present in the output type `Output` -/"}, {"content": "abbrev f_3_4_9_a : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 0, by simp ⟩", "line_number": 156, "declaration_attribute": "", "comment": "/-- Example 3.4.9 -/"}, {"content": "noncomputable abbrev f_3_4_9_b : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 0, by simp ⟩ else ⟨ 1, by simp ⟩", "line_number": 159, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_3_4_9_c : ({4,7}:Set) → ({0,1}:Set) :=\n  fun x ↦ if x.val = 4 then ⟨ 1, by simp ⟩ else ⟨ 0, by simp ⟩", "line_number": 163, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_3_4_9_d : ({4,7}:Set) → ({0,1}:Set) := fun x ↦ ⟨ 1, by simp ⟩", "line_number": 166, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.powerset (X:Set) : Set :=\n  (({0,1} ^ X): Set).replace (P := sorry) (by sorry)", "line_number": 183, "declaration_attribute": "", "comment": "/-- Exercise 3.4.6 (i). One needs to provide a suitable definition of the power set here. -/"}, {"content": "abbrev SetTheory.Set.iUnion (I: Set) (A: I → Set) : Set :=\n  union (I.replace (P := fun α S ↦ S = A α) (by intro x y y' ⟨ h1, h2⟩; simp at h1 h2; rw [h1,h2]))", "line_number": 239, "declaration_attribute": "", "comment": "/-- Indexed union -/"}, {"content": "noncomputable abbrev SetTheory.Set.index_example : ({1,2,3}:Set) → Set :=\n  fun i ↦ if i.val = 1 then {2,3} else if i.val = 2 then {3,4} else {4,5}", "line_number": 250, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=\n  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩", "line_number": 271, "declaration_attribute": "", "comment": "/-- Indexed intersection -/"}, {"content": "abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=\n  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)", "line_number": 274, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=\n  iInter' I (nonempty_choose hI) A", "line_number": 277, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_inter' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A ∩ B) = (image f A) ∩ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 312, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.image_of_diff' : Decidable (∀ X Y:Set, ∀ f:X → Y, ∀ A B: Set, image f (A \\ B) = (image f A) \\ (image f B)) := by\n  -- The first line of this construction should be either `apply isTrue` or `apply isFalse`\n  sorry", "line_number": 316, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 460, "content": "\ntheorem SetTheory.Set.recursion (X: Type) (f: nat → X → X) (c:X) :\n    ∃! a: nat → X, a 0 = c ∧ ∀ n, a (n + 1:ℕ) = f n (a n) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 464, "content": "\ntheorem SetTheory.Set.nat_unique (nat':Set) (zero:nat') (succ:nat' → nat')\n  (succ_ne: ∀ n:nat', succ n ≠ zero) (succ_of_ne: ∀ n m:nat', n ≠ m → succ n ≠ succ m)\n  (ind: ∀ P: nat' → Prop, P zero → (∀ n, P n → P (succ n)) → ∀ n, P n) :\n    ∃! f : nat → nat', Function.Bijective f ∧ f 0 = zero\n    ∧ ∀ (n:nat) (n':nat'), f n = n' ↔ f (n+1:ℕ) = succ n' := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 398, "content": "\ntheorem SetTheory.Set.diff_prod (A B C:Set) : (A \\ B) ×ˢ C = (A ×ˢ C) \\ (B ×ˢ C) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 419, "content": "\ntheorem SetTheory.Set.prod_subset_prod {A B C D:Set}\n  (hA: A ≠ ∅) (hB: B ≠ ∅) (hC: C ≠ ∅) (hD: D ≠ ∅) :\n    A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 352, "content": "\ntheorem SetTheory.Set.Tuple.eq {n:ℕ} (t t':Tuple n) :\n    t = t' ↔ ∀ n : Fin n, ((t.x n):Object) = ((t'.x n):Object) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 392, "content": "\ntheorem SetTheory.Set.union_prod (A B C:Set) : (A ∪ B) ×ˢ C = (A ×ˢ C) ∪ (B ×ˢ C) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 395, "content": "\ntheorem SetTheory.Set.inter_prod (A B C:Set) : (A ∩ B) ×ˢ C = (A ×ˢ C) ∩ (B ×ˢ C) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 445, "content": "\ntheorem SetTheory.Set.graph_inj {X Y:Set} (f f': X → Y) :\n    graph f = graph f' ↔ f = f' := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 383, "content": "\ntheorem SetTheory.Set.prod_union (A B C:Set) : A ×ˢ (B ∪ C) = (A ×ˢ B) ∪ (A ×ˢ C) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 386, "content": "\ntheorem SetTheory.Set.prod_inter (A B C:Set) : A ×ˢ (B ∩ C) = (A ×ˢ B) ∩ (A ×ˢ C) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 389, "content": "\ntheorem SetTheory.Set.prod_diff (A B C:Set) : A ×ˢ (B \\ C) = (A ×ˢ B) \\ (A ×ˢ C) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_5", "line_number": 429, "content": "\ntheorem SetTheory.Set.direct_sum {X Y Z:Set} (f: Z → X) (g: Z → Y) :\n    ∃! h: Z → X ×ˢ Y, fst ∘ h = f ∧ snd ∘ h = g := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "structure OrderedPair where\n  fst: Object\n  snd: Object", "line_number": 35, "declaration_attribute": "@[ext]", "comment": "/-- Definition 3.5.1 (Ordered pair).  One could also have used `Object × Object` to\ndefine `OrderedPair` here. -/"}, {"content": "def OrderedPair.toObject : OrderedPair ↪ Object where\n  toFun p := ({ (({p.fst}:Set):Object), (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 52, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, first part -/"}, {"content": "instance OrderedPair.inst_coeObject : Coe OrderedPair Object where\n  coe := OrderedPair.toObject", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.slice (x:Object) (Y:Set) : Set :=\n  Y.replace (P := fun y z ↦ z = (⟨x, y⟩:OrderedPair)) (by intros; simp_all)", "line_number": 63, "declaration_attribute": "", "comment": "/--\n  A technical operation, turning a object `x` and a set `Y` to a set `{x} × Y`, needed to define\n  the full Cartesian product\n-/"}, {"content": "abbrev SetTheory.Set.cartesian (X Y:Set) : Set :=\n  union (X.replace (P := fun x z ↦ z = slice x Y) (by intros; simp_all))", "line_number": 71, "declaration_attribute": "", "comment": "/-- Definition 3.5.4 (Cartesian product) -/"}, {"content": "instance SetTheory.Set.inst_SProd : SProd Set Set Set where\n  sprod := cartesian", "line_number": 75, "declaration_attribute": "", "comment": "/-- This instance enables the ×ˢ notation for Cartesian product. -/"}, {"content": "noncomputable abbrev SetTheory.Set.fst {X Y:Set} (z:X ×ˢ Y) : X :=\n  ((mem_cartesian _ _ _).mp z.property).choose", "line_number": 89, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.snd {X Y:Set} (z:X ×ˢ Y) : Y :=\n  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose", "line_number": 92, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.mk_cartesian {X Y:Set} (x:X) (y:Y) : X ×ˢ Y :=\n  ⟨(⟨ x, y ⟩:OrderedPair), by simp⟩", "line_number": 103, "declaration_attribute": "", "comment": "/-- This equips an `OrderedPair` with proofs that `x ∈ X` and `y ∈ Y`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_equiv_prod (X Y:Set) :\n    ((X ×ˢ Y):_root_.Set Object) ≃ (X:_root_.Set Object) ×ˢ (Y:_root_.Set Object) where\n  toFun := fun z ↦ ⟨(fst z, snd z), by simp⟩\n  invFun := fun z ↦ mk_cartesian ⟨z.val.1, z.prop.1⟩ ⟨z.val.2, z.prop.2⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 130, "declaration_attribute": "", "comment": "/--\n  Connections with the Mathlib set product, which consists of Lean pairs like `(x, y)`\n  equipped with a proof that `x` is in the left set, and `y` is in the right set.\n  Lean pairs like `(x, y)` are similar to our `OrderedPair`, but more general.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_commutator (X Y:Set) : X ×ˢ Y ≃ Y ×ˢ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 148, "declaration_attribute": "", "comment": "/-- Example 3.5.5 / Exercise 3.6.5. There is a bijection between `X ×ˢ Y` and `Y ×ˢ X`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.curry_equiv {X Y Z:Set} : (X → Y → Z) ≃ (X ×ˢ Y → Z) where\n  toFun := fun f z ↦ f (fst z) (snd z)\n  invFun := fun f x y ↦ f ⟨ (⟨ x, y ⟩:OrderedPair), by simp ⟩\n  left_inv := by intro; simp\n  right_inv := by intro; simp [←pair_eq_fst_snd]", "line_number": 155, "declaration_attribute": "", "comment": "/-- Example 3.5.5. A function of two variables can be thought of as a function of a pair. -/"}, {"content": "abbrev SetTheory.Set.tuple {I:Set} {X: I → Set} (x: ∀ i, X i) : Object :=\n  ((fun i ↦ ⟨ x i, by rw [mem_iUnion]; use i; exact (x i).property ⟩):I → iUnion I X)", "line_number": 164, "declaration_attribute": "", "comment": "/-- Definition 3.5.6.  The indexing set `I` plays the role of `{ i : 1 ≤ i ≤ n }` in the text.\n    See Exercise 3.5.10 below for some connections betweeen this concept and the preceding notion\n    of Cartesian product and ordered pair.  -/"}, {"content": "abbrev SetTheory.Set.iProd {I: Set} (X: I → Set) : Set :=\n  ((iUnion I X)^I).specify (fun t ↦ ∃ x : ∀ i, X i, t = tuple x)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 3.5.6 -/"}, {"content": "noncomputable abbrev SetTheory.Set.prod_associator (X Y Z:Set) : (X ×ˢ Y) ×ˢ Z ≃ X ×ˢ (Y ×ˢ Z) where\n  toFun := fun p ↦ mk_cartesian (fst (fst p)) (mk_cartesian (snd (fst p)) (snd p))\n  invFun := fun p ↦ mk_cartesian (mk_cartesian (fst p) (fst (snd p))) (snd (snd p))\n  left_inv := by intro; simp\n  right_inv := by intro; simp", "line_number": 188, "declaration_attribute": "", "comment": "/-- Example 3.5.8. There is a bijection between `(X ×ˢ Y) ×ˢ Z` and `X ×ˢ (Y ×ˢ Z)`. -/"}, {"content": "noncomputable abbrev SetTheory.Set.singleton_iProd_equiv (i:Object) (X:Set) :\n    iProd (fun _:({i}:Set) ↦ X) ≃ X where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 198, "declaration_attribute": "", "comment": "/--\n  Example 3.5.10. I suspect most of the equivalences will require classical reasoning and only be\n  defined non-computably, but would be happy to learn of counterexamples.\n-/"}, {"content": "noncomputable abbrev SetTheory.Set.empty_iProd_equiv (X: (∅:Set) → Set) : iProd X ≃ Unit where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 206, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_of_const_equiv (I:Set) (X: Set) :\n    iProd (fun i:I ↦ X) ≃ (I → X) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 213, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod (X: ({0,1}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 221, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_prod_triple (X: ({0,1,2}:Set) → Set) :\n    iProd X ≃ (X ⟨ 0, by simp ⟩) ×ˢ (X ⟨ 1, by simp ⟩) ×ˢ (X ⟨ 2, by simp ⟩) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 229, "declaration_attribute": "", "comment": "/-- Example 3.5.10 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_pi (I:Set) (X: I → Set) :\n    iProd X ≃ Set.pi .univ (fun i:I ↦ ((X i):_root_.Set Object)) where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 237, "declaration_attribute": "", "comment": "/-- Connections with Mathlib's `Set.pi` -/"}, {"content": "abbrev SetTheory.Set.Fin (n:ℕ) : Set := nat.specify (fun m ↦ (m:ℕ) < n)", "line_number": 254, "declaration_attribute": "", "comment": "/--\n  Here we set up some an analogue of Mathlib `Fin n` types within the Chapter 3 Set Theory,\n  with rudimentary API.\n-/"}, {"content": "abbrev SetTheory.Set.Fin_mk (n m:ℕ) (h: m < n): Fin n := ⟨ m, by rw [mem_Fin]; use m ⟩", "line_number": 266, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin.toNat {n:ℕ} (i: Fin n) : ℕ := (mem_Fin' i).choose", "line_number": 273, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "noncomputable instance SetTheory.Set.Fin.inst_coeNat {n:ℕ} : CoeOut (Fin n) ℕ where\n  coe := SetTheory.Set.Fin.toNat", "line_number": 275, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.Fin_embed (n N:ℕ) (h: n ≤ N) (i: Fin n) : Fin N := ⟨ i.val, by\n  have := i.property; rw [mem_Fin] at this ⊢\n  obtain ⟨ m, hm, im ⟩ := this; use m, by linarith\n⟩", "line_number": 292, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.Fin_equiv_Fin (n:ℕ) : Fin n ≃ _root_.Fin n where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 301, "declaration_attribute": "", "comment": "/--\n  I suspect that this equivalence is non-computable and requires classical logic,\n  unless there is a clever trick.\n-/"}, {"content": "abbrev OrderedPair.toObject' : OrderedPair ↪ Object where\n  toFun p := ({ p.fst, (({p.fst, p.snd}:Set):Object) }:Set)\n  inj' := by sorry", "line_number": 340, "declaration_attribute": "", "comment": "/-- Exercise 3.5.1, second part (requires axiom of regularity) -/"}, {"content": "structure SetTheory.Set.Tuple (n:ℕ) where\n  X: Set\n  x: SetTheory.Set.Fin n → X\n  surj: Function.Surjective x", "line_number": 346, "declaration_attribute": "@[ext]", "comment": "/-- An alternate definition of a tuple, used in Exercise 3.5.2 -/"}, {"content": "noncomputable abbrev SetTheory.Set.iProd_equiv_tuples (n:ℕ) (X: Fin n → Set) :\n    iProd X ≃ { t:Tuple n // ∀ i, (t.x i:Object) ∈ X i } where\n  toFun := sorry\n  invFun := sorry\n  left_inv := sorry\n  right_inv := sorry", "line_number": 355, "declaration_attribute": "", "comment": ""}, {"content": "def SetTheory.Set.union_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) ∪ (C ×ˢ D) = (A ∪ C) ×ˢ (B ∪ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 405, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.diff_of_prod :\n  Decidable (∀ (A B C D:Set), (A ×ˢ B) \\ (C ×ˢ D) = (A \\ C) ×ˢ (B \\ D)) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 411, "declaration_attribute": "", "comment": "/- Exercise 3.5.5 -/"}, {"content": "def SetTheory.Set.prod_subset_prod' :\n  Decidable (∀ (A B C D:Set), A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D) := by\n  -- the first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 423, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.graph {X Y:Set} (f: X → Y) : Set :=\n  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))", "line_number": 441, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_3_6", "line_number": 228, "content": "\ntheorem SetTheory.Set.prod_EqualCard_prod (A B:Set) :\n    EqualCard (A ×ˢ B) (B ×ˢ A) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 255, "content": "\ntheorem SetTheory.Set.pigeonhole_principle {n:ℕ} {A: Fin n → Set}\n  (hA: ∀ i, (A i).finite) (hAcard: (iUnion _ A).card > n) : ∃ i, (A i).card ≥ 2 := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 86, "content": "\ntheorem SetTheory.Set.has_card_zero {X:Set} : X.has_card 0 ↔ X = ∅ := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 251, "content": "\ntheorem SetTheory.Set.card_union_add_card_inter {A B:Set} (hA: A.finite) (hB: B.finite) :\n    A.card + B.card = (A ∪ B).card + (A ∩ B).card := by  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 37, "content": "\ntheorem SetTheory.Set.Example_3_6_3 : EqualCard nat (nat.specify (fun x ↦ Even (x:ℕ))) := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 270, "content": "\ntheorem SetTheory.Set.Permutations_ih (n: ℕ):\n    (Permutations (n + 1)).card = (n + 1) * (Permutations n).card := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 62, "content": "\ntheorem SetTheory.Set.Example_3_6_7a (a:Object) : ({a}:Set).has_card 1 := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 137, "content": "\ntheorem SetTheory.Set.bounded_on_finite {n:ℕ} (f: Fin n → nat) : ∃ M, ∀ i, (f i:ℕ) ≤ M := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 224, "content": "\ntheorem SetTheory.Set.card_eq_zero_of_empty {X:Set} (hX: X.finite) :\n    X.card = 0 ↔ X = ∅ := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 259, "content": "\ntheorem SetTheory.Set.two_to_two_iff {X Y:Set} (f: X → Y): Function.Injective f ↔\n    ∀ S ⊆ X, S.card = 2 → (image f S).card = 2 := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_3_6", "line_number": 232, "content": "\ntheorem SetTheory.Set.pow_pow_EqualCard_pow_prod (A B C:Set) :\n    EqualCard ((A ^ B) ^ C) (A ^ (B ×ˢ C)) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable [SetTheory]", "line_number": 28, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f", "line_number": 31, "declaration_attribute": "", "comment": "/-- Definition 3.6.1 (Equal cardinality) -/"}, {"content": "instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set := ⟨ EqualCard, {refl, symm, trans} ⟩", "line_number": 52, "declaration_attribute": "", "comment": "/-- Proposition 3.6.4 / Exercise 3.6.1 -/"}, {"content": "abbrev SetTheory.Set.has_card (X:Set) (n:ℕ) : Prop := X ≈ Fin n", "line_number": 55, "declaration_attribute": "", "comment": "/-- Definition 3.6.5 -/"}, {"content": "abbrev SetTheory.Set.finite (X:Set) : Prop := ∃ n:ℕ, X.has_card n", "line_number": 132, "declaration_attribute": "", "comment": ""}, {"content": "abbrev SetTheory.Set.infinite (X:Set) : Prop := ¬ finite X", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev SetTheory.Set.card (X:Set) : ℕ := if h:X.finite then h.choose else 0", "line_number": 151, "declaration_attribute": "", "comment": "/-- It is convenient for Lean purposes to give infinite sets the ``junk`` cardinality of zero. -/"}, {"content": "def SetTheory.Set.Permutations (n: ℕ): Set := (Fin n ^ Fin n).specify (fun F ↦\n    Function.Bijective ((powerset_axiom F).mp F.prop).choose)", "line_number": 263, "declaration_attribute": "", "comment": "/-- Exercise 3.6.12 -/"}]}
{"chapter_name": "Section_4_1", "line_number": 306, "content": "\ntheorem Int.sq_nonneg (n:Int) : 0 ≤ n*n := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "structure PreInt where\n  minuend : ℕ\n  subtrahend : ℕ", "line_number": 27, "declaration_attribute": "", "comment": ""}, {"content": "instance PreInt.instSetoid : Setoid PreInt where\n  r a b := a.minuend + b.subtrahend = b.minuend + a.subtrahend\n  iseqv := {\n    refl := by sorry\n    symm := by sorry\n    trans := by\n      -- This proof is written to follow the structure of the original text.\n      intro ⟨ a,b ⟩ ⟨ c,d ⟩ ⟨ e,f ⟩ h1 h2; simp at h1 h2 ⊢\n      have h3 := congrArg₂ (· + ·) h1 h2; simp at h3\n      have : (a + f) + (c + d) = (e + b) + (c + d) := calc\n        (a + f) + (c + d) = a + d + (c + f) := by abel\n        _ = c + b + (e + d) := h3\n        _ = (e + b) + (c + d) := by abel\n      exact Nat.add_right_cancel this\n    }", "line_number": 32, "declaration_attribute": "", "comment": "/-- Definition 4.1.1 -/"}, {"content": "abbrev Int := Quotient PreInt.instSetoid", "line_number": 51, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Int.formalDiff (a b:ℕ)  : Int := Quotient.mk PreInt.instSetoid ⟨ a,b ⟩", "line_number": 53, "declaration_attribute": "", "comment": ""}, {"content": "infix:100 \" —— \" => Int.formalDiff", "line_number": 55, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.decidableEq : DecidableEq Int := by\n  intro a b\n  have : ∀ (n:PreInt) (m: PreInt),\n      Decidable (Quotient.mk PreInt.instSetoid n = Quotient.mk PreInt.instSetoid m) := by\n    intro ⟨ a,b ⟩ ⟨ c,d ⟩\n    rw [eq]\n    exact decEq _ _\n  exact Quotient.recOnSubsingleton₂ a b this", "line_number": 62, "declaration_attribute": "", "comment": "/-- Decidability of equality -/"}, {"content": "instance Int.instAdd : Add Int where\n  add := Quotient.lift₂ (fun ⟨ a, b ⟩ ⟨ c, d ⟩ ↦ (a+c) —— (b+d) ) (by\n    intro ⟨ a, b ⟩ ⟨ c, d ⟩ ⟨ a', b' ⟩ ⟨ c', d' ⟩ h1 h2\n    simp [Setoid.r] at *\n    calc\n      _ = (a+b') + (c+d') := by abel\n      _ = (a'+b) + (c'+d) := by rw [h1,h2]\n      _ = _ := by abel)", "line_number": 75, "declaration_attribute": "", "comment": "/-- Lemma 4.1.3 (Addition well-defined) -/"}, {"content": "instance Int.instMul : Mul Int where\n  mul := Quotient.lift₂ (fun ⟨ a, b ⟩ ⟨ c, d ⟩ ↦ (a * c + b * d) —— (a * d + b * c)) (by\n    intro ⟨ a, b ⟩ ⟨ c, d ⟩ ⟨ a', b' ⟩ ⟨ c', d' ⟩ h1 h2; simp at h1 h2\n    convert mul_congr _ _ <;> simpa\n    )", "line_number": 110, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instOfNat {n:ℕ} : OfNat Int n where\n  ofNat := n —— 0", "line_number": 119, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instNatCast : NatCast Int where\n  natCast n := n —— 0", "line_number": 122, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instNeg : Neg Int where\n  neg := Quotient.lift (fun ⟨ a, b ⟩ ↦ b —— a) (by sorry)", "line_number": 148, "declaration_attribute": "", "comment": "/-- Definition 4.1.4 (Negation of integers) / Exercise 4.1.2 -/"}, {"content": "abbrev Int.IsPos (x:Int) : Prop := ∃ (n:ℕ), n > 0 ∧ x = n", "line_number": 155, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Int.IsNeg (x:Int) : Prop := ∃ (n:ℕ), n > 0 ∧ x = -n", "line_number": 156, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instAddGroup : AddGroup Int :=\n  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)", "line_number": 188, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instAddCommGroup : AddCommGroup Int where\n  add_comm := by sorry", "line_number": 192, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instCommMonoid : CommMonoid Int where\n  mul_comm := by sorry\n  mul_assoc := by\n    -- This proof is written to follow the structure of the original text.\n    intro x y z\n    obtain ⟨ a, b, rfl ⟩ := eq_diff x\n    obtain ⟨ c, d, rfl ⟩ := eq_diff y\n    obtain ⟨ e, f, rfl ⟩ := eq_diff z\n    simp_rw [mul_eq]; congr 1 <;> ring\n  one_mul := by sorry\n  mul_one := by sorry", "line_number": 196, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instCommRing : CommRing Int where\n  left_distrib := by sorry\n  right_distrib := by sorry\n  zero_mul := by sorry\n  mul_zero := by sorry", "line_number": 209, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instLE : LE Int where\n  le n m := ∃ a:ℕ, m = n + a", "line_number": 227, "declaration_attribute": "", "comment": "/-- Definition 4.1.10 (Ordering of the integers) -/"}, {"content": "instance Int.instLT : LT Int where\n  lt n m := n ≤ m ∧ n ≠ m", "line_number": 231, "declaration_attribute": "", "comment": "/-- Definition 4.1.10 (Ordering of the integers) -/"}, {"content": "instance Int.decidableRel : DecidableRel (· ≤ · : Int → Int → Prop) := by\n  intro n m\n  have : ∀ (n:PreInt) (m: PreInt),\n      Decidable (Quotient.mk PreInt.instSetoid n ≤ Quotient.mk PreInt.instSetoid m) := by\n    intro ⟨ a,b ⟩ ⟨ c,d ⟩\n    change Decidable (a —— b ≤ c —— d)\n    cases (a + d).decLe (b + c) with\n      | isTrue h =>\n        apply isTrue\n        sorry\n      | isFalse h =>\n        apply isFalse\n        sorry\n  exact Quotient.recOnSubsingleton₂ n m this", "line_number": 269, "declaration_attribute": "", "comment": "/-- (Not from textbook) Establish the decidability of this order. -/"}, {"content": "instance Int.instLinearOrder : LinearOrder Int where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := decidableRel", "line_number": 288, "declaration_attribute": "", "comment": "/-- (Not from textbook) Int has the structure of a linear ordering. -/"}, {"content": "abbrev Int.equivInt : Int ≃ ℤ where\n  toFun := Quotient.lift (fun ⟨ a, b ⟩ ↦ a - b) (by\n    sorry)\n  invFun := sorry\n  left_inv n := sorry\n  right_inv n := sorry", "line_number": 315, "declaration_attribute": "", "comment": "/--\n  Not in textbook: create an equivalence between Int and ℤ.\n  This requires some familiarity with the API for Mathlib's version of the integers.\n-/"}, {"content": "abbrev Int.equivInt_ordered_ring : Int ≃+*o ℤ where\n  toEquiv := equivInt\n  map_add' := by sorry\n  map_mul' := by sorry\n  map_le_map_iff' := by sorry", "line_number": 323, "declaration_attribute": "", "comment": "/-- Not in textbook: equivalence preserves order and ring operations -/"}]}
{"chapter_name": "Section_4_1", "line_number": 300, "content": "\ntheorem Int.no_induction : ∃ P: Int → Prop, P 0 ∧ ∀ n, P n → P (n+1) ∧ ¬ ∀ n, P n := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "structure PreInt where\n  minuend : ℕ\n  subtrahend : ℕ", "line_number": 27, "declaration_attribute": "", "comment": ""}, {"content": "instance PreInt.instSetoid : Setoid PreInt where\n  r a b := a.minuend + b.subtrahend = b.minuend + a.subtrahend\n  iseqv := {\n    refl := by sorry\n    symm := by sorry\n    trans := by\n      -- This proof is written to follow the structure of the original text.\n      intro ⟨ a,b ⟩ ⟨ c,d ⟩ ⟨ e,f ⟩ h1 h2; simp at h1 h2 ⊢\n      have h3 := congrArg₂ (· + ·) h1 h2; simp at h3\n      have : (a + f) + (c + d) = (e + b) + (c + d) := calc\n        (a + f) + (c + d) = a + d + (c + f) := by abel\n        _ = c + b + (e + d) := h3\n        _ = (e + b) + (c + d) := by abel\n      exact Nat.add_right_cancel this\n    }", "line_number": 32, "declaration_attribute": "", "comment": "/-- Definition 4.1.1 -/"}, {"content": "abbrev Int := Quotient PreInt.instSetoid", "line_number": 51, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Int.formalDiff (a b:ℕ)  : Int := Quotient.mk PreInt.instSetoid ⟨ a,b ⟩", "line_number": 53, "declaration_attribute": "", "comment": ""}, {"content": "infix:100 \" —— \" => Int.formalDiff", "line_number": 55, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.decidableEq : DecidableEq Int := by\n  intro a b\n  have : ∀ (n:PreInt) (m: PreInt),\n      Decidable (Quotient.mk PreInt.instSetoid n = Quotient.mk PreInt.instSetoid m) := by\n    intro ⟨ a,b ⟩ ⟨ c,d ⟩\n    rw [eq]\n    exact decEq _ _\n  exact Quotient.recOnSubsingleton₂ a b this", "line_number": 62, "declaration_attribute": "", "comment": "/-- Decidability of equality -/"}, {"content": "instance Int.instAdd : Add Int where\n  add := Quotient.lift₂ (fun ⟨ a, b ⟩ ⟨ c, d ⟩ ↦ (a+c) —— (b+d) ) (by\n    intro ⟨ a, b ⟩ ⟨ c, d ⟩ ⟨ a', b' ⟩ ⟨ c', d' ⟩ h1 h2\n    simp [Setoid.r] at *\n    calc\n      _ = (a+b') + (c+d') := by abel\n      _ = (a'+b) + (c'+d) := by rw [h1,h2]\n      _ = _ := by abel)", "line_number": 75, "declaration_attribute": "", "comment": "/-- Lemma 4.1.3 (Addition well-defined) -/"}, {"content": "instance Int.instMul : Mul Int where\n  mul := Quotient.lift₂ (fun ⟨ a, b ⟩ ⟨ c, d ⟩ ↦ (a * c + b * d) —— (a * d + b * c)) (by\n    intro ⟨ a, b ⟩ ⟨ c, d ⟩ ⟨ a', b' ⟩ ⟨ c', d' ⟩ h1 h2; simp at h1 h2\n    convert mul_congr _ _ <;> simpa\n    )", "line_number": 110, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instOfNat {n:ℕ} : OfNat Int n where\n  ofNat := n —— 0", "line_number": 119, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instNatCast : NatCast Int where\n  natCast n := n —— 0", "line_number": 122, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instNeg : Neg Int where\n  neg := Quotient.lift (fun ⟨ a, b ⟩ ↦ b —— a) (by sorry)", "line_number": 148, "declaration_attribute": "", "comment": "/-- Definition 4.1.4 (Negation of integers) / Exercise 4.1.2 -/"}, {"content": "abbrev Int.IsPos (x:Int) : Prop := ∃ (n:ℕ), n > 0 ∧ x = n", "line_number": 155, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Int.IsNeg (x:Int) : Prop := ∃ (n:ℕ), n > 0 ∧ x = -n", "line_number": 156, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instAddGroup : AddGroup Int :=\n  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)", "line_number": 188, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instAddCommGroup : AddCommGroup Int where\n  add_comm := by sorry", "line_number": 192, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instCommMonoid : CommMonoid Int where\n  mul_comm := by sorry\n  mul_assoc := by\n    -- This proof is written to follow the structure of the original text.\n    intro x y z\n    obtain ⟨ a, b, rfl ⟩ := eq_diff x\n    obtain ⟨ c, d, rfl ⟩ := eq_diff y\n    obtain ⟨ e, f, rfl ⟩ := eq_diff z\n    simp_rw [mul_eq]; congr 1 <;> ring\n  one_mul := by sorry\n  mul_one := by sorry", "line_number": 196, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instCommRing : CommRing Int where\n  left_distrib := by sorry\n  right_distrib := by sorry\n  zero_mul := by sorry\n  mul_zero := by sorry", "line_number": 209, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instLE : LE Int where\n  le n m := ∃ a:ℕ, m = n + a", "line_number": 227, "declaration_attribute": "", "comment": "/-- Definition 4.1.10 (Ordering of the integers) -/"}, {"content": "instance Int.instLT : LT Int where\n  lt n m := n ≤ m ∧ n ≠ m", "line_number": 231, "declaration_attribute": "", "comment": "/-- Definition 4.1.10 (Ordering of the integers) -/"}, {"content": "instance Int.decidableRel : DecidableRel (· ≤ · : Int → Int → Prop) := by\n  intro n m\n  have : ∀ (n:PreInt) (m: PreInt),\n      Decidable (Quotient.mk PreInt.instSetoid n ≤ Quotient.mk PreInt.instSetoid m) := by\n    intro ⟨ a,b ⟩ ⟨ c,d ⟩\n    change Decidable (a —— b ≤ c —— d)\n    cases (a + d).decLe (b + c) with\n      | isTrue h =>\n        apply isTrue\n        sorry\n      | isFalse h =>\n        apply isFalse\n        sorry\n  exact Quotient.recOnSubsingleton₂ n m this", "line_number": 269, "declaration_attribute": "", "comment": "/-- (Not from textbook) Establish the decidability of this order. -/"}, {"content": "instance Int.instLinearOrder : LinearOrder Int where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := decidableRel", "line_number": 288, "declaration_attribute": "", "comment": "/-- (Not from textbook) Int has the structure of a linear ordering. -/"}, {"content": "abbrev Int.equivInt : Int ≃ ℤ where\n  toFun := Quotient.lift (fun ⟨ a, b ⟩ ↦ a - b) (by\n    sorry)\n  invFun := sorry\n  left_inv n := sorry\n  right_inv n := sorry", "line_number": 315, "declaration_attribute": "", "comment": "/--\n  Not in textbook: create an equivalence between Int and ℤ.\n  This requires some familiarity with the API for Mathlib's version of the integers.\n-/"}, {"content": "abbrev Int.equivInt_ordered_ring : Int ≃+*o ℤ where\n  toEquiv := equivInt\n  map_add' := by sorry\n  map_mul' := by sorry\n  map_le_map_iff' := by sorry", "line_number": 323, "declaration_attribute": "", "comment": "/-- Not in textbook: equivalence preserves order and ring operations -/"}]}
{"chapter_name": "Section_4_1", "line_number": 309, "content": "\ntheorem Int.sq_nonneg' (n:Int) : ∃ (m:Nat), n*n = m := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "structure PreInt where\n  minuend : ℕ\n  subtrahend : ℕ", "line_number": 27, "declaration_attribute": "", "comment": ""}, {"content": "instance PreInt.instSetoid : Setoid PreInt where\n  r a b := a.minuend + b.subtrahend = b.minuend + a.subtrahend\n  iseqv := {\n    refl := by sorry\n    symm := by sorry\n    trans := by\n      -- This proof is written to follow the structure of the original text.\n      intro ⟨ a,b ⟩ ⟨ c,d ⟩ ⟨ e,f ⟩ h1 h2; simp at h1 h2 ⊢\n      have h3 := congrArg₂ (· + ·) h1 h2; simp at h3\n      have : (a + f) + (c + d) = (e + b) + (c + d) := calc\n        (a + f) + (c + d) = a + d + (c + f) := by abel\n        _ = c + b + (e + d) := h3\n        _ = (e + b) + (c + d) := by abel\n      exact Nat.add_right_cancel this\n    }", "line_number": 32, "declaration_attribute": "", "comment": "/-- Definition 4.1.1 -/"}, {"content": "abbrev Int := Quotient PreInt.instSetoid", "line_number": 51, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Int.formalDiff (a b:ℕ)  : Int := Quotient.mk PreInt.instSetoid ⟨ a,b ⟩", "line_number": 53, "declaration_attribute": "", "comment": ""}, {"content": "infix:100 \" —— \" => Int.formalDiff", "line_number": 55, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.decidableEq : DecidableEq Int := by\n  intro a b\n  have : ∀ (n:PreInt) (m: PreInt),\n      Decidable (Quotient.mk PreInt.instSetoid n = Quotient.mk PreInt.instSetoid m) := by\n    intro ⟨ a,b ⟩ ⟨ c,d ⟩\n    rw [eq]\n    exact decEq _ _\n  exact Quotient.recOnSubsingleton₂ a b this", "line_number": 62, "declaration_attribute": "", "comment": "/-- Decidability of equality -/"}, {"content": "instance Int.instAdd : Add Int where\n  add := Quotient.lift₂ (fun ⟨ a, b ⟩ ⟨ c, d ⟩ ↦ (a+c) —— (b+d) ) (by\n    intro ⟨ a, b ⟩ ⟨ c, d ⟩ ⟨ a', b' ⟩ ⟨ c', d' ⟩ h1 h2\n    simp [Setoid.r] at *\n    calc\n      _ = (a+b') + (c+d') := by abel\n      _ = (a'+b) + (c'+d) := by rw [h1,h2]\n      _ = _ := by abel)", "line_number": 75, "declaration_attribute": "", "comment": "/-- Lemma 4.1.3 (Addition well-defined) -/"}, {"content": "instance Int.instMul : Mul Int where\n  mul := Quotient.lift₂ (fun ⟨ a, b ⟩ ⟨ c, d ⟩ ↦ (a * c + b * d) —— (a * d + b * c)) (by\n    intro ⟨ a, b ⟩ ⟨ c, d ⟩ ⟨ a', b' ⟩ ⟨ c', d' ⟩ h1 h2; simp at h1 h2\n    convert mul_congr _ _ <;> simpa\n    )", "line_number": 110, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instOfNat {n:ℕ} : OfNat Int n where\n  ofNat := n —— 0", "line_number": 119, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instNatCast : NatCast Int where\n  natCast n := n —— 0", "line_number": 122, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instNeg : Neg Int where\n  neg := Quotient.lift (fun ⟨ a, b ⟩ ↦ b —— a) (by sorry)", "line_number": 148, "declaration_attribute": "", "comment": "/-- Definition 4.1.4 (Negation of integers) / Exercise 4.1.2 -/"}, {"content": "abbrev Int.IsPos (x:Int) : Prop := ∃ (n:ℕ), n > 0 ∧ x = n", "line_number": 155, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Int.IsNeg (x:Int) : Prop := ∃ (n:ℕ), n > 0 ∧ x = -n", "line_number": 156, "declaration_attribute": "", "comment": ""}, {"content": "instance Int.instAddGroup : AddGroup Int :=\n  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)", "line_number": 188, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instAddCommGroup : AddCommGroup Int where\n  add_comm := by sorry", "line_number": 192, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instCommMonoid : CommMonoid Int where\n  mul_comm := by sorry\n  mul_assoc := by\n    -- This proof is written to follow the structure of the original text.\n    intro x y z\n    obtain ⟨ a, b, rfl ⟩ := eq_diff x\n    obtain ⟨ c, d, rfl ⟩ := eq_diff y\n    obtain ⟨ e, f, rfl ⟩ := eq_diff z\n    simp_rw [mul_eq]; congr 1 <;> ring\n  one_mul := by sorry\n  mul_one := by sorry", "line_number": 196, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instCommRing : CommRing Int where\n  left_distrib := by sorry\n  right_distrib := by sorry\n  zero_mul := by sorry\n  mul_zero := by sorry", "line_number": 209, "declaration_attribute": "", "comment": "/-- Proposition 4.1.6 (laws of algebra) / Exercise 4.1.4 -/"}, {"content": "instance Int.instLE : LE Int where\n  le n m := ∃ a:ℕ, m = n + a", "line_number": 227, "declaration_attribute": "", "comment": "/-- Definition 4.1.10 (Ordering of the integers) -/"}, {"content": "instance Int.instLT : LT Int where\n  lt n m := n ≤ m ∧ n ≠ m", "line_number": 231, "declaration_attribute": "", "comment": "/-- Definition 4.1.10 (Ordering of the integers) -/"}, {"content": "instance Int.decidableRel : DecidableRel (· ≤ · : Int → Int → Prop) := by\n  intro n m\n  have : ∀ (n:PreInt) (m: PreInt),\n      Decidable (Quotient.mk PreInt.instSetoid n ≤ Quotient.mk PreInt.instSetoid m) := by\n    intro ⟨ a,b ⟩ ⟨ c,d ⟩\n    change Decidable (a —— b ≤ c —— d)\n    cases (a + d).decLe (b + c) with\n      | isTrue h =>\n        apply isTrue\n        sorry\n      | isFalse h =>\n        apply isFalse\n        sorry\n  exact Quotient.recOnSubsingleton₂ n m this", "line_number": 269, "declaration_attribute": "", "comment": "/-- (Not from textbook) Establish the decidability of this order. -/"}, {"content": "instance Int.instLinearOrder : LinearOrder Int where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := decidableRel", "line_number": 288, "declaration_attribute": "", "comment": "/-- (Not from textbook) Int has the structure of a linear ordering. -/"}, {"content": "abbrev Int.equivInt : Int ≃ ℤ where\n  toFun := Quotient.lift (fun ⟨ a, b ⟩ ↦ a - b) (by\n    sorry)\n  invFun := sorry\n  left_inv n := sorry\n  right_inv n := sorry", "line_number": 315, "declaration_attribute": "", "comment": "/--\n  Not in textbook: create an equivalence between Int and ℤ.\n  This requires some familiarity with the API for Mathlib's version of the integers.\n-/"}, {"content": "abbrev Int.equivInt_ordered_ring : Int ≃+*o ℤ where\n  toEquiv := equivInt\n  map_add' := by sorry\n  map_mul' := by sorry\n  map_le_map_iff' := by sorry", "line_number": 323, "declaration_attribute": "", "comment": "/-- Not in textbook: equivalence preserves order and ring operations -/"}]}
{"chapter_name": "Section_4_2", "line_number": 348, "content": "\ntheorem Rat.mul_lt_mul_right_of_neg (x y z:Rat) (hxy: x < y) (hz: z.isNeg) : x * z > y * z := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "structure PreRat where\n  numerator : ℤ\n  denominator : ℤ\n  nonzero : denominator ≠ 0", "line_number": 32, "declaration_attribute": "", "comment": ""}, {"content": "instance PreRat.instSetoid : Setoid PreRat where\n  r a b := a.numerator * b.denominator = b.numerator * a.denominator\n  iseqv := {\n    refl := by sorry\n    symm := by sorry\n    trans := by sorry\n    }", "line_number": 38, "declaration_attribute": "", "comment": "/-- Exercise 4.2.1 -/"}, {"content": "abbrev Rat := Quotient PreRat.instSetoid", "line_number": 50, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Rat.formalDiv (a b:ℤ)  : Rat :=\n  Quotient.mk PreRat.instSetoid (if h:b ≠ 0 then ⟨ a,b,h ⟩ else ⟨ 0, 1, by decide ⟩)", "line_number": 53, "declaration_attribute": "", "comment": "/-- We give division a \"junk\" value of 0//1 if the denominator is zero -/"}, {"content": "infix:100 \" // \" => Rat.formalDiv", "line_number": 56, "declaration_attribute": "", "comment": ""}, {"content": "instance Rat.decidableEq : DecidableEq Rat := by\n  sorry", "line_number": 73, "declaration_attribute": "", "comment": "/--\n  Decidability of equality. Hint: modify the proof of `DecidableEq Int` from the previous\n  section. However, because formal division handles the case of zero denominator separately, it\n  may be more convenient to avoid that operation and work directly with the `Quotient` API.\n-/"}, {"content": "instance Rat.add_inst : Add Rat where\n  add := Quotient.lift₂ (fun ⟨ a, b, h1 ⟩ ⟨ c, d, h2 ⟩ ↦ (a*d+b*c) // (b*d)) (by\n    intro ⟨ a, b, h1 ⟩ ⟨ c, d, h2 ⟩ ⟨ a', b', h1' ⟩ ⟨ c', d', h2' ⟩ h3 h4\n    simp_all [Setoid.r]\n    calc\n      _ = (a*b')*d*d' + b*b'*(c*d') := by ring\n      _ = (a'*b)*d*d' + b*b'*(c'*d) := by rw [h3, h4]\n      _ = _ := by ring\n  )", "line_number": 77, "declaration_attribute": "", "comment": "/-- Lemma 4.2.3 (Addition well-defined) -/"}, {"content": "instance Rat.mul_inst : Mul Rat where\n  mul := Quotient.lift₂ (fun ⟨ a, b, h1 ⟩ ⟨ c, d, h2 ⟩ ↦ (a*c) // (b*d)) (by sorry)", "line_number": 93, "declaration_attribute": "", "comment": "/-- Lemma 4.2.3 (Multiplication well-defined) -/"}, {"content": "instance Rat.neg_inst : Neg Rat where\n  neg := Quotient.lift (fun ⟨ a, b, h1 ⟩ ↦ (-a) // b) (by sorry)", "line_number": 102, "declaration_attribute": "", "comment": "/-- Lemma 4.2.3 (Negation well-defined) -/"}, {"content": "instance Rat.instIntCast : IntCast Rat where\n  intCast a := a // 1", "line_number": 110, "declaration_attribute": "", "comment": "/-- Embedding the integers in the rationals -/"}, {"content": "instance Rat.instNatCast : NatCast Rat where\n  natCast n := (n:ℤ) // 1", "line_number": 113, "declaration_attribute": "", "comment": ""}, {"content": "instance Rat.instOfNat {n:ℕ} : OfNat Rat n where\n  ofNat := (n:ℤ) // 1", "line_number": 116, "declaration_attribute": "", "comment": ""}, {"content": "instance Rat.instInv : Inv Rat where\n  inv := Quotient.lift (fun ⟨ a, b, h1 ⟩ ↦ b // a) (by\n    sorry -- hint: split into the `a=0` and `a≠0` cases\n)", "line_number": 140, "declaration_attribute": "", "comment": "/--\n  Whereas the book leaves the inverse of 0 undefined, it is more convenient in Lean to assign a\n  \"junk\" value to this inverse; we arbitrarily choose this junk value to be 0.\n-/"}, {"content": "instance Rat.addGroup_inst : AddGroup Rat :=\nAddGroup.ofLeftAxioms (by\n  -- this proof is written to follow the structure of the original text.\n  intro x y z\n  obtain ⟨ a, b, hb , rfl ⟩ := eq_diff x\n  obtain ⟨ c, d, hd , rfl ⟩ := eq_diff y\n  obtain ⟨ e, f, hf , rfl ⟩ := eq_diff z\n  have hbd : b*d ≠ 0 := Int.mul_ne_zero hb hd\n  have hdf : d*f ≠ 0 := Int.mul_ne_zero hd hf\n  have hbdf : b*d*f ≠ 0 := Int.mul_ne_zero hbd hf\n  rw [add_eq _ _ hb hd, add_eq _ _ hbd hf, add_eq _ _ hd hf,\n      add_eq _ _ hb hdf, ←mul_assoc b, eq _ _ hbdf hbdf]\n  ring\n)\n (by sorry) (by sorry)", "line_number": 152, "declaration_attribute": "", "comment": "/-- Proposition 4.2.4 (laws of algebra) / Exercise 4.2.3 -/"}, {"content": "instance Rat.instAddCommGroup : AddCommGroup Rat where\n  add_comm := by sorry", "line_number": 170, "declaration_attribute": "", "comment": "/-- Proposition 4.2.4 (laws of algebra) / Exercise 4.2.3 -/"}, {"content": "instance Rat.instCommMonoid : CommMonoid Rat where\n  mul_comm := by sorry\n  mul_assoc := by sorry\n  one_mul := by sorry\n  mul_one := by sorry", "line_number": 174, "declaration_attribute": "", "comment": "/-- Proposition 4.2.4 (laws of algebra) / Exercise 4.2.3 -/"}, {"content": "instance Rat.instCommRing : CommRing Rat where\n  left_distrib := by sorry\n  right_distrib := by sorry\n  zero_mul := by sorry\n  mul_zero := by sorry\n  mul_assoc := by sorry\n  natCast_succ := by sorry", "line_number": 181, "declaration_attribute": "", "comment": "/-- Proposition 4.2.4 (laws of algebra) / Exercise 4.2.3 -/"}, {"content": "instance Rat.instRatCast : RatCast Rat where\n  ratCast q := q.num // q.den", "line_number": 189, "declaration_attribute": "", "comment": ""}, {"content": "instance Rat.instDivInvMonoid : DivInvMonoid Rat where", "line_number": 204, "declaration_attribute": "", "comment": "/-- Default definition of division -/"}, {"content": "instance Rat.instField : Field Rat where\n  exists_pair_ne := by sorry\n  mul_inv_cancel := by sorry\n  inv_zero := rfl\n  ratCast_def := by\n    intro q\n    set num := q.num\n    set den := q.den\n    have hden : (den:ℤ) ≠ 0 := by simp [den, q.den_nz]\n    rw [← Rat.num_div_den q]\n    convert coe_Rat_eq _ hden\n    rw [coe_Int_eq, coe_Nat_eq, div_eq, inv_eq, mul_eq, eq] <;> simp [num, hden, den, q.den_nz]\n  qsmul := _\n  nnqsmul := _", "line_number": 209, "declaration_attribute": "", "comment": "/-- Proposition 4.2.4 (laws of algebra) / Exercise 4.2.3 -/"}, {"content": "def Rat.coe_int_hom : ℤ →+* Rat where\n  toFun n := (n:Rat)\n  map_zero' := rfl\n  map_one' := rfl\n  map_add' := by sorry\n  map_mul' := by sorry", "line_number": 226, "declaration_attribute": "", "comment": ""}, {"content": "def Rat.equiv_rat : ℚ ≃+* Rat where\n  toFun n := (n:Rat)\n  invFun := by sorry\n  map_add' := by sorry\n  map_mul' := by sorry\n  left_inv := by sorry\n  right_inv := by sorry", "line_number": 236, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) The textbook rationals are isomorphic (as a field) to the Mathlib rationals.\n-/"}, {"content": "def Rat.isPos (q:Rat) : Prop := ∃ a b:ℤ, a > 0 ∧ b > 0 ∧ q = a/b", "line_number": 246, "declaration_attribute": "", "comment": "/-- Definition 4.2.6 (positivity) -/"}, {"content": "def Rat.isNeg (q:Rat) : Prop := ∃ r:Rat, r.isPos ∧ q = -r", "line_number": 249, "declaration_attribute": "", "comment": "/-- Definition 4.2.6 (negativity) -/"}, {"content": "instance Rat.instLT : LT Rat where\n  lt x y := (x-y).isNeg", "line_number": 264, "declaration_attribute": "", "comment": "/-- Definition 4.2.8 (Ordering of the rationals) -/"}, {"content": "instance Rat.instLE : LE Rat where\n  le x y := (x < y) ∨ (x = y)", "line_number": 268, "declaration_attribute": "", "comment": "/-- Definition 4.2.8 (Ordering of the rationals) -/"}, {"content": "instance Rat.decidableRel : DecidableRel (· ≤ · : Rat → Rat → Prop) := by\n  intro n m\n  have : ∀ (n:PreRat) (m: PreRat),\n      Decidable (Quotient.mk PreRat.instSetoid n ≤ Quotient.mk PreRat.instSetoid m) := by\n    intro ⟨ a,b,hb ⟩ ⟨ c,d,hd ⟩\n    -- at this point, the goal is morally `Decidable(a//b ≤ c//d)`, but there are technical\n    -- issues due to the junk value of formal divisionwhen the denominator vanishes.\n    -- It may be more convenient to avoid formal division and work directly with `Quotient.mk`.\n    cases (0:ℤ).decLe (b*d) with\n      | isTrue hbd =>\n        cases (a * d).decLe (b * c) with\n          | isTrue h =>\n            apply isTrue\n            sorry\n          | isFalse h =>\n            apply isFalse\n            sorry\n      | isFalse hbd =>\n        cases (b * c).decLe (a * d) with\n          | isTrue h =>\n            apply isTrue\n            sorry\n          | isFalse h =>\n            apply isFalse\n            sorry\n  exact Quotient.recOnSubsingleton₂ n m this", "line_number": 302, "declaration_attribute": "", "comment": "/-- (Not from textbook) Establish the decidability of this order. -/"}, {"content": "instance Rat.instLinearOrder : LinearOrder Rat where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := decidableRel", "line_number": 330, "declaration_attribute": "", "comment": "/-- (Not from textbook) Rat has the structure of a linear ordering. -/"}, {"content": "instance Rat.instIsStrictOrderedRing : IsStrictOrderedRing Rat where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 339, "declaration_attribute": "", "comment": "/-- (Not from textbook) Rat has the structure of a strict ordered ring. -/"}, {"content": "abbrev Rat.equivRat : Rat ≃ ℚ where\n  toFun := Quotient.lift (fun ⟨ a, b, h ⟩ ↦ a / b) (by\n    sorry)\n  invFun := sorry\n  left_inv n := sorry\n  right_inv n := sorry", "line_number": 356, "declaration_attribute": "", "comment": "/--\n  Not in textbook: create an equivalence between Rat and ℚ. This requires some familiarity with\n  the API for Mathlib's version of the rationals.\n-/"}, {"content": "abbrev Rat.equivRat_order : Rat ≃o ℚ where\n  toEquiv := equivRat\n  map_rel_iff' := by sorry", "line_number": 364, "declaration_attribute": "", "comment": "/-- Not in textbook: equivalence preserves order -/"}, {"content": "abbrev Rat.equivRat_ring : Rat ≃+* ℚ where\n  toEquiv := equivRat\n  map_add' := by sorry\n  map_mul' := by sorry", "line_number": 369, "declaration_attribute": "", "comment": "/-- Not in textbook: equivalence preserves ring operations -/"}]}
{"chapter_name": "Section_4_3", "line_number": 242, "content": "\ntheorem two_pow_geq (N:ℕ) : 2^N ≥ N := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "def Rat.Close (ε : ℚ) (x y:ℚ) := |x-y| ≤ ε", "line_number": 29, "declaration_attribute": "", "comment": "/--\n  This definition needs to be made outside of the Section 4.3 namespace for technical reasons.\n-/"}, {"content": "abbrev abs (x:ℚ) : ℚ := if x > 0 then x else (if x < 0 then -x else 0)", "line_number": 35, "declaration_attribute": "", "comment": "/-- Definition 4.3.1 (Absolute value) -/"}, {"content": "abbrev dist (x y : ℚ) := |x - y|", "line_number": 52, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_4_4", "line_number": 43, "content": "\ntheorem Nat.no_infinite_descent : ¬ ∃ a:ℕ → ℕ, ∀ n, a (n+1) < a n := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "def Int.infinite_descent : Decidable (∃ a:ℕ → ℤ, ∀ n, a (n+1) < a n) := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 46, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_5_1", "line_number": 308, "content": "\ntheorem Sequence.ex_5_1_10_a : (1:ℚ).Steady sqrt_two := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "structure Sequence where\n  n₀ : ℤ\n  seq : ℤ → ℚ\n  vanish : ∀ n < n₀, seq n = 0", "line_number": 28, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 5.1.1 (Sequence). To avoid some technicalities involving dependent types, we extend\n  sequences by zero to the left of the starting point `n₀`.\n-/"}, {"content": "instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℚ) where\n  coe := fun a ↦ a.seq", "line_number": 34, "declaration_attribute": "", "comment": "/-- Sequences can be thought of as functions from ℤ to ℚ. -/"}, {"content": "def Sequence.ofNatFun (a : ℕ → ℚ) : Sequence where\n    n₀ := 0\n    seq := fun n ↦ if n ≥ 0 then a n.toNat else 0\n    vanish := by aesop", "line_number": 43, "declaration_attribute": "@[coe]", "comment": "/--\nFunctions from ℕ to ℚ can be thought of as sequences starting from 0; `ofNatFun` performs this conversion.\n\nThe `coe` attribute allows the delaborator to print `Sequence.ofNatFun f` as `↑f`, which is more concise; you may safely remove this if you prefer the more explicit notation.\n-/"}, {"content": "instance : Coe (ℕ → ℚ) Sequence where\n  coe := Sequence.ofNatFun", "line_number": 54, "declaration_attribute": "", "comment": "/--\nIf `a : ℕ → ℚ` is used in a context where a `Sequence` is expected, automatically coerce `a` to `Sequence.ofNatFun a` (which will be pretty-printed as `↑a`)\n-/"}, {"content": "abbrev Sequence.mk' (n₀:ℤ) (a: { n // n ≥ n₀ } → ℚ) : Sequence where\n  n₀ := n₀\n  seq := fun n ↦ if h : n ≥ n₀ then a ⟨n, h⟩ else 0\n  vanish := by aesop", "line_number": 57, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.squares : Sequence := ((fun n:ℕ ↦ (n^2:ℚ)):Sequence)", "line_number": 75, "declaration_attribute": "", "comment": "/-- Example 5.1.2 -/"}, {"content": "abbrev Sequence.three : Sequence := ((fun (_:ℕ) ↦ (3:ℚ)):Sequence)", "line_number": 81, "declaration_attribute": "", "comment": "/-- Example 5.1.2 -/"}, {"content": "abbrev Sequence.squares_from_three : Sequence := mk' 3 (fun n ↦ n^2)", "line_number": 87, "declaration_attribute": "", "comment": "/-- Example 5.1.2 -/"}, {"content": "abbrev Rat.Steady (ε: ℚ) (a: Chapter5.Sequence) : Prop :=\n  ∀ n ≥ a.n₀, ∀ m ≥ a.n₀, ε.Close (a n) (a m)", "line_number": 100, "declaration_attribute": "", "comment": "/--\nA slight generalization of Definition 5.1.3 - definition of ε-steadiness for a sequence with an\narbitrary starting point n₀\n-/"}, {"content": "abbrev Sequence.from (a:Sequence) (n₁:ℤ) : Sequence :=\n  mk' (max a.n₀ n₁) (fun n ↦ a (n:ℤ))", "line_number": 201, "declaration_attribute": "", "comment": "/--\n  a.from n₁ starts `a:Sequence` from `n₁`.  It is intended for use when `n₁ ≥ n₀`, but returns\n  the \"junk\" value of the original sequence `a` otherwise.\n-/"}, {"content": "abbrev Rat.EventuallySteady (ε: ℚ) (a: Chapter5.Sequence) : Prop := ∃ N ≥ a.n₀, ε.Steady (a.from N)", "line_number": 212, "declaration_attribute": "", "comment": "/-- Definition 5.1.6 (Eventually ε-steady) -/"}, {"content": "abbrev Sequence.IsCauchy (a:Sequence) : Prop := ∀ ε > (0:ℚ), ε.EventuallySteady a", "line_number": 263, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable def Sequence.sqrt_two : Sequence := (fun n:ℕ ↦ ((⌊ (Real.sqrt 2)*10^n ⌋ / 10^n):ℚ))", "line_number": 303, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedBy {n:ℕ} (a: Fin n → ℚ) (M:ℚ) : Prop :=\n  ∀ i, |a i| ≤ M", "line_number": 352, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.BoundedBy (a:Sequence) (M:ℚ) : Prop := ∀ n, |a n| ≤ M", "line_number": 362, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.IsBounded (a:Sequence) : Prop := ∃ M ≥ 0, a.BoundedBy M", "line_number": 368, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_5_2", "line_number": 118, "content": "\ntheorem Sequence.isBounded_of_eventuallyClose {ε:ℚ} {a b: ℕ → ℚ} (hab: ε.EventuallyClose a b) :\n    (a:Sequence).IsBounded ↔ (b:Sequence).IsBounded := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Rat.CloseSeq (ε: ℚ) (a b: Chapter5.Sequence) : Prop :=\n  ∀ n, n ≥ a.n₀ → n ≥ b.n₀ → ε.Close (a n) (b n)", "line_number": 21, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Rat.EventuallyClose (ε: ℚ) (a b: Chapter5.Sequence) : Prop :=\n  ∃ N, ε.CloseSeq (a.from N) (b.from N)", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.Equiv (a b: ℕ → ℚ) : Prop :=\n  ∀ ε > (0:ℚ), ε.EventuallyClose (a:Sequence) (b:Sequence)", "line_number": 64, "declaration_attribute": "", "comment": "/-- Definition 5.2.6 (Equivalent sequences) -/"}]}
{"chapter_name": "Section_5_3", "line_number": 466, "content": "\ntheorem Real.IsBounded.equiv {a b:ℕ → ℚ} (ha: (a:Sequence).IsBounded) (hab: Sequence.Equiv a b) :\n    (b:Sequence).IsBounded := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "class CauchySequence extends Sequence where\n  zero : n₀ = 0\n  cauchy : toSequence.IsCauchy", "line_number": 26, "declaration_attribute": "@[ext]", "comment": "/-- A class of Cauchy sequences that start at zero -/"}, {"content": "abbrev CauchySequence.mk' {a:ℕ → ℚ} (ha: (a:Sequence).IsCauchy) : CauchySequence where\n  n₀ := 0\n  seq := (a:Sequence).seq\n  vanish := by aesop\n  zero := rfl\n  cauchy := ha", "line_number": 35, "declaration_attribute": "", "comment": "/-- A sequence starting at zero that is Cauchy, can be viewed as a Cauchy sequence.-/"}, {"content": "instance CauchySequence.instCoeFun : CoeFun CauchySequence (fun _ ↦ ℕ → ℚ) where\n  coe := fun a n ↦ a.toSequence (n:ℤ)", "line_number": 46, "declaration_attribute": "", "comment": ""}, {"content": "instance CauchySequence.instSetoid : Setoid CauchySequence where\n  r := fun a b ↦ Sequence.Equiv a b\n  iseqv := {\n     refl := sorry\n     symm := sorry\n     trans := sorry\n  }", "line_number": 64, "declaration_attribute": "", "comment": "/-- Proposition 5.3.3 / Exercise 5.3.1 -/"}, {"content": "instance CauchySequence.instZero : Zero CauchySequence where\n  zero := CauchySequence.mk' (a := fun _: ℕ ↦ 0) (Sequence.IsCauchy.const (0:ℚ))", "line_number": 77, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real := Quotient CauchySequence.instSetoid", "line_number": 80, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev LIM (a:ℕ → ℚ) : Real :=\n  Quotient.mk _ (if h : (a:Sequence).IsCauchy then CauchySequence.mk' h else (0:CauchySequence))", "line_number": 88, "declaration_attribute": "", "comment": "/--\n  It is convenient in Lean to assign the \"dummy\" value of 0 to `LIM a` when `a` is not Cauchy.\n  This requires Classical logic, because the property of being Cauchy is not computable or\n  decidable.\n-/"}, {"content": "noncomputable instance Real.add_inst : Add Real where\n  add := fun x y ↦\n    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b)) (by\n      intro a b a' b' haa' hbb'\n      change LIM ((a:ℕ → ℚ) + (b:ℕ → ℚ)) = LIM ((a':ℕ → ℚ) + (b':ℕ → ℚ))\n      rw [LIM_eq_LIM]\n      . exact Sequence.add_equiv haa' hbb'\n      all_goals apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence]\n      . exact a.cauchy\n      . exact b.cauchy\n      . exact a'.cauchy\n      exact b'.cauchy\n      )", "line_number": 156, "declaration_attribute": "", "comment": "/-- Definition 5.3.4 (Addition of reals) -/"}, {"content": "noncomputable instance Real.mul_inst : Mul Real where\n  mul := fun x y ↦\n    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b)) (by\n      intro a b a' b' haa' hbb'\n      change LIM ((a:ℕ → ℚ) * (b:ℕ → ℚ)) = LIM ((a':ℕ → ℚ) * (b':ℕ → ℚ))\n      rw [LIM_eq_LIM]\n      . exact Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy) (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'\n      all_goals apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence]\n      . exact a.cauchy\n      . exact b.cauchy\n      . exact a'.cauchy\n      exact b'.cauchy\n      )", "line_number": 201, "declaration_attribute": "", "comment": "/-- Definition 5.3.9 (Product of reals) -/"}, {"content": "instance Real.instRatCast : RatCast Real where\n  ratCast := fun q ↦\n    Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))", "line_number": 221, "declaration_attribute": "", "comment": ""}, {"content": "instance Real.instOfNat {n:ℕ} : OfNat Real n where\n  ofNat := ((n:ℚ):Real)", "line_number": 232, "declaration_attribute": "", "comment": ""}, {"content": "instance Real.instNatCast : NatCast Real where\n  natCast n := ((n:ℚ):Real)", "line_number": 235, "declaration_attribute": "", "comment": ""}, {"content": "instance Real.instIntCast : IntCast Real where\n  intCast n := ((n:ℚ):Real)", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Real.instNeg : Neg Real where\n  neg := fun x ↦ ((-1:ℚ):Real) * x", "line_number": 252, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Real.addGroup_inst : AddGroup Real :=\nAddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)", "line_number": 266, "declaration_attribute": "", "comment": "/-- Proposition 5.3.11 (laws of algebra) -/"}, {"content": "noncomputable instance Real.instAddCommGroup : AddCommGroup Real where\n  add_comm := by sorry", "line_number": 283, "declaration_attribute": "", "comment": "/-- Proposition 5.3.11 (laws of algebra) -/"}, {"content": "noncomputable instance Real.instCommMonoid : CommMonoid Real where\n  mul_comm := by sorry\n  mul_assoc := by sorry\n  one_mul := by sorry\n  mul_one := by sorry", "line_number": 287, "declaration_attribute": "", "comment": "/-- Proposition 5.3.11 (laws of algebra) -/"}, {"content": "noncomputable instance Real.instCommRing : CommRing Real where\n  left_distrib := by sorry\n  right_distrib := by sorry\n  zero_mul := by sorry\n  mul_zero := by sorry\n  mul_assoc := by sorry\n  natCast_succ := by sorry\n  intCast_negSucc := by sorry", "line_number": 294, "declaration_attribute": "", "comment": "/-- Proposition 5.3.11 (laws of algebra) -/"}, {"content": "abbrev Real.ratCast_hom : ℚ →+* Real where\n  toFun := RatCast.ratCast\n  map_zero' := by sorry\n  map_one' := by sorry\n  map_add' := by sorry\n  map_mul' := by sorry", "line_number": 303, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedAwayZero (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, |a n| ≥ c", "line_number": 314, "declaration_attribute": "", "comment": "/--\n  Definition 5.3.12 (sequences bounded away from zero). Sequences are indexed to start from zero\n  as this is more convenient for Mathlib purposes.\n-/"}, {"content": "noncomputable instance Real.instInv : Inv Real where\n  inv x := if h: x ≠ 0 then LIM (boundedAwayZero_of_nonzero h).choose⁻¹ else 0", "line_number": 419, "declaration_attribute": "", "comment": "/--\n  Definition 5.3.16 (Reciprocation of real numbers).  Requires classical logic because we need to\n  assign a \"junk\" value to the inverse of 0.\n-/"}, {"content": "noncomputable instance Real.instDivInvMonoid : DivInvMonoid Real where", "line_number": 448, "declaration_attribute": "", "comment": "/-- Default definition of division -/"}, {"content": "noncomputable instance Real.instField : Field Real where\n  exists_pair_ne := by sorry\n  mul_inv_cancel := by sorry\n  inv_zero := by sorry\n  ratCast_def := by sorry\n  qsmul := _\n  nnqsmul := _", "line_number": 452, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_5_3", "line_number": 229, "content": "@[simp]\ntheorem Real.ratCast_inj (q r:ℚ) : (q:Real) = (r:Real) ↔ q = r := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "class CauchySequence extends Sequence where\n  zero : n₀ = 0\n  cauchy : toSequence.IsCauchy", "line_number": 26, "declaration_attribute": "@[ext]", "comment": "/-- A class of Cauchy sequences that start at zero -/"}, {"content": "abbrev CauchySequence.mk' {a:ℕ → ℚ} (ha: (a:Sequence).IsCauchy) : CauchySequence where\n  n₀ := 0\n  seq := (a:Sequence).seq\n  vanish := by aesop\n  zero := rfl\n  cauchy := ha", "line_number": 35, "declaration_attribute": "", "comment": "/-- A sequence starting at zero that is Cauchy, can be viewed as a Cauchy sequence.-/"}, {"content": "instance CauchySequence.instCoeFun : CoeFun CauchySequence (fun _ ↦ ℕ → ℚ) where\n  coe := fun a n ↦ a.toSequence (n:ℤ)", "line_number": 46, "declaration_attribute": "", "comment": ""}, {"content": "instance CauchySequence.instSetoid : Setoid CauchySequence where\n  r := fun a b ↦ Sequence.Equiv a b\n  iseqv := {\n     refl := sorry\n     symm := sorry\n     trans := sorry\n  }", "line_number": 64, "declaration_attribute": "", "comment": "/-- Proposition 5.3.3 / Exercise 5.3.1 -/"}, {"content": "instance CauchySequence.instZero : Zero CauchySequence where\n  zero := CauchySequence.mk' (a := fun _: ℕ ↦ 0) (Sequence.IsCauchy.const (0:ℚ))", "line_number": 77, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real := Quotient CauchySequence.instSetoid", "line_number": 80, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev LIM (a:ℕ → ℚ) : Real :=\n  Quotient.mk _ (if h : (a:Sequence).IsCauchy then CauchySequence.mk' h else (0:CauchySequence))", "line_number": 88, "declaration_attribute": "", "comment": "/--\n  It is convenient in Lean to assign the \"dummy\" value of 0 to `LIM a` when `a` is not Cauchy.\n  This requires Classical logic, because the property of being Cauchy is not computable or\n  decidable.\n-/"}, {"content": "noncomputable instance Real.add_inst : Add Real where\n  add := fun x y ↦\n    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b)) (by\n      intro a b a' b' haa' hbb'\n      change LIM ((a:ℕ → ℚ) + (b:ℕ → ℚ)) = LIM ((a':ℕ → ℚ) + (b':ℕ → ℚ))\n      rw [LIM_eq_LIM]\n      . exact Sequence.add_equiv haa' hbb'\n      all_goals apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence]\n      . exact a.cauchy\n      . exact b.cauchy\n      . exact a'.cauchy\n      exact b'.cauchy\n      )", "line_number": 156, "declaration_attribute": "", "comment": "/-- Definition 5.3.4 (Addition of reals) -/"}, {"content": "noncomputable instance Real.mul_inst : Mul Real where\n  mul := fun x y ↦\n    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b)) (by\n      intro a b a' b' haa' hbb'\n      change LIM ((a:ℕ → ℚ) * (b:ℕ → ℚ)) = LIM ((a':ℕ → ℚ) * (b':ℕ → ℚ))\n      rw [LIM_eq_LIM]\n      . exact Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy) (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'\n      all_goals apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence]\n      . exact a.cauchy\n      . exact b.cauchy\n      . exact a'.cauchy\n      exact b'.cauchy\n      )", "line_number": 201, "declaration_attribute": "", "comment": "/-- Definition 5.3.9 (Product of reals) -/"}, {"content": "instance Real.instRatCast : RatCast Real where\n  ratCast := fun q ↦\n    Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))", "line_number": 221, "declaration_attribute": "", "comment": ""}, {"content": "instance Real.instOfNat {n:ℕ} : OfNat Real n where\n  ofNat := ((n:ℚ):Real)", "line_number": 232, "declaration_attribute": "", "comment": ""}, {"content": "instance Real.instNatCast : NatCast Real where\n  natCast n := ((n:ℚ):Real)", "line_number": 235, "declaration_attribute": "", "comment": ""}, {"content": "instance Real.instIntCast : IntCast Real where\n  intCast n := ((n:ℚ):Real)", "line_number": 243, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Real.instNeg : Neg Real where\n  neg := fun x ↦ ((-1:ℚ):Real) * x", "line_number": 252, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Real.addGroup_inst : AddGroup Real :=\nAddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)", "line_number": 266, "declaration_attribute": "", "comment": "/-- Proposition 5.3.11 (laws of algebra) -/"}, {"content": "noncomputable instance Real.instAddCommGroup : AddCommGroup Real where\n  add_comm := by sorry", "line_number": 283, "declaration_attribute": "", "comment": "/-- Proposition 5.3.11 (laws of algebra) -/"}, {"content": "noncomputable instance Real.instCommMonoid : CommMonoid Real where\n  mul_comm := by sorry\n  mul_assoc := by sorry\n  one_mul := by sorry\n  mul_one := by sorry", "line_number": 287, "declaration_attribute": "", "comment": "/-- Proposition 5.3.11 (laws of algebra) -/"}, {"content": "noncomputable instance Real.instCommRing : CommRing Real where\n  left_distrib := by sorry\n  right_distrib := by sorry\n  zero_mul := by sorry\n  mul_zero := by sorry\n  mul_assoc := by sorry\n  natCast_succ := by sorry\n  intCast_negSucc := by sorry", "line_number": 294, "declaration_attribute": "", "comment": "/-- Proposition 5.3.11 (laws of algebra) -/"}, {"content": "abbrev Real.ratCast_hom : ℚ →+* Real where\n  toFun := RatCast.ratCast\n  map_zero' := by sorry\n  map_one' := by sorry\n  map_add' := by sorry\n  map_mul' := by sorry", "line_number": 303, "declaration_attribute": "", "comment": ""}, {"content": "abbrev BoundedAwayZero (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, |a n| ≥ c", "line_number": 314, "declaration_attribute": "", "comment": "/--\n  Definition 5.3.12 (sequences bounded away from zero). Sequences are indexed to start from zero\n  as this is more convenient for Mathlib purposes.\n-/"}, {"content": "noncomputable instance Real.instInv : Inv Real where\n  inv x := if h: x ≠ 0 then LIM (boundedAwayZero_of_nonzero h).choose⁻¹ else 0", "line_number": 419, "declaration_attribute": "", "comment": "/--\n  Definition 5.3.16 (Reciprocation of real numbers).  Requires classical logic because we need to\n  assign a \"junk\" value to the inverse of 0.\n-/"}, {"content": "noncomputable instance Real.instDivInvMonoid : DivInvMonoid Real where", "line_number": 448, "declaration_attribute": "", "comment": "/-- Default definition of division -/"}, {"content": "noncomputable instance Real.instField : Field Real where\n  exists_pair_ne := by sorry\n  mul_inv_cancel := by sorry\n  inv_zero := by sorry\n  ratCast_def := by sorry\n  qsmul := _\n  nnqsmul := _", "line_number": 452, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_5_4", "line_number": 353, "content": "\ntheorem Real.neg_max (x y:Real) : max x y = - min (-x) (-y) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 365, "content": "\ntheorem Real.max_add (x y z:Real) : max (x + z) (y + z) = max x y + z := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 332, "content": "\ntheorem Real.dist_le_iff (ε x y:Real) : |x-y| ≤ ε ↔ y-ε ≤ x ∧ x ≤ y+ε := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 376, "content": "\ntheorem Real.min_self (x:Real) : min x x = x := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 335, "content": "\ntheorem Real.le_add_eps_iff (x y:Real) : ∀ ε > 0, x ≤ y+ε ↔ x ≤ y := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 379, "content": "\ntheorem Real.min_add (x y z:Real) : min (x + z) (y + z) = min x y + z := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 373, "content": "\ntheorem Real.min_comm (x y:Real) : min x y = min y x := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 382, "content": "\ntheorem Real.min_mul (x y :Real) {z:Real} (hz: z.IsPos) : min (x * z) (y * z) = min x y * z := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 341, "content": "\ntheorem Real.LIM_of_le {x:Real} {a:ℕ → ℚ} (hcauchy: (a:Sequence).IsCauchy) (h: ∀ n, a n ≤ x) :\n    LIM a ≤ x := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 338, "content": "\ntheorem Real.dist_le_eps_iff (x y:Real) : ∀ ε > 0, |x-y| ≤ ε ↔ x = y := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 345, "content": "\ntheorem Real.LIM_of_ge {x:Real} {a:ℕ → ℚ} (hcauchy: (a:Sequence).IsCauchy) (h: ∀ n, a n ≥ x) :\n    LIM a ≥ x := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 359, "content": "\ntheorem Real.max_comm (x y:Real) : max x y = max y x := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 323, "content": "\ntheorem Real.floor_exist (x:Real) : ∃ n:ℤ, (n:Real) ≤ x ∧ x < (n:Real)+1 := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 329, "content": "\ntheorem Real.dist_lt_iff (ε x y:Real) : |x-y| < ε ↔ y-ε < x ∧ x < y+ε := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_4", "line_number": 386, "content": "\ntheorem Real.inv_max {x y :Real} (hx:x.IsPos) (hy:y.IsPos) : (max x y)⁻¹ = min x⁻¹ y⁻¹ := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev BoundedAwayPos (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≥ c", "line_number": 26, "declaration_attribute": "", "comment": "/--\n  Definition 5.4.1 (sequences bounded away from zero with sign). Sequences are indexed to start\n  from zero as this is more convenient for Mathlib purposes.\n-/"}, {"content": "abbrev BoundedAwayNeg (a:ℕ → ℚ) : Prop :=\n  ∃ (c:ℚ), c > 0 ∧ ∀ n, a n ≤ -c", "line_number": 30, "declaration_attribute": "", "comment": "/-- Definition 5.4.1 (sequences bounded away from zero with sign). -/"}, {"content": "abbrev Real.IsPos (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayPos a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.IsNeg (x:Real) : Prop :=\n  ∃ a:ℕ → ℚ, BoundedAwayNeg a ∧ (a:Sequence).IsCauchy ∧ x = LIM a", "line_number": 71, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.abs (x:Real) : Real := if x.IsPos then x else (if x.IsNeg then -x else 0)", "line_number": 116, "declaration_attribute": "", "comment": "/-- Need to use classical logic here because isPos and isNeg are not decidable -/"}, {"content": "instance Real.instLT : LT Real where\n  lt x y := (x-y).IsNeg", "line_number": 137, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "instance Real.instLE : LE Real where\n  le x y := (x < y) ∨ (x = y)", "line_number": 141, "declaration_attribute": "", "comment": "/-- Definition 5.4.6 (Ordering of the reals) -/"}, {"content": "noncomputable instance Real.instLinearOrder : LinearOrder Real where\n  le_refl := sorry\n  le_trans := sorry\n  lt_iff_le_not_le := sorry\n  le_antisymm := sorry\n  le_total := sorry\n  toDecidableLE := Classical.decRel _", "line_number": 193, "declaration_attribute": "", "comment": "/--\n  (Not from textbook) Real has the structure of a linear ordering. The order is not computable,\n  and so classical logic is required to impose decidability.\n-/"}, {"content": "instance Real.instIsStrictOrderedRing : IsStrictOrderedRing Real where\n  add_le_add_left := by sorry\n  add_le_add_right := by sorry\n  mul_lt_mul_of_pos_left := by sorry\n  mul_lt_mul_of_pos_right := by sorry\n  le_of_add_le_add_left := by sorry\n  zero_le_one := by sorry", "line_number": 230, "declaration_attribute": "", "comment": "/-- (Not from textbook) Real has the structure of a strict ordered ring. -/"}, {"content": "abbrev Real.ratCast_ordered_hom : ℚ →+*o Real where\n  toRingHom := ratCast_hom\n  monotone' := by sorry", "line_number": 392, "declaration_attribute": "", "comment": "/-- Not from textbook: the rationals map as an ordered ring homomorphism into the reals. -/"}]}
{"chapter_name": "Section_5_5", "line_number": 75, "content": "\ntheorem Real.upperBound_between {E: Set Real} {n:ℕ} {L K:ℤ} (hLK: L < K)\n  (hK: K*((1/(n+1):ℚ):Real) ∈ upperBounds E) (hL: L*((1/(n+1):ℚ):Real) ∉ upperBounds E) :\n    ∃ m, L < m\n    ∧ m ≤ K\n    ∧ m*((1/(n+1):ℚ):Real) ∈ upperBounds E\n    ∧ (m-1)*((1/(n+1):ℚ):Real) ∉ upperBounds E := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "inductive ExtendedReal where\n| neg_infty : ExtendedReal\n| real (x:Real) : ExtendedReal\n| infty : ExtendedReal", "line_number": 182, "declaration_attribute": "", "comment": "/-- A bare-bones extended real class to define supremum. -/"}, {"content": "instance ExtendedReal.inst_Top : Top ExtendedReal where\n  top := infty", "line_number": 188, "declaration_attribute": "", "comment": "/-- Mathlib prefers ⊤ to denote the +∞ element. -/"}, {"content": "instance ExtendedReal.inst_Bot: Bot ExtendedReal where\n  bot := infty", "line_number": 192, "declaration_attribute": "", "comment": "/-- Mathlib prefers ⊥ to denote the -∞ element.-/"}, {"content": "instance ExtendedReal.coe_real : Coe Real ExtendedReal where\n  coe x := ExtendedReal.real x", "line_number": 195, "declaration_attribute": "", "comment": ""}, {"content": "instance ExtendedReal.real_coe : Coe ExtendedReal Real where\n  coe X := match X with\n  | neg_infty => 0\n  | real x => x\n  | infty => 0", "line_number": 198, "declaration_attribute": "", "comment": ""}, {"content": "abbrev ExtendedReal.IsFinite (X : ExtendedReal) : Prop := match X with\n  | neg_infty => False\n  | real _ => True\n  | infty => False", "line_number": 204, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev ExtendedReal.sup (E: Set Real) : ExtendedReal :=\n  if h1:E.Nonempty then (if h2:BddAbove E then ((Real.LUB_exist h1 h2).choose:Real) else ⊤) else ⊥", "line_number": 216, "declaration_attribute": "", "comment": "/-- Definition 5.5.10 (Supremum)-/"}, {"content": "noncomputable abbrev ExtendedReal.inf (E: Set Real) : ExtendedReal :=\n  if h1:E.Nonempty then (if h2:BddBelow E then ((Real.GLB_exist h1 h2).choose:Real) else ⊥) else ⊤", "line_number": 299, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Real.inst_SupSet : SupSet Real where\n  sSup E := ((ExtendedReal.sup E):Real)", "line_number": 325, "declaration_attribute": "", "comment": "/- Use the notion of supremum in this section to define a Mathlib `sSup` operation -/"}, {"content": "noncomputable instance Real.inst_conditionallyCompleteLattice :\n    ConditionallyCompleteLattice Real :=\n  conditionallyCompleteLatticeOfsSup Real (fun _ _ ↦ Set.Finite.bddAbove (by norm_num))\n  (fun _ _ ↦ Set.Finite.bddBelow (by norm_num))\n  (by intros; solve_by_elim [ExtendedReal.sup_of_bounded])", "line_number": 329, "declaration_attribute": "", "comment": "/-- Use the `sSup` operation to build a conditionally complete lattice structure on `Real`-/"}]}
{"chapter_name": "Section_5_5", "line_number": 91, "content": "\ntheorem Real.LIM_of_Cauchy {q:ℕ → ℚ} (hq: ∀ M, ∀ n ≥ M, ∀ n' ≥ M, |q n - q n'| ≤ 1 / (M+1)) :\n    (q:Sequence).IsCauchy ∧ ∀ M, |q M - LIM q| ≤ 1 / (M+1) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "inductive ExtendedReal where\n| neg_infty : ExtendedReal\n| real (x:Real) : ExtendedReal\n| infty : ExtendedReal", "line_number": 182, "declaration_attribute": "", "comment": "/-- A bare-bones extended real class to define supremum. -/"}, {"content": "instance ExtendedReal.inst_Top : Top ExtendedReal where\n  top := infty", "line_number": 188, "declaration_attribute": "", "comment": "/-- Mathlib prefers ⊤ to denote the +∞ element. -/"}, {"content": "instance ExtendedReal.inst_Bot: Bot ExtendedReal where\n  bot := infty", "line_number": 192, "declaration_attribute": "", "comment": "/-- Mathlib prefers ⊥ to denote the -∞ element.-/"}, {"content": "instance ExtendedReal.coe_real : Coe Real ExtendedReal where\n  coe x := ExtendedReal.real x", "line_number": 195, "declaration_attribute": "", "comment": ""}, {"content": "instance ExtendedReal.real_coe : Coe ExtendedReal Real where\n  coe X := match X with\n  | neg_infty => 0\n  | real x => x\n  | infty => 0", "line_number": 198, "declaration_attribute": "", "comment": ""}, {"content": "abbrev ExtendedReal.IsFinite (X : ExtendedReal) : Prop := match X with\n  | neg_infty => False\n  | real _ => True\n  | infty => False", "line_number": 204, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev ExtendedReal.sup (E: Set Real) : ExtendedReal :=\n  if h1:E.Nonempty then (if h2:BddAbove E then ((Real.LUB_exist h1 h2).choose:Real) else ⊤) else ⊥", "line_number": 216, "declaration_attribute": "", "comment": "/-- Definition 5.5.10 (Supremum)-/"}, {"content": "noncomputable abbrev ExtendedReal.inf (E: Set Real) : ExtendedReal :=\n  if h1:E.Nonempty then (if h2:BddBelow E then ((Real.GLB_exist h1 h2).choose:Real) else ⊥) else ⊤", "line_number": 299, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Real.inst_SupSet : SupSet Real where\n  sSup E := ((ExtendedReal.sup E):Real)", "line_number": 325, "declaration_attribute": "", "comment": "/- Use the notion of supremum in this section to define a Mathlib `sSup` operation -/"}, {"content": "noncomputable instance Real.inst_conditionallyCompleteLattice :\n    ConditionallyCompleteLattice Real :=\n  conditionallyCompleteLatticeOfsSup Real (fun _ _ ↦ Set.Finite.bddAbove (by norm_num))\n  (fun _ _ ↦ Set.Finite.bddBelow (by norm_num))\n  (by intros; solve_by_elim [ExtendedReal.sup_of_bounded])", "line_number": 329, "declaration_attribute": "", "comment": "/-- Use the `sSup` operation to build a conditionally complete lattice structure on `Real`-/"}]}
{"chapter_name": "Section_5_5", "line_number": 318, "content": "\ntheorem Real.inf_neg {E: Set Real} {M:Real} (h: IsLUB E M) : IsGLB (-E) (-M) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "inductive ExtendedReal where\n| neg_infty : ExtendedReal\n| real (x:Real) : ExtendedReal\n| infty : ExtendedReal", "line_number": 182, "declaration_attribute": "", "comment": "/-- A bare-bones extended real class to define supremum. -/"}, {"content": "instance ExtendedReal.inst_Top : Top ExtendedReal where\n  top := infty", "line_number": 188, "declaration_attribute": "", "comment": "/-- Mathlib prefers ⊤ to denote the +∞ element. -/"}, {"content": "instance ExtendedReal.inst_Bot: Bot ExtendedReal where\n  bot := infty", "line_number": 192, "declaration_attribute": "", "comment": "/-- Mathlib prefers ⊥ to denote the -∞ element.-/"}, {"content": "instance ExtendedReal.coe_real : Coe Real ExtendedReal where\n  coe x := ExtendedReal.real x", "line_number": 195, "declaration_attribute": "", "comment": ""}, {"content": "instance ExtendedReal.real_coe : Coe ExtendedReal Real where\n  coe X := match X with\n  | neg_infty => 0\n  | real x => x\n  | infty => 0", "line_number": 198, "declaration_attribute": "", "comment": ""}, {"content": "abbrev ExtendedReal.IsFinite (X : ExtendedReal) : Prop := match X with\n  | neg_infty => False\n  | real _ => True\n  | infty => False", "line_number": 204, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev ExtendedReal.sup (E: Set Real) : ExtendedReal :=\n  if h1:E.Nonempty then (if h2:BddAbove E then ((Real.LUB_exist h1 h2).choose:Real) else ⊤) else ⊥", "line_number": 216, "declaration_attribute": "", "comment": "/-- Definition 5.5.10 (Supremum)-/"}, {"content": "noncomputable abbrev ExtendedReal.inf (E: Set Real) : ExtendedReal :=\n  if h1:E.Nonempty then (if h2:BddBelow E then ((Real.GLB_exist h1 h2).choose:Real) else ⊥) else ⊤", "line_number": 299, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Real.inst_SupSet : SupSet Real where\n  sSup E := ((ExtendedReal.sup E):Real)", "line_number": 325, "declaration_attribute": "", "comment": "/- Use the notion of supremum in this section to define a Mathlib `sSup` operation -/"}, {"content": "noncomputable instance Real.inst_conditionallyCompleteLattice :\n    ConditionallyCompleteLattice Real :=\n  conditionallyCompleteLatticeOfsSup Real (fun _ _ ↦ Set.Finite.bddAbove (by norm_num))\n  (fun _ _ ↦ Set.Finite.bddBelow (by norm_num))\n  (by intros; solve_by_elim [ExtendedReal.sup_of_bounded])", "line_number": 329, "declaration_attribute": "", "comment": "/-- Use the `sSup` operation to build a conditionally complete lattice structure on `Real`-/"}]}
{"chapter_name": "Section_5_5", "line_number": 321, "content": "\ntheorem Real.irrat_between {x y:Real} (hxy: x < y) :\n    ∃ z, x < z ∧ z < y ∧ ¬ ∃ q:ℚ, z = (q:Real) := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "inductive ExtendedReal where\n| neg_infty : ExtendedReal\n| real (x:Real) : ExtendedReal\n| infty : ExtendedReal", "line_number": 182, "declaration_attribute": "", "comment": "/-- A bare-bones extended real class to define supremum. -/"}, {"content": "instance ExtendedReal.inst_Top : Top ExtendedReal where\n  top := infty", "line_number": 188, "declaration_attribute": "", "comment": "/-- Mathlib prefers ⊤ to denote the +∞ element. -/"}, {"content": "instance ExtendedReal.inst_Bot: Bot ExtendedReal where\n  bot := infty", "line_number": 192, "declaration_attribute": "", "comment": "/-- Mathlib prefers ⊥ to denote the -∞ element.-/"}, {"content": "instance ExtendedReal.coe_real : Coe Real ExtendedReal where\n  coe x := ExtendedReal.real x", "line_number": 195, "declaration_attribute": "", "comment": ""}, {"content": "instance ExtendedReal.real_coe : Coe ExtendedReal Real where\n  coe X := match X with\n  | neg_infty => 0\n  | real x => x\n  | infty => 0", "line_number": 198, "declaration_attribute": "", "comment": ""}, {"content": "abbrev ExtendedReal.IsFinite (X : ExtendedReal) : Prop := match X with\n  | neg_infty => False\n  | real _ => True\n  | infty => False", "line_number": 204, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev ExtendedReal.sup (E: Set Real) : ExtendedReal :=\n  if h1:E.Nonempty then (if h2:BddAbove E then ((Real.LUB_exist h1 h2).choose:Real) else ⊤) else ⊥", "line_number": 216, "declaration_attribute": "", "comment": "/-- Definition 5.5.10 (Supremum)-/"}, {"content": "noncomputable abbrev ExtendedReal.inf (E: Set Real) : ExtendedReal :=\n  if h1:E.Nonempty then (if h2:BddBelow E then ((Real.GLB_exist h1 h2).choose:Real) else ⊥) else ⊤", "line_number": 299, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Real.inst_SupSet : SupSet Real where\n  sSup E := ((ExtendedReal.sup E):Real)", "line_number": 325, "declaration_attribute": "", "comment": "/- Use the notion of supremum in this section to define a Mathlib `sSup` operation -/"}, {"content": "noncomputable instance Real.inst_conditionallyCompleteLattice :\n    ConditionallyCompleteLattice Real :=\n  conditionallyCompleteLatticeOfsSup Real (fun _ _ ↦ Set.Finite.bddAbove (by norm_num))\n  (fun _ _ ↦ Set.Finite.bddBelow (by norm_num))\n  (by intros; solve_by_elim [ExtendedReal.sup_of_bounded])", "line_number": 329, "declaration_attribute": "", "comment": "/-- Use the `sSup` operation to build a conditionally complete lattice structure on `Real`-/"}]}
{"chapter_name": "Section_5_6", "line_number": 255, "content": "\ntheorem Real.pow_even (x:Real) {n:ℕ} (hn: Even n) : x^n ≥ 0 := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "noncomputable abbrev Real.root (x:Real) (n:ℕ) : Real := sSup { y:Real | y ≥ 0 ∧ y^n ≤ x }", "line_number": 101, "declaration_attribute": "", "comment": "/-- Definition 5.6.2.  We permit ``junk values'' when `x` is negative or `n` vanishes. -/"}, {"content": "noncomputable abbrev Real.sqrt (x:Real) := x.root 2", "line_number": 103, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.ratPow (x:Real) (q:ℚ) : Real := (x.root q.den)^(q.num)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 5.6.7 -/"}, {"content": "noncomputable instance Real.instRatPow : Pow Real ℚ where\n  pow x q := x.ratPow q", "line_number": 170, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_5_6", "line_number": 258, "content": "\ntheorem Real.max_ratPow {x y:Real} (hx: x > 0) (hy: y > 0) {q:ℚ} (hq: q > 0) :\n  max (x^q) y^q = (max x y)^q := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "noncomputable abbrev Real.root (x:Real) (n:ℕ) : Real := sSup { y:Real | y ≥ 0 ∧ y^n ≤ x }", "line_number": 101, "declaration_attribute": "", "comment": "/-- Definition 5.6.2.  We permit ``junk values'' when `x` is negative or `n` vanishes. -/"}, {"content": "noncomputable abbrev Real.sqrt (x:Real) := x.root 2", "line_number": 103, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Real.ratPow (x:Real) (q:ℚ) : Real := (x.root q.den)^(q.num)", "line_number": 168, "declaration_attribute": "", "comment": "/-- Definition 5.6.7 -/"}, {"content": "noncomputable instance Real.instRatPow : Pow Real ℚ where\n  pow x q := x.ratPow q", "line_number": 170, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_6_1", "line_number": 241, "content": "\ntheorem Sequence.tendsTo_iff (a:Sequence) (L:ℝ) :\n  a.TendsTo L ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - L| ≤ ε := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Close (ε x y : ℝ) : Prop := dist x y ≤ ε", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "structure Sequence where\n  m : ℤ\n  seq : ℤ → ℝ\n  vanish : ∀ n < m, seq n = 0", "line_number": 41, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 6.1.3 (Sequence). This is similar to the Chapter 5 sequence, except that now the\n  sequence is real-valued. As with Chapter 5, we start sequences from 0 by default.\n-/"}, {"content": "instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℝ) where\n  coe := fun a ↦ a.seq", "line_number": 47, "declaration_attribute": "", "comment": "/-- Sequences can be thought of as functions from ℤ to ℝ. -/"}, {"content": "abbrev Sequence.ofNatFun (a:ℕ → ℝ) : Sequence :=\n {\n    m := 0\n    seq := fun n ↦ if n ≥ 0 then a n.toNat else 0\n    vanish := by intros; simp_all\n }", "line_number": 51, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Sequence.instCoe : Coe (ℕ → ℝ) Sequence where\n  coe := ofNatFun", "line_number": 59, "declaration_attribute": "", "comment": "/-- Functions from ℕ to ℝ can be thought of as sequences. -/"}, {"content": "abbrev Sequence.mk' (m:ℤ) (a: { n // n ≥ m } → ℝ) : Sequence where\n  m := m\n  seq := fun n ↦ if h : n ≥ m then a ⟨n, h⟩ else 0\n  vanish := by intros; simp_all", "line_number": 63, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.from (a:Sequence) (m₁:ℤ) : Sequence := mk' (max a.m m₁) (a ↑·)", "line_number": 79, "declaration_attribute": "", "comment": "/--\n  a.from n₁ starts `a:Sequence` from `n₁`.  It is intended for use when `n₁ ≥ n₀`, but returns\n  the \"junk\" value of the original sequence `a` otherwise.\n-/"}, {"content": "abbrev Real.Steady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∀ n ≥ a.m, ∀ m ≥ a.m, ε.Close (a n) (a m)", "line_number": 88, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (ε-steady) -/"}, {"content": "abbrev Real.EventuallySteady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∃ N ≥ a.m, ε.Steady (a.from N)", "line_number": 96, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Eventually ε-steady) -/"}, {"content": "abbrev Sequence.IsCauchy (a:Sequence) : Prop := ∀ ε > (0:ℝ), ε.EventuallySteady a", "line_number": 120, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Cauchy sequence) -/"}, {"content": "abbrev Sequence.ofChapter5Sequence (a: Chapter5.Sequence) : Sequence :=\n{\n  m := a.n₀\n  seq := fun n ↦ (a n:ℝ)\n  vanish := by intro n hn; simp [a.vanish n hn]\n}", "line_number": 161, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Chapter5.Sequence.inst_coe_sequence : Coe Chapter5.Sequence Sequence  where\n  coe := Sequence.ofChapter5Sequence", "line_number": 168, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.CloseSeq (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop := ∀ n ≥ a.m, ε.Close (a n) L", "line_number": 202, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Real.EventuallyClose (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop :=\n  ∃ N ≥ a.m, ε.CloseSeq (a.from N) L", "line_number": 209, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Sequence.TendsTo (a:Sequence) (L:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.EventuallyClose a L", "line_number": 234, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable def seq_6_1_6 : Sequence := (fun (n:ℕ) ↦ 1-(10:ℝ)^(-(n:ℤ)-1):Sequence)", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.Convergent (a:Sequence) : Prop := ∃ L, a.TendsTo L", "line_number": 295, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "abbrev Sequence.Divergent (a:Sequence) : Prop := ¬ a.Convergent", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "noncomputable abbrev lim (a:Sequence) : ℝ := if h: a.Convergent then h.choose else 0", "line_number": 310, "declaration_attribute": "", "comment": "/--\n  Definition 6.1.8.  We give the limit of a sequence the junk value of 0 if it is not convergent.\n-/"}, {"content": "abbrev Sequence.BoundedBy (a:Sequence) (M:ℝ) : Prop :=\n  ∀ n, |a n| ≤ M", "line_number": 370, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "abbrev Sequence.IsBounded (a:Sequence) : Prop := ∃ M ≥ 0, a.BoundedBy M", "line_number": 378, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "instance Sequence.inst_add : Add Sequence where\n  add a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n + b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 397, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_mul : Mul Sequence where\n  mul a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n * b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 418, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_smul : SMul ℝ Sequence where\n  smul c a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ c * a n\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 440, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_sub : Sub Sequence where\n  sub a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n - b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 461, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_inv : Inv Sequence where\n  inv a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ (a n)⁻¹\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 482, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_div : Div Sequence where\n  div a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n / b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 504, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_max : Max Sequence where\n  max a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then max (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 525, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_min : Min Sequence where\n  min a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then min (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 546, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_6_1", "line_number": 576, "content": "\ntheorem Sequence.tendsTo_of_shift {a: Sequence} {c:ℝ} (k:ℕ) :\n    a.TendsTo c ↔ (Sequence.mk' a.m (fun n : {n // n ≥ a.m} ↦ a (n+k))).TendsTo c := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Close (ε x y : ℝ) : Prop := dist x y ≤ ε", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "structure Sequence where\n  m : ℤ\n  seq : ℤ → ℝ\n  vanish : ∀ n < m, seq n = 0", "line_number": 41, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 6.1.3 (Sequence). This is similar to the Chapter 5 sequence, except that now the\n  sequence is real-valued. As with Chapter 5, we start sequences from 0 by default.\n-/"}, {"content": "instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℝ) where\n  coe := fun a ↦ a.seq", "line_number": 47, "declaration_attribute": "", "comment": "/-- Sequences can be thought of as functions from ℤ to ℝ. -/"}, {"content": "abbrev Sequence.ofNatFun (a:ℕ → ℝ) : Sequence :=\n {\n    m := 0\n    seq := fun n ↦ if n ≥ 0 then a n.toNat else 0\n    vanish := by intros; simp_all\n }", "line_number": 51, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Sequence.instCoe : Coe (ℕ → ℝ) Sequence where\n  coe := ofNatFun", "line_number": 59, "declaration_attribute": "", "comment": "/-- Functions from ℕ to ℝ can be thought of as sequences. -/"}, {"content": "abbrev Sequence.mk' (m:ℤ) (a: { n // n ≥ m } → ℝ) : Sequence where\n  m := m\n  seq := fun n ↦ if h : n ≥ m then a ⟨n, h⟩ else 0\n  vanish := by intros; simp_all", "line_number": 63, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.from (a:Sequence) (m₁:ℤ) : Sequence := mk' (max a.m m₁) (a ↑·)", "line_number": 79, "declaration_attribute": "", "comment": "/--\n  a.from n₁ starts `a:Sequence` from `n₁`.  It is intended for use when `n₁ ≥ n₀`, but returns\n  the \"junk\" value of the original sequence `a` otherwise.\n-/"}, {"content": "abbrev Real.Steady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∀ n ≥ a.m, ∀ m ≥ a.m, ε.Close (a n) (a m)", "line_number": 88, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (ε-steady) -/"}, {"content": "abbrev Real.EventuallySteady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∃ N ≥ a.m, ε.Steady (a.from N)", "line_number": 96, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Eventually ε-steady) -/"}, {"content": "abbrev Sequence.IsCauchy (a:Sequence) : Prop := ∀ ε > (0:ℝ), ε.EventuallySteady a", "line_number": 120, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Cauchy sequence) -/"}, {"content": "abbrev Sequence.ofChapter5Sequence (a: Chapter5.Sequence) : Sequence :=\n{\n  m := a.n₀\n  seq := fun n ↦ (a n:ℝ)\n  vanish := by intro n hn; simp [a.vanish n hn]\n}", "line_number": 161, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Chapter5.Sequence.inst_coe_sequence : Coe Chapter5.Sequence Sequence  where\n  coe := Sequence.ofChapter5Sequence", "line_number": 168, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.CloseSeq (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop := ∀ n ≥ a.m, ε.Close (a n) L", "line_number": 202, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Real.EventuallyClose (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop :=\n  ∃ N ≥ a.m, ε.CloseSeq (a.from N) L", "line_number": 209, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Sequence.TendsTo (a:Sequence) (L:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.EventuallyClose a L", "line_number": 234, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable def seq_6_1_6 : Sequence := (fun (n:ℕ) ↦ 1-(10:ℝ)^(-(n:ℤ)-1):Sequence)", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.Convergent (a:Sequence) : Prop := ∃ L, a.TendsTo L", "line_number": 295, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "abbrev Sequence.Divergent (a:Sequence) : Prop := ¬ a.Convergent", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "noncomputable abbrev lim (a:Sequence) : ℝ := if h: a.Convergent then h.choose else 0", "line_number": 310, "declaration_attribute": "", "comment": "/--\n  Definition 6.1.8.  We give the limit of a sequence the junk value of 0 if it is not convergent.\n-/"}, {"content": "abbrev Sequence.BoundedBy (a:Sequence) (M:ℝ) : Prop :=\n  ∀ n, |a n| ≤ M", "line_number": 370, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "abbrev Sequence.IsBounded (a:Sequence) : Prop := ∃ M ≥ 0, a.BoundedBy M", "line_number": 378, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "instance Sequence.inst_add : Add Sequence where\n  add a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n + b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 397, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_mul : Mul Sequence where\n  mul a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n * b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 418, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_smul : SMul ℝ Sequence where\n  smul c a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ c * a n\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 440, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_sub : Sub Sequence where\n  sub a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n - b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 461, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_inv : Inv Sequence where\n  inv a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ (a n)⁻¹\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 482, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_div : Div Sequence where\n  div a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n / b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 504, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_max : Max Sequence where\n  max a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then max (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 525, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_min : Min Sequence where\n  min a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then min (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 546, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_6_1", "line_number": 586, "content": "\ntheorem Sequence.lim_div_fail :\n    ∃ a b, a.Convergent\n    ∧ b.Convergent\n    ∧ lim b = 0\n    ∧ ¬ ((a / b).Convergent ∧ lim (a / b) = lim a / lim b) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Close (ε x y : ℝ) : Prop := dist x y ≤ ε", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "structure Sequence where\n  m : ℤ\n  seq : ℤ → ℝ\n  vanish : ∀ n < m, seq n = 0", "line_number": 41, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 6.1.3 (Sequence). This is similar to the Chapter 5 sequence, except that now the\n  sequence is real-valued. As with Chapter 5, we start sequences from 0 by default.\n-/"}, {"content": "instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℝ) where\n  coe := fun a ↦ a.seq", "line_number": 47, "declaration_attribute": "", "comment": "/-- Sequences can be thought of as functions from ℤ to ℝ. -/"}, {"content": "abbrev Sequence.ofNatFun (a:ℕ → ℝ) : Sequence :=\n {\n    m := 0\n    seq := fun n ↦ if n ≥ 0 then a n.toNat else 0\n    vanish := by intros; simp_all\n }", "line_number": 51, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Sequence.instCoe : Coe (ℕ → ℝ) Sequence where\n  coe := ofNatFun", "line_number": 59, "declaration_attribute": "", "comment": "/-- Functions from ℕ to ℝ can be thought of as sequences. -/"}, {"content": "abbrev Sequence.mk' (m:ℤ) (a: { n // n ≥ m } → ℝ) : Sequence where\n  m := m\n  seq := fun n ↦ if h : n ≥ m then a ⟨n, h⟩ else 0\n  vanish := by intros; simp_all", "line_number": 63, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.from (a:Sequence) (m₁:ℤ) : Sequence := mk' (max a.m m₁) (a ↑·)", "line_number": 79, "declaration_attribute": "", "comment": "/--\n  a.from n₁ starts `a:Sequence` from `n₁`.  It is intended for use when `n₁ ≥ n₀`, but returns\n  the \"junk\" value of the original sequence `a` otherwise.\n-/"}, {"content": "abbrev Real.Steady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∀ n ≥ a.m, ∀ m ≥ a.m, ε.Close (a n) (a m)", "line_number": 88, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (ε-steady) -/"}, {"content": "abbrev Real.EventuallySteady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∃ N ≥ a.m, ε.Steady (a.from N)", "line_number": 96, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Eventually ε-steady) -/"}, {"content": "abbrev Sequence.IsCauchy (a:Sequence) : Prop := ∀ ε > (0:ℝ), ε.EventuallySteady a", "line_number": 120, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Cauchy sequence) -/"}, {"content": "abbrev Sequence.ofChapter5Sequence (a: Chapter5.Sequence) : Sequence :=\n{\n  m := a.n₀\n  seq := fun n ↦ (a n:ℝ)\n  vanish := by intro n hn; simp [a.vanish n hn]\n}", "line_number": 161, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Chapter5.Sequence.inst_coe_sequence : Coe Chapter5.Sequence Sequence  where\n  coe := Sequence.ofChapter5Sequence", "line_number": 168, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.CloseSeq (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop := ∀ n ≥ a.m, ε.Close (a n) L", "line_number": 202, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Real.EventuallyClose (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop :=\n  ∃ N ≥ a.m, ε.CloseSeq (a.from N) L", "line_number": 209, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Sequence.TendsTo (a:Sequence) (L:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.EventuallyClose a L", "line_number": 234, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable def seq_6_1_6 : Sequence := (fun (n:ℕ) ↦ 1-(10:ℝ)^(-(n:ℤ)-1):Sequence)", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.Convergent (a:Sequence) : Prop := ∃ L, a.TendsTo L", "line_number": 295, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "abbrev Sequence.Divergent (a:Sequence) : Prop := ¬ a.Convergent", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "noncomputable abbrev lim (a:Sequence) : ℝ := if h: a.Convergent then h.choose else 0", "line_number": 310, "declaration_attribute": "", "comment": "/--\n  Definition 6.1.8.  We give the limit of a sequence the junk value of 0 if it is not convergent.\n-/"}, {"content": "abbrev Sequence.BoundedBy (a:Sequence) (M:ℝ) : Prop :=\n  ∀ n, |a n| ≤ M", "line_number": 370, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "abbrev Sequence.IsBounded (a:Sequence) : Prop := ∃ M ≥ 0, a.BoundedBy M", "line_number": 378, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "instance Sequence.inst_add : Add Sequence where\n  add a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n + b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 397, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_mul : Mul Sequence where\n  mul a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n * b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 418, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_smul : SMul ℝ Sequence where\n  smul c a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ c * a n\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 440, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_sub : Sub Sequence where\n  sub a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n - b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 461, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_inv : Inv Sequence where\n  inv a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ (a n)⁻¹\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 482, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_div : Div Sequence where\n  div a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n / b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 504, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_max : Max Sequence where\n  max a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then max (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 525, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_min : Min Sequence where\n  min a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then min (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 546, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_6_1", "line_number": 594, "content": "\ntheorem Chapter5.Sequence.IsCauchy_iff (a:Chapter5.Sequence) :\n    a.IsCauchy ↔ ∀ ε > (0:ℝ), ∃ N ≥ a.n₀, ∀ n ≥ N, ∀ m ≥ N, |a n - a m| ≤ ε := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Close (ε x y : ℝ) : Prop := dist x y ≤ ε", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "structure Sequence where\n  m : ℤ\n  seq : ℤ → ℝ\n  vanish : ∀ n < m, seq n = 0", "line_number": 41, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 6.1.3 (Sequence). This is similar to the Chapter 5 sequence, except that now the\n  sequence is real-valued. As with Chapter 5, we start sequences from 0 by default.\n-/"}, {"content": "instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℝ) where\n  coe := fun a ↦ a.seq", "line_number": 47, "declaration_attribute": "", "comment": "/-- Sequences can be thought of as functions from ℤ to ℝ. -/"}, {"content": "abbrev Sequence.ofNatFun (a:ℕ → ℝ) : Sequence :=\n {\n    m := 0\n    seq := fun n ↦ if n ≥ 0 then a n.toNat else 0\n    vanish := by intros; simp_all\n }", "line_number": 51, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Sequence.instCoe : Coe (ℕ → ℝ) Sequence where\n  coe := ofNatFun", "line_number": 59, "declaration_attribute": "", "comment": "/-- Functions from ℕ to ℝ can be thought of as sequences. -/"}, {"content": "abbrev Sequence.mk' (m:ℤ) (a: { n // n ≥ m } → ℝ) : Sequence where\n  m := m\n  seq := fun n ↦ if h : n ≥ m then a ⟨n, h⟩ else 0\n  vanish := by intros; simp_all", "line_number": 63, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.from (a:Sequence) (m₁:ℤ) : Sequence := mk' (max a.m m₁) (a ↑·)", "line_number": 79, "declaration_attribute": "", "comment": "/--\n  a.from n₁ starts `a:Sequence` from `n₁`.  It is intended for use when `n₁ ≥ n₀`, but returns\n  the \"junk\" value of the original sequence `a` otherwise.\n-/"}, {"content": "abbrev Real.Steady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∀ n ≥ a.m, ∀ m ≥ a.m, ε.Close (a n) (a m)", "line_number": 88, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (ε-steady) -/"}, {"content": "abbrev Real.EventuallySteady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∃ N ≥ a.m, ε.Steady (a.from N)", "line_number": 96, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Eventually ε-steady) -/"}, {"content": "abbrev Sequence.IsCauchy (a:Sequence) : Prop := ∀ ε > (0:ℝ), ε.EventuallySteady a", "line_number": 120, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Cauchy sequence) -/"}, {"content": "abbrev Sequence.ofChapter5Sequence (a: Chapter5.Sequence) : Sequence :=\n{\n  m := a.n₀\n  seq := fun n ↦ (a n:ℝ)\n  vanish := by intro n hn; simp [a.vanish n hn]\n}", "line_number": 161, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Chapter5.Sequence.inst_coe_sequence : Coe Chapter5.Sequence Sequence  where\n  coe := Sequence.ofChapter5Sequence", "line_number": 168, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.CloseSeq (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop := ∀ n ≥ a.m, ε.Close (a n) L", "line_number": 202, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Real.EventuallyClose (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop :=\n  ∃ N ≥ a.m, ε.CloseSeq (a.from N) L", "line_number": 209, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Sequence.TendsTo (a:Sequence) (L:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.EventuallyClose a L", "line_number": 234, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable def seq_6_1_6 : Sequence := (fun (n:ℕ) ↦ 1-(10:ℝ)^(-(n:ℤ)-1):Sequence)", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.Convergent (a:Sequence) : Prop := ∃ L, a.TendsTo L", "line_number": 295, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "abbrev Sequence.Divergent (a:Sequence) : Prop := ¬ a.Convergent", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "noncomputable abbrev lim (a:Sequence) : ℝ := if h: a.Convergent then h.choose else 0", "line_number": 310, "declaration_attribute": "", "comment": "/--\n  Definition 6.1.8.  We give the limit of a sequence the junk value of 0 if it is not convergent.\n-/"}, {"content": "abbrev Sequence.BoundedBy (a:Sequence) (M:ℝ) : Prop :=\n  ∀ n, |a n| ≤ M", "line_number": 370, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "abbrev Sequence.IsBounded (a:Sequence) : Prop := ∃ M ≥ 0, a.BoundedBy M", "line_number": 378, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "instance Sequence.inst_add : Add Sequence where\n  add a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n + b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 397, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_mul : Mul Sequence where\n  mul a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n * b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 418, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_smul : SMul ℝ Sequence where\n  smul c a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ c * a n\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 440, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_sub : Sub Sequence where\n  sub a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n - b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 461, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_inv : Inv Sequence where\n  inv a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ (a n)⁻¹\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 482, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_div : Div Sequence where\n  div a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n / b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 504, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_max : Max Sequence where\n  max a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then max (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 525, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_min : Min Sequence where\n  min a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then min (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 546, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_6_1", "line_number": 567, "content": "\ntheorem Sequence.mono_if {a: ℕ → ℝ} (ha: ∀ n, a (n+1) > a n) {n m:ℕ} (hnm: m > n) : a m > a n := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Close (ε x y : ℝ) : Prop := dist x y ≤ ε", "line_number": 26, "declaration_attribute": "", "comment": ""}, {"content": "structure Sequence where\n  m : ℤ\n  seq : ℤ → ℝ\n  vanish : ∀ n < m, seq n = 0", "line_number": 41, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 6.1.3 (Sequence). This is similar to the Chapter 5 sequence, except that now the\n  sequence is real-valued. As with Chapter 5, we start sequences from 0 by default.\n-/"}, {"content": "instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℝ) where\n  coe := fun a ↦ a.seq", "line_number": 47, "declaration_attribute": "", "comment": "/-- Sequences can be thought of as functions from ℤ to ℝ. -/"}, {"content": "abbrev Sequence.ofNatFun (a:ℕ → ℝ) : Sequence :=\n {\n    m := 0\n    seq := fun n ↦ if n ≥ 0 then a n.toNat else 0\n    vanish := by intros; simp_all\n }", "line_number": 51, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Sequence.instCoe : Coe (ℕ → ℝ) Sequence where\n  coe := ofNatFun", "line_number": 59, "declaration_attribute": "", "comment": "/-- Functions from ℕ to ℝ can be thought of as sequences. -/"}, {"content": "abbrev Sequence.mk' (m:ℤ) (a: { n // n ≥ m } → ℝ) : Sequence where\n  m := m\n  seq := fun n ↦ if h : n ≥ m then a ⟨n, h⟩ else 0\n  vanish := by intros; simp_all", "line_number": 63, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.from (a:Sequence) (m₁:ℤ) : Sequence := mk' (max a.m m₁) (a ↑·)", "line_number": 79, "declaration_attribute": "", "comment": "/--\n  a.from n₁ starts `a:Sequence` from `n₁`.  It is intended for use when `n₁ ≥ n₀`, but returns\n  the \"junk\" value of the original sequence `a` otherwise.\n-/"}, {"content": "abbrev Real.Steady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∀ n ≥ a.m, ∀ m ≥ a.m, ε.Close (a n) (a m)", "line_number": 88, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (ε-steady) -/"}, {"content": "abbrev Real.EventuallySteady (ε: ℝ) (a: Chapter6.Sequence) : Prop :=\n  ∃ N ≥ a.m, ε.Steady (a.from N)", "line_number": 96, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Eventually ε-steady) -/"}, {"content": "abbrev Sequence.IsCauchy (a:Sequence) : Prop := ∀ ε > (0:ℝ), ε.EventuallySteady a", "line_number": 120, "declaration_attribute": "", "comment": "/-- Definition 6.1.3 (Cauchy sequence) -/"}, {"content": "abbrev Sequence.ofChapter5Sequence (a: Chapter5.Sequence) : Sequence :=\n{\n  m := a.n₀\n  seq := fun n ↦ (a n:ℝ)\n  vanish := by intro n hn; simp [a.vanish n hn]\n}", "line_number": 161, "declaration_attribute": "@[coe]", "comment": ""}, {"content": "instance Chapter5.Sequence.inst_coe_sequence : Coe Chapter5.Sequence Sequence  where\n  coe := Sequence.ofChapter5Sequence", "line_number": 168, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.CloseSeq (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop := ∀ n ≥ a.m, ε.Close (a n) L", "line_number": 202, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Real.EventuallyClose (ε: ℝ) (a: Chapter6.Sequence) (L:ℝ) : Prop :=\n  ∃ N ≥ a.m, ε.CloseSeq (a.from N) L", "line_number": 209, "declaration_attribute": "", "comment": "/-- Definition 6.1.5 -/"}, {"content": "abbrev Sequence.TendsTo (a:Sequence) (L:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.EventuallyClose a L", "line_number": 234, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable def seq_6_1_6 : Sequence := (fun (n:ℕ) ↦ 1-(10:ℝ)^(-(n:ℤ)-1):Sequence)", "line_number": 244, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.Convergent (a:Sequence) : Prop := ∃ L, a.TendsTo L", "line_number": 295, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "abbrev Sequence.Divergent (a:Sequence) : Prop := ¬ a.Convergent", "line_number": 301, "declaration_attribute": "", "comment": "/-- Definition 6.1.8 -/"}, {"content": "noncomputable abbrev lim (a:Sequence) : ℝ := if h: a.Convergent then h.choose else 0", "line_number": 310, "declaration_attribute": "", "comment": "/--\n  Definition 6.1.8.  We give the limit of a sequence the junk value of 0 if it is not convergent.\n-/"}, {"content": "abbrev Sequence.BoundedBy (a:Sequence) (M:ℝ) : Prop :=\n  ∀ n, |a n| ≤ M", "line_number": 370, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "abbrev Sequence.IsBounded (a:Sequence) : Prop := ∃ M ≥ 0, a.BoundedBy M", "line_number": 378, "declaration_attribute": "", "comment": "/-- Definition 6.1.16 -/"}, {"content": "instance Sequence.inst_add : Add Sequence where\n  add a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n + b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 397, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_mul : Mul Sequence where\n  mul a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n * b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 418, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_smul : SMul ℝ Sequence where\n  smul c a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ c * a n\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 440, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_sub : Sub Sequence where\n  sub a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n - b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 461, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_inv : Inv Sequence where\n  inv a := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ (a n)⁻¹\n    vanish := by intro n hn; simp [a.vanish n hn]\n  }", "line_number": 482, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable instance Sequence.inst_div : Div Sequence where\n  div a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a n / b n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 504, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_max : Max Sequence where\n  max a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then max (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 525, "declaration_attribute": "", "comment": ""}, {"content": "instance Sequence.inst_min : Min Sequence where\n  min a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then min (a n) (b n) else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 546, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_6_3", "line_number": 143, "content": "\ntheorem lim_of_exp' {x:ℝ} (hbound: x > 1) : ¬((fun (n:ℕ) ↦ x^n):Sequence).Convergent := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "noncomputable abbrev Sequence.sup (a:Sequence) : EReal := sSup { x | ∃ n ≥ a.m, x = a n }", "line_number": 24, "declaration_attribute": "", "comment": "/-- Definition 6.3.1 -/"}, {"content": "noncomputable abbrev Sequence.inf (a:Sequence) : EReal := sInf { x | ∃ n ≥ a.m, x = a n }", "line_number": 27, "declaration_attribute": "", "comment": "/-- Definition 6.3.1 -/"}, {"content": "abbrev Sequence.BddAboveBy (a:Sequence) (M:ℝ) : Prop := ∀ n ≥ a.m, a n ≤ M", "line_number": 47, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.BddAbove (a:Sequence) : Prop := ∃ M, a.BddAboveBy M", "line_number": 49, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.BddBelowBy (a:Sequence) (M:ℝ) : Prop := ∀ n ≥ a.m, a n ≥ M", "line_number": 51, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.BddBelow (a:Sequence) : Prop := ∃ M, a.BddBelowBy M", "line_number": 53, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.IsMonotone (a:Sequence) : Prop := ∀ n ≥ a.m, a (n+1) ≥ a n", "line_number": 81, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.IsAntitone (a:Sequence) : Prop := ∀ n ≥ a.m, a (n+1) ≤ a n", "line_number": 83, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_3_9 (n:ℕ) := ⌊ Real.pi * 10^n ⌋ / (10:ℝ)^n", "line_number": 106, "declaration_attribute": "", "comment": "/-- Example 6.3.9 -/"}]}
{"chapter_name": "Section_6_4", "line_number": 326, "content": "\ntheorem Sequence.sup_not_strict_mono : ∃ (a b:ℕ → ℝ), (∀ n, a n < b n) ∧ (a:Sequence).sup ≠ (b:Sequence).sup := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Adherent (ε:ℝ) (a:Chapter6.Sequence) (x:ℝ) := ∃ n ≥ a.m, ε.Close (a n) x", "line_number": 22, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.ContinuallyAdherent (ε:ℝ) (a:Chapter6.Sequence) (x:ℝ) :=\n  ∀ N ≥ a.m, ε.Adherent (a.from N) x", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.LimitPoint (a:Sequence) (x:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.ContinuallyAdherent a x", "line_number": 29, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_3 : Sequence := (fun (n:ℕ) ↦ 1 - (10:ℝ)^(-(n:ℤ)-1))", "line_number": 37, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_4 : Sequence :=\n  (fun (n:ℕ) ↦ (-1:ℝ)^n * (1 + (10:ℝ)^(-(n:ℤ)-1)))", "line_number": 51, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.upperseq (a:Sequence) : ℤ → EReal := fun N ↦ (a.from N).sup", "line_number": 78, "declaration_attribute": "", "comment": "/--\n  A technical issue uncovered by the formalization: the upper and lower sequences of a real\n  sequence take values in the extended reals rather than the reals, so the definitions need to be\n  adjusted accordingly.\n-/"}, {"content": "noncomputable abbrev Sequence.limsup (a:Sequence) : EReal :=\n  sInf { x | ∃ N ≥ a.m, x = a.upperseq N }", "line_number": 80, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.lowerseq (a:Sequence) : ℤ → EReal := fun N ↦ (a.from N).inf", "line_number": 83, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.liminf (a:Sequence) : EReal :=\n  sSup { x | ∃ N ≥ a.m, x = a.lowerseq N }", "line_number": 85, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_7 : Sequence := (fun (n:ℕ) ↦ (-1:ℝ)^n * (1 + (10:ℝ)^(-(n:ℤ)-1)))", "line_number": 88, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_8 : Sequence := (fun (n:ℕ) ↦ if Even n then (n+1:ℝ) else -(n:ℝ)-1)", "line_number": 107, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_9 : Sequence :=\n  (fun (n:ℕ) ↦ if Even n then (n+1:ℝ)⁻¹ else -(n+1:ℝ)⁻¹)", "line_number": 117, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_10 : Sequence := (fun (n:ℕ) ↦ (n+1:ℝ))", "line_number": 128, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.abs (a:Sequence) : Sequence where\n  m := a.m\n  seq := fun n ↦ |a n|\n  vanish := by intro n hn; simp [a.vanish n hn]", "line_number": 238, "declaration_attribute": "", "comment": ""}, {"content": "def Sequence.tendsTo_real_iff :\n  Decidable (∀ (a:Sequence) (x:ℝ), a.TendsTo x ↔ a.abs.TendsTo x) := by\n  -- The first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 330, "declaration_attribute": "", "comment": "/- Exercise 6.4.7 -/"}, {"content": "abbrev Sequence.ExtendedLimitPoint (a:Sequence) (x:EReal) : Prop := if x = ⊤ then ¬ a.BddAbove else if x = ⊥ then ¬ a.BddBelow else a.LimitPoint x.toReal", "line_number": 336, "declaration_attribute": "", "comment": "/-- This definition is needed for Exercises 6.4.8 and 6.4.9. -/"}]}
{"chapter_name": "Section_6_4", "line_number": 352, "content": "\ntheorem Sequence.limit_points_of_limit_points {a b:Sequence} {c:ℝ} (hab: ∀ n ≥ b.m, a.LimitPoint (b n)) (hbc: b.LimitPoint c) : a.LimitPoint c := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Adherent (ε:ℝ) (a:Chapter6.Sequence) (x:ℝ) := ∃ n ≥ a.m, ε.Close (a n) x", "line_number": 22, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.ContinuallyAdherent (ε:ℝ) (a:Chapter6.Sequence) (x:ℝ) :=\n  ∀ N ≥ a.m, ε.Adherent (a.from N) x", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.LimitPoint (a:Sequence) (x:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.ContinuallyAdherent a x", "line_number": 29, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_3 : Sequence := (fun (n:ℕ) ↦ 1 - (10:ℝ)^(-(n:ℤ)-1))", "line_number": 37, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_4 : Sequence :=\n  (fun (n:ℕ) ↦ (-1:ℝ)^n * (1 + (10:ℝ)^(-(n:ℤ)-1)))", "line_number": 51, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.upperseq (a:Sequence) : ℤ → EReal := fun N ↦ (a.from N).sup", "line_number": 78, "declaration_attribute": "", "comment": "/--\n  A technical issue uncovered by the formalization: the upper and lower sequences of a real\n  sequence take values in the extended reals rather than the reals, so the definitions need to be\n  adjusted accordingly.\n-/"}, {"content": "noncomputable abbrev Sequence.limsup (a:Sequence) : EReal :=\n  sInf { x | ∃ N ≥ a.m, x = a.upperseq N }", "line_number": 80, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.lowerseq (a:Sequence) : ℤ → EReal := fun N ↦ (a.from N).inf", "line_number": 83, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.liminf (a:Sequence) : EReal :=\n  sSup { x | ∃ N ≥ a.m, x = a.lowerseq N }", "line_number": 85, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_7 : Sequence := (fun (n:ℕ) ↦ (-1:ℝ)^n * (1 + (10:ℝ)^(-(n:ℤ)-1)))", "line_number": 88, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_8 : Sequence := (fun (n:ℕ) ↦ if Even n then (n+1:ℝ) else -(n:ℝ)-1)", "line_number": 107, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_9 : Sequence :=\n  (fun (n:ℕ) ↦ if Even n then (n+1:ℝ)⁻¹ else -(n+1:ℝ)⁻¹)", "line_number": 117, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_10 : Sequence := (fun (n:ℕ) ↦ (n+1:ℝ))", "line_number": 128, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.abs (a:Sequence) : Sequence where\n  m := a.m\n  seq := fun n ↦ |a n|\n  vanish := by intro n hn; simp [a.vanish n hn]", "line_number": 238, "declaration_attribute": "", "comment": ""}, {"content": "def Sequence.tendsTo_real_iff :\n  Decidable (∀ (a:Sequence) (x:ℝ), a.TendsTo x ↔ a.abs.TendsTo x) := by\n  -- The first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 330, "declaration_attribute": "", "comment": "/- Exercise 6.4.7 -/"}, {"content": "abbrev Sequence.ExtendedLimitPoint (a:Sequence) (x:EReal) : Prop := if x = ⊤ then ¬ a.BddAbove else if x = ⊥ then ¬ a.BddBelow else a.LimitPoint x.toReal", "line_number": 336, "declaration_attribute": "", "comment": "/-- This definition is needed for Exercises 6.4.8 and 6.4.9. -/"}]}
{"chapter_name": "Section_6_4", "line_number": 342, "content": "\ntheorem Sequence.extended_limit_point_of_liminf (a:Sequence) : a.ExtendedLimitPoint a.liminf := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Adherent (ε:ℝ) (a:Chapter6.Sequence) (x:ℝ) := ∃ n ≥ a.m, ε.Close (a n) x", "line_number": 22, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.ContinuallyAdherent (ε:ℝ) (a:Chapter6.Sequence) (x:ℝ) :=\n  ∀ N ≥ a.m, ε.Adherent (a.from N) x", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.LimitPoint (a:Sequence) (x:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.ContinuallyAdherent a x", "line_number": 29, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_3 : Sequence := (fun (n:ℕ) ↦ 1 - (10:ℝ)^(-(n:ℤ)-1))", "line_number": 37, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_4 : Sequence :=\n  (fun (n:ℕ) ↦ (-1:ℝ)^n * (1 + (10:ℝ)^(-(n:ℤ)-1)))", "line_number": 51, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.upperseq (a:Sequence) : ℤ → EReal := fun N ↦ (a.from N).sup", "line_number": 78, "declaration_attribute": "", "comment": "/--\n  A technical issue uncovered by the formalization: the upper and lower sequences of a real\n  sequence take values in the extended reals rather than the reals, so the definitions need to be\n  adjusted accordingly.\n-/"}, {"content": "noncomputable abbrev Sequence.limsup (a:Sequence) : EReal :=\n  sInf { x | ∃ N ≥ a.m, x = a.upperseq N }", "line_number": 80, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.lowerseq (a:Sequence) : ℤ → EReal := fun N ↦ (a.from N).inf", "line_number": 83, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.liminf (a:Sequence) : EReal :=\n  sSup { x | ∃ N ≥ a.m, x = a.lowerseq N }", "line_number": 85, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_7 : Sequence := (fun (n:ℕ) ↦ (-1:ℝ)^n * (1 + (10:ℝ)^(-(n:ℤ)-1)))", "line_number": 88, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_8 : Sequence := (fun (n:ℕ) ↦ if Even n then (n+1:ℝ) else -(n:ℝ)-1)", "line_number": 107, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_9 : Sequence :=\n  (fun (n:ℕ) ↦ if Even n then (n+1:ℝ)⁻¹ else -(n+1:ℝ)⁻¹)", "line_number": 117, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_10 : Sequence := (fun (n:ℕ) ↦ (n+1:ℝ))", "line_number": 128, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.abs (a:Sequence) : Sequence where\n  m := a.m\n  seq := fun n ↦ |a n|\n  vanish := by intro n hn; simp [a.vanish n hn]", "line_number": 238, "declaration_attribute": "", "comment": ""}, {"content": "def Sequence.tendsTo_real_iff :\n  Decidable (∀ (a:Sequence) (x:ℝ), a.TendsTo x ↔ a.abs.TendsTo x) := by\n  -- The first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 330, "declaration_attribute": "", "comment": "/- Exercise 6.4.7 -/"}, {"content": "abbrev Sequence.ExtendedLimitPoint (a:Sequence) (x:EReal) : Prop := if x = ⊤ then ¬ a.BddAbove else if x = ⊥ then ¬ a.BddBelow else a.LimitPoint x.toReal", "line_number": 336, "declaration_attribute": "", "comment": "/-- This definition is needed for Exercises 6.4.8 and 6.4.9. -/"}]}
{"chapter_name": "Section_6_4", "line_number": 339, "content": "\ntheorem Sequence.extended_limit_point_of_limsup (a:Sequence) : a.ExtendedLimitPoint a.limsup := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.Adherent (ε:ℝ) (a:Chapter6.Sequence) (x:ℝ) := ∃ n ≥ a.m, ε.Close (a n) x", "line_number": 22, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.ContinuallyAdherent (ε:ℝ) (a:Chapter6.Sequence) (x:ℝ) :=\n  ∀ N ≥ a.m, ε.Adherent (a.from N) x", "line_number": 24, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.LimitPoint (a:Sequence) (x:ℝ) : Prop :=\n  ∀ ε > (0:ℝ), ε.ContinuallyAdherent a x", "line_number": 29, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_3 : Sequence := (fun (n:ℕ) ↦ 1 - (10:ℝ)^(-(n:ℤ)-1))", "line_number": 37, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_4 : Sequence :=\n  (fun (n:ℕ) ↦ (-1:ℝ)^n * (1 + (10:ℝ)^(-(n:ℤ)-1)))", "line_number": 51, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.upperseq (a:Sequence) : ℤ → EReal := fun N ↦ (a.from N).sup", "line_number": 78, "declaration_attribute": "", "comment": "/--\n  A technical issue uncovered by the formalization: the upper and lower sequences of a real\n  sequence take values in the extended reals rather than the reals, so the definitions need to be\n  adjusted accordingly.\n-/"}, {"content": "noncomputable abbrev Sequence.limsup (a:Sequence) : EReal :=\n  sInf { x | ∃ N ≥ a.m, x = a.upperseq N }", "line_number": 80, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.lowerseq (a:Sequence) : ℤ → EReal := fun N ↦ (a.from N).inf", "line_number": 83, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sequence.liminf (a:Sequence) : EReal :=\n  sSup { x | ∃ N ≥ a.m, x = a.lowerseq N }", "line_number": 85, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_7 : Sequence := (fun (n:ℕ) ↦ (-1:ℝ)^n * (1 + (10:ℝ)^(-(n:ℤ)-1)))", "line_number": 88, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_8 : Sequence := (fun (n:ℕ) ↦ if Even n then (n+1:ℝ) else -(n:ℝ)-1)", "line_number": 107, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_9 : Sequence :=\n  (fun (n:ℕ) ↦ if Even n then (n+1:ℝ)⁻¹ else -(n+1:ℝ)⁻¹)", "line_number": 117, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Example_6_4_10 : Sequence := (fun (n:ℕ) ↦ (n+1:ℝ))", "line_number": 128, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Sequence.abs (a:Sequence) : Sequence where\n  m := a.m\n  seq := fun n ↦ |a n|\n  vanish := by intro n hn; simp [a.vanish n hn]", "line_number": 238, "declaration_attribute": "", "comment": ""}, {"content": "def Sequence.tendsTo_real_iff :\n  Decidable (∀ (a:Sequence) (x:ℝ), a.TendsTo x ↔ a.abs.TendsTo x) := by\n  -- The first line of this construction should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 330, "declaration_attribute": "", "comment": "/- Exercise 6.4.7 -/"}, {"content": "abbrev Sequence.ExtendedLimitPoint (a:Sequence) (x:EReal) : Prop := if x = ⊤ then ¬ a.BddAbove else if x = ⊥ then ¬ a.BddBelow else a.LimitPoint x.toReal", "line_number": 336, "declaration_attribute": "", "comment": "/-- This definition is needed for Exercises 6.4.8 and 6.4.9. -/"}]}
{"chapter_name": "Section_6_5", "line_number": 100, "content": "\ntheorem Sequence.lim_of_rat_power_growth {q:ℚ} (hq: q > 0) :\n    (fun (n:ℕ) ↦ ((n+1:ℝ)^(q:ℝ)):Sequence).Divergent := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "instance Sequence.inst_pow: Pow Sequence ℕ where\n  pow a k := {\n    m := a.m\n    seq := fun (n:ℤ) ↦ if n ≥ a.m then a n ^ k else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 23, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_6_6", "line_number": 76, "content": "\ntheorem Sequence.subseq_of_unbounded {a:ℕ → ℝ} (ha: ¬ (a:Sequence).IsBounded) :\n    ∃ b:ℕ → ℝ, Sequence.subseq a b ∧ (b:Sequence)⁻¹.TendsTo 0 := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Sequence.subseq (a b: ℕ → ℝ) : Prop := ∃ f : ℕ → ℕ, StrictMono f ∧ ∀ n, b n = a (f n)", "line_number": 21, "declaration_attribute": "", "comment": "/-- Definition 6.6.1 -/"}, {"content": "def Sequence.exist_subseq_of_subseq :\n  Decidable (∃ a b : ℕ → ℝ, a ≠ b ∧ Sequence.subseq a b ∧ Sequence.subseq b a) := by\n    -- The first line of this construction should be `apply isTrue` or `apply isFalse`.\n    sorry", "line_number": 67, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_7_1", "line_number": 318, "content": "\ntheorem binomial_theorem (x y:ℝ) (n:ℕ) :\n    (x + y)^n\n    = ∑ j ∈ Icc (0:ℤ) n,\n    n.factorial / (j.toNat.factorial * (n-j).toNat.factorial) * x^j * y^(n - j) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable (n : ℤ) (A : Finset ℤ) (f : ℤ → ℝ)", "line_number": 18, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_7_2", "line_number": 123, "content": "\ntheorem Series.example_7_2_7 : ((fun n:ℕ ↦ (1:ℝ)):Series).diverges := by\n  apply diverges_of_nodecay\n  sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "structure Series where\n  m : ℤ\n  seq : ℤ → ℝ\n  vanish : ∀ n < m, seq n = 0", "line_number": 29, "declaration_attribute": "@[ext]", "comment": "/--\n  Definition 7.2.1 (Formal infinite series). This is similar to Chapter 6 sequence, but is\n  manipulated differently. As with Chapter 5, we will start series from 0 by default.\n-/"}, {"content": "instance Series.instCoe : Coe (ℕ → ℝ) Series where\n  coe := fun a ↦ {\n    m := 0\n    seq := fun n ↦ if n ≥ 0 then a n.toNat else 0\n    vanish := by intro n hn; simp [hn]\n  }", "line_number": 35, "declaration_attribute": "", "comment": "/-- Functions from ℕ to ℝ can be thought of as series. -/"}, {"content": "abbrev Series.mk' {m:ℤ} (a: { n // n ≥ m } → ℝ) : Series where\n  m := m\n  seq := fun n ↦ if h : n ≥ m then a ⟨n, h⟩ else 0\n  vanish := by intro n hn; simp [hn]", "line_number": 45, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Series.partial (s : Series) (N:ℤ) : ℝ := ∑ n ∈ Finset.Icc s.m N, s.seq n", "line_number": 54, "declaration_attribute": "", "comment": "/-- Definition 7.2.2 (Convergence of series) -/"}, {"content": "abbrev Series.convergesTo (s : Series) (L:ℝ) : Prop := Filter.atTop.Tendsto (s.partial) (nhds L)", "line_number": 68, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Series.converges (s : Series) : Prop := ∃ L, s.convergesTo L", "line_number": 70, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Series.diverges (s : Series) : Prop := ¬s.converges", "line_number": 72, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Series.sum (s : Series) : ℝ := if h : s.converges then h.choose else 0", "line_number": 75, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Series.example_7_2_4 := mk' (m := 1) (fun n ↦ (2:ℝ)^(-n:ℤ))", "line_number": 92, "declaration_attribute": "", "comment": "/-- Example 7.2.4 -/"}, {"content": "noncomputable abbrev Series.example_7_2_4' := mk' (m := 1) (fun n ↦ (2:ℝ)^(n:ℤ))", "line_number": 101, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Series.abs (s:Series) : Series := mk' (m:=s.m) (fun n ↦ |s.seq n|)", "line_number": 132, "declaration_attribute": "", "comment": "/-- Definition 7.2.8 (Absolute convergence) -/"}, {"content": "abbrev Series.absConverges (s:Series) : Prop := s.abs.converges", "line_number": 134, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Series.condConverges (s:Series) : Prop := s.converges ∧ ¬ s.absConverges", "line_number": 136, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Series.example_7_2_13 : Series := (mk' (m:=1) (fun n ↦ (-1:ℝ)^(n:ℤ) / (n:ℤ)))", "line_number": 187, "declaration_attribute": "", "comment": "/-- Example 7.2.13 -/"}, {"content": "instance Series.inst_add : Add Series where\n  add a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a.seq n + b.seq n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 198, "declaration_attribute": "", "comment": ""}, {"content": "instance Series.inst.smul : SMul ℝ Series where\n  smul c s := {\n    m := s.m\n    seq := fun n ↦ if n ≥ s.m then c * s.seq n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 217, "declaration_attribute": "", "comment": ""}, {"content": "instance Series.inst_sub : Sub Series where\n  sub a b := {\n    m := max a.m b.m\n    seq := fun (n:ℤ) ↦ if n ≥ max a.m b.m then a.seq n - b.seq n else 0\n    vanish := by intro n hn; rw [lt_iff_not_ge] at hn; simp [hn]\n  }", "line_number": 237, "declaration_attribute": "", "comment": "/-- The corresponding API for subtraction was not in the textbook, but is useful in later sections, so is included here. -/"}, {"content": "abbrev Series.from (s:Series) (m₁:ℤ) : Series := mk' (m := max s.m m₁) (fun n ↦ s.seq (n:ℤ))", "line_number": 255, "declaration_attribute": "", "comment": ""}, {"content": "def Series.exercise_7_2_1_convergent :\n  Decidable ( (mk' (m := 1) (fun n ↦ (-1:ℝ)^(n:ℤ))).converges ) := by\n  -- The first line of this proof should be `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 277, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_7_3", "line_number": 203, "content": "\ntheorem Series.nonneg_sum_zero {a:ℕ → ℝ} (ha: (a:Series).nonneg) (hconv: (a:Series).converges) : (a:Series).sum = 0 ↔ ∀ n, a n = 0 := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Series.nonneg (s: Series) : Prop := ∀ n, s.seq n ≥ 0", "line_number": 23, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Series.partial_of_nonneg {s: Series} (h: s.nonneg) : Monotone s.partial := by sorry", "line_number": 25, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_7_4", "line_number": 111, "content": "\ntheorem Series.zeta_2_converges : (fun n:ℕ ↦ 1/(n+1:ℝ)^2 : Series).converges := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "noncomputable abbrev Series.a_7_4_4 : ℕ → ℝ := fun n ↦ (-1:ℝ)^n / (n+2)", "line_number": 192, "declaration_attribute": "", "comment": "/-- Example 7.4.4 -/"}, {"content": "abbrev Series.f_7_4_4 : ℕ → ℕ := fun n ↦ if n % 3 = 0 then 2 * (n/3) else 2*n - (n/3) - 1", "line_number": 198, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_7_4", "line_number": 207, "content": "\ntheorem Series.absConverges_of_subseries {a:ℕ → ℝ} (ha: (a:Series).absConverges) {f: ℕ → ℕ} (hf: StrictMono f) :\n  (fun n ↦ a (f n):Series).absConverges := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "noncomputable abbrev Series.a_7_4_4 : ℕ → ℝ := fun n ↦ (-1:ℝ)^n / (n+2)", "line_number": 192, "declaration_attribute": "", "comment": "/-- Example 7.4.4 -/"}, {"content": "abbrev Series.f_7_4_4 : ℕ → ℕ := fun n ↦ if n % 3 = 0 then 2 * (n/3) else 2*n - (n/3) - 1", "line_number": 198, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_7_5", "line_number": 216, "content": "\ntheorem Series.poly_mul_geom_converges {x:ℝ} (hx: |x|<1) (q:ℝ) : (fun n:ℕ ↦ (n:ℝ)^q * x^n : Series).converges ∧ Filter.atTop.Tendsto (fun n:ℕ ↦ (n:ℝ)^q * x^n) (nhds 0) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": []}
{"chapter_name": "Section_8_2", "line_number": 499, "content": "\ntheorem permute_diverges_of_divergent {a: ℕ → ℝ} (ha: (a:Series).converges)\n  (ha': ¬ (a:Series).absConverges)  :\n  ∃ f : ℕ → ℕ,  Function.Bijective f ∧ Filter.atTop.Tendsto (fun N ↦ ((a ∘ f:Series).partial N : EReal)) (nhds ⊤) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev AbsConvergent {X:Type} (f: X → ℝ) : Prop := ∃ g: ℕ → X, Function.Bijective g ∧ (f ∘ g: Series).absConverges", "line_number": 35, "declaration_attribute": "", "comment": "/-- Definition 8.2.1 (Series on countable sets).  Note that with this definition, functions defined\non finite sets will not be absolutely convergent; one should use `AbsConvergent'` instead for such\ncases.-/"}, {"content": "noncomputable abbrev Sum {X:Type} (f: X → ℝ) : ℝ := if h: AbsConvergent f then (f ∘ h.choose:Series).sum else\n  if _hX: Finite X then (∑ x ∈ @Finset.univ X (Fintype.ofFinite X), f x) else 0", "line_number": 42, "declaration_attribute": "", "comment": "/-- The definition has been chosen to give a sensible value when `X` is finite, even though\n`AbsConvergent` is by definition false in this context. -/"}, {"content": "abbrev AbsConvergent' {X:Type} (f: X → ℝ) : Prop := BddAbove ( (fun A ↦ ∑ x ∈ A, |f x|) '' .univ )", "line_number": 215, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev Sum' {X:Type} (f: X → ℝ) : ℝ := Sum (fun x : { x | f x ≠ 0 } ↦ f x)", "line_number": 253, "declaration_attribute": "", "comment": "/-- A generalized sum.  Note that this will give junk values if `f` is not `AbsConvergent'`. -/"}]}
{"chapter_name": "Section_8_3", "line_number": 184, "content": "\ntheorem Schroder_Bernstein {X Y:Type}\n  (hXY : LeCard X Y)\n  (hYX : LeCard Y X) :\n  EqualCard X Y := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev LeCard (X Y: Type) : Prop := ∃ f: X → Y, Function.Injective f", "line_number": 181, "declaration_attribute": "", "comment": ""}, {"content": "abbrev LtCard (X Y: Type) : Prop := LeCard X Y ∧ ¬ EqualCard X Y", "line_number": 190, "declaration_attribute": "", "comment": ""}, {"content": "abbrev CardOrder : Preorder Type := {\n  le := LeCard\n  lt := LtCard\n  le_refl := by\n    sorry\n  le_trans := by\n    sorry\n  lt_iff_le_not_le := by\n    sorry\n}", "line_number": 199, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_8_4", "line_number": 165, "content": "\ntheorem axiom_of_choice_from_exists_set_singleton_intersect {I: Type} {X: I → Type} (h : ∀ i, Nonempty (X i)) :\n  Nonempty (∀ i, X i) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev CartesianProduct {I U: Type} (X : I → Set U) := { x : I → ⋃ α, X α // ∀ α, ↑(x α) ∈ X α }", "line_number": 40, "declaration_attribute": "", "comment": "/-- Definition 8.4.1 (Infinite Cartesian products).  We will avoid using this definition in favor\nof the Mathlib form `∀ α, X α` which we will shortly show is equivalent to (or more precisely,\ngeneralizes) this one.\n\nBecause Lean does not allow unrestricted unions of types, we cheat slightly here by assuming all the\n`X α` are sets in a common universe `U`.  Note that the Mathlib definition does not have this\nrestriction. -/"}, {"content": "def CartesianProduct.equiv {I U: Type} (X : I → Set U) :\n  CartesianProduct X ≃ ∀ α, X α := {\n  toFun x α := ⟨ x.val α, by aesop ⟩\n  invFun x := ⟨ fun α ↦ ⟨ x α, by simp; use α; aesop ⟩, by aesop ⟩\n  left_inv x := by aesop\n  right_inv x := by aesop\n  }", "line_number": 43, "declaration_attribute": "", "comment": "/-- Equivalence with Mathlib's product -/"}, {"content": "def Function.equiv {I X:Type} : (∀ _:I, X) ≃ (I → X) := {\n  toFun f := f\n  invFun f := f\n  left_inv f := rfl\n  right_inv f := rfl\n}", "line_number": 52, "declaration_attribute": "", "comment": "/-- Example 8.4.2. -/"}, {"content": "def product_zero_equiv {X: Fin 0 → Type} : (∀ i:Fin 0, X i) ≃ PUnit := {\n  toFun f := PUnit.unit\n  invFun x i := nomatch i\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 59, "declaration_attribute": "", "comment": ""}, {"content": "def product_one_equiv {X: Fin 1 → Type} : (∀ i:Fin 1, X i) ≃ X 0 := {\n  toFun f := f 0\n  invFun x i := by rwa [←Fin.fin_one_eq_zero i] at x\n  left_inv f := by ext i; rw [Fin.fin_one_eq_zero i]; simp\n  right_inv f := rfl\n}", "line_number": 66, "declaration_attribute": "", "comment": ""}, {"content": "def product_two_equiv {X: Fin 2 → Type} : (∀ i:Fin 2, X i) ≃ (X 0 × X 1) := {\n  toFun f := (f 0, f 1)\n  invFun f i := match i with\n    | 0 => f.1\n    | 1 => f.2\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 73, "declaration_attribute": "", "comment": ""}, {"content": "def product_three_equiv {X: Fin 3 → Type} : (∀ i:Fin 3, X i) ≃ (X 0 × X 1 × X 2) := {\n  toFun f := (f 0, f 1, f 2)\n  invFun f i := match i with\n    | 0 => f.1\n    | 1 => f.2.1\n    | 2 => f.2.2\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 82, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_8_4", "line_number": 177, "content": "\ntheorem axiom_of_choice_from_function_injective_inv_surjective {I: Type} {X: I → Type} (h : ∀ i, Nonempty (X i)) :\n  Nonempty (∀ i, X i) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev CartesianProduct {I U: Type} (X : I → Set U) := { x : I → ⋃ α, X α // ∀ α, ↑(x α) ∈ X α }", "line_number": 40, "declaration_attribute": "", "comment": "/-- Definition 8.4.1 (Infinite Cartesian products).  We will avoid using this definition in favor\nof the Mathlib form `∀ α, X α` which we will shortly show is equivalent to (or more precisely,\ngeneralizes) this one.\n\nBecause Lean does not allow unrestricted unions of types, we cheat slightly here by assuming all the\n`X α` are sets in a common universe `U`.  Note that the Mathlib definition does not have this\nrestriction. -/"}, {"content": "def CartesianProduct.equiv {I U: Type} (X : I → Set U) :\n  CartesianProduct X ≃ ∀ α, X α := {\n  toFun x α := ⟨ x.val α, by aesop ⟩\n  invFun x := ⟨ fun α ↦ ⟨ x α, by simp; use α; aesop ⟩, by aesop ⟩\n  left_inv x := by aesop\n  right_inv x := by aesop\n  }", "line_number": 43, "declaration_attribute": "", "comment": "/-- Equivalence with Mathlib's product -/"}, {"content": "def Function.equiv {I X:Type} : (∀ _:I, X) ≃ (I → X) := {\n  toFun f := f\n  invFun f := f\n  left_inv f := rfl\n  right_inv f := rfl\n}", "line_number": 52, "declaration_attribute": "", "comment": "/-- Example 8.4.2. -/"}, {"content": "def product_zero_equiv {X: Fin 0 → Type} : (∀ i:Fin 0, X i) ≃ PUnit := {\n  toFun f := PUnit.unit\n  invFun x i := nomatch i\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 59, "declaration_attribute": "", "comment": ""}, {"content": "def product_one_equiv {X: Fin 1 → Type} : (∀ i:Fin 1, X i) ≃ X 0 := {\n  toFun f := f 0\n  invFun x i := by rwa [←Fin.fin_one_eq_zero i] at x\n  left_inv f := by ext i; rw [Fin.fin_one_eq_zero i]; simp\n  right_inv f := rfl\n}", "line_number": 66, "declaration_attribute": "", "comment": ""}, {"content": "def product_two_equiv {X: Fin 2 → Type} : (∀ i:Fin 2, X i) ≃ (X 0 × X 1) := {\n  toFun f := (f 0, f 1)\n  invFun f i := match i with\n    | 0 => f.1\n    | 1 => f.2\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 73, "declaration_attribute": "", "comment": ""}, {"content": "def product_three_equiv {X: Fin 3 → Type} : (∀ i:Fin 3, X i) ≃ (X 0 × X 1 × X 2) := {\n  toFun f := (f 0, f 1, f 2)\n  invFun f i := match i with\n    | 0 => f.1\n    | 1 => f.2.1\n    | 2 => f.2.2\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 82, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_8_4", "line_number": 170, "content": "\ntheorem Function.Injective.inv_surjective {A B:Type} {g: B → A} (hg: Function.Surjective g) :\n  ∃ f : A → B, Function.Injective f ∧ Function.RightInverse f g := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev CartesianProduct {I U: Type} (X : I → Set U) := { x : I → ⋃ α, X α // ∀ α, ↑(x α) ∈ X α }", "line_number": 40, "declaration_attribute": "", "comment": "/-- Definition 8.4.1 (Infinite Cartesian products).  We will avoid using this definition in favor\nof the Mathlib form `∀ α, X α` which we will shortly show is equivalent to (or more precisely,\ngeneralizes) this one.\n\nBecause Lean does not allow unrestricted unions of types, we cheat slightly here by assuming all the\n`X α` are sets in a common universe `U`.  Note that the Mathlib definition does not have this\nrestriction. -/"}, {"content": "def CartesianProduct.equiv {I U: Type} (X : I → Set U) :\n  CartesianProduct X ≃ ∀ α, X α := {\n  toFun x α := ⟨ x.val α, by aesop ⟩\n  invFun x := ⟨ fun α ↦ ⟨ x α, by simp; use α; aesop ⟩, by aesop ⟩\n  left_inv x := by aesop\n  right_inv x := by aesop\n  }", "line_number": 43, "declaration_attribute": "", "comment": "/-- Equivalence with Mathlib's product -/"}, {"content": "def Function.equiv {I X:Type} : (∀ _:I, X) ≃ (I → X) := {\n  toFun f := f\n  invFun f := f\n  left_inv f := rfl\n  right_inv f := rfl\n}", "line_number": 52, "declaration_attribute": "", "comment": "/-- Example 8.4.2. -/"}, {"content": "def product_zero_equiv {X: Fin 0 → Type} : (∀ i:Fin 0, X i) ≃ PUnit := {\n  toFun f := PUnit.unit\n  invFun x i := nomatch i\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 59, "declaration_attribute": "", "comment": ""}, {"content": "def product_one_equiv {X: Fin 1 → Type} : (∀ i:Fin 1, X i) ≃ X 0 := {\n  toFun f := f 0\n  invFun x i := by rwa [←Fin.fin_one_eq_zero i] at x\n  left_inv f := by ext i; rw [Fin.fin_one_eq_zero i]; simp\n  right_inv f := rfl\n}", "line_number": 66, "declaration_attribute": "", "comment": ""}, {"content": "def product_two_equiv {X: Fin 2 → Type} : (∀ i:Fin 2, X i) ≃ (X 0 × X 1) := {\n  toFun f := (f 0, f 1)\n  invFun f i := match i with\n    | 0 => f.1\n    | 1 => f.2\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 73, "declaration_attribute": "", "comment": ""}, {"content": "def product_three_equiv {X: Fin 3 → Type} : (∀ i:Fin 3, X i) ≃ (X 0 × X 1 × X 2) := {\n  toFun f := (f 0, f 1, f 2)\n  invFun f i := match i with\n    | 0 => f.1\n    | 1 => f.2.1\n    | 2 => f.2.2\n  left_inv f := by aesop\n  right_inv f := rfl\n}", "line_number": 82, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_8_5", "line_number": 126, "content": "\ntheorem IsMax.ofFinite {X:Type} [LinearOrder X] [Finite X] [Nonempty X] : ∃ x:X, IsMax x := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "def PartialOrder.mk {X:Type} [LE X]\n  (hrefl: ∀ x:X, x ≤ x)\n  (hantisymm: ∀ x y:X, x ≤ y → y ≤ x → x = y)\n  (htrans: ∀ x y z:X, x ≤ y → y ≤ z → x ≤ z) : PartialOrder X :=\n{\n  le := (· ≤ ·)\n  le_refl := hrefl\n  le_antisymm := hantisymm\n  le_trans := htrans\n}", "line_number": 30, "declaration_attribute": "", "comment": ""}, {"content": "def IsTotal (X:Type) [PartialOrder X] : Prop := ∀ x y:X, x ≤ y ∨ y ≤ x", "line_number": 46, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable def LinearOrder.mk {X:Type} [PartialOrder X]\n  (htotal: IsTotal X) : LinearOrder X :=\n{\n   le_total := htotal\n   toDecidableLE := decRel LE.le\n}", "line_number": 50, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable def LinearOrder.subtype {X:Type} [LinearOrder X] (A: Set X) : LinearOrder A :=\nLinearOrder.mk (by\n  sorry\n  )", "line_number": 64, "declaration_attribute": "", "comment": ""}, {"content": "abbrev X_8_5_4 : Set (Set ℕ) := { {1,2}, {2}, {2,3}, {2,3,4}, {5} }", "line_number": 77, "declaration_attribute": "", "comment": ""}, {"content": "abbrev IsUpperBound {X:Type} [PartialOrder X] (A:Set X) (x:X) : Prop :=\n  ∀ y ∈ A, y ≤ x", "line_number": 149, "declaration_attribute": "", "comment": "/-- Definition 8.5.12 (Upper bounds and strict upper bounds) -/"}, {"content": "abbrev IsStrictUpperBound {X:Type} [PartialOrder X] (A:Set X) (x:X) : Prop :=\n  IsUpperBound A x ∧ x ∉ A", "line_number": 156, "declaration_attribute": "", "comment": ""}, {"content": "def empty_set_partial_order [h₀: LE Empty] : Decidable (∃ h : PartialOrder Empty, h.le = h₀.le) := by\n  sorry", "line_number": 311, "declaration_attribute": "", "comment": "/-- Exercise 8.5.1 -/"}, {"content": "def empty_set_linear_order [h₀: LE Empty] : Decidable (∃ h : LinearOrder Empty, h.le = h₀.le) := by\n  sorry", "line_number": 314, "declaration_attribute": "", "comment": ""}, {"content": "def empty_set_well_order [h₀: LT Empty]: Decidable (Nonempty (WellFoundedLT Empty)) := by\n  sorry", "line_number": 317, "declaration_attribute": "", "comment": ""}, {"content": "def Ex_8_5_5_b : Decidable (∀ (X Y:Type) (h: LinearOrder Y) (f:X → Y), ∃ h₀: LinearOrder X, h₀.le = (fun x y ↦ f x < f y ∨ x = y)) := by\n  sorry", "line_number": 338, "declaration_attribute": "", "comment": ""}, {"content": "abbrev OrderIdeals (X: Type) [PartialOrder X] : Set (Set X) := .Iic '' (.univ : Set X)", "line_number": 344, "declaration_attribute": "", "comment": "/-- Exercise 8.5.6 -/"}, {"content": "def OrderIdeals.iso {X: Type} [PartialOrder X] : X ≃o OrderIdeals X := {\n  toFun := fun x ↦ ⟨ .Iic x, by simp ⟩\n  invFun := by sorry\n  left_inv := by sorry\n  right_inv := by sorry\n  map_rel_iff' := by sorry\n  }", "line_number": 346, "declaration_attribute": "", "comment": ""}, {"content": "def Lex' (α : Type) := α", "line_number": 368, "declaration_attribute": "", "comment": "/-- Exercise 8.5.12.  Here we make a copy of Mathlib's `Lex` wrapper for lexicographical orderings.  This wrapper is needed\nbecause products `X × Y` of ordered sets are given the default instance of the product partial order instead of\nthe lexicographical one. -/"}, {"content": "instance Lex'.partialOrder {X Y: Type} [PartialOrder X] [PartialOrder Y] : PartialOrder (Lex' (X × Y)) := {\n  le := fun ⟨ x, y ⟩ ⟨ x', y' ⟩ ↦ (x < x') ∨ (x = x' ∧ y ≤ y')\n  le_refl := by sorry\n  le_antisymm := by sorry\n  le_trans := by sorry\n}", "line_number": 370, "declaration_attribute": "", "comment": ""}, {"content": "instance Lex'.linearOrder {X Y:Type} [LinearOrder X] [LinearOrder Y] : LinearOrder (Lex' (X × Y)) := by sorry", "line_number": 377, "declaration_attribute": "", "comment": ""}, {"content": "instance Lex'.WellFoundedLT {X Y:Type} [LinearOrder X] [WellFoundedLT X] [LinearOrder Y] [WellFoundedLT Y]:\n  WellFoundedLT (Lex' (X × Y)) := by sorry", "line_number": 379, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_9_1", "line_number": 329, "content": "\ntheorem Q_unbounded (a: ℝ) : ¬ Bornology.IsBounded ((fun n:ℚ ↦ (n:ℝ)) '' .univ) := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "variable (I : Type*)", "line_number": 23, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.adherent' (ε:ℝ) (x:ℝ) (X: Set ℝ) := ∃ y ∈ X, |x - y| ≤ ε", "line_number": 61, "declaration_attribute": "", "comment": "/-- Definition 9.1.5.  Note that a slightly different `Real.adherent` was defined in Chapter 6.4 -/"}, {"content": "abbrev AdherentPt (x:ℝ) (X:Set ℝ) := ∀ ε > (0:ℝ), ε.adherent' x X", "line_number": 74, "declaration_attribute": "", "comment": "/-- Definition 9.1.-/"}, {"content": "abbrev LimitPt (x:ℝ) (X: Set ℝ) := AdherentPt x (X \\ {x})", "line_number": 226, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Limit points) -/"}, {"content": "abbrev IsolatedPt (x:ℝ) (X: Set ℝ) := x ∈ X ∧ ∃ ε>0, ∀ y ∈ X \\ {x}, |x-y| > ε", "line_number": 233, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Isolated points) -/"}]}
{"chapter_name": "Section_9_1", "line_number": 106, "content": "\ntheorem closure_of_subset_closure {X Y:Set ℝ} (h: X ⊆ Y) (h' : Y ⊆ closure X): closure Y = closure X := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "variable (I : Type*)", "line_number": 23, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.adherent' (ε:ℝ) (x:ℝ) (X: Set ℝ) := ∃ y ∈ X, |x - y| ≤ ε", "line_number": 61, "declaration_attribute": "", "comment": "/-- Definition 9.1.5.  Note that a slightly different `Real.adherent` was defined in Chapter 6.4 -/"}, {"content": "abbrev AdherentPt (x:ℝ) (X:Set ℝ) := ∀ ε > (0:ℝ), ε.adherent' x X", "line_number": 74, "declaration_attribute": "", "comment": "/-- Definition 9.1.-/"}, {"content": "abbrev LimitPt (x:ℝ) (X: Set ℝ) := AdherentPt x (X \\ {x})", "line_number": 226, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Limit points) -/"}, {"content": "abbrev IsolatedPt (x:ℝ) (X: Set ℝ) := x ∈ X ∧ ∃ ε>0, ∀ y ∈ X \\ {x}, |x-y| > ε", "line_number": 233, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Isolated points) -/"}]}
{"chapter_name": "Section_9_1", "line_number": 317, "content": "\ntheorem Icc_bounded (a b:ℝ) : Bornology.IsBounded (.Icc a b) := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "variable (I : Type*)", "line_number": 23, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.adherent' (ε:ℝ) (x:ℝ) (X: Set ℝ) := ∃ y ∈ X, |x - y| ≤ ε", "line_number": 61, "declaration_attribute": "", "comment": "/-- Definition 9.1.5.  Note that a slightly different `Real.adherent` was defined in Chapter 6.4 -/"}, {"content": "abbrev AdherentPt (x:ℝ) (X:Set ℝ) := ∀ ε > (0:ℝ), ε.adherent' x X", "line_number": 74, "declaration_attribute": "", "comment": "/-- Definition 9.1.-/"}, {"content": "abbrev LimitPt (x:ℝ) (X: Set ℝ) := AdherentPt x (X \\ {x})", "line_number": 226, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Limit points) -/"}, {"content": "abbrev IsolatedPt (x:ℝ) (X: Set ℝ) := x ∈ X ∧ ∃ ε>0, ∀ y ∈ X \\ {x}, |x-y| > ε", "line_number": 233, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Isolated points) -/"}]}
{"chapter_name": "Section_9_1", "line_number": 323, "content": "\ntheorem N_unbounded (a: ℝ) : ¬ Bornology.IsBounded ((fun n:ℕ ↦ (n:ℝ)) '' .univ) := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "variable (I : Type*)", "line_number": 23, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.adherent' (ε:ℝ) (x:ℝ) (X: Set ℝ) := ∃ y ∈ X, |x - y| ≤ ε", "line_number": 61, "declaration_attribute": "", "comment": "/-- Definition 9.1.5.  Note that a slightly different `Real.adherent` was defined in Chapter 6.4 -/"}, {"content": "abbrev AdherentPt (x:ℝ) (X:Set ℝ) := ∀ ε > (0:ℝ), ε.adherent' x X", "line_number": 74, "declaration_attribute": "", "comment": "/-- Definition 9.1.-/"}, {"content": "abbrev LimitPt (x:ℝ) (X: Set ℝ) := AdherentPt x (X \\ {x})", "line_number": 226, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Limit points) -/"}, {"content": "abbrev IsolatedPt (x:ℝ) (X: Set ℝ) := x ∈ X ∧ ∃ ε>0, ∀ y ∈ X \\ {x}, |x-y| > ε", "line_number": 233, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Isolated points) -/"}]}
{"chapter_name": "Section_9_1", "line_number": 332, "content": "\ntheorem R_unbounded (a: ℝ) : ¬ Bornology.IsBounded (.univ: Set ℝ) := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "variable (I : Type*)", "line_number": 23, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Real.adherent' (ε:ℝ) (x:ℝ) (X: Set ℝ) := ∃ y ∈ X, |x - y| ≤ ε", "line_number": 61, "declaration_attribute": "", "comment": "/-- Definition 9.1.5.  Note that a slightly different `Real.adherent` was defined in Chapter 6.4 -/"}, {"content": "abbrev AdherentPt (x:ℝ) (X:Set ℝ) := ∀ ε > (0:ℝ), ε.adherent' x X", "line_number": 74, "declaration_attribute": "", "comment": "/-- Definition 9.1.-/"}, {"content": "abbrev LimitPt (x:ℝ) (X: Set ℝ) := AdherentPt x (X \\ {x})", "line_number": 226, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Limit points) -/"}, {"content": "abbrev IsolatedPt (x:ℝ) (X: Set ℝ) := x ∈ X ∧ ∃ ε>0, ∀ y ∈ X \\ {x}, |x-y| > ε", "line_number": 233, "declaration_attribute": "", "comment": "/-- Definition 9.1.18 (Isolated points) -/"}]}
{"chapter_name": "Section_9_3", "line_number": 178, "content": "\ntheorem Convergesto.sign_right : Convergesto (.Ioi 0) Real.sign 1 0 := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "abbrev Real.CloseFn (ε:ℝ) (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) : Prop :=\n  ∀ x ∈ X, |f x - L| < ε", "line_number": 29, "declaration_attribute": "", "comment": "/-- Definition 9.3.1 -/"}, {"content": "abbrev Real.CloseNear (ε:ℝ) (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) (x₀:ℝ) : Prop :=\n  ∃ δ > 0, ε.CloseFn (X ∩ .Ioo (x₀-δ) (x₀+δ)) f L", "line_number": 33, "declaration_attribute": "", "comment": "/-- Definition 9.3.3 -/"}, {"content": "abbrev Convergesto (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) (x₀:ℝ) : Prop := ∀ ε > (0:ℝ), ε.CloseNear X f L x₀", "line_number": 61, "declaration_attribute": "", "comment": "/-- Definition 9.3.6 (Convergence of functions at a point)-/"}, {"content": "noncomputable abbrev f_9_3_17 : ℝ → ℝ := fun x ↦ if x = 0 then 1 else 0", "line_number": 186, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_3_21 : ℝ → ℝ := fun x ↦ if x ∈ (fun q:ℚ ↦ (q:ℝ)) '' .univ then 1 else 0", "line_number": 205, "declaration_attribute": "", "comment": "/-- Example 9.3.21 -/"}]}
{"chapter_name": "Section_9_3", "line_number": 216, "content": "\ntheorem Convergesto.squeeze {E:Set ℝ} {f g h: ℝ → ℝ} {L:ℝ} {x₀:ℝ} (had: AdherentPt x₀ E)\n  (hfg: ∀ x ∈ E, f x ≤ g x) (hgh: ∀ x ∈ E, g x ≤ h x)\n  (hf: Convergesto E f L x₀) (hh: Convergesto E h L x₀) :\n  Convergesto E g L x₀ := by\n    sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.CloseFn (ε:ℝ) (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) : Prop :=\n  ∀ x ∈ X, |f x - L| < ε", "line_number": 29, "declaration_attribute": "", "comment": "/-- Definition 9.3.1 -/"}, {"content": "abbrev Real.CloseNear (ε:ℝ) (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) (x₀:ℝ) : Prop :=\n  ∃ δ > 0, ε.CloseFn (X ∩ .Ioo (x₀-δ) (x₀+δ)) f L", "line_number": 33, "declaration_attribute": "", "comment": "/-- Definition 9.3.3 -/"}, {"content": "abbrev Convergesto (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) (x₀:ℝ) : Prop := ∀ ε > (0:ℝ), ε.CloseNear X f L x₀", "line_number": 61, "declaration_attribute": "", "comment": "/-- Definition 9.3.6 (Convergence of functions at a point)-/"}, {"content": "noncomputable abbrev f_9_3_17 : ℝ → ℝ := fun x ↦ if x = 0 then 1 else 0", "line_number": 186, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_3_21 : ℝ → ℝ := fun x ↦ if x ∈ (fun q:ℚ ↦ (q:ℝ)) '' .univ then 1 else 0", "line_number": 205, "declaration_attribute": "", "comment": "/-- Example 9.3.21 -/"}]}
{"chapter_name": "Section_9_3", "line_number": 181, "content": "\ntheorem Convergesto.sign_left : Convergesto (.Iio 0) Real.sign (-1) 0 := by sorry", "type_fl": "theorem", "type_nl": "Example", "chapter_definitions": [{"content": "abbrev Real.CloseFn (ε:ℝ) (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) : Prop :=\n  ∀ x ∈ X, |f x - L| < ε", "line_number": 29, "declaration_attribute": "", "comment": "/-- Definition 9.3.1 -/"}, {"content": "abbrev Real.CloseNear (ε:ℝ) (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) (x₀:ℝ) : Prop :=\n  ∃ δ > 0, ε.CloseFn (X ∩ .Ioo (x₀-δ) (x₀+δ)) f L", "line_number": 33, "declaration_attribute": "", "comment": "/-- Definition 9.3.3 -/"}, {"content": "abbrev Convergesto (X:Set ℝ) (f: ℝ → ℝ) (L:ℝ) (x₀:ℝ) : Prop := ∀ ε > (0:ℝ), ε.CloseNear X f L x₀", "line_number": 61, "declaration_attribute": "", "comment": "/-- Definition 9.3.6 (Convergence of functions at a point)-/"}, {"content": "noncomputable abbrev f_9_3_17 : ℝ → ℝ := fun x ↦ if x = 0 then 1 else 0", "line_number": 186, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_3_21 : ℝ → ℝ := fun x ↦ if x ∈ (fun q:ℚ ↦ (q:ℝ)) '' .univ then 1 else 0", "line_number": 205, "declaration_attribute": "", "comment": "/-- Example 9.3.21 -/"}]}
{"chapter_name": "Section_9_4", "line_number": 140, "content": "\ntheorem ContinuousOn.restrict {X Y:Set ℝ} {f: ℝ → ℝ} (hY: Y ⊆ X) (hf: ContinuousOn f X) : ContinuousOn f Y := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "noncomputable abbrev f_9_4_6 (x:ℝ) : ℝ := if x ≥ 0 then 1 else 0", "line_number": 52, "declaration_attribute": "", "comment": "/-- Example 9.4.6 --/"}]}
{"chapter_name": "Section_9_7", "line_number": 127, "content": "\ntheorem exists_fixed_pt {f:ℝ → ℝ} (hf: ContinuousOn f (.Icc 0 1)) (hmap: f '' .Icc 0 1 ⊆ .Icc 0 1) : ∃ x ∈ Set.Icc 0 1, f x = x := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "noncomputable abbrev f_9_7_1 : ℝ → ℝ := fun x ↦ if x ≤ 0 then -1 else 1", "line_number": 102, "declaration_attribute": "", "comment": ""}, {"content": "abbrev f_9_7_2 : ℝ → ℝ := fun x ↦ x^3 - x", "line_number": 108, "declaration_attribute": "", "comment": "/-- Remark 9.7.2 -/"}]}
{"chapter_name": "Section_9_8", "line_number": 168, "content": "\ntheorem ContinuousAt.of_f_9_8_5 {x:ℝ} (hx: ¬ ∃ r:ℚ, x = r) : ContinuousAt f_9_8_5 x := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "def MonotoneOn.exist_inverse_without_continuity {a b:ℝ} (h: a < b) {f: ℝ → ℝ} (hmono: StrictMonoOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 126, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "def MonotoneOn.exist_inverse_without_strictmono {a b:ℝ} (h: a < b) (f: ℝ → ℝ)\n  (hcont: ContinuousOn f (.Icc a b)) (hmono: MonotoneOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 137, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ := nonempty_equiv_of_countable.some", "line_number": 153, "declaration_attribute": "", "comment": "/-- An equivalence between the natural numbers and the rationals. -/"}, {"content": "noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2:ℝ)^(-q_9_8_5.symm q:ℤ)", "line_number": 155, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : {r:ℚ // (r:ℝ) < x}, g_9_8_5 r", "line_number": 157, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_9_8", "line_number": 86, "content": "\ntheorem IsMaxOn.of_monotone_on_compact {a b:ℝ} (h:a < b) {f:ℝ → ℝ} (hf: MonotoneOn f (.Icc a b)) :\n  ∃ xmax ∈ Set.Icc a b, IsMaxOn f (.Icc a b) xmax := by sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "def MonotoneOn.exist_inverse_without_continuity {a b:ℝ} (h: a < b) {f: ℝ → ℝ} (hmono: StrictMonoOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 126, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "def MonotoneOn.exist_inverse_without_strictmono {a b:ℝ} (h: a < b) (f: ℝ → ℝ)\n  (hcont: ContinuousOn f (.Icc a b)) (hmono: MonotoneOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 137, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ := nonempty_equiv_of_countable.some", "line_number": 153, "declaration_attribute": "", "comment": "/-- An equivalence between the natural numbers and the rationals. -/"}, {"content": "noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2:ℝ)^(-q_9_8_5.symm q:ℤ)", "line_number": 155, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : {r:ℚ // (r:ℝ) < x}, g_9_8_5 r", "line_number": 157, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_9_8", "line_number": 160, "content": "\ntheorem StrictMonoOn.of_f_9_8_5 : StrictMonoOn f_9_8_5 .univ := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "def MonotoneOn.exist_inverse_without_continuity {a b:ℝ} (h: a < b) {f: ℝ → ℝ} (hmono: StrictMonoOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 126, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "def MonotoneOn.exist_inverse_without_strictmono {a b:ℝ} (h: a < b) (f: ℝ → ℝ)\n  (hcont: ContinuousOn f (.Icc a b)) (hmono: MonotoneOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 137, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ := nonempty_equiv_of_countable.some", "line_number": 153, "declaration_attribute": "", "comment": "/-- An equivalence between the natural numbers and the rationals. -/"}, {"content": "noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2:ℝ)^(-q_9_8_5.symm q:ℤ)", "line_number": 155, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : {r:ℚ // (r:ℝ) < x}, g_9_8_5 r", "line_number": 157, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_9_8", "line_number": 119, "content": "\ntheorem mono_of_continuous_inj {a b:ℝ} (h: a < b) {f:ℝ → ℝ}\n  (hf: ContinuousOn f (.Icc a b))\n  (hinj: Function.Injective (fun x: Set.Icc a b ↦ f x )) :\n  StrictMonoOn f (.Icc a b) ∨ StrictAntiOn f (.Icc a b) := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "def MonotoneOn.exist_inverse_without_continuity {a b:ℝ} (h: a < b) {f: ℝ → ℝ} (hmono: StrictMonoOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 126, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "def MonotoneOn.exist_inverse_without_strictmono {a b:ℝ} (h: a < b) (f: ℝ → ℝ)\n  (hcont: ContinuousOn f (.Icc a b)) (hmono: MonotoneOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 137, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ := nonempty_equiv_of_countable.some", "line_number": 153, "declaration_attribute": "", "comment": "/-- An equivalence between the natural numbers and the rationals. -/"}, {"content": "noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2:ℝ)^(-q_9_8_5.symm q:ℤ)", "line_number": 155, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : {r:ℚ // (r:ℝ) < x}, g_9_8_5 r", "line_number": 157, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_9_8", "line_number": 164, "content": "\ntheorem ContinuousAt.of_f_9_8_5' (r:ℚ) : ¬ ContinuousAt f_9_8_5 r := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "def MonotoneOn.exist_inverse_without_continuity {a b:ℝ} (h: a < b) {f: ℝ → ℝ} (hmono: StrictMonoOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 126, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "def MonotoneOn.exist_inverse_without_strictmono {a b:ℝ} (h: a < b) (f: ℝ → ℝ)\n  (hcont: ContinuousOn f (.Icc a b)) (hmono: MonotoneOn f (.Icc a b)) :\n  Decidable ( f '' (.Icc a b) = .Icc (f a) (f b) ∧\n  ∃ finv: ℝ → ℝ, ContinuousOn finv (.Icc (f a) (f b)) ∧ StrictMonoOn finv (.Icc (f a) (f b)) ∧\n  finv '' (.Icc (f a) (f b)) = .Icc a b ∧\n  (∀ x ∈ Set.Icc a b, finv (f x) = x) ∧\n  ∀ y ∈ Set.Icc (f a) (f b), f (finv y) = y )\n   := by\n  -- the first line of this construction should be either `apply isTrue` or `apply isFalse`.\n  sorry", "line_number": 137, "declaration_attribute": "", "comment": "/-- Exercise 9.8.4 -/"}, {"content": "noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ := nonempty_equiv_of_countable.some", "line_number": 153, "declaration_attribute": "", "comment": "/-- An equivalence between the natural numbers and the rationals. -/"}, {"content": "noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2:ℝ)^(-q_9_8_5.symm q:ℤ)", "line_number": 155, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : {r:ℚ // (r:ℝ) < x}, g_9_8_5 r", "line_number": 157, "declaration_attribute": "", "comment": ""}]}
{"chapter_name": "Section_9_9", "line_number": 225, "content": "\ntheorem UniformContinuousOn.comp {X Y: Set ℝ} {f g:ℝ → ℝ}\n  (hf: UniformContinuousOn f X) (hg: UniformContinuousOn g Y)\n  (hrange: f '' X ⊆ Y) : UniformContinuousOn (g ∘ f) X := by\n  sorry", "type_fl": "theorem", "type_nl": "Exercise", "chapter_definitions": [{"content": "abbrev Real.CloseSeqs (ε:ℝ) (a b: Chapter6.Sequence) : Prop :=\n  (a.m = b.m) ∧ ∀ n ≥ a.m, ε.Close (a n) (b n)", "line_number": 84, "declaration_attribute": "", "comment": "/-- Definition 9.9.5.  This is similar but not identical to `Real.close_seq` from Section 6.1. -/"}, {"content": "abbrev Real.EventuallyCloseSeqs (ε:ℝ) (a b: Chapter6.Sequence) : Prop :=\n  ∃ N ≥ a.m, ε.CloseSeqs (a.from N) (b.from N)", "line_number": 87, "declaration_attribute": "", "comment": ""}, {"content": "abbrev Chapter6.Sequence.equiv (a b: Sequence) : Prop :=\n  ∀ ε > (0:ℝ), ε.EventuallyCloseSeqs a b", "line_number": 90, "declaration_attribute": "", "comment": ""}, {"content": "noncomputable abbrev f_9_9_10 : ℝ → ℝ := fun x ↦ 1/x", "line_number": 121, "declaration_attribute": "", "comment": "/-- Example 9.9.10 -/"}, {"content": "abbrev f_9_9_11 : ℝ → ℝ := fun x ↦ x^2", "line_number": 135, "declaration_attribute": "", "comment": "/-- Example 9.9.11 -/"}]}
