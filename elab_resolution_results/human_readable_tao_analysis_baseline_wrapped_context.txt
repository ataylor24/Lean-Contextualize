Section_2_2: Chapter2.Nat.backwards_induction

import Mathlib.Tactic

namespace Chapter2
inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
  deriving Repr, DecidableEq
namespace Nat
abbrev recurse (f : Nat → Nat → Nat) (c : Nat) : Nat → Nat := fun n ↦
  match n with
  | 0 => c
  | n++ => f n (recurse f c n)
abbrev add (n m : Nat) : Nat :=
  Nat.recurse (fun _ sum ↦ sum++) m n
instance instAdd : Add Nat where add := add
instance instLE : LE Nat where le n m := ∃ a : Nat, m = n + a
end Nat
theorem Nat.backwards_induction {n:Nat} {P: Nat → Prop}
  (hind: ∀ m, P (m++) → P m) (hn: P n) :
    ∀ m, m ≤ n → P m := by
  sorry
end Chapter2

-----------------------------------

Section_2_3: Chapter2.Nat.sq_add_eq

import Mathlib.Tactic

namespace Chapter2
inductive Nat where
  | zero : Nat
  | succ : Nat → Nat
  deriving Repr, DecidableEq
namespace Nat
abbrev recurse (f : Nat → Nat → Nat) (c : Nat) : Nat → Nat := fun n ↦
  match n with
  | 0 => c
  | n++ => f n (recurse f c n)
abbrev add (n m : Nat) : Nat :=
  Nat.recurse (fun _ sum ↦ sum++) m n
instance instAdd : Add Nat where add := add
instance instZero : Zero Nat :=
  ⟨zero⟩
instance instOfNat {n : _root_.Nat} : OfNat Nat n where ofNat := _root_.Nat.rec 0 (fun _ n ↦ n++) n
abbrev mul (n m : Nat) : Nat :=
  Nat.recurse (fun _ prod ↦ prod + m) 0 n
instance instMul : Mul Nat where mul := mul
abbrev pow (m n : Nat) : Nat :=
  Nat.recurse (fun _ prod ↦ prod * m) 1 n
instance instPow : HomogeneousPow Nat where pow := Nat.pow
end Nat
theorem Nat.sq_add_eq (a b: Nat) :
    (a + b) ^ (2 : Nat) = a ^ (2 : Nat) + 2 * a * b + b ^ (2 : Nat) := by
  sorry
end Chapter2

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.subset_union_right

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
instance instUnion : Union Set where union := union_pair
end Set
end SetTheory
theorem SetTheory.Set.subset_union_right (A B:Set) : B ⊆ A ∪ B := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.union_subset_iff

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
instance instUnion : Union Set where union := union_pair
end Set
end SetTheory
@[simp]
theorem SetTheory.Set.union_subset_iff (A B C:Set) : A ∪ B ⊆ C ↔ A ⊆ C ∧ B ⊆ C := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.specification_from_replacement

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
end Set
end SetTheory
theorem SetTheory.Set.specification_from_replacement {A:Set} {P: A → Prop} :
    ∃ B, B ⊆ A ∧ ∀ x, x.val ∈ B ↔ P x := by sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.union_eq_partition

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
instance instSDiff : SDiff Set where
  sdiff X
    Y :=
    X.specify
      (fun x ↦ x.val ∉ Y)
        -- Now we can use the `X \ Y` notation for a difference of two `Set`s.
instance instUnion : Union Set where union := union_pair
end Set
end SetTheory
theorem SetTheory.Set.union_eq_partition (A B:Set) : A ∪ B = (A \ B) ∪ (A ∩ B) ∪ (B \ A) := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.subset_union_left

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
instance instUnion : Union Set where union := union_pair
end Set
end SetTheory
theorem SetTheory.Set.subset_union_left (A B:Set) : A ⊆ A ∪ B := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.subset_inter_iff

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
end Set
end SetTheory
@[simp]
theorem SetTheory.Set.subset_inter_iff (A B C:Set) : C ⊆ A ∩ B ↔ C ⊆ A ∧ C ⊆ B := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.subset_inter_subset

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
end Set
end SetTheory
theorem SetTheory.Set.subset_inter_subset {A B A' B':Set} (hA'A: A' ⊆ A) (hB'B: B' ⊆ B) :
    A' ∩ B' ⊆ A ∩ B := by sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.emptyset_neq_singleton

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
abbrev empty : Set :=
  ∅
instance instSingleton : Singleton Object Set where singleton := singleton
abbrev singleton_empty : Set :=
  {(empty : Object)}
end Set
end SetTheory
theorem SetTheory.Set.emptyset_neq_singleton : empty ≠ singleton_empty := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.inter_subset_left

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
end Set
end SetTheory
theorem SetTheory.Set.inter_subset_left (A B:Set) : A ∩ B ⊆ A := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.pair_eq_pair

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
namespace Set
instance instSingleton : Singleton Object Set where singleton := singleton
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
end Set
end SetTheory
theorem SetTheory.Set.pair_eq_pair {a b c d:Object} (h: ({a,b}:Set) = {c,d}) :
    a = c ∧ b = d ∨ a = d ∧ b = c := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.subset_tfae

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
instance instUnion : Union Set where union := union_pair
end Set
end SetTheory
theorem SetTheory.Set.subset_tfae (A B:Set) : [A ⊆ B, A ∪ B = B, A ∩ B = A].TFAE := by sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.pairwise_disjoint

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
theorem subset_antisymm (A B : Set) (hAB : A ⊆ B) (hBA : B ⊆ A) : A = B := by sorry
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
@[simp]
theorem empty_subset (A : Set) : ∅ ⊆ A := by sorry
theorem subset_def (X Y : Set) : X ⊆ Y ↔ ∀ x, x ∈ X → x ∈ Y := by rfl
@[simp, refl]
theorem subset_self (A : Set) : A ⊆ A := by sorry
theorem subset_trans {A B C : Set} (hAB : A ⊆ B) (hBC : B ⊆ C) : A ⊆ C := by
  -- This proof is written to follow the structure of the original text.
  
  rw [subset_def]
  intro x hx
  rw [subset_def] at hAB
  apply hAB x at hx
  apply hBC x at hx
  assumption
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
instance instSDiff : SDiff Set where
  sdiff X
    Y :=
    X.specify
      (fun x ↦ x.val ∉ Y)
        -- Now we can use the `X \ Y` notation for a difference of two `Set`s.
instance instUnion : Union Set where union := union_pair
instance instDistribLattice : DistribLattice Set where
  le := (· ⊆ ·)
  le_refl := subset_self
  le_trans := fun _ _ _ ↦ subset_trans
  le_antisymm := subset_antisymm
  inf := (· ∩ ·)
  sup := (· ∪ ·)
  le_sup_left := by sorry
  le_sup_right := by sorry
  sup_le := by sorry
  inf_le_left := by sorry
  inf_le_right := by sorry
  le_inf := by sorry
  le_sup_inf := by
    intro X Y Z; change (X ∪ Y) ∩ (X ∪ Z) ⊆ X ∪ (Y ∩ Z)
    rw [← union_inter_distrib_left]
instance instOrderBot : OrderBot Set where
  bot := ∅
  bot_le := empty_subset
end Set
end SetTheory
theorem SetTheory.Set.pairwise_disjoint (A B:Set) :
    Pairwise (Function.onFun Disjoint ![A \ B, A ∩ B, B \ A]) := by sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.subset_union_subset

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
instance instUnion : Union Set where union := union_pair
end Set
end SetTheory
theorem SetTheory.Set.subset_union_subset {A B A' B':Set} (hA'A: A' ⊆ A) (hB'B: B' ⊆ B) :
    A' ∪ B' ⊆ A ∪ B := by sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.singleton_iff

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
instance instSSubset : HasSSubset Set where SSubset X Y := X ⊆ Y ∧ X ≠ Y
instance instSingleton : Singleton Object Set where singleton := singleton
end Set
end SetTheory
theorem SetTheory.Set.singleton_iff (A:Set) (hA: A ≠ ∅) : (¬∃ B ⊂ A, B ≠ ∅) ↔ ∃ x, A = {x} := by sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.partition_right

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
instance instSDiff : SDiff Set where
  sdiff X
    Y :=
    X.specify
      (fun x ↦ x.val ∉ Y)
        -- Now we can use the `X \ Y` notation for a difference of two `Set`s.
instance instUnion : Union Set where union := union_pair
end Set
end SetTheory
theorem SetTheory.Set.partition_right {A B X:Set} (h_union: A ∪ B = X) (h_inter: A ∩ B = ∅) :
    B = X \ A := by
  sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.subset_diff_subset_counter

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instSDiff : SDiff Set where
  sdiff X
    Y :=
    X.specify
      (fun x ↦ x.val ∉ Y)
        -- Now we can use the `X \ Y` notation for a difference of two `Set`s.
end Set
end SetTheory
theorem SetTheory.Set.subset_diff_subset_counter :
    ∃ (A B A' B':Set), (A' ⊆ A) ∧ (B' ⊆ B) ∧ ¬ (A' \ B') ⊆ (A \ B) := by sorry
end Chapter3

-----------------------------------

Section_3_1: Chapter3.SetTheory.Set.emptyset_neq_pair

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
abbrev empty : Set :=
  ∅
instance instSingleton : Singleton Object Set where singleton := singleton
abbrev singleton_empty : Set :=
  {(empty : Object)}
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev pair_empty : Set :=
  {(empty : Object), (singleton_empty : Object)}
end Set
end SetTheory
theorem SetTheory.Set.emptyset_neq_pair : empty ≠ pair_empty := by sorry
end Chapter3

-----------------------------------

Section_3_2: Chapter3.SetTheory.Set.pair_exists

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
end SetTheory
theorem SetTheory.Set.pair_exists (h: axiom_of_universal_specification) (x₁ x₂:Object):
    ∃ (X:Set), ∀ y, y ∈ X ↔ y = x₁ ∨ y = x₂ := by
  sorry
end Chapter3

-----------------------------------

Section_3_2: Chapter3.SetTheory.Set.singleton_exists

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
end SetTheory
theorem SetTheory.Set.singleton_exists (h: axiom_of_universal_specification) (x:Object):
    ∃ (X:Set), ∀ y, y ∈ X ↔ y = x := by
  sorry
end Chapter3

-----------------------------------

Section_3_2: Chapter3.SetTheory.Set.not_mem_mem

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
end SetTheory
theorem SetTheory.Set.not_mem_mem (A B:Set) : (A:Object) ∉ B ∨ (B:Object) ∉ A := by sorry
end Chapter3

-----------------------------------

Section_3_2: Chapter3.SetTheory.Set.replace_exists

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
end Set
end SetTheory
theorem SetTheory.Set.replace_exists (h: axiom_of_universal_specification) (A:Set)
  (P: A → Object → Prop) (hP: ∀ x y y', P x y ∧ P x y' → y = y') :
    ∃ (Z:Set), ∀ y, y ∈ Z ↔ ∃ a : A, P a y := by
  sorry
end Chapter3

-----------------------------------

Section_3_2: Chapter3.SetTheory.Set.not_mem_self

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
end SetTheory
theorem SetTheory.Set.not_mem_self (A:Set) : (A:Object) ∉ A := by sorry
end Chapter3

-----------------------------------

Section_3_2: Chapter3.SetTheory.Set.emptyset_exists

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
end SetTheory
theorem SetTheory.Set.emptyset_exists (h: axiom_of_universal_specification):
    ∃ (X:Set), ∀ x, x ∉ X := by
  sorry
end Chapter3

-----------------------------------

Section_3_2: Chapter3.SetTheory.Set.univ_iff

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
end SetTheory
theorem SetTheory.Set.univ_iff : axiom_of_universal_specification ↔
  ∃ (U:Set), ∀ x, x ∈ U := by sorry
end Chapter3

-----------------------------------

Section_3_2: Chapter3.SetTheory.Set.union_exists

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
end SetTheory
theorem SetTheory.Set.union_exists (h: axiom_of_universal_specification) (A B:Set):
    ∃ (Z:Set), ∀ z, z ∈ Z ↔ z ∈ A ∨ z ∈ B := by
  sorry
end Chapter3

-----------------------------------

Section_3_3: Chapter3.Function.comp_of_inj

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace Function
abbrev mk_fn {X Y : Set} (f : X → Y) : Function X Y :=
  Function.mk (fun x y ↦ y = f x) (by simp)
noncomputable def to_fn {X Y : Set} (f : Function X Y) : X → Y := fun x ↦ (f.unique x).choose
noncomputable abbrev comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) : Function X Z :=
  Function.mk_fn
    (fun x ↦ g (f x))
      -- `∘` is already taken in Mathlib for the composition of Mathlib functions,
      -- so we use `○` here instead to avoid ambiguity.
abbrev one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'
end Function
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
end Set
end SetTheory
theorem Function.comp_of_inj {X Y Z:Set} {f: Function X Y} {g : Function Y Z} (hf: f.one_to_one)
  (hg: g.one_to_one) : (g ○ f).one_to_one := by sorry
end Chapter3

-----------------------------------

Section_3_3: Chapter3.Function.comp_injective

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace Function
abbrev mk_fn {X Y : Set} (f : X → Y) : Function X Y :=
  Function.mk (fun x y ↦ y = f x) (by simp)
noncomputable def to_fn {X Y : Set} (f : Function X Y) : X → Y := fun x ↦ (f.unique x).choose
noncomputable abbrev comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) : Function X Z :=
  Function.mk_fn
    (fun x ↦ g (f x))
      -- `∘` is already taken in Mathlib for the composition of Mathlib functions,
      -- so we use `○` here instead to avoid ambiguity.
abbrev one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'
end Function
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
end Set
end SetTheory
theorem Function.comp_injective {X Y Z:Set} {f: Function X Y} {g : Function Y Z} (hinj :
    (g ○ f).one_to_one) : f.one_to_one := by sorry
end Chapter3

-----------------------------------

Section_3_3: Chapter3.Function.comp_cancel_left

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace Function
abbrev mk_fn {X Y : Set} (f : X → Y) : Function X Y :=
  Function.mk (fun x y ↦ y = f x) (by simp)
noncomputable def to_fn {X Y : Set} (f : Function X Y) : X → Y := fun x ↦ (f.unique x).choose
noncomputable abbrev comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) : Function X Z :=
  Function.mk_fn
    (fun x ↦ g (f x))
      -- `∘` is already taken in Mathlib for the composition of Mathlib functions,
      -- so we use `○` here instead to avoid ambiguity.
abbrev one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'
end Function
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
end Set
end SetTheory
theorem Function.comp_cancel_left {X Y Z:Set} {f f': Function X Y} {g : Function Y Z}
  (heq : g ○ f = g ○ f') (hg: g.one_to_one) : f = f' := by sorry
end Chapter3

-----------------------------------

Section_3_3: Chapter3.Function.refl

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
theorem Function.refl {X Y:Set} (f: Function X Y) : f = f := by sorry
end Chapter3

-----------------------------------

Section_3_3: Chapter3.Function.inverse_comp_self

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace Function
noncomputable def to_fn {X Y : Set} (f : Function X Y) : X → Y := fun x ↦ (f.unique x).choose
abbrev inverse {X Y : Set} (f : Function X Y) (h : f.bijective) : Function Y X :=
  Function.mk (fun y x ↦ f x = y)
    (by
      intros
      apply existsUnique_of_exists_of_unique
      . aesop
      intro _ _ hx hx'; simp at hx hx'
      rw [← hx'] at hx
      apply f.one_to_one_iff.mp h.1
      simp [hx])
abbrev one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'
abbrev onto {X Y : Set} (f : Function X Y) : Prop :=
  ∀ y : Y, ∃ x : X, f x = y
abbrev bijective {X Y : Set} (f : Function X Y) : Prop :=
  f.one_to_one ∧ f.onto
end Function
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
end Set
end SetTheory
theorem Function.inverse_comp_self {X Y: Set} {f: Function X Y} (h: f.bijective) (x: X) :
    (f.inverse h) (f x) = x := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.union_of_nonempty

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
instance instUnion : Union Set where union := union_pair
end Set
end SetTheory
theorem SetTheory.Set.union_of_nonempty {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) : I ∪ J ≠ ∅ := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.preimage_image_of_inj

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
abbrev image {X Y : Set} (f : X → Y) (S : Set) : Set :=
  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev preimage {X Y : Set} (f : X → Y) (U : Set) : Set :=
  X.specify (P := fun x ↦ (f x).val ∈ U)
end Set
end SetTheory
theorem SetTheory.Set.preimage_image_of_inj {X Y:Set} (f:X → Y) :
    (∀ S, S ⊆ X → preimage f (image f S) = S) ↔ Function.Injective f := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.union_pair_exists

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
end SetTheory
theorem SetTheory.Set.union_pair_exists (X Y:Set) : ∃ Z:Set, ∀ x, x ∈ Z ↔ (x ∈ X ∨ x ∈ Y) := by
  sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.iInter'_insensitive

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev iInter' (I : Set) (β : I) (A : I → Set) : Set :=
  (A β).specify (P := fun x ↦ ∀ α : I, x.val ∈ A α)
end Set
end SetTheory
theorem SetTheory.Set.iInter'_insensitive {I:Set} (β β':I) (A: I → Set) :
    iInter' I β A = iInter' I β' A := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.preimage_eq_image_of_inv

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
abbrev image {X Y : Set} (f : X → Y) (S : Set) : Set :=
  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev preimage {X Y : Set} (f : X → Y) (U : Set) : Set :=
  X.specify (P := fun x ↦ (f x).val ∈ U)
end Set
end SetTheory
theorem SetTheory.Set.preimage_eq_image_of_inv {X Y V:Set} (f:X → Y) (f_inv: Y → X)
  (hf: Function.LeftInverse f_inv f ∧ Function.RightInverse f_inv f) (hV: V ⊆ Y) :
    image f_inv V = preimage f V := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.compl_iInter

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
@[ext]
theorem ext {X Y : Set} (h : ∀ x, x ∈ X ↔ x ∈ Y) : X = Y :=
  extensionality _ _ h
theorem nonempty_def {X : Set} (h : X ≠ ∅) : ∃ x, x ∈ X := by
  -- This proof is written to follow the structure of the original text.
  
  by_contra! this
  have claim (x : Object) : x ∈ X ↔ x ∈ (∅ : Set) := by simp [this, not_mem_empty]
  apply ext at claim
  contradiction
noncomputable abbrev nonempty_choose {I : Set} (hI : I ≠ ∅) : I :=
  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev iInter' (I : Set) (β : I) (A : I → Set) : Set :=
  (A β).specify (P := fun x ↦ ∀ α : I, x.val ∈ A α)
noncomputable abbrev iInter (I : Set) (hI : I ≠ ∅) (A : I → Set) : Set :=
  iInter' I (nonempty_choose hI) A
instance instSDiff : SDiff Set where
  sdiff X
    Y :=
    X.specify
      (fun x ↦ x.val ∉ Y)
        -- Now we can use the `X \ Y` notation for a difference of two `Set`s.
abbrev iUnion (I : Set) (A : I → Set) : Set :=
  union (I.replace (P := fun α S ↦ S = A α) (by grind))
end Set
end SetTheory
theorem SetTheory.Set.compl_iInter {X I: Set} (hI: I ≠ ∅) (A: I → Set) :
    X \ iInter I hI A = iUnion I (fun α ↦ X \ A α) := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.mem_powerset

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Object
instance instOfNat {n : ℕ} : OfNat Object n where
  ofNat :=
    ((n : Nat) : Object)
      -- Now we can define `Object` with a natural literal.
end Object
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
instance instNatCast : NatCast Nat where natCast n := nat_equiv n
instance inst_pow : Pow Set Set where pow := pow
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
def powerset (X : Set) : Set :=
  (({0, 1} ^ X) : Set).replace (P := sorry) (by sorry)
end Set
end SetTheory
@[simp]
theorem SetTheory.Set.mem_powerset {X:Set} (x:Object) :
    x ∈ powerset X ↔ ∃ Y:Set, x = Y ∧ Y ⊆ X := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.image_preimage_of_surj

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
abbrev image {X Y : Set} (f : X → Y) (S : Set) : Set :=
  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev preimage {X Y : Set} (f : X → Y) (U : Set) : Set :=
  X.specify (P := fun x ↦ (f x).val ∈ U)
end Set
end SetTheory
theorem SetTheory.Set.image_preimage_of_surj {X Y:Set} (f:X → Y) :
    (∀ S, S ⊆ Y → image f (preimage f S) = S) ↔ Function.Surjective f := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.partial_functions

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
@[coe]
def coe_of_fun {X Y : Set} (f : X → Y) : Object :=
  function_to_object X Y f
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
end Set
end SetTheory
theorem SetTheory.Set.partial_functions {X Y:Set} :
    ∃ Z:Set, ∀ F:Object, F ∈ Z ↔ ∃ X' Y':Set, X' ⊆ X ∧ Y' ⊆ Y ∧ ∃ f: X' → Y', F = f := by
  sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.inter_iInter

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
@[ext]
theorem ext {X Y : Set} (h : ∀ x, x ∈ X ↔ x ∈ Y) : X = Y :=
  extensionality _ _ h
theorem nonempty_def {X : Set} (h : X ≠ ∅) : ∃ x, x ∈ X := by
  -- This proof is written to follow the structure of the original text.
  
  by_contra! this
  have claim (x : Object) : x ∈ X ↔ x ∈ (∅ : Set) := by simp [this, not_mem_empty]
  apply ext at claim
  contradiction
noncomputable abbrev nonempty_choose {I : Set} (hI : I ≠ ∅) : I :=
  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev iInter' (I : Set) (β : I) (A : I → Set) : Set :=
  (A β).specify (P := fun x ↦ ∀ α : I, x.val ∈ A α)
noncomputable abbrev iInter (I : Set) (hI : I ≠ ∅) (A : I → Set) : Set :=
  iInter' I (nonempty_choose hI) A
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
instance instUnion : Union Set where union := union_pair
theorem union_of_nonempty {I J : Set} (hI : I ≠ ∅) (hJ : J ≠ ∅) : I ∪ J ≠ ∅ := by sorry
end Set
end SetTheory
theorem SetTheory.Set.inter_iInter {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) (A: (I ∪ J:Set) → Set) :
    iInter I hI (fun α ↦ A ⟨ α.val, by simp [α.property]⟩)
    ∩ iInter J hJ (fun α ↦ A ⟨ α.val, by simp [α.property]⟩)
    = iInter (I ∪ J) (union_of_nonempty hI hJ) A := by sorry
end Chapter3

-----------------------------------

Section_3_4: Chapter3.SetTheory.Set.preimage_of_inter

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
abbrev preimage {X Y : Set} (f : X → Y) (U : Set) : Set :=
  X.specify (P := fun x ↦ (f x).val ∈ U)
end Set
end SetTheory
theorem SetTheory.Set.preimage_of_inter {X Y:Set} (f:X → Y) (A B: Set) :
    preimage f (A ∩ B) = (preimage f A) ∩ (preimage f B) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.recursion

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
instance instNatCast : NatCast Nat where natCast n := nat_equiv n
instance instOfNat {n : ℕ} : OfNat Nat n where ofNat := nat_equiv n
end Set
end SetTheory
theorem SetTheory.Set.recursion (X: Type) (f: nat → X → X) (c:X) :
    ∃! a: nat → X, a 0 = c ∧ ∀ n, a (n + 1:ℕ) = f n (a n) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.nat_unique

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
@[simp]
theorem nat_equiv_coe_of_coe' (n : Nat) : ((n : ℕ) : Nat) = n :=
  Equiv.symm_apply_apply nat_equiv.symm n
instance instNatCast : NatCast Nat where natCast n := nat_equiv n
instance instOfNat {n : ℕ} : OfNat Nat n where ofNat := nat_equiv n
theorem recursion (X : Set) (f : nat → X → X) (c : X) : ∃! a : nat → X, a 0 = c ∧ ∀ n, a (n + 1 : ℕ) = f n (a n) := by
  sorry
end Set
end SetTheory
theorem SetTheory.Set.nat_unique (nat':Set) (zero:nat') (succ:nat' → nat')
  (succ_ne: ∀ n:nat', succ n ≠ zero) (succ_of_ne: ∀ n m:nat', n ≠ m → succ n ≠ succ m)
  (ind: ∀ P: nat' → Prop, P zero → (∀ n, P n → P (succ n)) → ∀ n, P n) :
    ∃! f : nat → nat', Function.Bijective f ∧ f 0 = zero
    ∧ ∀ (n:nat) (n':nat'), f n = n' ↔ f (n+1:ℕ) = succ n' := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.diff_prod

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instSDiff : SDiff Set where
  sdiff X
    Y :=
    X.specify
      (fun x ↦ x.val ∉ Y)
        -- Now we can use the `X \ Y` notation for a difference of two `Set`s.
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.diff_prod (A B C:Set) : (A \ B) ×ˢ C = (A ×ˢ C) \ (B ×ˢ C) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.prod_subset_prod

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.prod_subset_prod {A B C D:Set}
  (hA: A ≠ ∅) (hB: B ≠ ∅) (hC: C ≠ ∅) (hD: D ≠ ∅) :
    A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.Tuple.eq

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
structure Tuple (n : ℕ) where
  X : Set
  x : Fin n → X
  surj : Function.Surjective x
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
end Set
end SetTheory
theorem SetTheory.Set.Tuple.eq {n:ℕ} (t t':Tuple n) :
    t = t' ↔ ∀ n : Fin n, ((t.x n):Object) = ((t'.x n):Object) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.union_prod

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.union_prod (A B C:Set) : (A ∪ B) ×ˢ C = (A ×ˢ C) ∪ (B ×ˢ C) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.inter_prod

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.inter_prod (A B C:Set) : (A ∩ B) ×ˢ C = (A ×ˢ C) ∩ (B ×ˢ C) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.graph_inj

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
noncomputable abbrev fst {X Y : Set} (z : X ×ˢ Y) : X :=
  ((mem_cartesian _ _ _).mp z.property).choose
noncomputable abbrev snd {X Y : Set} (z : X ×ˢ Y) : Y :=
  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose
abbrev graph {X Y : Set} (f : X → Y) : Set :=
  (X ×ˢ Y).specify (fun p ↦ (f (fst p) = snd p))
end Set
end SetTheory
theorem SetTheory.Set.graph_inj {X Y:Set} (f f': X → Y) :
    graph f = graph f' ↔ f = f' := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.prod_union

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.prod_union (A B C:Set) : A ×ˢ (B ∪ C) = (A ×ˢ B) ∪ (A ×ˢ C) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.prod_inter

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.prod_inter (A B C:Set) : A ×ˢ (B ∩ C) = (A ×ˢ B) ∩ (A ×ˢ C) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.prod_diff

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
instance instSDiff : SDiff Set where
  sdiff X
    Y :=
    X.specify
      (fun x ↦ x.val ∉ Y)
        -- Now we can use the `X \ Y` notation for a difference of two `Set`s.
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.prod_diff (A B C:Set) : A ×ˢ (B \ C) = (A ×ˢ B) \ (A ×ˢ C) := by sorry
end Chapter3

-----------------------------------

Section_3_5: Chapter3.SetTheory.Set.direct_sum

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
noncomputable abbrev fst {X Y : Set} (z : X ×ˢ Y) : X :=
  ((mem_cartesian _ _ _).mp z.property).choose
noncomputable abbrev snd {X Y : Set} (z : X ×ˢ Y) : Y :=
  (exists_comm.mp ((mem_cartesian _ _ _).mp z.property)).choose
end Set
end SetTheory
theorem SetTheory.Set.direct_sum {X Y Z:Set} (f: Z → X) (g: Z → Y) :
    ∃! h: Z → X ×ˢ Y, fst ∘ h = f ∧ snd ∘ h = g := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.prod_EqualCard_prod

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.prod_EqualCard_prod (A B:Set) :
    EqualCard (A ×ˢ B) (B ×ˢ A) := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.pigeonhole_principle

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
abbrev has_card (X : Set) (n : ℕ) : Prop :=
  X ≈ Fin n
abbrev finite (X : Set) : Prop :=
  ∃ n : ℕ, X.has_card n
noncomputable def card (X : Set) : ℕ :=
  if h : X.finite then h.choose else 0
abbrev iUnion (I : Set) (A : I → Set) : Set :=
  union (I.replace (P := fun α S ↦ S = A α) (by grind))
namespace EqualCard
instance inst_setoid : Setoid SetTheory.Set :=
  ⟨EqualCard, { refl, symm, trans }⟩
end EqualCard
end Set
end SetTheory
theorem SetTheory.Set.pigeonhole_principle {n:ℕ} {A: Fin n → Set}
  (hA: ∀ i, (A i).finite) (hAcard: (iUnion _ A).card > n) : ∃ i, (A i).card ≥ 2 := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.has_card_zero

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
abbrev has_card (X : Set) (n : ℕ) : Prop :=
  X ≈ Fin n
namespace EqualCard
instance inst_setoid : Setoid SetTheory.Set :=
  ⟨EqualCard, { refl, symm, trans }⟩
end EqualCard
end Set
end SetTheory
theorem SetTheory.Set.has_card_zero {X:Set} : X.has_card 0 ↔ X = ∅ := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.card_union_add_card_inter

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
abbrev has_card (X : Set) (n : ℕ) : Prop :=
  X ≈ Fin n
abbrev finite (X : Set) : Prop :=
  ∃ n : ℕ, X.has_card n
noncomputable def card (X : Set) : ℕ :=
  if h : X.finite then h.choose else 0
instance instIntersection : Inter Set where
  inter X
    Y :=
    X.specify
      (fun x ↦ x.val ∈ Y)
        -- Now we can use the `X ∩ Y` notation for an intersection of two `Set`s.
instance instUnion : Union Set where union := union_pair
namespace EqualCard
instance inst_setoid : Setoid SetTheory.Set :=
  ⟨EqualCard, { refl, symm, trans }⟩
end EqualCard
end Set
end SetTheory
theorem SetTheory.Set.card_union_add_card_inter {A B:Set} (hA: A.finite) (hB: B.finite) :
    A.card + B.card = (A ∪ B).card + (A ∩ B).card := by  sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.Example_3_6_3

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
end Set
end SetTheory
theorem SetTheory.Set.Example_3_6_3 : EqualCard nat (nat.specify (fun x ↦ Even (x:ℕ))) := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.Permutations_ih

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Object
instance instNatCast : NatCast Object where natCast n := (n : Nat).val
end Object
namespace Set
@[coe]
def coe_of_fun {X Y : Set} (f : X → Y) : Object :=
  function_to_object X Y f
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
instance instNatCast : NatCast Nat where natCast n := nat_equiv n
instance inst_pow : Pow Set Set where pow := pow
noncomputable def pow_fun_equiv {A B : Set} : ↑(A ^ B) ≃ (B → A)
    where
  toFun := sorry
  invFun := sorry
  left_inv := sorry
  right_inv := sorry
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
abbrev Fin_mk (n m : ℕ) (h : m < n) : Fin n :=
  ⟨m, by rw [mem_Fin]; use m⟩
def Permutations (n : ℕ) : Set :=
  (Fin n ^ Fin n).specify (fun F ↦ Function.Bijective (pow_fun_equiv F))
noncomputable def Permutations_toFun {n : ℕ} (p : Permutations n) : (Fin n) → (Fin n) :=
  by
  have := p.property
  simp only [Permutations, specification_axiom'', powerset_axiom] at this
  exact this.choose.choose
theorem Permutations_bijective {n : ℕ} (p : Permutations n) : Function.Bijective (Permutations_toFun p) := by sorry
abbrev has_card (X : Set) (n : ℕ) : Prop :=
  X ≈ Fin n
abbrev finite (X : Set) : Prop :=
  ∃ n : ℕ, X.has_card n
noncomputable def card (X : Set) : ℕ :=
  if h : X.finite then h.choose else 0
noncomputable def perm_equiv_equiv {n : ℕ} : Permutations n ≃ (Fin n ≃ Fin n) :=
  { toFun := fun p => Equiv.ofBijective (Permutations_toFun p) (Permutations_bijective p)
    invFun := sorry
    left_inv := sorry
    right_inv := sorry }
namespace EqualCard
instance inst_setoid : Setoid SetTheory.Set :=
  ⟨EqualCard, { refl, symm, trans }⟩
end EqualCard
namespace Fin
def last (n : ℕ) : Fin (n + 1) :=
  Fin_mk _ n (by omega)
end Fin
end Set
end SetTheory
theorem SetTheory.Set.Permutations_ih (n: ℕ):
    (Permutations (n + 1)).card = (n + 1) * (Permutations n).card := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.Example_3_6_7a

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Object
@[simp]
theorem ofnat_eq'' {n : Nat} : ((n : ℕ) : Object) = (n : Object) := by simp [instNatCast, Nat.cast, Set.instNatCast]
instance instNatCast : NatCast Object where natCast n := (n : Nat).val
@[simp]
theorem natCast_inj (n m : ℕ) : (n : Object) = (m : Object) ↔ n = m := by simp [← ofnat_eq, Subtype.val_inj]
@[simp]
theorem ofnat_eq {n : ℕ} : ((n : Nat) : Object) = (n : Object) :=
  rfl
end Object
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
instance instNatCast : NatCast Nat where natCast n := nat_equiv n
instance instSingleton : Singleton Object Set where singleton := singleton
theorem specification_axiom' {A : Set} (P : A → Prop) (x : A) : x.val ∈ A.specify P ↔ P x :=
  (SetTheory.specification_axiom A P).2 x
theorem specification_axiom {A : Set} {P : A → Prop} {x : Object} (h : x ∈ A.specify P) : x ∈ A :=
  (SetTheory.specification_axiom A P).1 x h
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
@[simp]
theorem specification_axiom'' {A : Set} (P : A → Prop) (x : Object) : x ∈ A.specify P ↔ ∃ h : x ∈ A, P ⟨x, h⟩ :=
  by
  constructor
  . intro h; use specification_axiom h
    simp [← specification_axiom' P, h]
  intro ⟨h, hP⟩
  simpa [← specification_axiom' P] using hP
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
abbrev Fin_mk (n m : ℕ) (h : m < n) : Fin n :=
  ⟨m, by rw [mem_Fin]; use m⟩
abbrev has_card (X : Set) (n : ℕ) : Prop :=
  X ≈ Fin n
theorem has_card_iff (X : Set) (n : ℕ) : X.has_card n ↔ ∃ f : X → Fin n, Function.Bijective f := by
  simp [has_card, HasEquiv.Equiv, Setoid.r, EqualCard]
theorem mem_Fin (n : ℕ) (x : Object) : x ∈ Fin n ↔ ∃ m, m < n ∧ x = m :=
  by
  rw [specification_axiom'']; constructor
  . intro ⟨h1, h2⟩; use ↑(⟨x, h1⟩ : nat); simp [h2]
  intro ⟨m, hm, h⟩
  use (by rw [h, ← Object.ofnat_eq]; exact (m : nat).property)
  grind [Object.ofnat_eq''']
theorem mem_Fin' {n : ℕ} (x : Fin n) : ∃ m, ∃ h : m < n, x = Fin_mk n m h :=
  by
  choose m hm this using (mem_Fin _ _).mp x.property; use m, hm
  simp [Fin_mk, ← Subtype.val_inj, this]
namespace EqualCard
instance inst_setoid : Setoid SetTheory.Set :=
  ⟨EqualCard, { refl, symm, trans }⟩
end EqualCard
namespace Fin
@[coe]
noncomputable abbrev toNat {n : ℕ} (i : Fin n) : ℕ :=
  (mem_Fin' i).choose
theorem toNat_spec {n : ℕ} (i : Fin n) : ∃ h : i < n, i = Fin_mk n i h :=
  (mem_Fin' i).choose_spec
@[simp]
theorem coe_toNat {n : ℕ} (i : Fin n) : ((i : ℕ) : Object) = (i : Object) := by set j := (i : ℕ);
  obtain ⟨h, h' : i = Fin_mk n j h⟩ := toNat_spec i; rw [h']
theorem toNat_lt {n : ℕ} (i : Fin n) : i < n :=
  (toNat_spec i).choose
@[simp]
theorem toNat_mk {n : ℕ} (m : ℕ) (h : m < n) : (Fin_mk n m h : ℕ) = m :=
  by
  have := coe_toNat (Fin_mk n m h)
  rwa [Object.natCast_inj] at this
end Fin
end Set
end SetTheory
theorem SetTheory.Set.Example_3_6_7a (a:Object) : ({a}:Set).has_card 1 := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.bounded_on_finite

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
end Set
end SetTheory
theorem SetTheory.Set.bounded_on_finite {n:ℕ} (f: Fin n → nat) : ∃ M, ∀ i, (f i:ℕ) ≤ M := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.card_eq_zero_of_empty

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
instance instEmpty : EmptyCollection Set where emptyCollection := emptyset
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
abbrev has_card (X : Set) (n : ℕ) : Prop :=
  X ≈ Fin n
abbrev finite (X : Set) : Prop :=
  ∃ n : ℕ, X.has_card n
noncomputable def card (X : Set) : ℕ :=
  if h : X.finite then h.choose else 0
theorem empty_iff_card_eq_zero {X : Set} : X = ∅ ↔ X.finite ∧ X.card = 0 := by sorry
namespace EqualCard
instance inst_setoid : Setoid SetTheory.Set :=
  ⟨EqualCard, { refl, symm, trans }⟩
end EqualCard
end Set
end SetTheory
theorem SetTheory.Set.card_eq_zero_of_empty {X:Set} (hX: X.finite) :
    X.card = 0 ↔ X = ∅ := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.two_to_two_iff

import Mathlib.Tactic

namespace Chapter3
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
abbrev Nat :=
  SetTheory.nat
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
def nat_equiv : ℕ ≃ Nat :=
  SetTheory.nat_equiv
instance instSubset : HasSubset Set where Subset X Y := ∀ x, x ∈ X → x ∈ Y
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
abbrev image {X Y : Set} (f : X → Y) (S : Set) : Set :=
  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S) (by simp_all)
abbrev specify (A : Set) (P : A → Prop) : Set :=
  SetTheory.specify A P
abbrev Fin (n : ℕ) : Set :=
  nat.specify (fun m ↦ (m : ℕ) < n)
abbrev has_card (X : Set) (n : ℕ) : Prop :=
  X ≈ Fin n
abbrev finite (X : Set) : Prop :=
  ∃ n : ℕ, X.has_card n
noncomputable def card (X : Set) : ℕ :=
  if h : X.finite then h.choose else 0
namespace EqualCard
instance inst_setoid : Setoid SetTheory.Set :=
  ⟨EqualCard, { refl, symm, trans }⟩
end EqualCard
end Set
end SetTheory
theorem SetTheory.Set.two_to_two_iff {X Y:Set} (f: X → Y): Function.Injective f ↔
    ∀ S ⊆ X, S.card = 2 → (image f S).card = 2 := by sorry
end Chapter3

-----------------------------------

Section_3_6: Chapter3.SetTheory.Set.pow_pow_EqualCard_pow_prod

import Mathlib.Tactic

namespace Chapter3
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem :
    Object →
      Set →
        Prop -- Axiom 3.1
          
  extensionality X Y : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset : Set
  emptyset_mem x : ¬mem x emptyset
  singleton : Object → Set
  singleton_axiom x y : mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom X Y x :
    mem x (union_pair X Y) ↔
      (mem x X ∨ mem x Y) -- Axiom 3.5
        
  specify A (P : Subtype (mem . A) → Prop) : Set
  specification_axiom A (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧ ∀ x, mem x.val (specify A P) ↔ P x
  replace A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set
  replacement_axiom A (P : Subtype (mem . A) → Object → Prop) (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∀ y, mem y (replace A P hP) ↔ ∃ x, P x y
  nat : Set
  nat_equiv :
    ℕ ≃
      Subtype
        (mem . nat) -- Axiom 3.8
          
  regularity_axiom A (hA : ∃ x, mem x A) : ∃ x, mem x A ∧ ∀ S, x = set_to_object S → ¬∃ y, mem y A ∧ mem y S
  pow : Set → Set → Set
  function_to_object (X : Set) (Y : Set) : (Subtype (mem . X) → Subtype (mem . Y)) ↪ Object
  powerset_axiom (X : Set) (Y : Set) (F : Object) :
    mem F (pow X Y) ↔ ∃ f : Subtype (mem . Y) → Subtype (mem . X), function_to_object Y X f = F
  union : Set → Set
  union_axiom A x : mem x (union A) ↔ ∃ S, mem x S ∧ mem (set_to_object S) A
namespace OrderedPair
def toObject : OrderedPair ↪ Object
    where
  toFun p := ({(({ p.fst } : Set) : Object), (({ p.fst, p.snd } : Set) : Object)} : Set)
  inj' := by sorry
end OrderedPair
namespace SetTheory
instance objects_mem_sets : Membership Object Set where mem X x := mem x X
namespace Set
abbrev toSubtype (A : Set) :=
  Subtype (fun x ↦ x ∈ A)
abbrev EqualCard (X Y : Set) : Prop :=
  ∃ f : X → Y, Function.Bijective f
instance inst_pow : Pow Set Set where pow := pow
abbrev replace (A : Set) {P : A → Object → Prop} (hP : ∀ x y y', P x y ∧ P x y' → y = y') : Set :=
  SetTheory.replace A P hP
instance instSingleton : Singleton Object Set where singleton := singleton
instance instUnion : Union Set where union := union_pair
instance instInsert : Insert Object Set where insert x X := { x } ∪ X
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace (P := fun y z ↦ z = (⟨x, y⟩ : OrderedPair)) (by grind)
abbrev cartesian (X Y : Set) : Set :=
  union (X.replace (P := fun x z ↦ z = slice x Y) (by grind))
instance inst_SProd : SProd Set Set Set where sprod := cartesian
end Set
end SetTheory
theorem SetTheory.Set.pow_pow_EqualCard_pow_prod (A B C:Set) :
    EqualCard ((A ^ B) ^ C) (A ^ (B ×ˢ C)) := by sorry
end Chapter3

-----------------------------------

Section_4_1: Section_4_1.Int.sq_nonneg

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

theorem Int.sq_nonneg (n:Int) : 0 ≤ n*n := by sorry

-----------------------------------

Section_4_1: Section_4_1.Int.no_induction

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

theorem Int.no_induction : ∃ P: Int → Prop, P 0 ∧ ∀ n, P n → P (n+1) ∧ ¬ ∀ n, P n := by sorry

-----------------------------------

Section_4_1: Section_4_1.Int.sq_nonneg'

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

theorem Int.sq_nonneg' (n:Int) : ∃ (m:Nat), n*n = m := by sorry

-----------------------------------

Section_4_2: Section_4_2.Rat.mul_lt_mul_right_of_neg

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

theorem Rat.mul_lt_mul_right_of_neg (x y z:Rat) (hxy: x < y) (hz: z.isNeg) : x * z > y * z := by
  sorry

-----------------------------------

Section_4_3: Section_4_3.two_pow_geq

import Mathlib.Tactic

theorem two_pow_geq (N:ℕ) : 2^N ≥ N := by sorry

-----------------------------------

Section_4_4: Nat.no_infinite_descent

import Mathlib.Tactic

theorem Nat.no_infinite_descent : ¬ ∃ a:ℕ → ℕ, ∀ n, a (n+1) < a n := by
  sorry

-----------------------------------

Section_5_1: Chapter5.Sequence.ex_5_1_10_a

import Mathlib.Tactic

namespace Chapter5
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
namespace Sequence
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
noncomputable def sqrt_two : Sequence :=
  (fun n : ℕ ↦ ((⌊(Real.sqrt 2) * 10 ^ n⌋ / 10 ^ n) : ℚ))
end Sequence
theorem Sequence.ex_5_1_10_a : (1:ℚ).Steady sqrt_two := by sorry
end Chapter5

-----------------------------------

Section_5_2: Chapter5.Sequence.isBounded_of_eventuallyClose

import Mathlib.Tactic

namespace Chapter5
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
namespace Sequence
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev BoundedBy (a : Sequence) (M : ℚ) : Prop :=
  ∀ n, |a n| ≤ M
abbrev IsBounded (a : Sequence) : Prop :=
  ∃ M ≥ 0, a.BoundedBy M
end Sequence
theorem Sequence.isBounded_of_eventuallyClose {ε:ℚ} {a b: ℕ → ℚ} (hab: ε.EventuallyClose a b) :
    (a:Sequence).IsBounded ↔ (b:Sequence).IsBounded := by sorry
end Chapter5

-----------------------------------

Section_5_3: Chapter5.Real.IsBounded.equiv

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Chapter5
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
namespace Sequence
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
abbrev BoundedBy (a : Sequence) (M : ℚ) : Prop :=
  ∀ n, |a n| ≤ M
abbrev IsBounded (a : Sequence) : Prop :=
  ∃ M ≥ 0, a.BoundedBy M
end Sequence
theorem Real.IsBounded.equiv {a b:ℕ → ℚ} (ha: (a:Sequence).IsBounded) (hab: Sequence.Equiv a b) :
    (b:Sequence).IsBounded := by sorry
end Chapter5

-----------------------------------

Section_5_3: Chapter5.Real.ratCast_inj

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Chapter5
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
end CauchySequence
namespace Real
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
@[simp]
theorem Real.ratCast_inj (q r:ℚ) : (q:Real) = (r:Real) ↔ q = r := by
  sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.neg_max

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.neg_max (x y:Real) : max x y = - min (-x) (-y) := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.max_add

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.max_add (x y z:Real) : max (x + z) (y + z) = max x y + z := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.dist_le_iff

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.dist_le_iff (ε x y:Real) : |x-y| ≤ ε ↔ y-ε ≤ x ∧ x ≤ y+ε := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.min_self

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.min_self (x:Real) : min x x = x := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.le_add_eps_iff

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.le_add_eps_iff (x y:Real) : ∀ ε > 0, x ≤ y+ε ↔ x ≤ y := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.min_add

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.min_add (x y z:Real) : min (x + z) (y + z) = min x y + z := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.min_comm

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.min_comm (x y:Real) : min x y = min y x := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.min_mul

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
abbrev BoundedAwayPos (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≥ c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
abbrev IsPos (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayPos a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.min_mul (x y :Real) {z:Real} (hz: z.IsPos) : min (x * z) (y * z) = min x y * z := by
  sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.LIM_of_le

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.LIM_of_le {x:Real} {a:ℕ → ℚ} (hcauchy: (a:Sequence).IsCauchy) (h: ∀ n, a n ≤ x) :
    LIM a ≤ x := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.dist_le_eps_iff

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.dist_le_eps_iff (x y:Real) : ∀ ε > 0, |x-y| ≤ ε ↔ x = y := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.LIM_of_ge

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.LIM_of_ge {x:Real} {a:ℕ → ℚ} (hcauchy: (a:Sequence).IsCauchy) (h: ∀ n, a n ≥ x) :
    LIM a ≥ x := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.max_comm

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.max_comm (x y:Real) : max x y = max y x := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.floor_exist

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instIntCast : IntCast Real where intCast n := ((n : ℚ) : Real)
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.floor_exist (x:Real) : ∃ n:ℤ, (n:Real) ≤ x ∧ x < (n:Real)+1 := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.dist_lt_iff

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.dist_lt_iff (ε x y:Real) : |x-y| < ε ↔ y-ε < x ∧ x < y+ε := by sorry
end Chapter5

-----------------------------------

Section_5_4: Chapter5.Real.inv_max

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
abbrev BoundedAwayPos (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≥ c
abbrev BoundedAwayZero (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, |a n| ≥ c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
theorem LIM_def {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : LIM a = Quotient.mk _ (CauchySequence.mk' ha) := by
  rw [LIM, dif_pos ha]
theorem bounded_away_zero_def (a : ℕ → ℚ) : BoundedAwayZero a ↔ ∃ (c : ℚ), c > 0 ∧ ∀ n, |a n| ≥ c := by rfl
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
theorem equiv_iff (a b : CauchySequence) : a ≈ b ↔ Sequence.Equiv a b := by rfl
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
@[simp]
theorem coe_to_sequence (a : CauchySequence) : ((a : ℕ → ℚ) : Sequence) = a.toSequence :=
  by
  apply Sequence.ext (by simp [Sequence.n0_coe, a.zero])
  ext n; by_cases h : n ≥ 0 <;> simp_all
  rw [a.vanish]; rwa [a.zero]
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
abbrev IsPos (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayPos a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
theorem LIM_eq_LIM {a b : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) (hb : (b : Sequence).IsCauchy) :
    LIM a = LIM b ↔ Sequence.Equiv a b := by
  constructor
  . intro h; replace h := Quotient.exact h
    rwa [dif_pos ha, dif_pos hb, CauchySequence.equiv_iff] at h
  intro h; apply Quotient.sound
  rwa [dif_pos ha, dif_pos hb, CauchySequence.equiv_iff]
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
theorem boundedAwayZero_of_nonzero {x : Real} (hx : x ≠ 0) :
    ∃ a : ℕ → ℚ, (a : Sequence).IsCauchy ∧ BoundedAwayZero a ∧ x = LIM a := by
  -- This proof is written to follow the structure of the original text.
  
  obtain ⟨b, hb, rfl⟩ := eq_lim x
  simp only [← LIM.zero, ne_eq] at hx
  rw [LIM_eq_LIM hb (by convert Sequence.IsCauchy.const 0), Sequence.equiv_iff] at hx
  simp at hx
  choose ε hε hx using hx
  choose N hb' using (Sequence.IsCauchy.coe _).mp hb _ (half_pos hε)
  choose n₀ hn₀ hx using hx N
  have how : ∀ j ≥ N, |b j| ≥ ε / 2 := by sorry
  set a : ℕ → ℚ := fun n ↦ if n < n₀ then ε / 2 else b n
  have not_hard : Sequence.Equiv a b := by sorry
  have ha := (Sequence.isCauchy_of_equiv not_hard).mpr hb
  refine ⟨a, ha, ?_, by rw [(LIM_eq_LIM ha hb).mpr not_hard]⟩
  rw [bounded_away_zero_def]
  use ε / 2, half_pos hε
  intro n; by_cases hn : n < n₀ <;> simp [a, hn, le_abs_self _]
  grind
noncomputable instance instInv : Inv Real where
  inv x := if h : x ≠ 0 then LIM (boundedAwayZero_of_nonzero h).choose⁻¹ else 0
end Real
namespace Sequence
abbrev mk' (n₀ : ℤ) (a : { n // n ≥ n₀ } → ℚ) : Sequence
    where
  n₀ := n₀
  seq n := if h : n ≥ n₀ then a ⟨n, h⟩ else 0
  vanish := by grind
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
theorem equiv_iff (a b : ℕ → ℚ) : Equiv a b ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - b n| ≤ ε := by sorry
theorem isCauchy_of_equiv {a b : ℕ → ℚ} (hab : Equiv a b) : (a : Sequence).IsCauchy ↔ (b : Sequence).IsCauchy := by
  sorry
@[simp]
theorem n0_coe (a : ℕ → ℚ) : (a : Sequence).n₀ = 0 := by norm_cast
@[simp]
theorem eval_coe_at_int (n : ℤ) (a : ℕ → ℚ) : (a : Sequence) n = if n ≥ 0 then a n.toNat else 0 := by norm_cast
abbrev «from» (a : Sequence) (n₁ : ℤ) : Sequence :=
  mk' (max a.n₀ n₁) (fun n ↦ a (n : ℤ))
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
theorem coe (a : ℕ → ℚ) :
    (a : Sequence).IsCauchy ↔ ∀ ε > (0 : ℚ), ∃ N, ∀ j ≥ N, ∀ k ≥ N, Section_4_3.dist (a j) (a k) ≤ ε :=
  by
  constructor <;> intro h ε hε
  · choose N hN h' using h ε hε
    lift N to ℕ using hN; use N
    intro j _ k _; simp [Rat.steady_def] at h'; specialize h' j _ k _ <;> try omega
    simp_all; exact h'
  choose N h' using h ε hε
  refine ⟨max N 0, by simp, ?_⟩
  intro n hn m hm; simp at hn hm
  have npos : 0 ≤ n := ?_
  have mpos : 0 ≤ m := ?_
  lift n to ℕ using npos
  lift m to ℕ using mpos
  simp [hn, hm]; specialize h' n _ m _
  all_goals try omega
  norm_cast
end IsCauchy
end Sequence
theorem Real.inv_max {x y :Real} (hx:x.IsPos) (hy:y.IsPos) : (max x y)⁻¹ = min x⁻¹ y⁻¹ := by sorry
end Chapter5

-----------------------------------

Section_5_5: Chapter5.Real.upperBound_between

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instIntCast : IntCast Real where intCast n := ((n : ℚ) : Real)
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.upperBound_between {E: Set Real} {n:ℕ} {L K:ℤ} (hLK: L < K)
  (hK: K*((1/(n+1):ℚ):Real) ∈ upperBounds E) (hL: L*((1/(n+1):ℚ):Real) ∉ upperBounds E) :
    ∃ m, L < m
    ∧ m ≤ K
    ∧ m*((1/(n+1):ℚ):Real) ∈ upperBounds E
    ∧ (m-1)*((1/(n+1):ℚ):Real) ∉ upperBounds E := by sorry
end Chapter5

-----------------------------------

Section_5_5: Chapter5.Real.LIM_of_Cauchy

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
abbrev BoundedAwayZero (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, |a n| ≥ c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
theorem LIM_def {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : LIM a = Quotient.mk _ (CauchySequence.mk' ha) := by
  rw [LIM, dif_pos ha]
theorem bounded_away_zero_def (a : ℕ → ℚ) : BoundedAwayZero a ↔ ∃ (c : ℚ), c > 0 ∧ ∀ n, |a n| ≥ c := by rfl
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
theorem equiv_iff (a b : CauchySequence) : a ≈ b ↔ Sequence.Equiv a b := by rfl
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
@[simp]
theorem coe_to_sequence (a : CauchySequence) : ((a : ℕ → ℚ) : Sequence) = a.toSequence :=
  by
  apply Sequence.ext (by simp [Sequence.n0_coe, a.zero])
  ext n; by_cases h : n ≥ 0 <;> simp_all
  rw [a.vanish]; rwa [a.zero]
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
theorem LIM_eq_LIM {a b : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) (hb : (b : Sequence).IsCauchy) :
    LIM a = LIM b ↔ Sequence.Equiv a b := by
  constructor
  . intro h; replace h := Quotient.exact h
    rwa [dif_pos ha, dif_pos hb, CauchySequence.equiv_iff] at h
  intro h; apply Quotient.sound
  rwa [dif_pos ha, dif_pos hb, CauchySequence.equiv_iff]
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instIntCast : IntCast Real where intCast n := ((n : ℚ) : Real)
instance instNatCast : NatCast Real where natCast n := ((n : ℚ) : Real)
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instCommMonoid : CommMonoid Real
    where
  mul_comm := by sorry
  mul_assoc := by sorry
  one_mul := by sorry
  mul_one := by sorry
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
noncomputable instance instAddCommGroup : AddCommGroup Real where add_comm := by sorry
noncomputable instance instCommRing : CommRing Real
    where
  left_distrib := by sorry
  right_distrib := by sorry
  zero_mul := by sorry
  mul_zero := by sorry
  mul_assoc := by sorry
  natCast_succ := by sorry
  intCast_negSucc := by sorry
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
theorem boundedAwayZero_of_nonzero {x : Real} (hx : x ≠ 0) :
    ∃ a : ℕ → ℚ, (a : Sequence).IsCauchy ∧ BoundedAwayZero a ∧ x = LIM a := by
  -- This proof is written to follow the structure of the original text.
  
  obtain ⟨b, hb, rfl⟩ := eq_lim x
  simp only [← LIM.zero, ne_eq] at hx
  rw [LIM_eq_LIM hb (by convert Sequence.IsCauchy.const 0), Sequence.equiv_iff] at hx
  simp at hx
  choose ε hε hx using hx
  choose N hb' using (Sequence.IsCauchy.coe _).mp hb _ (half_pos hε)
  choose n₀ hn₀ hx using hx N
  have how : ∀ j ≥ N, |b j| ≥ ε / 2 := by sorry
  set a : ℕ → ℚ := fun n ↦ if n < n₀ then ε / 2 else b n
  have not_hard : Sequence.Equiv a b := by sorry
  have ha := (Sequence.isCauchy_of_equiv not_hard).mpr hb
  refine ⟨a, ha, ?_, by rw [(LIM_eq_LIM ha hb).mpr not_hard]⟩
  rw [bounded_away_zero_def]
  use ε / 2, half_pos hε
  intro n; by_cases hn : n < n₀ <;> simp [a, hn, le_abs_self _]
  grind
noncomputable instance instInv : Inv Real where
  inv x := if h : x ≠ 0 then LIM (boundedAwayZero_of_nonzero h).choose⁻¹ else 0
noncomputable instance instDivInvMonoid : DivInvMonoid Real where
end Real
namespace Sequence
abbrev mk' (n₀ : ℤ) (a : { n // n ≥ n₀ } → ℚ) : Sequence
    where
  n₀ := n₀
  seq n := if h : n ≥ n₀ then a ⟨n, h⟩ else 0
  vanish := by grind
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
theorem equiv_iff (a b : ℕ → ℚ) : Equiv a b ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - b n| ≤ ε := by sorry
theorem isCauchy_of_equiv {a b : ℕ → ℚ} (hab : Equiv a b) : (a : Sequence).IsCauchy ↔ (b : Sequence).IsCauchy := by
  sorry
@[simp]
theorem n0_coe (a : ℕ → ℚ) : (a : Sequence).n₀ = 0 := by norm_cast
@[simp]
theorem eval_coe_at_int (n : ℤ) (a : ℕ → ℚ) : (a : Sequence) n = if n ≥ 0 then a n.toNat else 0 := by norm_cast
abbrev «from» (a : Sequence) (n₁ : ℤ) : Sequence :=
  mk' (max a.n₀ n₁) (fun n ↦ a (n : ℤ))
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
theorem coe (a : ℕ → ℚ) :
    (a : Sequence).IsCauchy ↔ ∀ ε > (0 : ℚ), ∃ N, ∀ j ≥ N, ∀ k ≥ N, Section_4_3.dist (a j) (a k) ≤ ε :=
  by
  constructor <;> intro h ε hε
  · choose N hN h' using h ε hε
    lift N to ℕ using hN; use N
    intro j _ k _; simp [Rat.steady_def] at h'; specialize h' j _ k _ <;> try omega
    simp_all; exact h'
  choose N h' using h ε hε
  refine ⟨max N 0, by simp, ?_⟩
  intro n hn m hm; simp at hn hm
  have npos : 0 ≤ n := ?_
  have mpos : 0 ≤ m := ?_
  lift n to ℕ using npos
  lift m to ℕ using mpos
  simp [hn, hm]; specialize h' n _ m _
  all_goals try omega
  norm_cast
end IsCauchy
end Sequence
theorem Real.LIM_of_Cauchy {q:ℕ → ℚ} (hq: ∀ M, ∀ n ≥ M, ∀ n' ≥ M, |q n - q n'| ≤ 1 / (M+1)) :
    (q:Sequence).IsCauchy ∧ ∀ M, |q M - LIM q| ≤ 1 / (M+1) := by sorry
end Chapter5

-----------------------------------

Section_5_5: Chapter5.Real.inf_neg

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instIntCast : IntCast Real where intCast n := ((n : ℚ) : Real)
instance instNatCast : NatCast Real where natCast n := ((n : ℚ) : Real)
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instCommMonoid : CommMonoid Real
    where
  mul_comm := by sorry
  mul_assoc := by sorry
  one_mul := by sorry
  mul_one := by sorry
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
noncomputable instance instAddCommGroup : AddCommGroup Real where add_comm := by sorry
noncomputable instance instCommRing : CommRing Real
    where
  left_distrib := by sorry
  right_distrib := by sorry
  zero_mul := by sorry
  mul_zero := by sorry
  mul_assoc := by sorry
  natCast_succ := by sorry
  intCast_negSucc := by sorry
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.inf_neg {E: Set Real} {M:Real} (h: IsLUB E M) : IsGLB (-E) (-M) := by sorry
end Chapter5

-----------------------------------

Section_5_5: Chapter5.Real.irrat_between

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
instance instLT : LT Real where lt x y := (x - y).IsNeg
end Real
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
end IsCauchy
end Sequence
theorem Real.irrat_between {x y:Real} (hxy: x < y) :
    ∃ z, x < z ∧ z < y ∧ ¬ ∃ q:ℚ, z = (q:Real) := by sorry
end Chapter5

-----------------------------------

Section_5_6: Chapter5.Real.pow_even

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
abbrev BoundedAwayZero (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, |a n| ≥ c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
theorem LIM_def {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : LIM a = Quotient.mk _ (CauchySequence.mk' ha) := by
  rw [LIM, dif_pos ha]
theorem bounded_away_zero_def (a : ℕ → ℚ) : BoundedAwayZero a ↔ ∃ (c : ℚ), c > 0 ∧ ∀ n, |a n| ≥ c := by rfl
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
theorem equiv_iff (a b : CauchySequence) : a ≈ b ↔ Sequence.Equiv a b := by rfl
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
@[simp]
theorem coe_to_sequence (a : CauchySequence) : ((a : ℕ → ℚ) : Sequence) = a.toSequence :=
  by
  apply Sequence.ext (by simp [Sequence.n0_coe, a.zero])
  ext n; by_cases h : n ≥ 0 <;> simp_all
  rw [a.vanish]; rwa [a.zero]
end CauchySequence
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
theorem LIM_eq_LIM {a b : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) (hb : (b : Sequence).IsCauchy) :
    LIM a = LIM b ↔ Sequence.Equiv a b := by
  constructor
  . intro h; replace h := Quotient.exact h
    rwa [dif_pos ha, dif_pos hb, CauchySequence.equiv_iff] at h
  intro h; apply Quotient.sound
  rwa [dif_pos ha, dif_pos hb, CauchySequence.equiv_iff]
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instIntCast : IntCast Real where intCast n := ((n : ℚ) : Real)
instance instNatCast : NatCast Real where natCast n := ((n : ℚ) : Real)
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instCommMonoid : CommMonoid Real
    where
  mul_comm := by sorry
  mul_assoc := by sorry
  one_mul := by sorry
  mul_one := by sorry
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
noncomputable instance instAddCommGroup : AddCommGroup Real where add_comm := by sorry
noncomputable instance instCommRing : CommRing Real
    where
  left_distrib := by sorry
  right_distrib := by sorry
  zero_mul := by sorry
  mul_zero := by sorry
  mul_assoc := by sorry
  natCast_succ := by sorry
  intCast_negSucc := by sorry
instance instLT : LT Real where lt x y := (x - y).IsNeg
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
theorem boundedAwayZero_of_nonzero {x : Real} (hx : x ≠ 0) :
    ∃ a : ℕ → ℚ, (a : Sequence).IsCauchy ∧ BoundedAwayZero a ∧ x = LIM a := by
  -- This proof is written to follow the structure of the original text.
  
  obtain ⟨b, hb, rfl⟩ := eq_lim x
  simp only [← LIM.zero, ne_eq] at hx
  rw [LIM_eq_LIM hb (by convert Sequence.IsCauchy.const 0), Sequence.equiv_iff] at hx
  simp at hx
  choose ε hε hx using hx
  choose N hb' using (Sequence.IsCauchy.coe _).mp hb _ (half_pos hε)
  choose n₀ hn₀ hx using hx N
  have how : ∀ j ≥ N, |b j| ≥ ε / 2 := by sorry
  set a : ℕ → ℚ := fun n ↦ if n < n₀ then ε / 2 else b n
  have not_hard : Sequence.Equiv a b := by sorry
  have ha := (Sequence.isCauchy_of_equiv not_hard).mpr hb
  refine ⟨a, ha, ?_, by rw [(LIM_eq_LIM ha hb).mpr not_hard]⟩
  rw [bounded_away_zero_def]
  use ε / 2, half_pos hε
  intro n; by_cases hn : n < n₀ <;> simp [a, hn, le_abs_self _]
  grind
noncomputable instance instInv : Inv Real where
  inv x := if h : x ≠ 0 then LIM (boundedAwayZero_of_nonzero h).choose⁻¹ else 0
noncomputable instance instDivInvMonoid : DivInvMonoid Real where
noncomputable instance instField : Field Real
    where
  exists_pair_ne := by sorry
  mul_inv_cancel := by sorry
  inv_zero := by sorry
  ratCast_def := by sorry
  qsmul := _
  nnqsmul := _
end Real
namespace Sequence
abbrev mk' (n₀ : ℤ) (a : { n // n ≥ n₀ } → ℚ) : Sequence
    where
  n₀ := n₀
  seq n := if h : n ≥ n₀ then a ⟨n, h⟩ else 0
  vanish := by grind
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
theorem equiv_iff (a b : ℕ → ℚ) : Equiv a b ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - b n| ≤ ε := by sorry
theorem isCauchy_of_equiv {a b : ℕ → ℚ} (hab : Equiv a b) : (a : Sequence).IsCauchy ↔ (b : Sequence).IsCauchy := by
  sorry
@[simp]
theorem n0_coe (a : ℕ → ℚ) : (a : Sequence).n₀ = 0 := by norm_cast
@[simp]
theorem eval_coe_at_int (n : ℤ) (a : ℕ → ℚ) : (a : Sequence) n = if n ≥ 0 then a n.toNat else 0 := by norm_cast
abbrev «from» (a : Sequence) (n₁ : ℤ) : Sequence :=
  mk' (max a.n₀ n₁) (fun n ↦ a (n : ℤ))
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
theorem coe (a : ℕ → ℚ) :
    (a : Sequence).IsCauchy ↔ ∀ ε > (0 : ℚ), ∃ N, ∀ j ≥ N, ∀ k ≥ N, Section_4_3.dist (a j) (a k) ≤ ε :=
  by
  constructor <;> intro h ε hε
  · choose N hN h' using h ε hε
    lift N to ℕ using hN; use N
    intro j _ k _; simp [Rat.steady_def] at h'; specialize h' j _ k _ <;> try omega
    simp_all; exact h'
  choose N h' using h ε hε
  refine ⟨max N 0, by simp, ?_⟩
  intro n hn m hm; simp at hn hm
  have npos : 0 ≤ n := ?_
  have mpos : 0 ≤ m := ?_
  lift n to ℕ using npos
  lift m to ℕ using mpos
  simp [hn, hm]; specialize h' n _ m _
  all_goals try omega
  norm_cast
end IsCauchy
end Sequence
theorem Real.pow_even (x:Real) {n:ℕ} (hn: Even n) : x^n ≥ 0 := by sorry
end Chapter5

-----------------------------------

Section_5_6: Chapter5.Real.max_ratPow

import Mathlib.Tactic

namespace Chapter5
abbrev BoundedAwayNeg (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c
abbrev BoundedAwayPos (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≥ c
abbrev BoundedAwayZero (a : ℕ → ℚ) : Prop :=
  ∃ (c : ℚ), c > 0 ∧ ∀ n, |a n| ≥ c
@[ext]
class CauchySequence extends Sequence where
  zero : n₀ = 0
  cauchy : toSequence.IsCauchy
inductive ExtendedReal where
  | neg_infty : ExtendedReal
  | real (x : Real) : ExtendedReal
  | infty : ExtendedReal
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
noncomputable abbrev LIM (a : ℕ → ℚ) : Real :=
  Quotient.mk _ (if h : (a : Sequence).IsCauchy then CauchySequence.mk' h else (0 : CauchySequence))
abbrev Real :=
  Quotient CauchySequence.instSetoid
theorem LIM_def {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : LIM a = Quotient.mk _ (CauchySequence.mk' ha) := by
  rw [LIM, dif_pos ha]
theorem boundedAwayNeg_def (a : ℕ → ℚ) : BoundedAwayNeg a ↔ ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≤ -c := by rfl
theorem boundedAwayPos_def (a : ℕ → ℚ) : BoundedAwayPos a ↔ ∃ (c : ℚ), c > 0 ∧ ∀ n, a n ≥ c := by rfl
theorem bounded_away_zero_def (a : ℕ → ℚ) : BoundedAwayZero a ↔ ∃ (c : ℚ), c > 0 ∧ ∀ n, |a n| ≥ c := by rfl
namespace CauchySequence
abbrev mk' {a : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) : CauchySequence
    where
  n₀ := 0
  seq := (a : Sequence).seq
  vanish := by aesop
  zero := rfl
  cauchy := ha
instance instSetoid : Setoid CauchySequence
    where
  r := fun a b ↦ Sequence.Equiv a b
  iseqv :=
    { refl := sorry
      symm := sorry
      trans := sorry }
theorem equiv_iff (a b : CauchySequence) : a ≈ b ↔ Sequence.Equiv a b := by rfl
instance instZero : Zero CauchySequence where
  zero := CauchySequence.mk' (a := fun _ : ℕ ↦ 0) (Sequence.IsCauchy.const (0 : ℚ))
@[simp]
theorem coe_to_sequence (a : CauchySequence) : ((a : ℕ → ℚ) : Sequence) = a.toSequence :=
  by
  apply Sequence.ext (by simp [Sequence.n0_coe, a.zero])
  ext n; by_cases h : n ≥ 0 <;> simp_all
  rw [a.vanish]; rwa [a.zero]
end CauchySequence
namespace ExtendedReal
instance inst_Bot : Bot ExtendedReal where bot := infty
instance inst_Top : Top ExtendedReal where top := infty
noncomputable abbrev sup (E : Set Real) : ExtendedReal :=
  if h1 : E.Nonempty then (if h2 : BddAbove E then ((Real.LUB_exist h1 h2).choose : Real) else ⊤) else ⊥
theorem sup_of_bounded {E : Set Real} (hnon : E.Nonempty) (hb : BddAbove E) : IsLUB E (sup E) := by
  simp [hnon, hb, sup]; exact (Real.LUB_exist hnon hb).choose_spec
end ExtendedReal
namespace Rat
theorem eventuallyClose_iff (ε : ℚ) (a b : ℕ → ℚ) :
    ε.EventuallyClose (a : Sequence) (b : Sequence) ↔ ∃ N, ∀ n ≥ N, |a n - b n| ≤ ε := by sorry
end Rat
namespace Real
abbrev IsNeg (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
abbrev IsPos (x : Real) : Prop :=
  ∃ a : ℕ → ℚ, BoundedAwayPos a ∧ (a : Sequence).IsCauchy ∧ x = LIM a
theorem LIM_eq_LIM {a b : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) (hb : (b : Sequence).IsCauchy) :
    LIM a = LIM b ↔ Sequence.Equiv a b := by
  constructor
  . intro h; replace h := Quotient.exact h
    rwa [dif_pos ha, dif_pos hb, CauchySequence.equiv_iff] at h
  intro h; apply Quotient.sound
  rwa [dif_pos ha, dif_pos hb, CauchySequence.equiv_iff]
noncomputable instance add_inst : Add Real where
  add := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a + b))
      (by
        intro a b a' b' _ _
        change LIM ((a : ℕ → ℚ) + (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) + (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        . solve_by_elim [Sequence.add_equiv]
        all_goals
          apply Sequence.IsCauchy.add <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
instance instRatCast : RatCast Real where
  ratCast := fun q ↦ Quotient.mk _ (CauchySequence.mk' (a := fun _ ↦ q) (Sequence.IsCauchy.const q))
instance instIntCast : IntCast Real where intCast n := ((n : ℚ) : Real)
instance instNatCast : NatCast Real where natCast n := ((n : ℚ) : Real)
instance instOfNat {n : ℕ} : OfNat Real n where ofNat := ((n : ℚ) : Real)
theorem isNeg_def (x : Real) : IsNeg x ↔ ∃ a : ℕ → ℚ, BoundedAwayNeg a ∧ (a : Sequence).IsCauchy ∧ x = LIM a := by rfl
theorem isPos_def (x : Real) : IsPos x ↔ ∃ a : ℕ → ℚ, BoundedAwayPos a ∧ (a : Sequence).IsCauchy ∧ x = LIM a := by rfl
noncomputable instance mul_inst : Mul Real where
  mul := fun x y ↦
    Quotient.liftOn₂ x y (fun a b ↦ LIM (a * b))
      (by
        intro a b a' b' haa' hbb'
        change LIM ((a : ℕ → ℚ) * (b : ℕ → ℚ)) = LIM ((a' : ℕ → ℚ) * (b' : ℕ → ℚ))
        rw [LIM_eq_LIM]
        .
          exact
            Sequence.mul_equiv (by rw [CauchySequence.coe_to_sequence]; exact a.cauchy)
              (by rw [CauchySequence.coe_to_sequence]; exact b'.cauchy) haa' hbb'
        all_goals
          apply Sequence.IsCauchy.mul <;> rw [CauchySequence.coe_to_sequence] <;> convert @CauchySequence.cauchy ?_)
noncomputable instance instCommMonoid : CommMonoid Real
    where
  mul_comm := by sorry
  mul_assoc := by sorry
  one_mul := by sorry
  mul_one := by sorry
noncomputable instance instNeg : Neg Real where neg x := ((-1 : ℚ) : Real) * x
noncomputable instance addGroup_inst : AddGroup Real :=
  AddGroup.ofLeftAxioms (by sorry) (by sorry) (by sorry)
theorem LIM_sub {a b : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) (hb : (b : Sequence).IsCauchy) :
    LIM a - LIM b = LIM (a - b) := by sorry
noncomputable instance instAddCommGroup : AddCommGroup Real where add_comm := by sorry
noncomputable instance instCommRing : CommRing Real
    where
  left_distrib := by sorry
  right_distrib := by sorry
  zero_mul := by sorry
  mul_zero := by sorry
  mul_assoc := by sorry
  natCast_succ := by sorry
  intCast_negSucc := by sorry
instance instLT : LT Real where lt x y := (x - y).IsNeg
theorem antisymm (x y : Real) : x < y ↔ (y - x).IsPos := by sorry
instance instLE : LE Real where le x y := (x < y) ∨ (x = y)
theorem LIM_of_ge {x : Real} {a : ℕ → ℚ} (hcauchy : (a : Sequence).IsCauchy) (h : ∀ n, a n ≥ x) : LIM a ≥ x := by sorry
theorem LIM_of_le {x : Real} {a : ℕ → ℚ} (hcauchy : (a : Sequence).IsCauchy) (h : ∀ n, a n ≤ x) : LIM a ≤ x := by sorry
theorem bddAbove_def (E : Set Real) : BddAbove E ↔ ∃ M, M ∈ upperBounds E :=
  Set.nonempty_def
noncomputable instance instLinearOrder : LinearOrder Real
    where
  le_refl := sorry
  le_trans := sorry
  lt_iff_le_not_ge := sorry
  le_antisymm := sorry
  le_total := sorry
  toDecidableLE := Classical.decRel _
theorem isLUB_def (E : Set Real) (M : Real) : IsLUB E M ↔ M ∈ upperBounds E ∧ ∀ M' ∈ upperBounds E, M' ≥ M := by rfl
theorem isNeg_iff (x : Real) : x.IsNeg ↔ x < 0 := by sorry
theorem isPos_iff (x : Real) : x.IsPos ↔ x > 0 := by sorry
theorem lt_of_coe (q q' : ℚ) : q < q' ↔ (q : Real) < (q' : Real) := by sorry
theorem gt_of_coe (q q' : ℚ) : q > q' ↔ (q : Real) > (q' : Real) :=
  Real.lt_of_coe _ _
theorem mul_le_mul_left {x y z : Real} (hxy : x ≤ y) (hz : z.IsPos) : z * x ≤ z * y := by sorry
theorem pos_mul {x y : Real} (hx : x.IsPos) (hy : y.IsPos) : (x * y).IsPos := by sorry
theorem ratCast_def (q : ℚ) : (q : Real) = LIM (fun _ ↦ q) := by rw [LIM_def]; rfl
theorem trichotomous (x : Real) : x = 0 ∨ x.IsPos ∨ x.IsNeg := by sorry
theorem upperBound_between {E : Set Real} {n : ℕ} {L K : ℤ} (hLK : L < K)
    (hK : K * ((1 / (n + 1) : ℚ) : Real) ∈ upperBounds E) (hL : L * ((1 / (n + 1) : ℚ) : Real) ∉ upperBounds E) :
    ∃ m,
      L < m ∧
        m ≤ K ∧ m * ((1 / (n + 1) : ℚ) : Real) ∈ upperBounds E ∧ (m - 1) * ((1 / (n + 1) : ℚ) : Real) ∉ upperBounds E :=
  by sorry
theorem upperBound_def (E : Set Real) (M : Real) : M ∈ upperBounds E ↔ ∀ x ∈ E, x ≤ M :=
  mem_upperBounds
theorem upperBound_upper {M M' : Real} (h : M ≤ M') {E : Set Real} (hb : M ∈ upperBounds E) : M' ∈ upperBounds E := by
  sorry
theorem LIM_of_nonneg {a : ℕ → ℚ} (ha : ∀ n, a n ≥ 0) (hcauchy : (a : Sequence).IsCauchy) : LIM a ≥ 0 := by
  -- This proof is written to follow the structure of the original text.
  
  by_contra! hlim
  set x := LIM a
  rw [← isNeg_iff, isNeg_def] at hlim; choose b hb hb_cauchy hlim using hlim
  rw [boundedAwayNeg_def] at hb; choose c cpos hb using hb
  have claim1 : ∀ n, ¬(c / 2).Close (a n) (b n) := by
    intro n; specialize ha n; specialize hb n
    simp [Section_4_3.close_iff]
    calc
      _ < c := by linarith
      _ ≤ a n - b n := by linarith
      _ ≤ _ := le_abs_self _
  have claim2 : ¬(c / 2).EventuallyClose (a : Sequence) (b : Sequence) := by contrapose! claim1;
    rw [Rat.eventuallyClose_iff] at claim1; peel claim1 with N claim1; grind [Section_4_3.close_iff]
  have claim3 : ¬Sequence.Equiv a b := by contrapose! claim2; rw [Sequence.equiv_def] at claim2;
    solve_by_elim [half_pos]
  simp_rw [x, LIM_eq_LIM hcauchy hb_cauchy] at hlim
  contradiction
theorem boundedAwayZero_of_nonzero {x : Real} (hx : x ≠ 0) :
    ∃ a : ℕ → ℚ, (a : Sequence).IsCauchy ∧ BoundedAwayZero a ∧ x = LIM a := by
  -- This proof is written to follow the structure of the original text.
  
  obtain ⟨b, hb, rfl⟩ := eq_lim x
  simp only [← LIM.zero, ne_eq] at hx
  rw [LIM_eq_LIM hb (by convert Sequence.IsCauchy.const 0), Sequence.equiv_iff] at hx
  simp at hx
  choose ε hε hx using hx
  choose N hb' using (Sequence.IsCauchy.coe _).mp hb _ (half_pos hε)
  choose n₀ hn₀ hx using hx N
  have how : ∀ j ≥ N, |b j| ≥ ε / 2 := by sorry
  set a : ℕ → ℚ := fun n ↦ if n < n₀ then ε / 2 else b n
  have not_hard : Sequence.Equiv a b := by sorry
  have ha := (Sequence.isCauchy_of_equiv not_hard).mpr hb
  refine ⟨a, ha, ?_, by rw [(LIM_eq_LIM ha hb).mpr not_hard]⟩
  rw [bounded_away_zero_def]
  use ε / 2, half_pos hε
  intro n; by_cases hn : n < n₀ <;> simp [a, hn, le_abs_self _]
  grind
noncomputable instance instInv : Inv Real where
  inv x := if h : x ≠ 0 then LIM (boundedAwayZero_of_nonzero h).choose⁻¹ else 0
noncomputable instance instDivInvMonoid : DivInvMonoid Real where
theorem LIM_of_Cauchy {q : ℕ → ℚ} (hq : ∀ M, ∀ n ≥ M, ∀ n' ≥ M, |q n - q n'| ≤ 1 / (M + 1)) :
    (q : Sequence).IsCauchy ∧ ∀ M, |q M - LIM q| ≤ 1 / (M + 1) := by sorry
theorem div_of_pos {x y : Real} (hx : x.IsPos) (hy : y.IsPos) : (x / y).IsPos := by sorry
noncomputable instance instField : Field Real
    where
  exists_pair_ne := by sorry
  mul_inv_cancel := by sorry
  inv_zero := by sorry
  ratCast_def := by sorry
  qsmul := _
  nnqsmul := _
instance instIsStrictOrderedRing : IsStrictOrderedRing Real
    where
  add_le_add_left := by sorry
  add_le_add_right := by sorry
  mul_lt_mul_of_pos_left := by sorry
  mul_lt_mul_of_pos_right := by sorry
  le_of_add_le_add_left := by sorry
  zero_le_one := by sorry
theorem LIM_mono {a b : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) (hb : (b : Sequence).IsCauchy) (hmono : ∀ n, a n ≤ b n) :
    LIM a ≤ LIM b := by
  -- This proof is written to follow the structure of the original text.
  
  have := LIM_of_nonneg (a := b - a) (by intro n; simp [hmono n]) (Sequence.IsCauchy.sub hb ha)
  rw [← Real.LIM_sub hb ha] at this; linarith
theorem exists_rat_le_and_nat_ge {x : Real} (hx : x.IsPos) :
    (∃ q : ℚ, q > 0 ∧ (q : Real) ≤ x) ∧ ∃ N : ℕ, x < (N : Real) := by
  -- This proof is written to follow the structure of the original text.
  
  rw [isPos_def] at hx; choose a hbound hcauchy heq using hx
  rw [boundedAwayPos_def] at hbound; choose q hq hbound using hbound
  have := Sequence.isBounded_of_isCauchy hcauchy
  rw [Sequence.isBounded_def] at this; choose r hr this using this
  simp [Sequence.boundedBy_def] at this
  refine ⟨⟨q, hq, ?_⟩, ?_⟩
  . convert LIM_mono (Sequence.IsCauchy.const _) hcauchy hbound
    exact Real.ratCast_def q
  choose N hN using exists_nat_gt r; use N
  calc
    x ≤ r := by
      rw [Real.ratCast_def r]
      convert LIM_mono hcauchy (Sequence.IsCauchy.const r) _
      intro n; specialize this n; simp at this
      exact (le_abs_self _).trans this
    _ < ((N : ℚ) : Real) := by simp [hN]
    _ = N := rfl
theorem mul_lt_mul_right {x y z : Real} (hxy : x < y) (hz : z.IsPos) : x * z < y * z := by rw [antisymm] at hxy ⊢;
  convert pos_mul hxy hz using 1; ring
theorem le_mul {ε : Real} (hε : ε.IsPos) (x : Real) : ∃ M : ℕ, M > 0 ∧ M * ε > x := by
  -- This proof is written to follow the structure of the original text.
  
  obtain rfl | hx | hx := trichotomous x
  . use 1; simpa [isPos_iff] using hε
  . choose N hN using (exists_rat_le_and_nat_ge (div_of_pos hx hε)).2
    set M := N + 1; refine ⟨M, by positivity, ?_⟩
    replace hN : x / ε < M := hN.trans (by simp [M])
    simp
    convert mul_lt_mul_right hN hε
    rw [isPos_iff] at hε; field_simp
  use 1; simp_all [isPos_iff]; linarith
theorem LUB_claim1 (n : ℕ) {E : Set Real} (hE : Set.Nonempty E) (hbound : BddAbove E) :
    ∃! m : ℤ,
      (((m : ℚ) / (n + 1) : ℚ) : Real) ∈ upperBounds E ∧
        ¬(((m : ℚ) / (n + 1) - 1 / (n + 1) : ℚ) : Real) ∈ upperBounds E :=
  by
  set x₀ := Set.Nonempty.some hE
  observe hx₀ : x₀ ∈ E
  set ε := ((1 / (n + 1) : ℚ) : Real)
  have hpos : ε.IsPos := by simp [isPos_iff, ε]; positivity
  apply existsUnique_of_exists_of_unique
  . rw [bddAbove_def] at hbound; obtain ⟨M, hbound⟩ := hbound
    choose K _ hK using le_mul hpos M
    choose L' _ hL using le_mul hpos (-x₀)
    set L := -(L' : ℤ)
    have claim1_1 : L * ε < x₀ := by simp [L]; linarith
    have claim1_2 : L * ε ∉ upperBounds E := by grind [upperBound_def]
    have claim1_3 : (K : Real) > (L : Real) := by
      contrapose! claim1_2
      replace claim1_2 := mul_le_mul_left claim1_2 hpos
      simp_rw [mul_comm] at claim1_2
      replace claim1_2 : M ≤ L * ε := by order
      grind [upperBound_upper]
    have claim1_4 : ∃ m : ℤ, L < m ∧ m ≤ K ∧ m * ε ∈ upperBounds E ∧ (m - 1) * ε ∉ upperBounds E :=
      by
      convert Real.upperBound_between (n := n) _ _ claim1_2
      . qify; rwa [← gt_iff_lt, gt_of_coe]
      simp [ε] at *; apply upperBound_upper _ hbound; order
    choose m _ _ hm hm' using claim1_4; use m
    have : (m / (n + 1) : ℚ) = m * ε := by simp [ε]; field_simp
    exact ⟨by convert hm, by convert hm'; simp [this, sub_mul, ε]⟩
  grind [upperBound_discrete_unique]
theorem LUB_exist {E : Set Real} (hE : Set.Nonempty E) (hbound : BddAbove E) : ∃ S, IsLUB E S := by
  -- This proof is written to follow the structure of the original text.
  
  set x₀ := hE.some
  have hx₀ : x₀ ∈ E := hE.some_mem
  set m : ℕ → ℤ := fun n ↦ (LUB_claim1 n hE hbound).exists.choose
  set a : ℕ → ℚ := fun n ↦ (m n : ℚ) / (n + 1)
  set b : ℕ → ℚ := fun n ↦ 1 / (n + 1)
  have claim1 (n : ℕ) := LUB_claim1 n hE hbound
  have hb : (b : Sequence).IsCauchy := .harmonic'
  have hm1 (n : ℕ) := (claim1 n).exists.choose_spec.1
  have hm2 (n : ℕ) : ¬((a - b) n : Real) ∈ upperBounds E := (claim1 n).exists.choose_spec.2
  have claim2 (N : ℕ) := LUB_claim2 N (by aesop) hm1 hm2
  have claim3 : (a : Sequence).IsCauchy := (LIM_of_Cauchy claim2).1
  set S := LIM a; use S
  have claim4 : S = LIM (a - b) := by
    have : LIM b = 0 := LIM.harmonic
    simp [← LIM_sub claim3 hb, S, this]
  rw [isLUB_def, upperBound_def]
  split_ands
  . intros; apply LIM_of_ge claim3; grind [upperBound_def]
  intro y hy
  have claim5 (n : ℕ) : y ≥ (a - b) n := by contrapose! hm2; use n; apply upperBound_upper _ hy; order
  rw [claim4]; apply LIM_of_le _ claim5; solve_by_elim [Sequence.IsCauchy.sub]
noncomputable instance inst_SupSet : SupSet Real where sSup E := ((ExtendedReal.sup E) : Real)
noncomputable instance inst_conditionallyCompleteLattice : ConditionallyCompleteLattice Real :=
  conditionallyCompleteLatticeOfLatticeOfsSup Real (by intros; solve_by_elim [ExtendedReal.sup_of_bounded])
noncomputable abbrev root (x : Real) (n : ℕ) : Real :=
  sSup {y : Real | y ≥ 0 ∧ y ^ n ≤ x}
noncomputable abbrev ratPow (x : Real) (q : ℚ) : Real :=
  (x.root q.den) ^ (q.num)
noncomputable instance instRatPow : Pow Real ℚ where pow x q := x.ratPow q
namespace LIM
theorem harmonic : LIM (fun n ↦ 1 / ((n : ℚ) + 1)) = 0 := by sorry
end LIM
end Real
namespace Sequence
abbrev mk' (n₀ : ℤ) (a : { n // n ≥ n₀ } → ℚ) : Sequence
    where
  n₀ := n₀
  seq n := if h : n ≥ n₀ then a ⟨n, h⟩ else 0
  vanish := by grind
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
@[coe]
def ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish := by
    grind
      -- Notice how the delaborator prints this as `↑fun x ↦ ↑x ^ 2 : Sequence`.
abbrev Equiv (a b : ℕ → ℚ) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallyClose (a : Sequence) (b : Sequence)
theorem equiv_def (a b : ℕ → ℚ) : Equiv a b ↔ ∀ (ε : ℚ), ε > 0 → ε.EventuallyClose (a : Sequence) (b : Sequence) := by
  rfl
theorem equiv_iff (a b : ℕ → ℚ) : Equiv a b ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - b n| ≤ ε := by sorry
theorem isCauchy_of_equiv {a b : ℕ → ℚ} (hab : Equiv a b) : (a : Sequence).IsCauchy ↔ (b : Sequence).IsCauchy := by
  sorry
@[simp]
theorem n0_coe (a : ℕ → ℚ) : (a : Sequence).n₀ = 0 := by norm_cast
abbrev BoundedBy (a : Sequence) (M : ℚ) : Prop :=
  ∀ n, |a n| ≤ M
abbrev IsBounded (a : Sequence) : Prop :=
  ∃ M ≥ 0, a.BoundedBy M
@[simp]
theorem eval_coe_at_int (n : ℤ) (a : ℕ → ℚ) : (a : Sequence) n = if n ≥ 0 then a n.toNat else 0 := by norm_cast
abbrev «from» (a : Sequence) (n₁ : ℤ) : Sequence :=
  mk' (max a.n₀ n₁) (fun n ↦ a (n : ℤ))
theorem isBounded_def (a : Sequence) : a.IsBounded ↔ ∃ M ≥ 0, a.BoundedBy M := by rfl
theorem isBounded_of_isCauchy {a : Sequence} (h : a.IsCauchy) : a.IsBounded := by sorry
namespace IsCauchy
theorem const (a : ℚ) : ((fun _ : ℕ ↦ a) : Sequence).IsCauchy := by sorry
theorem sub {a b : ℕ → ℚ} (ha : (a : Sequence).IsCauchy) (hb : (b : Sequence).IsCauchy) :
    ((a - b : ℕ → ℚ) : Sequence).IsCauchy := by sorry
theorem harmonic : (mk' 1 (fun n ↦ (1 : ℚ) / n)).IsCauchy :=
  by
  rw [IsCauchy.mk]
  intro ε hε
  obtain ⟨N, hN : N > 1 / ε⟩ := exists_nat_gt (1 / ε)
  have hN' : N > 0 := by
    observe : (1 / ε) > 0
    observe : (N : ℚ) > 0
    norm_cast at this
  refine ⟨N, by norm_cast, ?_⟩
  intro j hj k hk
  lift j to ℕ using (by linarith)
  lift k to ℕ using (by linarith)
  norm_cast at hj hk
  simp [show j ≥ 1 by linarith, show k ≥ 1 by linarith]
  have hdist : Section_4_3.dist ((1 : ℚ) / j) ((1 : ℚ) / k) ≤ (1 : ℚ) / N :=
    by
    rw [Section_4_3.dist_eq, abs_le']
      
      
    have : 1 / j ≤ (1 : ℚ) / N := by gcongr
    observe : (0 : ℚ) ≤ 1 / j
    have : 1 / k ≤ (1 : ℚ) / N := by gcongr
    observe : (0 : ℚ) ≤ 1 / k
    grind
  simp at *; apply hdist.trans
  rw [inv_le_comm₀] <;> try positivity
  order
theorem coe (a : ℕ → ℚ) :
    (a : Sequence).IsCauchy ↔ ∀ ε > (0 : ℚ), ∃ N, ∀ j ≥ N, ∀ k ≥ N, Section_4_3.dist (a j) (a k) ≤ ε :=
  by
  constructor <;> intro h ε hε
  · choose N hN h' using h ε hε
    lift N to ℕ using hN; use N
    intro j _ k _; simp [Rat.steady_def] at h'; specialize h' j _ k _ <;> try omega
    simp_all; exact h'
  choose N h' using h ε hε
  refine ⟨max N 0, by simp, ?_⟩
  intro n hn m hm; simp at hn hm
  have npos : 0 ≤ n := ?_
  have mpos : 0 ≤ m := ?_
  lift n to ℕ using npos
  lift m to ℕ using mpos
  simp [hn, hm]; specialize h' n _ m _
  all_goals try omega
  norm_cast
theorem harmonic' : ((fun n ↦ 1 / ((n : ℚ) + 1) : ℕ → ℚ) : Sequence).IsCauchy :=
  by
  rw [coe]; intro ε hε; choose N h1 h2 using (mk _).mp harmonic ε hε
  use N.toNat; intro j _ k _; specialize h2 (j + 1) _ (k + 1) _ <;> try omega
  simp_all
end IsCauchy
end Sequence
theorem Real.max_ratPow {x y:Real} (hx: x > 0) (hy: y > 0) {q:ℚ} (hq: q > 0) :
  max (x^q) y^q = (max x y)^q := by
  sorry
end Chapter5

-----------------------------------

Section_6_1: Chapter6.Sequence.tendsTo_iff

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
abbrev TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.EventuallyClose a L
end Sequence
theorem Sequence.tendsTo_iff (a:Sequence) (L:ℝ) :
  a.TendsTo L ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - L| ≤ ε := by sorry
end Chapter6

-----------------------------------

Section_6_1: Chapter6.Sequence.tendsTo_of_shift

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
abbrev mk' (m : ℤ) (a : { n // n ≥ m } → ℝ) : Sequence
    where
  m := m
  seq n := if h : n ≥ m then a ⟨n, h⟩ else 0
  vanish := by simp_all
abbrev TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.EventuallyClose a L
end Sequence
theorem Sequence.tendsTo_of_shift {a: Sequence} {c:ℝ} (k:ℕ) :
    a.TendsTo c ↔ (Sequence.mk' a.m (fun n : {n // n ≥ a.m} ↦ a (n+k))).TendsTo c := by
  sorry
end Chapter6

-----------------------------------

Section_6_1: Chapter6.Sequence.lim_div_fail

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
noncomputable abbrev lim (a : Sequence) : ℝ :=
  if h : a.Convergent then h.choose else 0
namespace Sequence
abbrev TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.EventuallyClose a L
abbrev Convergent (a : Sequence) : Prop :=
  ∃ L, a.TendsTo L
noncomputable instance inst_div : Div Sequence where
  div a
    b :=
    { m := max a.m b.m
      seq n := if n ≥ max a.m b.m then a n / b n else 0
      vanish := by grind }
end Sequence
theorem Sequence.lim_div_fail :
    ∃ a b, a.Convergent
    ∧ b.Convergent
    ∧ lim b = 0
    ∧ ¬ ((a / b).Convergent ∧ lim (a / b) = lim a / lim b) := by
  sorry
end Chapter6

-----------------------------------

Section_6_1: Chapter6.Chapter5.Sequence.IsCauchy_iff

import Mathlib.Tactic

namespace Chapter5
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0
namespace Sequence
abbrev IsCauchy (a : Sequence) : Prop :=
  ∀ ε > (0 : ℚ), ε.EventuallySteady a
end Sequence
end Chapter5
theorem Chapter5.Sequence.IsCauchy_iff (a:Chapter5.Sequence) :
    a.IsCauchy ↔ ∀ ε > (0:ℝ), ∃ N ≥ a.n₀, ∀ n ≥ N, ∀ m ≥ N, |a n - a m| ≤ ε := by
  sorry

-----------------------------------

Section_6_1: Chapter6.Sequence.mono_if

import Mathlib.Tactic

theorem Sequence.mono_if {a: ℕ → ℝ} (ha: ∀ n, a (n+1) > a n) {n m:ℕ} (hnm: m > n) : a m > a n := by
  sorry

-----------------------------------

Section_6_3: Chapter6.lim_of_exp'

import Mathlib.Tactic
import Mathlib.Analysis.SpecialFunctions.Trigonometric.Basic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
abbrev TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.EventuallyClose a L
abbrev Convergent (a : Sequence) : Prop :=
  ∃ L, a.TendsTo L
@[coe]
abbrev ofNatFun (a : ℕ → ℝ) : Sequence :=
  { m := 0
    seq n := if n ≥ 0 then a n.toNat else 0
    vanish := by simp_all }
end Sequence
theorem lim_of_exp' {x:ℝ} (hbound: x > 1) : ¬((fun (n:ℕ) ↦ x^n):Sequence).Convergent := by sorry
end Chapter6

-----------------------------------

Section_6_4: Chapter6.Sequence.sup_not_strict_mono

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
@[coe]
abbrev ofNatFun (a : ℕ → ℝ) : Sequence :=
  { m := 0
    seq n := if n ≥ 0 then a n.toNat else 0
    vanish := by simp_all }
noncomputable abbrev sup (a : Sequence) : EReal :=
  sSup {x | ∃ n ≥ a.m, x = a n}
end Sequence
theorem Sequence.sup_not_strict_mono : ∃ (a b:ℕ → ℝ), (∀ n, a n < b n) ∧ (a:Sequence).sup ≠ (b:Sequence).sup := by
  sorry
end Chapter6

-----------------------------------

Section_6_4: Chapter6.Sequence.limit_points_of_limit_points

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
abbrev LimitPoint (a : Sequence) (x : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.ContinuallyAdherent a x
end Sequence
theorem Sequence.limit_points_of_limit_points {a b:Sequence} {c:ℝ} (hab: ∀ n ≥ b.m, a.LimitPoint (b n)) (hbc: b.LimitPoint c) : a.LimitPoint c := by sorry
end Chapter6

-----------------------------------

Section_6_4: Chapter6.Sequence.extended_limit_point_of_liminf

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
abbrev mk' (m : ℤ) (a : { n // n ≥ m } → ℝ) : Sequence
    where
  m := m
  seq n := if h : n ≥ m then a ⟨n, h⟩ else 0
  vanish := by simp_all
abbrev LimitPoint (a : Sequence) (x : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.ContinuallyAdherent a x
abbrev BddAboveBy (a : Sequence) (M : ℝ) : Prop :=
  ∀ n ≥ a.m, a n ≤ M
abbrev BddAbove (a : Sequence) : Prop :=
  ∃ M, a.BddAboveBy M
abbrev BddBelowBy (a : Sequence) (M : ℝ) : Prop :=
  ∀ n ≥ a.m, a n ≥ M
abbrev BddBelow (a : Sequence) : Prop :=
  ∃ M, a.BddBelowBy M
abbrev ExtendedLimitPoint (a : Sequence) (x : EReal) : Prop :=
  if x = ⊤ then ¬a.BddAbove else if x = ⊥ then ¬a.BddBelow else a.LimitPoint x.toReal
abbrev «from» (a : Sequence) (m₁ : ℤ) : Sequence :=
  mk' (max a.m m₁) (a ↑·)
noncomputable abbrev inf (a : Sequence) : EReal :=
  sInf {x | ∃ n ≥ a.m, x = a n}
noncomputable abbrev lowerseq (a : Sequence) : ℤ → EReal := fun N ↦ (a.from N).inf
noncomputable abbrev liminf (a : Sequence) : EReal :=
  sSup {x | ∃ N ≥ a.m, x = a.lowerseq N}
end Sequence
theorem Sequence.extended_limit_point_of_liminf (a:Sequence) : a.ExtendedLimitPoint a.liminf := by sorry
end Chapter6

-----------------------------------

Section_6_4: Chapter6.Sequence.extended_limit_point_of_limsup

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
abbrev mk' (m : ℤ) (a : { n // n ≥ m } → ℝ) : Sequence
    where
  m := m
  seq n := if h : n ≥ m then a ⟨n, h⟩ else 0
  vanish := by simp_all
abbrev LimitPoint (a : Sequence) (x : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.ContinuallyAdherent a x
abbrev BddAboveBy (a : Sequence) (M : ℝ) : Prop :=
  ∀ n ≥ a.m, a n ≤ M
abbrev BddAbove (a : Sequence) : Prop :=
  ∃ M, a.BddAboveBy M
abbrev BddBelowBy (a : Sequence) (M : ℝ) : Prop :=
  ∀ n ≥ a.m, a n ≥ M
abbrev BddBelow (a : Sequence) : Prop :=
  ∃ M, a.BddBelowBy M
abbrev ExtendedLimitPoint (a : Sequence) (x : EReal) : Prop :=
  if x = ⊤ then ¬a.BddAbove else if x = ⊥ then ¬a.BddBelow else a.LimitPoint x.toReal
abbrev «from» (a : Sequence) (m₁ : ℤ) : Sequence :=
  mk' (max a.m m₁) (a ↑·)
noncomputable abbrev sup (a : Sequence) : EReal :=
  sSup {x | ∃ n ≥ a.m, x = a n}
noncomputable abbrev upperseq (a : Sequence) : ℤ → EReal := fun N ↦ (a.from N).sup
noncomputable abbrev limsup (a : Sequence) : EReal :=
  sInf {x | ∃ N ≥ a.m, x = a.upperseq N}
end Sequence
theorem Sequence.extended_limit_point_of_limsup (a:Sequence) : a.ExtendedLimitPoint a.limsup := by sorry
end Chapter6

-----------------------------------

Section_6_5: Chapter6.Sequence.lim_of_rat_power_growth

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
abbrev TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.EventuallyClose a L
abbrev Convergent (a : Sequence) : Prop :=
  ∃ L, a.TendsTo L
abbrev Divergent (a : Sequence) : Prop :=
  ¬a.Convergent
@[coe]
abbrev ofNatFun (a : ℕ → ℝ) : Sequence :=
  { m := 0
    seq n := if n ≥ 0 then a n.toNat else 0
    vanish := by simp_all }
end Sequence
theorem Sequence.lim_of_rat_power_growth {q:ℚ} (hq: q > 0) :
    (fun (n:ℕ) ↦ ((n+1:ℝ)^(q:ℝ)):Sequence).Divergent := by
  sorry
end Chapter6

-----------------------------------

Section_6_6: Chapter6.Sequence.subseq_of_unbounded

import Mathlib.Tactic

namespace Chapter6
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Sequence
abbrev TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.EventuallyClose a L
@[coe]
abbrev ofNatFun (a : ℕ → ℝ) : Sequence :=
  { m := 0
    seq n := if n ≥ 0 then a n.toNat else 0
    vanish := by simp_all }
abbrev BoundedBy (a : Sequence) (M : ℝ) : Prop :=
  ∀ n, |a n| ≤ M
abbrev IsBounded (a : Sequence) : Prop :=
  ∃ M ≥ 0, a.BoundedBy M
noncomputable instance inst_inv : Inv Sequence where
  inv
    a :=
    { m := a.m
      seq n := (a n)⁻¹
      vanish n hn := by simp [a.vanish n hn] }
abbrev subseq (a b : ℕ → ℝ) : Prop :=
  ∃ f : ℕ → ℕ,
    StrictMono f ∧
      ∀ n,
        b n =
          a
            (f n)
end Sequence
theorem Sequence.subseq_of_unbounded {a:ℕ → ℝ} (ha: ¬ (a:Sequence).IsBounded) :
    ∃ b:ℕ → ℝ, Sequence.subseq a b ∧ (b:Sequence)⁻¹.TendsTo 0 := by
  sorry
end Chapter6

-----------------------------------

Section_7_1: Finset.binomial_theorem

import Mathlib.Tactic

theorem binomial_theorem (x y:ℝ) (n:ℕ) :
    (x + y)^n
    = ∑ j ∈ Icc (0:ℤ) n,
    n.factorial / (j.toNat.factorial * (n-j).toNat.factorial) * x^j * y^(n - j) := by
  sorry

-----------------------------------

Section_7_2: Chapter7.Series.example_7_2_7

import Mathlib.Tactic
import Mathlib.Algebra.Field.Power

namespace Chapter7
@[ext]
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Series
abbrev «partial» (s : Series) (N : ℤ) : ℝ :=
  ∑ n ∈ Finset.Icc s.m N, s.seq n
abbrev convergesTo (s : Series) (L : ℝ) : Prop :=
  Filter.atTop.Tendsto (s.partial) (nhds L)
abbrev converges (s : Series) : Prop :=
  ∃ L, s.convergesTo L
abbrev diverges (s : Series) : Prop :=
  ¬s.converges
theorem diverges_of_nodecay {s : Series} (h : ¬Filter.atTop.Tendsto s.seq (nhds 0)) : s.diverges := by sorry
end Series
theorem Series.example_7_2_7 : ((fun n:ℕ ↦ (1:ℝ)):Series).diverges := by
  apply diverges_of_nodecay
  sorry
end Chapter7

-----------------------------------

Section_7_3: Chapter7.Series.nonneg_sum_zero

import Mathlib.Tactic
import Mathlib.Algebra.Field.Power
import Mathlib.NumberTheory.LSeries.RiemannZeta
import Mathlib.NumberTheory.LSeries.HurwitzZetaValues

namespace Chapter7
@[ext]
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Series
abbrev nonneg (s : Series) : Prop :=
  ∀ n, s.seq n ≥ 0
abbrev «partial» (s : Series) (N : ℤ) : ℝ :=
  ∑ n ∈ Finset.Icc s.m N, s.seq n
abbrev convergesTo (s : Series) (L : ℝ) : Prop :=
  Filter.atTop.Tendsto (s.partial) (nhds L)
abbrev converges (s : Series) : Prop :=
  ∃ L, s.convergesTo L
noncomputable abbrev sum (s : Series) : ℝ :=
  if h : s.converges then h.choose else 0
end Series
theorem Series.nonneg_sum_zero {a:ℕ → ℝ} (ha: (a:Series).nonneg) (hconv: (a:Series).converges) : (a:Series).sum = 0 ↔ ∀ n, a n = 0 := by sorry
end Chapter7

-----------------------------------

Section_7_4: Chapter7.Series.zeta_2_converges

import Mathlib.Tactic

namespace Chapter7
@[ext]
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Series
abbrev «partial» (s : Series) (N : ℤ) : ℝ :=
  ∑ n ∈ Finset.Icc s.m N, s.seq n
abbrev convergesTo (s : Series) (L : ℝ) : Prop :=
  Filter.atTop.Tendsto (s.partial) (nhds L)
abbrev converges (s : Series) : Prop :=
  ∃ L, s.convergesTo L
end Series
theorem Series.zeta_2_converges : (fun n:ℕ ↦ 1/(n+1:ℝ)^2 : Series).converges := by sorry
end Chapter7

-----------------------------------

Section_7_4: Chapter7.Series.absConverges_of_subseries

import Mathlib.Tactic

namespace Chapter7
@[ext]
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Series
abbrev mk' {m : ℤ} (a : { n // n ≥ m } → ℝ) : Series where
  m := m
  seq n := if h : n ≥ m then a ⟨n, h⟩ else 0
  vanish := by grind
abbrev abs (s : Series) : Series :=
  mk' (m := s.m) (fun n ↦ |s.seq n|)
abbrev «partial» (s : Series) (N : ℤ) : ℝ :=
  ∑ n ∈ Finset.Icc s.m N, s.seq n
abbrev convergesTo (s : Series) (L : ℝ) : Prop :=
  Filter.atTop.Tendsto (s.partial) (nhds L)
abbrev converges (s : Series) : Prop :=
  ∃ L, s.convergesTo L
abbrev absConverges (s : Series) : Prop :=
  s.abs.converges
end Series
theorem Series.absConverges_of_subseries {a:ℕ → ℝ} (ha: (a:Series).absConverges) {f: ℕ → ℕ} (hf: StrictMono f) :
  (fun n ↦ a (f n):Series).absConverges := by sorry
end Chapter7

-----------------------------------

Section_7_5: Chapter7.Series.poly_mul_geom_converges

import Mathlib.Tactic
import Mathlib.Topology.Instances.EReal.Lemmas
import Mathlib.Analysis.SpecialFunctions.Pow.Continuity

namespace Chapter7
@[ext]
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Series
abbrev «partial» (s : Series) (N : ℤ) : ℝ :=
  ∑ n ∈ Finset.Icc s.m N, s.seq n
abbrev convergesTo (s : Series) (L : ℝ) : Prop :=
  Filter.atTop.Tendsto (s.partial) (nhds L)
abbrev converges (s : Series) : Prop :=
  ∃ L, s.convergesTo L
end Series
theorem Series.poly_mul_geom_converges {x:ℝ} (hx: |x|<1) (q:ℝ) : (fun n:ℕ ↦ (n:ℝ)^q * x^n : Series).converges ∧ Filter.atTop.Tendsto (fun n:ℕ ↦ (n:ℝ)^q * x^n) (nhds 0) := by
  sorry
end Chapter7

-----------------------------------

Section_8_2: Chapter8.permute_diverges_of_divergent

import Mathlib.Tactic

namespace Chapter7
@[ext]
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0
namespace Series
abbrev mk' {m : ℤ} (a : { n // n ≥ m } → ℝ) : Series where
  m := m
  seq n := if h : n ≥ m then a ⟨n, h⟩ else 0
  vanish := by grind
abbrev abs (s : Series) : Series :=
  mk' (m := s.m) (fun n ↦ |s.seq n|)
abbrev «partial» (s : Series) (N : ℤ) : ℝ :=
  ∑ n ∈ Finset.Icc s.m N, s.seq n
abbrev convergesTo (s : Series) (L : ℝ) : Prop :=
  Filter.atTop.Tendsto (s.partial) (nhds L)
abbrev converges (s : Series) : Prop :=
  ∃ L, s.convergesTo L
abbrev absConverges (s : Series) : Prop :=
  s.abs.converges
end Series
end Chapter7
theorem permute_diverges_of_divergent {a: ℕ → ℝ} (ha: (a:Series).converges)
  (ha': ¬ (a:Series).absConverges)  :
  ∃ f : ℕ → ℕ,  Function.Bijective f ∧ Filter.atTop.Tendsto (fun N ↦ ((a ∘ f:Series).partial N : EReal)) (nhds ⊤) := by
  sorry

-----------------------------------

Section_8_3: Chapter8.Schroder_Bernstein

import Mathlib.Tactic

namespace Chapter8
abbrev EqualCard (X Y : Type) : Prop :=
  ∃ f : X → Y, Function.Bijective f
abbrev LeCard (X Y : Type) : Prop :=
  ∃ f : X → Y, Function.Injective f
theorem Schroder_Bernstein {X Y:Type}
  (hXY : LeCard X Y)
  (hYX : LeCard Y X) :
  EqualCard X Y := by
  sorry
end Chapter8

-----------------------------------

Section_8_4: Chapter8.axiom_of_choice_from_exists_set_singleton_intersect

import Mathlib.Tactic

theorem axiom_of_choice_from_exists_set_singleton_intersect {I: Type} {X: I → Type} (h : ∀ i, Nonempty (X i)) :
  Nonempty (∀ i, X i) := by
  sorry

-----------------------------------

Section_8_4: Chapter8.axiom_of_choice_from_function_injective_inv_surjective

import Mathlib.Tactic

theorem axiom_of_choice_from_function_injective_inv_surjective {I: Type} {X: I → Type} (h : ∀ i, Nonempty (X i)) :
  Nonempty (∀ i, X i) := by
  sorry

-----------------------------------

Section_8_4: Chapter8.Function.Injective.inv_surjective

import Mathlib.Tactic

theorem Function.Injective.inv_surjective {A B:Type} {g: B → A} (hg: Function.Surjective g) :
  ∃ f : A → B, Function.Injective f ∧ Function.RightInverse f g := by
  sorry

-----------------------------------

Section_8_5: Chapter8.IsMax.ofFinite

import Mathlib.Tactic

theorem IsMax.ofFinite {X:Type} [LinearOrder X] [Finite X] [Nonempty X] : ∃ x:X, IsMax x := by sorry

-----------------------------------

Section_9_1: Chapter9.Q_unbounded

import Mathlib.Tactic
import Mathlib.Analysis.SpecificLimits.Basic

theorem Q_unbounded (a: ℝ) : ¬ Bornology.IsBounded ((fun n:ℚ ↦ (n:ℝ)) '' .univ) := by sorry

-----------------------------------

Section_9_1: Chapter9.closure_of_subset_closure

import Mathlib.Tactic
import Mathlib.Analysis.SpecificLimits.Basic

theorem closure_of_subset_closure {X Y:Set ℝ} (h: X ⊆ Y) (h' : Y ⊆ closure X): closure Y = closure X := by sorry

-----------------------------------

Section_9_1: Chapter9.Icc_bounded

import Mathlib.Tactic
import Mathlib.Analysis.SpecificLimits.Basic

theorem Icc_bounded (a b:ℝ) : Bornology.IsBounded (.Icc a b) := by sorry

-----------------------------------

Section_9_1: Chapter9.N_unbounded

import Mathlib.Tactic
import Mathlib.Analysis.SpecificLimits.Basic

theorem N_unbounded (a: ℝ) : ¬ Bornology.IsBounded ((fun n:ℕ ↦ (n:ℝ)) '' .univ) := by sorry

-----------------------------------

Section_9_1: Chapter9.R_unbounded

import Mathlib.Tactic
import Mathlib.Analysis.SpecificLimits.Basic

theorem R_unbounded (a: ℝ) : ¬ Bornology.IsBounded (.univ: Set ℝ) := by sorry

-----------------------------------

Section_9_3: Chapter9.Convergesto.sign_right

import Mathlib.Tactic
import Mathlib.Data.Real.Sign

namespace Chapter9
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.CloseNear X f L x₀
theorem Convergesto.sign_right : Convergesto (.Ioi 0) Real.sign 1 0 := by sorry
end Chapter9

-----------------------------------

Section_9_3: Chapter9.Convergesto.squeeze

import Mathlib.Tactic
import Mathlib.Data.Real.Sign

namespace Chapter9
abbrev AdherentPt (x : ℝ) (X : Set ℝ) :=
  ∀ ε > (0 : ℝ), ε.adherent' x X
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.CloseNear X f L x₀
theorem Convergesto.squeeze {E:Set ℝ} {f g h: ℝ → ℝ} {L:ℝ} {x₀:ℝ} (had: AdherentPt x₀ E)
  (hfg: ∀ x ∈ E, f x ≤ g x) (hgh: ∀ x ∈ E, g x ≤ h x)
  (hf: Convergesto E f L x₀) (hh: Convergesto E h L x₀) :
  Convergesto E g L x₀ := by
    sorry
end Chapter9

-----------------------------------

Section_9_3: Chapter9.Convergesto.sign_left

import Mathlib.Tactic
import Mathlib.Data.Real.Sign

namespace Chapter9
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.CloseNear X f L x₀
theorem Convergesto.sign_left : Convergesto (.Iio 0) Real.sign (-1) 0 := by sorry
end Chapter9

-----------------------------------

Section_9_4: Chapter9.ContinuousOn.restrict

import Mathlib.Tactic
import Mathlib.Data.Real.Sign
import Mathlib.Topology.ContinuousOn

theorem ContinuousOn.restrict {X Y:Set ℝ} {f: ℝ → ℝ} (hY: Y ⊆ X) (hf: ContinuousOn f X) : ContinuousOn f Y := by
  sorry

-----------------------------------

Section_9_7: Chapter9.exists_fixed_pt

import Mathlib.Tactic

theorem exists_fixed_pt {f:ℝ → ℝ} (hf: ContinuousOn f (.Icc 0 1)) (hmap: f '' .Icc 0 1 ⊆ .Icc 0 1) : ∃ x ∈ Set.Icc 0 1, f x = x := by
  sorry

-----------------------------------

Section_9_8: Chapter9.ContinuousAt.of_f_9_8_5

import Mathlib.Tactic

namespace Chapter9
noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ :=
  nonempty_equiv_of_countable.some
noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2 : ℝ) ^ (-q_9_8_5.symm q : ℤ)
noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : { r : ℚ // (r : ℝ) < x }, g_9_8_5 r
theorem ContinuousAt.of_f_9_8_5 {x:ℝ} (hx: ¬ ∃ r:ℚ, x = r) : ContinuousAt f_9_8_5 x := by
  sorry
end Chapter9

-----------------------------------

Section_9_8: Chapter9.IsMaxOn.of_monotone_on_compact

import Mathlib.Tactic

theorem IsMaxOn.of_monotone_on_compact {a b:ℝ} (h:a < b) {f:ℝ → ℝ} (hf: MonotoneOn f (.Icc a b)) :
  ∃ xmax ∈ Set.Icc a b, IsMaxOn f (.Icc a b) xmax := by sorry

-----------------------------------

Section_9_8: Chapter9.StrictMonoOn.of_f_9_8_5

import Mathlib.Tactic

namespace Chapter9
noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ :=
  nonempty_equiv_of_countable.some
noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2 : ℝ) ^ (-q_9_8_5.symm q : ℤ)
noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : { r : ℚ // (r : ℝ) < x }, g_9_8_5 r
theorem StrictMonoOn.of_f_9_8_5 : StrictMonoOn f_9_8_5 .univ := by
  sorry
end Chapter9

-----------------------------------

Section_9_8: Chapter9.mono_of_continuous_inj

import Mathlib.Tactic

theorem mono_of_continuous_inj {a b:ℝ} (h: a < b) {f:ℝ → ℝ}
  (hf: ContinuousOn f (.Icc a b))
  (hinj: Function.Injective (fun x: Set.Icc a b ↦ f x )) :
  StrictMonoOn f (.Icc a b) ∨ StrictAntiOn f (.Icc a b) := by
  sorry

-----------------------------------

Section_9_8: Chapter9.ContinuousAt.of_f_9_8_5'

import Mathlib.Tactic

namespace Chapter9
noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ :=
  nonempty_equiv_of_countable.some
noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2 : ℝ) ^ (-q_9_8_5.symm q : ℤ)
noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : { r : ℚ // (r : ℝ) < x }, g_9_8_5 r
theorem ContinuousAt.of_f_9_8_5' (r:ℚ) : ¬ ContinuousAt f_9_8_5 r := by
  sorry
end Chapter9

-----------------------------------

Section_9_9: Chapter9.UniformContinuousOn.comp

import Mathlib.Tactic
import Mathlib.Data.Nat.Nth

theorem UniformContinuousOn.comp {X Y: Set ℝ} {f g:ℝ → ℝ}
  (hf: UniformContinuousOn f X) (hg: UniformContinuousOn g Y)
  (hrange: f '' X ⊆ Y) : UniformContinuousOn (g ∘ f) X := by
  sorry

-----------------------------------

Section_10_1: HasDerivWithinAt.of_pow

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

theorem _root_.HasDerivWithinAt.of_pow (n:ℕ) (x₀:ℝ) : HasDerivWithinAt (fun x ↦ x^n)
(n * x₀^((n:ℤ)-1)) .univ x₀ := by
  sorry

-----------------------------------

Section_10_1: HasDerivWithinAt.of_zpow

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

theorem _root_.HasDerivWithinAt.of_zpow (n:ℤ) (x₀:ℝ) (hx₀: x₀ ≠ 0) :
  HasDerivWithinAt (fun x ↦ x^n) (n * x₀^(n-1)) (.univ \ {0}) x₀ := by
  sorry

-----------------------------------

Section_10_2: UniformContinuousOn.of_lipschitz

import Mathlib.Tactic

namespace Chapter9
abbrev BddOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  ∃ M, ∀ x ∈ X, |f x| ≤ M
end Chapter9
theorem _root_.UniformContinuousOn.of_lipschitz {f:ℝ → ℝ}
  (hcont: ContinuousOn f .univ)
  (hderiv: DifferentiableOn ℝ f .univ)
  (hlip: BddOn (deriv f) .univ) :
  UniformContinuousOn f (.univ) := by
  sorry

-----------------------------------

Section_10_2: Chapter10.lipschitz_bound

import Mathlib.Tactic

theorem lipschitz_bound {M a b:ℝ} (hM: M > 0) (hab: a < b) {f:ℝ → ℝ}
  (hcont: ContinuousOn f (.Icc a b))
  (hderiv: DifferentiableOn ℝ f (.Ioo a b))
  (hlip: ∀ x ∈ Set.Ioo a b, |derivWithin f (.Ioo a b) x| ≤ M)
  {x y:ℝ} (hx: x ∈ Set.Ioo a b) (hy: y ∈ Set.Ioo a b) :
  |f x - f y| ≤ M * |x - y| := by
  sorry

-----------------------------------

Section_11_1: Chapter11.Partition.exist_right

import Mathlib.Tactic

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I
namespace BoundedInterval
abbrev a (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo a _ => a
  | Icc a _ => a
  | Ioc a _ => a
  | Ico a _ => a
abbrev b (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo _ b => b
  | Icc _ b => b
  | Ioc _ b => b
  | Ico _ b => b
@[coe]
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => .Ioo a b
  | Icc a b => .Icc a b
  | Ioc a b => .Ioc a b
  | Ico a b => .Ico a b
instance instMembership : Membership ℝ BoundedInterval where mem I x := x ∈ (I : Set ℝ)
end BoundedInterval
namespace Partition
instance instMembership (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals
end Partition
theorem Partition.exist_right {I: BoundedInterval} (hI: I.a < I.b) (hI': I.b ∉ I)
  {P: Partition I}
  : ∃ c ∈ Set.Ico I.a I.b, Ioo c I.b ∈ P ∨ Ico c I.b ∈ P := by
  sorry
end Chapter11

-----------------------------------

Section_11_2: Chapter11.ConstantOn.piecewiseConstantOn

import Mathlib.Tactic

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
abbrev Constant {X Y : Type} (f : X → Y) : Prop :=
  ∃ c, ∀ x, f x = c
abbrev ConstantOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  Constant (fun x : X ↦ f ↑x)
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I
abbrev PiecewiseConstantWith (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : Prop :=
  ∀ J ∈ P, ConstantOn f (J : Set ℝ)
abbrev PiecewiseConstantOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∃ P : Partition I, PiecewiseConstantWith f P
namespace BoundedInterval
@[coe]
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => .Ioo a b
  | Icc a b => .Icc a b
  | Ioc a b => .Ioc a b
  | Ico a b => .Ico a b
end BoundedInterval
namespace Partition
instance instMembership (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals
end Partition
theorem ConstantOn.piecewiseConstantOn {f:ℝ → ℝ} {I: BoundedInterval} (h: ConstantOn f (I:Set ℝ)) :
  PiecewiseConstantOn f I := by sorry
end Chapter11

-----------------------------------

Section_11_3: Chapter11.MajorizesOn.trans

import Mathlib.Tactic

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
abbrev MajorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), f x ≤ g x
namespace BoundedInterval
@[coe]
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => .Ioo a b
  | Icc a b => .Icc a b
  | Ioc a b => .Ioc a b
  | Ico a b => .Ico a b
end BoundedInterval
theorem MajorizesOn.trans {f g h: ℝ → ℝ} {I: BoundedInterval}
  (hfg: MajorizesOn f g I) (hgh: MajorizesOn g h I) : MajorizesOn f h I := by
  sorry
end Chapter11

-----------------------------------

Section_11_4: Chapter11.IntegrableOn.split

import Mathlib.Tactic

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
abbrev Constant {X Y : Type} (f : X → Y) : Prop :=
  ∃ c, ∀ x, f x = c
abbrev ConstantOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  Constant (fun x : X ↦ f ↑x)
abbrev MajorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), f x ≤ g x
abbrev MinorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), g x ≤ f x
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I
abbrev PiecewiseConstantWith (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : Prop :=
  ∀ J ∈ P, ConstantOn f (J : Set ℝ)
abbrev PiecewiseConstantOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∃ P : Partition I, PiecewiseConstantWith f P
noncomputable abbrev constant_value {X Y : Type} [hY : Nonempty Y] (f : X → Y) : Y :=
  if h : Constant f then h.choose else hY.some
noncomputable abbrev constant_value_on (f : ℝ → ℝ) (X : Set ℝ) : ℝ :=
  constant_value (fun x : X ↦ f ↑x)
noncomputable abbrev lower_integral (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  sSup ((PiecewiseConstantOn.integ · I) '' {g | MinorizesOn g f I ∧ PiecewiseConstantOn g I})
noncomputable abbrev upper_integral (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  sInf ((PiecewiseConstantOn.integ · I) '' {g | MajorizesOn g f I ∧ PiecewiseConstantOn g I})
noncomputable abbrev integ (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  upper_integral f I
noncomputable abbrev IntegrableOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  BddOn f I ∧ lower_integral f I = upper_integral f I
namespace BoundedInterval
abbrev a (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo a _ => a
  | Icc a _ => a
  | Ioc a _ => a
  | Ico a _ => a
abbrev b (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo _ b => b
  | Icc _ b => b
  | Ioc _ b => b
  | Ico _ b => b
abbrev length (I : BoundedInterval) : ℝ :=
  max (I.b - I.a) 0
@[coe]
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => .Ioo a b
  | Icc a b => .Icc a b
  | Ioc a b => .Ioc a b
  | Ico a b => .Ico a b
end BoundedInterval
namespace Partition
instance instMembership (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals
end Partition
namespace PiecewiseConstantOn
noncomputable abbrev integ (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  if h : PiecewiseConstantOn f I then PiecewiseConstantWith.integ f h.choose else 0
end PiecewiseConstantOn
namespace PiecewiseConstantWith
noncomputable abbrev integ (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : ℝ :=
  ∑ J ∈ P.intervals, constant_value_on f (J : Set ℝ) * |J|ₗ
end PiecewiseConstantWith
theorem IntegrableOn.split {I: BoundedInterval} {f: ℝ → ℝ} (hf: IntegrableOn f I) (P: Partition I) :
  integ f I = ∑ J ∈ P.intervals, integ f J := by
    sorry
end Chapter11
namespace Chapter9
abbrev BddOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  ∃ M, ∀ x ∈ X, |f x| ≤ M
end Chapter9

-----------------------------------

Section_11_5: Chapter11.integ_zero

import Mathlib.Tactic

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
abbrev Constant {X Y : Type} (f : X → Y) : Prop :=
  ∃ c, ∀ x, f x = c
abbrev ConstantOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  Constant (fun x : X ↦ f ↑x)
abbrev MajorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), f x ≤ g x
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I
abbrev PiecewiseConstantWith (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : Prop :=
  ∀ J ∈ P, ConstantOn f (J : Set ℝ)
abbrev PiecewiseConstantOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∃ P : Partition I, PiecewiseConstantWith f P
noncomputable abbrev constant_value {X Y : Type} [hY : Nonempty Y] (f : X → Y) : Y :=
  if h : Constant f then h.choose else hY.some
noncomputable abbrev constant_value_on (f : ℝ → ℝ) (X : Set ℝ) : ℝ :=
  constant_value (fun x : X ↦ f ↑x)
noncomputable abbrev upper_integral (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  sInf ((PiecewiseConstantOn.integ · I) '' {g | MajorizesOn g f I ∧ PiecewiseConstantOn g I})
noncomputable abbrev integ (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  upper_integral f I
namespace BoundedInterval
abbrev a (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo a _ => a
  | Icc a _ => a
  | Ioc a _ => a
  | Ico a _ => a
abbrev b (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo _ b => b
  | Icc _ b => b
  | Ioc _ b => b
  | Ico _ b => b
abbrev length (I : BoundedInterval) : ℝ :=
  max (I.b - I.a) 0
@[coe]
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => .Ioo a b
  | Icc a b => .Icc a b
  | Ioc a b => .Ioc a b
  | Ico a b => .Ico a b
instance instMembership : Membership ℝ BoundedInterval where mem I x := x ∈ (I : Set ℝ)
end BoundedInterval
namespace Partition
instance instMembership (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals
end Partition
namespace PiecewiseConstantOn
noncomputable abbrev integ (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  if h : PiecewiseConstantOn f I then PiecewiseConstantWith.integ f h.choose else 0
end PiecewiseConstantOn
namespace PiecewiseConstantWith
noncomputable abbrev integ (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : ℝ :=
  ∑ J ∈ P.intervals, constant_value_on f (J : Set ℝ) * |J|ₗ
end PiecewiseConstantWith
theorem integ_zero {a b:ℝ} (hab: a ≤ b) (f: ℝ → ℝ) (hf: ContinuousOn f (Icc a b))
  (hnonneg: MajorizesOn f (fun _ ↦ 0) (Icc a b)) (hinteg : integ f (Icc a b) = 0) :
  ∀ x ∈ Icc a b, f x = 0 := by
    sorry
end Chapter11

-----------------------------------

Section_11_8: Chapter11.α_len_of_id

import Mathlib.Tactic
import Mathlib.Topology.Instances.Irrational

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
noncomputable abbrev left_lim (f : ℝ → ℝ) (x₀ : ℝ) : ℝ :=
  lim ((nhdsWithin x₀ (.Iio x₀)).map f)
noncomputable abbrev right_lim (f : ℝ → ℝ) (x₀ : ℝ) : ℝ :=
  lim ((nhdsWithin x₀ (.Ioi x₀)).map f)
noncomputable abbrev α_length (α : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  match I with
  | Icc a b => if a ≤ b then (right_lim α b) - (left_lim α a) else 0
  | Ico a b => if a ≤ b then (left_lim α b) - (left_lim α a) else 0
  | Ioc a b => if a ≤ b then (right_lim α b) - (right_lim α a) else 0
  | Ioo a b => if a < b then (left_lim α b) - (right_lim α a) else 0
namespace BoundedInterval
abbrev a (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo a _ => a
  | Icc a _ => a
  | Ioc a _ => a
  | Ico a _ => a
abbrev b (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo _ b => b
  | Icc _ b => b
  | Ioc _ b => b
  | Ico _ b => b
abbrev length (I : BoundedInterval) : ℝ :=
  max (I.b - I.a) 0
end BoundedInterval
@[simp]
theorem α_len_of_id (I: BoundedInterval) : (fun x ↦ x)[I]ₗ = |I|ₗ := by
  sorry
end Chapter11

-----------------------------------

Section_11_8: Chapter11.PiecewiseConstantWith.RS_integ_eq_integ

import Mathlib.Tactic
import Mathlib.Topology.Instances.Irrational

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
abbrev Constant {X Y : Type} (f : X → Y) : Prop :=
  ∃ c, ∀ x, f x = c
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I
noncomputable abbrev constant_value {X Y : Type} [hY : Nonempty Y] (f : X → Y) : Y :=
  if h : Constant f then h.choose else hY.some
noncomputable abbrev constant_value_on (f : ℝ → ℝ) (X : Set ℝ) : ℝ :=
  constant_value (fun x : X ↦ f ↑x)
noncomputable abbrev left_lim (f : ℝ → ℝ) (x₀ : ℝ) : ℝ :=
  lim ((nhdsWithin x₀ (.Iio x₀)).map f)
noncomputable abbrev right_lim (f : ℝ → ℝ) (x₀ : ℝ) : ℝ :=
  lim ((nhdsWithin x₀ (.Ioi x₀)).map f)
noncomputable abbrev α_length (α : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  match I with
  | Icc a b => if a ≤ b then (right_lim α b) - (left_lim α a) else 0
  | Ico a b => if a ≤ b then (left_lim α b) - (left_lim α a) else 0
  | Ioc a b => if a ≤ b then (right_lim α b) - (right_lim α a) else 0
  | Ioo a b => if a < b then (left_lim α b) - (right_lim α a) else 0
namespace BoundedInterval
abbrev a (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo a _ => a
  | Icc a _ => a
  | Ioc a _ => a
  | Ico a _ => a
abbrev b (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo _ b => b
  | Icc _ b => b
  | Ioc _ b => b
  | Ico _ b => b
abbrev length (I : BoundedInterval) : ℝ :=
  max (I.b - I.a) 0
@[coe]
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => .Ioo a b
  | Icc a b => .Icc a b
  | Ioc a b => .Ioc a b
  | Ico a b => .Ico a b
end BoundedInterval
namespace PiecewiseConstantWith
noncomputable abbrev integ (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : ℝ :=
  ∑ J ∈ P.intervals, constant_value_on f (J : Set ℝ) * |J|ₗ
noncomputable abbrev RS_integ (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) (α : ℝ → ℝ) : ℝ :=
  ∑ J ∈ P.intervals, constant_value_on f (J : Set ℝ) * α[J]ₗ
end PiecewiseConstantWith
theorem PiecewiseConstantWith.RS_integ_eq_integ {f:ℝ → ℝ} {I: BoundedInterval} (P: Partition I) :RS_integ f P (fun x ↦ x) = integ f P := by
  sorry
end Chapter11

-----------------------------------

Section_11_8: Chapter11.RS_integ_of_uniform_cts

import Mathlib.Tactic
import Mathlib.Topology.Instances.Irrational

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
abbrev Constant {X Y : Type} (f : X → Y) : Prop :=
  ∃ c, ∀ x, f x = c
abbrev ConstantOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  Constant (fun x : X ↦ f ↑x)
abbrev MajorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), f x ≤ g x
abbrev MinorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), g x ≤ f x
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I
abbrev PiecewiseConstantWith (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : Prop :=
  ∀ J ∈ P, ConstantOn f (J : Set ℝ)
abbrev PiecewiseConstantOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∃ P : Partition I, PiecewiseConstantWith f P
noncomputable abbrev constant_value {X Y : Type} [hY : Nonempty Y] (f : X → Y) : Y :=
  if h : Constant f then h.choose else hY.some
noncomputable abbrev constant_value_on (f : ℝ → ℝ) (X : Set ℝ) : ℝ :=
  constant_value (fun x : X ↦ f ↑x)
noncomputable abbrev left_lim (f : ℝ → ℝ) (x₀ : ℝ) : ℝ :=
  lim ((nhdsWithin x₀ (.Iio x₀)).map f)
noncomputable abbrev right_lim (f : ℝ → ℝ) (x₀ : ℝ) : ℝ :=
  lim ((nhdsWithin x₀ (.Ioi x₀)).map f)
noncomputable abbrev α_length (α : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  match I with
  | Icc a b => if a ≤ b then (right_lim α b) - (left_lim α a) else 0
  | Ico a b => if a ≤ b then (left_lim α b) - (left_lim α a) else 0
  | Ioc a b => if a ≤ b then (right_lim α b) - (right_lim α a) else 0
  | Ioo a b => if a < b then (left_lim α b) - (right_lim α a) else 0
noncomputable abbrev lower_RS_integral (f : ℝ → ℝ) (I : BoundedInterval) (α : ℝ → ℝ) : ℝ :=
  sSup ((PiecewiseConstantOn.RS_integ · I α) '' {g | MinorizesOn g f I ∧ PiecewiseConstantOn g I})
noncomputable abbrev upper_RS_integral (f : ℝ → ℝ) (I : BoundedInterval) (α : ℝ → ℝ) : ℝ :=
  sInf ((PiecewiseConstantOn.RS_integ · I α) '' {g | MajorizesOn g f I ∧ PiecewiseConstantOn g I})
noncomputable abbrev RS_IntegrableOn (f : ℝ → ℝ) (I : BoundedInterval) (α : ℝ → ℝ) : Prop :=
  BddOn f I ∧ lower_RS_integral f I α = upper_RS_integral f I α
namespace BoundedInterval
@[coe]
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => .Ioo a b
  | Icc a b => .Icc a b
  | Ioc a b => .Ioc a b
  | Ico a b => .Ico a b
end BoundedInterval
namespace Partition
instance instMembership (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals
end Partition
namespace PiecewiseConstantOn
noncomputable abbrev RS_integ (f : ℝ → ℝ) (I : BoundedInterval) (α : ℝ → ℝ) : ℝ :=
  if h : PiecewiseConstantOn f I then PiecewiseConstantWith.RS_integ f h.choose α else 0
end PiecewiseConstantOn
namespace PiecewiseConstantWith
noncomputable abbrev RS_integ (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) (α : ℝ → ℝ) : ℝ :=
  ∑ J ∈ P.intervals, constant_value_on f (J : Set ℝ) * α[J]ₗ
end PiecewiseConstantWith
theorem RS_integ_of_uniform_cts {I: BoundedInterval} {f:ℝ → ℝ} (hf: UniformContinuousOn f I)
 {α:ℝ → ℝ} (hα: Monotone α):
  RS_IntegrableOn f I α := by
  sorry
end Chapter11
namespace Chapter9
abbrev BddOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  ∃ M, ∀ x ∈ X, |f x| ≤ M
end Chapter9

-----------------------------------

Section_11_9: Chapter11.DifferentiableOn.of_F_11_9_2'

import Mathlib.Tactic
import Mathlib.Topology.ContinuousOn

namespace Chapter11
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
abbrev Constant {X Y : Type} (f : X → Y) : Prop :=
  ∃ c, ∀ x, f x = c
abbrev ConstantOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  Constant (fun x : X ↦ f ↑x)
abbrev MajorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), f x ≤ g x
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I
abbrev PiecewiseConstantWith (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : Prop :=
  ∀ J ∈ P, ConstantOn f (J : Set ℝ)
abbrev PiecewiseConstantOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∃ P : Partition I, PiecewiseConstantWith f P
noncomputable abbrev constant_value {X Y : Type} [hY : Nonempty Y] (f : X → Y) : Y :=
  if h : Constant f then h.choose else hY.some
noncomputable abbrev constant_value_on (f : ℝ → ℝ) (X : Set ℝ) : ℝ :=
  constant_value (fun x : X ↦ f ↑x)
noncomputable abbrev upper_integral (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  sInf ((PiecewiseConstantOn.integ · I) '' {g | MajorizesOn g f I ∧ PiecewiseConstantOn g I})
noncomputable abbrev integ (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  upper_integral f I
noncomputable abbrev F_11_9_2 := fun x ↦ integ f_9_8_5 (Icc 0 x)
namespace BoundedInterval
abbrev a (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo a _ => a
  | Icc a _ => a
  | Ioc a _ => a
  | Ico a _ => a
abbrev b (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo _ b => b
  | Icc _ b => b
  | Ioc _ b => b
  | Ico _ b => b
abbrev length (I : BoundedInterval) : ℝ :=
  max (I.b - I.a) 0
@[coe]
def toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => .Ioo a b
  | Icc a b => .Icc a b
  | Ioc a b => .Ioc a b
  | Ico a b => .Ico a b
end BoundedInterval
namespace Partition
instance instMembership (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals
end Partition
namespace PiecewiseConstantOn
noncomputable abbrev integ (f : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  if h : PiecewiseConstantOn f I then PiecewiseConstantWith.integ f h.choose else 0
end PiecewiseConstantOn
namespace PiecewiseConstantWith
noncomputable abbrev integ (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : ℝ :=
  ∑ J ∈ P.intervals, constant_value_on f (J : Set ℝ) * |J|ₗ
end PiecewiseConstantWith
theorem DifferentiableOn.of_F_11_9_2' {q:ℚ} (hq: (q:ℝ) ∈ Set.Icc 0 1) : ¬ DifferentiableWithinAt ℝ F_11_9_2 (.Icc 0 1) q := by sorry
end Chapter11
namespace Chapter9
noncomputable abbrev q_9_8_5 : ℕ ≃ ℚ :=
  nonempty_equiv_of_countable.some
noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun q ↦ (2 : ℝ) ^ (-q_9_8_5.symm q : ℤ)
noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun x ↦ ∑' r : { r : ℚ // (r : ℝ) < x }, g_9_8_5 r
end Chapter9

-----------------------------------

