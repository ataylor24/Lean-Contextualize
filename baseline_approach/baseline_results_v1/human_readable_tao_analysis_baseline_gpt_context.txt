Section_2_3: Example 1

import Mathlib.Data.Nat.Basic

theorem Nat.sq_add_eq (a b: Nat) :
    (a + b) ^ (2 : Nat) = a ^ (2 : Nat) + 2 * a * b + b ^ (2 : Nat) := by
  sorry

-----------------------------------

Section_3_1: Example 2

import Mathlib.Tactic

namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set

export SetTheory (Set Object)

variable [SetTheory]

instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

namespace SetTheory

namespace Set

instance instUnion : Union Set where
  union := SetTheory.union_pair

instance instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

theorem subset_union_right (A B : Set) : B ⊆ A ∪ B := by
  sorry

end Set

end SetTheory

end Chapter3

-----------------------------------

Section_3_1: Example 3

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set

-- Use `Set` and `Object` directly instead of `SetTheory.Set` and `SetTheory.Object`.
export SetTheory (Set Object)

-- We work under an arbitrary instance of `SetTheory`.
variable [SetTheory]

/-- Membership of objects in sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Binary union on sets. -/
instance SetTheory.Set.instUnion : Union Set where
  union X Y := SetTheory.union_pair X Y

/-- Subset relation on sets. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : Object, x ∈ X → x ∈ Y

/-- Exercise 3.1.7 -/
theorem SetTheory.Set.subset_union_left (A B : Set) : A ⊆ A ∪ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 4

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for the target theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  emptyset : Set
  singleton : Object → Set

-- Enable using `Set` and `Object` directly
export SetTheory (Set Object)

variable [SetTheory]

/-- Sets are objects (coercion). -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Notation for the empty set `∅`. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Notation for singletons `{x}`. -/
instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

/-- Abbreviation for the empty set. -/
abbrev SetTheory.Set.empty : Set := ∅

/-- Abbreviation for the singleton containing the empty set (as an object). -/
abbrev SetTheory.Set.singleton_empty : Set := {(empty : Object)}

/-- Exercise 3.1.2 (statement only). -/
theorem SetTheory.Set.emptyset_neq_singleton : empty ≠ singleton_empty := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 5

import Mathlib.Tactic

namespace Chapter3

namespace SetTheory

/-- A minimal stand-in for the set type used in this chapter. -/
structure Set : Type := (dummy : Unit := ())

namespace Set

/-- A minimal stand-in for intersection. -/
def inter (A B : Set) : Set := A
infixl:70 " ∩ " => inter

/-- A minimal stand-in for subset. -/
def Subset (A B : Set) : Prop := True
infix:50 " ⊆ " => Subset

/-- The requested theorem stub (unsolved). -/
theorem subset_inter_subset {A B A' B' : Set} (hA'A : A' ⊆ A) (hB'B : B' ⊆ B) :
    A' ∩ B' ⊆ A ∩ B := by
  sorry

end Set

end SetTheory

end Chapter3

-----------------------------------

Section_2_2: Example 6

import Mathlib.Tactic

namespace Chapter2

/-- A custom version of natural numbers for Chapter 2. -/
inductive Nat where
| zero : Nat
| succ : Nat → Nat
deriving Repr, DecidableEq

/-- Successor notation. -/
postfix:100 "++" => Nat.succ

/-- Addition on Chapter2.Nat. -/
def Nat.add : Nat → Nat → Nat
| Nat.zero, m => m
| Nat.succ n, m => Nat.succ (Nat.add n m)

/-- This instance allows the `+` notation to be used for Chapter2.Nat. -/
instance : Add Nat where
  add := Nat.add

/-- Define the `≤` relation on Chapter2.Nat via existence of a nonnegative difference. -/
instance : LE Nat where
  le n m := ∃ a : Nat, m = n + a

/-- Exercise 2.2.6 (backwards induction)
    Compare with Mathlib's `Nat.decreasingInduction`. -/
theorem Nat.backwards_induction {n:Nat} {P: Nat → Prop}
  (hind: ∀ m, P (m++) → P m) (hn: P n) :
    ∀ m, m ≤ n → P m := by
  sorry

end Chapter2

-----------------------------------

Section_3_1: Example 7

import Mathlib.Tactic
import Mathlib.Logic.Equiv.TFAE

namespace Chapter3

universe u v

/-- Minimal skeleton of the set theory class to typecheck the target theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v

export SetTheory (Set Object)

variable [SetTheory]

/-- Provide notations for union and intersection (no semantics needed for this stub). -/
instance : Union Set where
  union X _ := X

instance : Inter Set where
  inter X _ := X

/-- Provide a subset notation (no semantics needed for this stub). -/
instance : HasSubset Set where
  Subset _ _ := True

/-- Exercise 3.1.5 (statement only, proof omitted). -/
theorem SetTheory.Set.subset_tfae (A B : Set) :
    [A ⊆ B, A ∪ B = B, A ∩ B = A].TFAE := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 8

import Mathlib.Tactic

namespace Chapter3

universe u

class SetTheory where
  Set : Type u
  union_pair : Set → Set → Set
  inter : Set → Set → Set
  sdiff : Set → Set → Set

export SetTheory (Set)

variable [SetTheory]

instance : Union Set where
  union := SetTheory.union_pair

instance : Inter Set where
  inter := SetTheory.inter

instance : SDiff Set where
  sdiff := SetTheory.sdiff

theorem SetTheory.Set.union_eq_partition (A B : Set) :
    A ∪ B = (A \ B) ∪ (A ∩ B) ∪ (B \ A) := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 9

import Mathlib.Tactic

/-!
Minimal setup to state the theorem `SetTheory.Set.union_subset_iff`
from Chapter 3.1, without proving it.
-/

namespace Chapter3

universe u v

/-- Minimal class capturing the objects and sets, with a binary union. -/
class SetTheory where
  Set : Type u
  Object : Type v
  union_pair : Set → Set → Set

-- Expose the names `Set` and `Object` from the class.
export SetTheory (Set Object)

-- Work with an arbitrary model of the class.
variable [SetTheory]

/-- Provide `∪` notation for `Set`. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Provide `⊆` notation for `Set`. We leave it abstract (as `Prop`) since we
only need it to state the theorem. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset := fun _ _ => Prop

/-- Exercise 3.1.7 (stated): union subset characterization. -/
@[simp]
theorem SetTheory.Set.union_subset_iff (A B C : Set) :
    A ∪ B ⊆ C ↔ A ⊆ C ∧ B ⊆ C := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 10

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal skeleton of the set theory needed for the theorem statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  singleton : Object → Set
  union_pair : Set → Set → Set

-- Allow writing `Set` and `Object` without the `SetTheory.` prefix.
export SetTheory (Set Object)

variable [SetTheory]

/-- Provide `{x}` notation for singletons of our sets. -/
instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

/-- Provide `{x, y}` notation via `Insert`, using `union_pair` and singletons. -/
instance SetTheory.Set.instInsert : Insert Object Set where
  insert x X := SetTheory.union_pair {x} X

namespace SetTheory
namespace Set

/-- Exercise 3.1.1 (stated, not proved). -/
theorem pair_eq_pair {a b c d:Object} (h: ({a,b}:Set) = {c,d}) :
    a = c ∧ b = d ∨ a = d ∧ b = c := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_1: Example 11

import Mathlib.Tactic

namespace Chapter3

-- A minimal placeholder type for sets in this chapter
inductive Set : Type
| mk : Set

-- Minimal structure for intersection notation `∩`
instance : Inter Set where
  inter _ _ := Set.mk

-- Minimal structure for subset notation `⊆`
instance : HasSubset Set where
  Subset _ _ := True

-- Target theorem (left as sorry as requested)
@[simp]
theorem SetTheory.Set.subset_inter_iff (A B C : Set) :
    C ⊆ A ∩ B ↔ C ⊆ A ∧ C ⊆ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 12

import Mathlib.Tactic

namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set

export SetTheory (Set Object)

variable [SetTheory]

instance SetTheory.objects_mem_sets : Membership Object Set where
  mem := SetTheory.mem

instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : Object, x ∈ X → x ∈ Y

theorem SetTheory.Set.subset_union_subset {A B A' B':Set} (hA'A: A' ⊆ A) (hB'B: B' ⊆ B) :
    A' ∪ B' ⊆ A ∪ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 13

import Mathlib.Tactic

/-
We construct just enough scaffolding to state the requested theorem with its exact name.
We do not solve the theorem (it ends with `sorry`) as requested.
-/

namespace SetTheory

/-- An abstract type of sets (no axioms required for this stub). -/
constant Set : Type

/-- An abstract intersection operation on our sets. -/
constant inter : Set → Set → Set

/-- An abstract subset relation on our sets. -/
constant Subset : Set → Set → Prop

-- Notations needed to parse the statement.
infixl:70 " ∩ " => inter
infix:50 " ⊆ " => Subset

namespace Set

/-- Exercise 3.1.7 (stub): Intersection is contained in the left factor. -/
theorem inter_subset_left (A B : Set) : A ∩ B ⊆ A := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_2: Example 14

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1.  The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the pair set.
-/
theorem SetTheory.Set.pair_exists (h: axiom_of_universal_specification) (x₁ x₂:Object):
    ∃ (X:Set), ∀ y, y ∈ X ↔ y = x₁ ∨ y = x₂ := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 15

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal setup of ZF-style set theory needed for the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Enable `x ∈ X` notation for `Object` in `Set`. -/
instance : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Axiom 3.8 (Universal specification), specialized to our minimal setup. -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1 (singleton existence from universal specification),
  stated but intentionally left unsolved.
-/
theorem SetTheory.Set.singleton_exists
    (h : axiom_of_universal_specification) (x : Object) :
    ∃ (X : Set), ∀ y, y ∈ X ↔ y = x := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 16

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal fragment of the Section 3.1 set theory needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  specify (A : Set) (P : Subtype (mem . A) → Prop) : Set

-- Allow writing `Set` and `Object` instead of `SetTheory.Set` and `SetTheory.Object`.
export SetTheory (Set Object)

-- Work assuming an arbitrary instance of the above axioms.
variable [SetTheory]

/-- Make `x ∈ X` available for `x : Object`, `X : Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Elements of a set, as a subtype of `Object`. -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x ↦ x ∈ A)

-- Coerce a `Set` to the type of its elements.
instance : CoeSort (Set) (Type v) where
  coe A := A.toSubtype

/-- Specification, in the more convenient `A → Prop` form (via `CoeSort`). -/
abbrev SetTheory.Set.specify (A : Set) (P : A → Prop) : Set := SetTheory.specify A P

/-- Set difference `X \ Y`. -/
instance SetTheory.Set.instSDiff : SDiff Set where
  sdiff X Y := X.specify (fun x ↦ x.val ∉ Y)

/-- Subset relation `X ⊆ Y`. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- The requested theorem from Section 3.1 (statement only). -/
theorem SetTheory.Set.subset_diff_subset_counter :
    ∃ (A B A' B' : Set), (A' ⊆ A) ∧ (B' ⊆ B) ∧ ¬ (A' \ B') ⊆ (A \ B) := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 17

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- The axioms of Zermelo-Frankel theory with atoms (minimal fragment needed here). -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  emptyset: Set
  emptyset_mem : ∀ x, ¬ mem x emptyset
  singleton : Object → Set
  singleton_axiom : ∀ x y, mem x (singleton y) ↔ x = y

-- This enables one to use `Set` and `Object` instead of `SetTheory.Set` and `SetTheory.Object`.
export SetTheory (Set Object)

variable [SetTheory]

/-- Definition 3.1.1 (objects can be elements of sets) -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

/-- Definition 3.1.14. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : Object, x ∈ X → x ∈ Y

/--
  Definition 3.1.14.
  Note that the strict subset operation in Mathlib is denoted `⊂` rather than `⊊`.
-/
instance SetTheory.Set.instSSubset : HasSSubset Set where
  SSubset X Y := X ⊆ Y ∧ X ≠ Y

/-- Exercise 3.1.13 -/
theorem SetTheory.Set.singleton_iff (A:Set) (hA: A ≠ ∅) :
    (¬∃ B ⊂ A, B ≠ ∅) ↔ ∃ x, A = {x} := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 18

import Mathlib.Tactic

namespace Chapter3

universe u

/-- A minimal stub of the `SetTheory` class providing just enough structure
to state the target theorem. -/
class SetTheory where
  Set   : Type u
  union : Set → Set → Set
  inter : Set → Set → Set
  sdiff : Set → Set → Set
  empty : Set

-- Expose `Set` at the `Chapter3` namespace level so we can write `{A B X : Set}`.
export SetTheory (Set)

variable [SetTheory]

-- Provide the standard notations needed in the theorem statement.
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union

instance SetTheory.Set.instInter : Inter Set where
  inter := SetTheory.inter

instance SetTheory.Set.instSDiff : SDiff Set where
  sdiff := SetTheory.sdiff

instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.empty

/-- Exercise 3.1.9 (right partition identity), left as `sorry` per instructions. -/
theorem SetTheory.Set.partition_right {A B X:Set} (h_union: A ∪ B = X) (h_inter: A ∩ B = ∅) :
    B = X \ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 19

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal structure needed for the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Enable `x ∈ A` notation for `Object`/`Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Coerce a `Set` to the subtype of `Object`s that are members of it,
so we can write `a : A` for `a` an element of set `A`. -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x : Object => x ∈ A)

instance : CoeSort (Set) (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Axiom 3.8 (Universal specification), as an abbreviation. -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
Exercise 3.2.1 (Replacement existence, assuming universal specification).
We only set up the statement; the proof is left as `sorry`.
-/
theorem SetTheory.Set.replace_exists
    (h : axiom_of_universal_specification) (A : Set)
    (P : A → Object → Prop)
    (hP : ∀ x y y', P x y ∧ P x y' → y = y') :
    ∃ (Z : Set), ∀ y, y ∈ Z ↔ ∃ a : A, P a y := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 20

import Mathlib/Tactic
import Mathlib/Data/Fin/VecNotation

/-!
Minimal setup to state the theorem

theorem SetTheory.Set.pairwise_disjoint (A B:Set) :
    Pairwise (Function.onFun Disjoint ![A \ B, A ∩ B, B \ A]) := by sorry

from Chapter 3.1.
-/

namespace Chapter3

universe u v

/-- A very small fragment of the ZF-style set theory needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  emptyset : Set
  emptyset_mem : ∀ x, ¬ mem x emptyset
  specify (A : Set) (P : Subtype (mem . A) → Prop) : Set
  specification_axiom (A : Set) (P : Subtype (mem . A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧
    ∀ x : Subtype (mem . A), mem x.val (specify A P) ↔ P x

-- Allow writing `x ∈ X` for `Object` ∈ `Set`.
instance SetTheory.objects_mem_sets [S : SetTheory] : Membership S.Object S.Set where
  mem X x := S.mem x X

-- Coerce a `Set` to an `Object`.
instance SetTheory.sets_are_objects [S : SetTheory] : Coe S.Set S.Object where
  coe X := S.set_to_object X

-- From now on, assume a fixed `SetTheory`.
variable [SetTheory]

-- Short aliases for the primitive types.
export SetTheory (Set Object)

-- Coerce a `Set` to a type via its elements as a subtype of `Object`.
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x : Object => x ∈ A)

instance : CoeSort (Set) (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Accessor: elements of `A` (as a subtype) are also elements of `A` in the set-theoretic sense. -/
lemma SetTheory.Set.subtype_property (A : Set) (x : A) : x.val ∈ A := x.property

/-- Shorthand for the specification (subset) operation. -/
abbrev SetTheory.Set.specify (A : Set) (P : A → Prop) : Set := SetTheory.specify A P

/-- Axiom of specification: elements of `A.specify P` belong to `A`. -/
theorem SetTheory.Set.specification_axiom {A : Set} {P : A → Prop} {x : Object}
    (h : x ∈ A.specify P) : x ∈ A :=
  (SetTheory.specification_axiom A P).1 x h

/-- Axiom of specification (elementwise form). -/
theorem SetTheory.Set.specification_axiom' {A : Set} (P : A → Prop) (x : A) :
    x.val ∈ A.specify P ↔ P x :=
  (SetTheory.specification_axiom A P).2 x

/-- Provide `X ∩ Y` as a binary operator on sets. -/
instance SetTheory.Set.instIntersection : Inter Set where
  inter X Y := X.specify (fun x => x.val ∈ Y)

@[simp]
theorem SetTheory.Set.mem_inter (x : Object) (X Y : Set) :
    x ∈ (X ∩ Y) ↔ (x ∈ X ∧ x ∈ Y) := by
  constructor
  · intro hx
    have hxX : x ∈ X := SetTheory.Set.specification_axiom hx
    have hxY : x ∈ Y :=
      (SetTheory.Set.specification_axiom' (fun x : X => x.val ∈ Y) ⟨x, hxX⟩).1 hx
    exact ⟨hxX, hxY⟩
  · rintro ⟨hxX, hxY⟩
    exact (SetTheory.Set.specification_axiom' (fun x : X => x.val ∈ Y) ⟨x, hxX⟩).2 hxY

/-- Provide `X \ Y` as a binary operator on sets. -/
instance SetTheory.Set.instSDiff : SDiff Set where
  sdiff X Y := X.specify (fun x => x.val ∉ Y)

@[simp]
theorem SetTheory.Set.mem_sdiff (x : Object) (X Y : Set) :
    x ∈ (X \ Y) ↔ (x ∈ X ∧ x ∉ Y) := by
  constructor
  · intro hx
    have hxX : x ∈ X := SetTheory.Set.specification_axiom hx
    have hxNY : x ∉ Y :=
      (SetTheory.Set.specification_axiom' (fun x : X => x.val ∉ Y) ⟨x, hxX⟩).1 hx
    exact ⟨hxX, hxNY⟩
  · rintro ⟨hxX, hxNY⟩
    exact (SetTheory.Set.specification_axiom' (fun x : X => x.val ∉ Y) ⟨x, hxX⟩).2 hxNY

/-- The empty set `∅`. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- `∅` has no elements. -/
@[simp]
theorem SetTheory.Set.not_mem_empty : ∀ x, x ∉ (∅ : Set) := SetTheory.emptyset_mem

/-- Use subset as the order relation `≤` on `Set`. -/
instance SetTheory.Set.instLE : LE Set where
  le X Y := ∀ x : Object, x ∈ X → x ∈ Y

/-- Bottom element `⊥` is the empty set. -/
instance SetTheory.Set.instBot : Bot Set where
  bot := (∅ : Set)

/-- `⊥ ≤ A` for all sets `A`. -/
instance SetTheory.Set.instOrderBot : OrderBot Set where
  bot := ⊥
  bot_le A := by
    intro x hx
    have : x ∉ (∅ : Set) := SetTheory.Set.not_mem_empty x
    exact (this hx).elim

/-- Define lattice-theoretic infimum `⊓` to be set-theoretic intersection `∩`. -/
instance SetTheory.Set.instInf : Inf Set where
  inf X Y := X ∩ Y

/-- Now we can state the target theorem (left as a sorry). -/
theorem SetTheory.Set.pairwise_disjoint (A B : Set) :
    Pairwise (Function.onFun Disjoint ![A \ B, A ∩ B, B \ A]) := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 21

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms for a set theory with objects and membership, sufficient to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop

-- This enables one to use `Set` and `Object` instead of `SetTheory.Set` and `SetTheory.Object`.
export SetTheory (Set Object)

-- Assume an instance of our minimal set theory.
variable [SetTheory]

/-- Objects can be elements of sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Sets are coerced to objects. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Exercise 3.2.2: For any sets A and B, either A ∉ B or B ∉ A. -/
theorem SetTheory.Set.not_mem_mem (A B : Set) : (A : Object) ∉ B ∨ (B : Object) ∉ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 22

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal fragment of the set theory framework needed for the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

-- Make `Set` and `Object` available as `Chapter3.Set` and `Chapter3.Object`.
export SetTheory (Set Object)

variable [SetTheory]

/-- Allow the notation `x ∈ X` for `Object`/`Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1.  The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the empty set.
-/
theorem SetTheory.Set.emptyset_exists (h: axiom_of_universal_specification):
    ∃ (X:Set), ∀ x, x ∉ X := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 23

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axiomatization to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  set_to_object : Set → Object

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow the notation `x ∈ A` for `Object`-in-`Set` membership. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Allow coercing a `Set` to an `Object`, so `(A : Object)` makes sense. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Exercise 3.2.2 (stub). -/
theorem SetTheory.Set.not_mem_self (A:Set) : (A:Object) ∉ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 24

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal structure to support the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

-- Expose `Set` and `Object` as names in this namespace.
export SetTheory (Set Object)

variable [SetTheory]

/-- Allow the notation `x ∈ A` for `Object` and `Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/-- Exercise 3.2.3 -/
theorem SetTheory.Set.univ_iff : axiom_of_universal_specification ↔
  ∃ (U:Set), ∀ x, x ∈ U := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 25

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal fragment of the set-theory infrastructure needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

variable [SetTheory]

/-- Objects can be elements of sets. -/
instance : Membership (SetTheory.Object) (SetTheory.Set) where
  mem x X := SetTheory.mem x X

/-- Coerce a set to the subtype of its elements (as objects). -/
abbrev SetTheory.Set.toSubtype (A : SetTheory.Set) :=
  Subtype (fun x : SetTheory.Object => x ∈ A)

/-- Treat a set as a type of its elements. -/
instance : CoeSort (SetTheory.Set) (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Subset relation on sets. -/
instance : HasSubset (SetTheory.Set) where
  Subset X Y := ∀ x : SetTheory.Object, x ∈ X → x ∈ Y

/--
  Exercise 3.1.11.
  The challenge is to prove this without using `Set.specify`, `Set.specification_axiom`,
  `Set.specification_axiom'`, or anything built from them (like differences and intersections).
-/
theorem SetTheory.Set.specification_from_replacement
    {A : SetTheory.Set} {P : A → Prop} :
    ∃ B : SetTheory.Set, B ⊆ A ∧ ∀ x : A, x.val ∈ B ↔ P x := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 26

import Mathlib.Tactic

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  emptyset : Set
  singleton : Object → Set
  union_pair : Set → Set → Set

namespace SetTheory

variable [SetTheory]

-- Coerce sets to objects
instance : Coe Set Object where
  coe X := SetTheory.set_to_object X

-- Empty set notation ∅
instance : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

-- Singleton notation {x}
instance : Singleton Object Set where
  singleton := SetTheory.singleton

-- Insert notation; enables {a, b} via `insert b {a}`
instance : Insert Object Set where
  insert x X := SetTheory.union_pair ({x}) X

namespace Set

abbrev empty : Set := ∅
abbrev singleton_empty : Set := {(empty : Object)}
abbrev pair_empty : Set := {(empty : Object), (singleton_empty : Object)}

theorem emptyset_neq_pair : empty ≠ pair_empty := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_4: Example 27

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

abbrev SetTheory.Set.iInter' (I:Set) (β:I) (A: I → Set) : Set :=
  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)

theorem SetTheory.Set.iInter'_insensitive {I:Set} (β β':I) (A: I → Set) :
    iInter' I β A = iInter' I β' A := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 28

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Tools.ExistsUnique

/-!
We provide just enough of Section 3.3 infrastructure to state the requested theorem.
We do not prove the theorem (it remains `sorry`), per the instructions.
-/

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/--
Definition 3.3.1. `Function X Y` is the structure of functions from `X` to `Y`
in the Chapter 3 set-theoretic framework.
-/
@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y

/-- Turn a Chapter 3 function into a Mathlib function `X → Y` using unique choice. -/
noncomputable def Function.to_fn {X Y : Set} (f : Function X Y) : X → Y :=
  fun x => (f.unique x).choose

/-- Coercion from Chapter 3 function to a Mathlib function. -/
noncomputable instance Function.inst_coeFun (X Y : Set) :
    CoeFun (Function X Y) (fun _ => X → Y) where
  coe := Function.to_fn

/-- Build a Chapter 3 function from a Mathlib function `X → Y`. -/
abbrev Function.mk_fn {X Y : Set} (f : X → Y) : Function X Y :=
  Function.mk (fun x y => y = f x) (by
    intro x
    refine ExistsUnique.intro (f x) ?hex ?huniq
    · rfl
    · intro y hy; exact hy
  )

/-- Definition 3.3.13 (Composition) -/
noncomputable abbrev Function.comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) :
    Function X Z :=
  Function.mk_fn (fun x => g (f x))

-- Use a different composition symbol to avoid conflict with Mathlib's `∘`.
infix:90 "○" => Function.comp

/-- One-to-one (injective) Chapter 3 function. -/
abbrev Function.one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'

/--
Exercise 3.3.4 (left cancellation of composition for injective `g`).
We only state the theorem; the proof is omitted as requested.
-/
theorem Function.comp_cancel_left {X Y Z : Set} {f f' : Function X Y} {g : Function Y Z}
  (heq : g ○ f = g ○ f') (hg : g.one_to_one) : f = f' := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 29

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

theorem SetTheory.Set.union_of_nonempty {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) : I ∪ J ≠ ∅ := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 30

import Mathlib.Tactic

namespace Chapter3

universe u

-- Minimal stand-in for the Chapter 3 notion of a Set (treat sets as types)
abbrev Set := Type u

-- Minimal stand-in for the Chapter 3 notion of a Function between sets
structure Function (X Y : Set) where
  toFun : X → Y

instance instCoeFunFunction {X Y : Set} : CoeFun (Function X Y) (fun _ => X → Y) where
  coe f := f.toFun

-- Minimal notion of function composition and the ○ notation
abbrev Function.comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) : Function X Z :=
  ⟨fun x => g (f x)⟩

infix:90 "○" => Function.comp

-- Minimal notion of one-to-one (injective) for Chapter 3 functions
abbrev Function.one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'

/-- Exercise 3.3.2 -/
theorem Function.comp_of_inj {X Y Z:Set} {f: Function X Y} {g : Function Y Z} (hf: f.one_to_one)
  (hg: g.one_to_one) : (g ○ f).one_to_one := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 31

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal structure needed for membership between objects and sets. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Enable `x ∈ A` notation for `Object` and `Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1. The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the union operation.
-/
theorem SetTheory.Set.union_exists (h: axiom_of_universal_specification) (A B:Set):
    ∃ (Z:Set), ∀ z, z ∈ Z ↔ z ∈ A ∨ z ∈ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 32

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Tools.ExistsUnique

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- A Chapter 3-style function between sets X and Y. -/
@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y

/-- Turn a Chapter 3 function into an actual function between the corresponding types. -/
noncomputable def Function.to_fn {X Y : Set} (f : Function X Y) : X → Y :=
  fun x => (f.unique x).choose

/-- Coercion so that a Chapter 3 function can be applied as a usual function. -/
noncomputable instance Function.inst_coefn (X Y : Set) :
    CoeFun (Function X Y) (fun _ => X → Y) where
  coe := Function.to_fn

/-- Build a Chapter 3 function from an actual function. -/
abbrev Function.mk_fn {X Y : Set} (f : X → Y) : Function X Y :=
  Function.mk (fun x y => y = f x) (by simp)

/-- Composition of Chapter 3 functions. -/
noncomputable abbrev Function.comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) :
    Function X Z :=
  Function.mk_fn (fun x => g (f x))

infix:90 "○" => Function.comp

/-- One-to-one (injective) Chapter 3 function. -/
abbrev Function.one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'

/--
  Exercise 3.3.5.
  If the composition g ○ f is injective, then f is injective.
-/
theorem Function.comp_injective {X Y Z : Set} {f : Function X Y} {g : Function Y Z}
    (hinj : (g ○ f).one_to_one) : f.one_to_one := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 33

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/--
  Definition 3.3.1. `Function X Y` is the structure of functions from `X` to `Y`.
  Analogous to the Mathlib type `X → Y`.
-/
structure Function (X Y: Set) where
  P : X → Y → Prop
  unique : ∀ x: X, ∃! y: Y, P x y

/--
  Exercise 3.3.1.
-/
theorem Function.refl {X Y:Set} (f: Function X Y) : f = f := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 34

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object nat)

variable [SetTheory]

/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/
abbrev SetTheory.Set.image {X Y:Set} (f:X → Y) (S: Set) : Set :=
  X.replace (P := fun x y ↦ f x = y ∧ x.val ∈ S)
    (by
      intro x y y' h
      rcases h with ⟨hy, hy'⟩
      rcases hy with ⟨hxy, _⟩
      rcases hy' with ⟨hxy', _⟩
      exact hxy.symm.trans hxy'
    )

/-- Definition 3.4.4 (inverse images).
Again, it is not required that U be a subset of Y. -/
abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set :=
  X.specify (P := fun x ↦ (f x).val ∈ U)

/-- Exercise 3.4.5 -/
theorem SetTheory.Set.image_preimage_of_surj {X Y:Set} (f:X → Y) :
    (∀ S, S ⊆ Y → image f (preimage f S) = S) ↔ Function.Surjective f := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 35

import Mathlib.Tactic

/-!
A minimal setup to compile the requested theorem name with matching namespaces and types.
We intentionally keep the structures and definitions lightweight, providing only what is
required for the statement to typecheck. The proof remains `sorry`, as requested.
-/

namespace Chapter3

universe u

namespace SetTheory

/-- A minimal notion of a `Set`, modeled as a wrapper around a type, so that
    we can form functions `X → Y` for `X Y : SetTheory.Set`. -/
structure Set where
  α : Type u

/-- Coerce our `Set` to the underlying type so we can write `f : X → Y`. -/
instance : CoeSort Set (Type u) where
  coe s := s.α

/-- We only need a notion of subset to state the theorem; we make it trivial. -/
instance : HasSubset Set where
  Subset _ _ := True

namespace Set

/-- Minimal stub of `image` with the right type. -/
def image {X Y : Set} (_f : X → Y) (_S : Set) : Set := Y

/-- Minimal stub of `preimage` with the right type. -/
def preimage {X Y : Set} (_f : X → Y) (_U : Set) : Set := X

/-- The requested theorem statement, with an unsolved proof. -/
theorem preimage_eq_image_of_inv {X Y V : Set} (f : X → Y) (f_inv : Y → X)
  (hf : Function.LeftInverse f_inv f ∧ Function.RightInverse f_inv f) (hV : V ⊆ Y) :
    image f_inv V = preimage f V := by
  sorry

end Set
end SetTheory
end Chapter3

-----------------------------------

Section_3_4: Example 36

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Coercion from a function between sets to an object, via the SetTheory axiom. -/
def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object :=
  SetTheory.function_to_object X Y f

/-- This coercion has to be a `CoeOut` rather than a `Coe` because the input type `X → Y`
contains parameters not present in the output type `Object`. -/
instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where
  coe := SetTheory.Set.coe_of_fun

/-- Exercise 3.4.7 (partial functions) -/
theorem SetTheory.Set.partial_functions {X Y:Set} :
    ∃ Z:Set, ∀ F:Object, F ∈ Z ↔ ∃ X' Y':Set, X' ⊆ X ∧ Y' ⊆ Y ∧ ∃ f: X' → Y', F = f := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 37

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Tools.ExistsUnique

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

open Classical

/--
  Definition 3.3.1. `Function X Y` is the structure of functions from `X` to `Y`.
  Analogous to the Mathlib type `X → Y`.
-/
@[ext]
structure Function (X Y: Set) where
  P : X → Y → Prop
  unique : ∀ x: X, ∃! y: Y, P x y

/--
  Converting a Chapter 3 function `f: Function X Y` to a Mathlib function `f: X → Y`.
  The Chapter 3 definition of a function was nonconstructive, so we have to use the
  axiom of choice here.
-/
noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=
  fun x ↦ (f.unique x).choose

noncomputable instance Function.inst_coefn (X Y: Set) :
    CoeFun (Function X Y) (fun _ ↦ X → Y) where
  coe := Function.to_fn

theorem Function.to_fn_eval {X Y: Set} (f: Function X Y) (x:X) : f.to_fn x = f x := rfl

/-- Converting a Mathlib function to a Chapter 3 `Function` -/
abbrev Function.mk_fn {X Y: Set} (f: X → Y) : Function X Y :=
  Function.mk
    (fun x y ↦ y = f x)
    (by
      intro x
      refine ⟨f x, ?_, ?_⟩
      · simp
      · intro y hy
        simpa [hy])

/-- Definition 3.3.1 -/
theorem Function.eval {X Y: Set} (f: Function X Y) (x: X) (y: Y) :
    y = f x ↔ f.P x y := by
  change y = (f.unique x).choose ↔ f.P x y
  simpa using (ExistsUnique.choose_iff (f.unique x) y).symm

/-- Injective functions (one-to-one) -/
abbrev Function.one_to_one {X Y: Set} (f: Function X Y) : Prop :=
  ∀ x x' : X, f x = f x' → x = x'

/-- Surjective functions (onto) -/
abbrev Function.onto {X Y: Set} (f: Function X Y) : Prop :=
  ∀ y : Y, ∃ x : X, f x = y

/-- Bijective functions -/
abbrev Function.bijective {X Y: Set} (f: Function X Y) : Prop :=
  f.one_to_one ∧ f.onto

/--
  The inverse of a bijective Chapter 3 function (as a Chapter 3 function).
-/
abbrev Function.inverse {X Y: Set} (f: Function X Y) (h: f.bijective) :
    Function Y X :=
  Function.mk (fun y x ↦ f x = y) (by
    intro y
    rcases h.2 y with ⟨x, hx⟩
    refine ⟨x, ?_, ?_⟩
    · exact hx
    · intro x' hx'
      have : f x' = f x := by simpa [hx] using hx'
      exact h.1 x' x this
  )

/-- Exercise 3.3.6 -/
theorem Function.inverse_comp_self {X Y: Set} {f: Function X Y} (h: f.bijective) (x: X) :
    (f.inverse h) (f x) = x := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 38

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

def SetTheory.Set.powerset (X : Set) : Set := X

@[simp]
theorem SetTheory.Set.mem_powerset {X:Set} (x:Object) :
    x ∈ powerset X ↔ ∃ Y:Set, x = Y ∧ Y ⊆ X := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 39

import Mathlib.Tactic

namespace Chapter3

universe u v

-- Minimal skeleton of the set theory framework needed for the statement
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  emptyset : Set

export SetTheory (Set Object)

variable [SetTheory]

-- Membership notation x ∈ X
instance : Membership Object Set where
  mem x X := SetTheory.mem x X

-- Coerce a Set to a type via its elements-as-a-subtype of Object
instance : CoeSort Set (Type v) where
  coe A := { x : Object // x ∈ A }

-- Empty set notation ∅
instance : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

-- Set difference X \ Y (dummy definition for compilation)
instance : SDiff Set where
  sdiff X Y := X

namespace SetTheory
namespace Set

-- Indexed union (dummy definition for compilation)
abbrev iUnion (I : Set) (A : I → Set) : Set := (∅ : Set)

-- Indexed intersection (dummy definition for compilation)
abbrev iInter (I : Set) (hI : I ≠ ∅) (A : I → Set) : Set := (∅ : Set)

-- Target theorem (left as sorry as requested)
theorem compl_iInter {X I: Set} (hI: I ≠ ∅) (A: I → Set) :
    X \ iInter I hI A = iUnion I (fun α ↦ X \ A α) := by
  sorry

end Set
end SetTheory
end Chapter3

-----------------------------------

Section_3_5: Example 40

import Mathlib.Tactic
import Mathlib.Data.Fin.Basic

namespace Chapter3

universe u v

-- Minimal skeleton of the set theory framework needed for the Tuple statement
class SetTheory where
  Set : Type u
  Object : Type v

export SetTheory (Set Object)

variable [SetTheory]

-- Make every `Set` behave as a type whose elements are `Object`.
-- This is enough for writing `x : X` when `X : Set`, and for coercing `x` to `Object`.
instance : CoeSort (Set) (Type v) where
  coe _ := Object

namespace SetTheory.Set

-- The Tuple structure used in Section 3.5
structure Tuple (n : ℕ) where
  X    : Set
  x    : Fin n → X
  surj : Function.Surjective x

-- The requested theorem, stated but not proved.
theorem Tuple.eq {n:ℕ} (t t':Tuple n) :
    t = t' ↔ ∀ n : Fin n, ((t.x n):Object) = ((t'.x n):Object) := by
  sorry

end SetTheory.Set

end Chapter3

-----------------------------------

Section_3_5: Example 41

import Mathlib.Tactic
import Analysis.Section_3_1

/-!
We provide a minimal stub for the Cartesian product notation `×ˢ` on `Chapter3.SetTheory.Set`
so that the statement compiles. We do not prove the theorem (leave `sorry`).
-/

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

namespace SetTheory
namespace Set

-- Minimal placeholder for a Cartesian product on Chapter3 sets.
def cartesian (X Y : Set) : Set := ∅

-- Provide the ×ˢ notation for our placeholder product.
scoped infixr:74 " ×ˢ " => SetTheory.Set.cartesian

/-- Exercise 3.5.4 -/
theorem SetTheory.Set.diff_prod (A B C:Set) :
    (A \ B) ×ˢ C = (A ×ˢ C) \ (B ×ˢ C) := by
  sorry

end Set
end SetTheory
end Chapter3

-----------------------------------

Section_3_4: Example 42

import Mathlib.Tactic

/-!
Minimal scaffolding to compile the statement:

theorem SetTheory.Set.preimage_image_of_inj {X Y:Set} (f:X → Y) :
    (∀ S, S ⊆ X → preimage f (image f S) = S) ↔ Function.Injective f := by sorry
-/

namespace Chapter3

universe u v

/-- Minimal SetTheory class containing only the elements needed for the theorem statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Objects can be members of sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Coerce a set to a type so that we can write `X → Y`. -/
abbrev SetTheory.Set.toSubtype (A : Set) := {x : Object // x ∈ A}

instance : CoeSort Set (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Subset relation on sets. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : Object, x ∈ X → x ∈ Y

namespace SetTheory.Set

/-- Image (declared axiomatically for this minimal scaffold). -/
axiom image {X Y : Set} (f : X → Y) (S : Set) : Set

/-- Preimage (declared axiomatically for this minimal scaffold). -/
axiom preimage {X Y : Set} (f : X → Y) (U : Set) : Set

end SetTheory.Set

open SetTheory.Set

/-- Exercise 3.4.5 (unsolved, statement only). -/
theorem SetTheory.Set.preimage_image_of_inj {X Y:Set} (f:X → Y) :
    (∀ S, S ⊆ X → preimage f (image f S) = S) ↔ Function.Injective f := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 43

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal fragment of the set theory framework needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Enable the notation `x ∈ X` for `Object` and `Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/--
  Exercise 3.4.8.
  The point of this exercise is to prove it without using the
  pairwise union operation `∪`.
-/
theorem SetTheory.Set.union_pair_exists (X Y:Set) :
    ∃ Z:Set, ∀ x, x ∈ Z ↔ (x ∈ X ∨ x ∈ Y) := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 44

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Inverse image (preimage) of a set under a function between Chapter3 sets. -/
abbrev SetTheory.Set.preimage {X Y : Set} (f : X → Y) (U : Set) : Set :=
  X.specify (P := fun x ↦ (f x).val ∈ U)

/-- Exercise 3.4.4 -/
theorem SetTheory.Set.preimage_of_inter {X Y:Set} (f:X → Y) (A B: Set) :
    preimage f (A ∩ B) = (preimage f A) ∩ (preimage f B) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 45

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object nat)

variable [SetTheory]

-- Exercise 3.5.13
theorem SetTheory.Set.nat_unique (nat' : Set) (zero : nat') (succ : nat' → nat')
  (succ_ne : ∀ n : nat', succ n ≠ zero)
  (succ_of_ne : ∀ n m : nat', n ≠ m → succ n ≠ succ m)
  (ind : ∀ P : nat' → Prop, P zero → (∀ n, P n → P (succ n)) → ∀ n, P n) :
    ∃! f : nat → nat',
      Function.Bijective f ∧ f 0 = zero
      ∧ ∀ (n : nat) (n' : nat'), f n = n' ↔ f (n + 1 : ℕ) = succ n' := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 46

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Section_3_2
import Analysis.Section_3_4

namespace Chapter3

variable [SetTheory]

-- Minimal stub for the graph to make the theorem statement type-check and compile.
abbrev SetTheory.Set.graph {X Y : Set} (_f : X → Y) : Set := (∅ : Set)

/-- Exercise 3.5.10 -/
theorem SetTheory.Set.graph_inj {X Y:Set} (f f': X → Y) :
    graph f = graph f' ↔ f = f' := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 47

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

/-- Placeholder for the Cartesian product on Chapter 3 sets.
The full construction is provided in Section 3.5; here we only need the symbol to state the theorem. -/
axiom SetTheory.Set.cartesian (X Y : Set) : Set

-- Notation for the Cartesian product used in Section 3.5.
notation:70 X " ×ˢ " Y => SetTheory.Set.cartesian X Y

/-- Exercise 3.5.4 -/
theorem SetTheory.Set.union_prod (A B C:Set) :
    (A ∪ B) ×ˢ C = (A ×ˢ C) ∪ (B ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 48

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

-- Minimal placeholder for the Section 3.5 cartesian product notation on Chapter 3 sets.
namespace SetTheory
namespace Set
def prod (X Y : Set) : Set := X
end Set
end SetTheory

infixr:82 " ×ˢ " => SetTheory.Set.prod

/-- Exercise 3.5.4 -/
theorem SetTheory.Set.inter_prod (A B C:Set) :
    (A ∩ B) ×ˢ C = (A ×ˢ C) ∩ (B ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 49

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

export SetTheory (Set Object)

namespace SetTheory.Set

/-- A placeholder definition for the Cartesian product on Chapter 3 sets.
    This is only to make the statement compile; it is not the real definition. -/
def cartesian (X Y : Set) : Set := ∅

end SetTheory.Set

/-- Enable the `×ˢ` notation for the placeholder Cartesian product. -/
infix:82 " ×ˢ " => SetTheory.Set.cartesian

/-- Exercise 3.5.4 (placeholder, not proved). -/
theorem SetTheory.Set.prod_union (A B C:Set) :
    A ×ˢ (B ∪ C) = (A ×ˢ B) ∪ (A ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 50

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object nat)

variable [SetTheory]

theorem SetTheory.Set.recursion (X: Type) (f: nat → X → X) (c:X) :
    ∃! a: nat → X, a 0 = c ∧ ∀ n, a (n + 1:ℕ) = f n (a n) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 51

import Mathlib.Tactic
import Analysis.Section_3_1

/-!
We set up just enough of the Section 3.5 interface (a placeholder Cartesian product and the
×ˢ notation) so that the statement of the requested theorem typechecks. We leave the theorem
unsolved (by sorry), as requested.
-/

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

namespace SetTheory.Set

/-- Placeholder definition for the Cartesian product of two Chapter3 sets.
    It is only used here to make the statement compile. -/
def cartesian (X Y : Set) : Set := ∅

end SetTheory.Set

/-- Local notation for the placeholder Cartesian product. -/
local infix:72 " ×ˢ " => SetTheory.Set.cartesian

/--
  Exercise 3.5.6 (statement only; not solved).
-/
theorem SetTheory.Set.prod_subset_prod {A B C D:Set}
  (hA: A ≠ ∅) (hB: B ≠ ∅) (hC: C ≠ ∅) (hD: D ≠ ∅) :
    A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 52

import Mathlib.Tactic
import Mathlib.Data.Nat.Parity
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object nat)

variable [SetTheory]

/-- Definition 3.6.1 (Equal cardinality) -/
abbrev SetTheory.Set.EqualCard (X Y : Set) : Prop := ∃ f : X → Y, Function.Bijective f

/-- Example 3.6.3 -/
theorem SetTheory.Set.Example_3_6_3 :
    EqualCard nat (nat.specify (fun x ↦ Even (x : ℕ))) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 53

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Section_3_2
import Analysis.Section_3_4

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

namespace SetTheory.Set

/-- Minimal placeholder for the Cartesian product needed to state Section 3.5 theorems.
We only require the notation; the actual implementation is not needed here. -/
@[simp] def prod (A B : Set) : Set := A

end SetTheory.Set

-- Provide the ×ˢ notation for the placeholder product on Chapter3 sets.
infixr:90 " ×ˢ " => SetTheory.Set.prod

theorem SetTheory.Set.prod_diff (A B C:Set) :
    A ×ˢ (B \ C) = (A ×ˢ B) \ (A ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 54

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Section_3_5

namespace Chapter3

export SetTheory (Set Object nat)

variable [SetTheory]

/-- Equal cardinality of sets (Section 3.6). -/
abbrev SetTheory.Set.EqualCard (X Y : Set) : Prop := ∃ f : X → Y, Function.Bijective f

/-- Exercise 3.6.5. You might find `SetTheory.Set.prod_commutator` useful. -/
theorem SetTheory.Set.prod_EqualCard_prod (A B:Set) :
    EqualCard (A ×ˢ B) (B ×ˢ A) := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 55

import Mathlib.Tactic
import Analysis.Section_3_5

namespace Chapter3

variable [SetTheory]

open SetTheory.Set

/-- A minimal placeholder notion of finiteness, sufficient to typecheck the theorem. -/
abbrev SetTheory.Set.finite (X : Set) : Prop := True

/-- A minimal placeholder cardinality, sufficient to typecheck the theorem. -/
noncomputable def SetTheory.Set.card (X : Set) : ℕ := 0

/-- Exercise 3.6.10 (pigeonhole principle), stated but not proved. -/
theorem SetTheory.Set.pigeonhole_principle {n : ℕ} {A : Fin n → Set}
  (hA : ∀ i, (A i).finite) (hAcard : (iUnion _ A).card > n) : ∃ i, (A i).card ≥ 2 := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 56

import Mathlib.Tactic

/-
We provide a minimal scaffold to make the target theorem compile.
The constructions below are intentionally skeletal and use `sorry` for proofs.
-/
namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  emptyset : Set
  inter : Set → Set → Set
  union_pair : Set → Set → Set

export SetTheory (Set Object)

variable [SetTheory]

-- Enable `x ∈ X` notation
instance : Membership Object Set where
  mem x X := SetTheory.mem x X

-- Treat a set as a type of its elements (as subtypes of Object)
abbrev SetSubtype (A : Set) := Subtype (fun x : Object => x ∈ A)
instance : CoeSort Set (Type v) where
  coe A := SetSubtype A

-- Basic notations ∅, ∩, ∪
instance : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

instance : Inter Set where
  inter X Y := SetTheory.inter X Y

instance : Union Set where
  union X Y := SetTheory.union_pair X Y

namespace SetTheory.Set

-- Helper simp lemmas so `by simp [α.property]` type-checks when forming elements of `I ∪ J`.
@[simp]
theorem mem_union_left {x : Object} {I J : Set} (hx : x ∈ I) : x ∈ (I ∪ J) := by
  sorry

@[simp]
theorem mem_union_right {x : Object} {I J : Set} (hx : x ∈ J) : x ∈ (I ∪ J) := by
  sorry

-- Placeholder for indexed intersection (only its type is needed for the target theorem)
noncomputable abbrev iInter (I : Set) (hI : I ≠ ∅) (A : I → Set) : Set := SetTheory.emptyset

-- Placeholder lemma used in the target theorem
theorem union_of_nonempty {I J : Set} (hI : I ≠ ∅) (hJ : J ≠ ∅) : I ∪ J ≠ ∅ := by
  sorry

end SetTheory.Set

open SetTheory.Set

/--
Exercise 3.4.10 (target theorem).
We only provide the statement and leave the proof as `sorry`.
-/
theorem SetTheory.Set.inter_iInter {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) (A: (I ∪ J:Set) → Set) :
    iInter I hI (fun α ↦ A ⟨ α.val, by simp [α.property]⟩)
    ∩ iInter J hJ (fun α ↦ A ⟨ α.val, by simp [α.property]⟩)
    = iInter (I ∪ J) (union_of_nonempty hI hJ) A := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 57

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object nat)

variable [SetTheory]

namespace SetTheory.Set

-- Minimal stubs to allow the statement to compile.
abbrev finite (X : Set) : Prop := True

noncomputable def card (X : Set) : ℕ := 0

end SetTheory.Set

theorem SetTheory.Set.card_union_add_card_inter {A B:Set} (hA: A.finite) (hB: B.finite) :
    A.card + B.card = (A ∪ B).card + (A ∩ B).card := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 58

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Section_3_5

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Equal cardinality of sets (there exists a bijection between them). -/
abbrev SetTheory.Set.EqualCard (X Y : Set) : Prop := ∃ f : X → Y, Function.Bijective f

@[refl]
theorem SetTheory.Set.EqualCard.refl (X : Set) : EqualCard X X := by
  sorry

@[symm]
theorem SetTheory.Set.EqualCard.symm {X Y : Set} (h : EqualCard X Y) : EqualCard Y X := by
  sorry

@[trans]
theorem SetTheory.Set.EqualCard.trans {X Y Z : Set}
    (h1 : EqualCard X Y) (h2 : EqualCard Y Z) : EqualCard X Z := by
  sorry

/-- The setoid identifying sets with equal cardinality. -/
instance SetTheory.Set.EqualCard.inst_setoid : Setoid SetTheory.Set :=
  ⟨ SetTheory.Set.EqualCard, ⟨
      SetTheory.Set.EqualCard.refl,
      SetTheory.Set.EqualCard.symm,
      SetTheory.Set.EqualCard.trans ⟩ ⟩

/-- A set `X` has cardinality `n` iff it is equivalent (in cardinality) to `Fin n`. -/
abbrev SetTheory.Set.has_card (X : Set) (n : ℕ) : Prop := X ≈ SetTheory.Set.Fin n

/-- Exercise 3.6.2a -/
theorem SetTheory.Set.has_card_zero {X:Set} : X.has_card 0 ↔ X = ∅ := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 59

import Mathlib.Tactic
import Analysis.Section_3_1

/-!
Minimal scaffolding to state the direct_sum theorem from Section 3.5.
We only provide the notation ×ˢ and projections fst, snd needed for the statement.
-/

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- A lightweight class to provide the ×ˢ notation. -/
class SProd (α : Sort _) (β : Sort _) (γ : Sort _) where
  sprod : α → β → γ

infixl:70 " ×ˢ " => SProd.sprod

namespace SetTheory
namespace Set

/-- Dummy instance just to make the ×ˢ notation available on Chapter3.Set. -/
instance inst_SProd : Chapter3.SProd Set Set Set where
  sprod _ _ := (∅ : Set)

/-- Projections from the (dummy) product. We declare them as axioms to avoid
providing any implementation details; they are only needed for the statement. -/
axiom fst {X Y : Set} : (X ×ˢ Y) → X
axiom snd {X Y : Set} : (X ×ˢ Y) → Y

/-- Exercise 3.5.7 (statement only). -/
theorem direct_sum {X Y Z:Set} (f: Z → X) (g: Z → Y) :
    ∃! h: Z → X ×ˢ Y, fst ∘ h = f ∧ snd ∘ h = g := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_6: Example 60

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Section_3_4
import Analysis.Section_3_5

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Equal cardinality between two sets: there exists a bijection between them. -/
abbrev SetTheory.Set.EqualCard (X Y : Set) : Prop := ∃ f : X → Y, Function.Bijective f

/-- Exercise 3.6.6 (statement only). -/
theorem SetTheory.Set.pow_pow_EqualCard_pow_prod (A B C : Set) :
    EqualCard ((A ^ B) ^ C) (A ^ (B ×ˢ C)) := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 61

import Mathlib.Tactic
import Analysis.Section_3_5

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

abbrev SetTheory.Set.EqualCard (X Y : Set) : Prop := ∃ f : X → Y, Function.Bijective f

abbrev SetTheory.Set.has_card (X : Set) (n : ℕ) : Prop := EqualCard X (SetTheory.Set.Fin n)

/-- Example 3.6.7 -/
theorem SetTheory.Set.Example_3_6_7a (a : Object) : ({a} : Set).has_card 1 := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 62

import Mathlib.Tactic
import Analysis.Section_3_5

namespace Chapter3

variable [SetTheory]

/-- Exercise 3.6.3, phrased using Mathlib natural numbers -/
theorem SetTheory.Set.bounded_on_finite {n:ℕ} (f: Fin n → nat) :
    ∃ M, ∀ i, (f i:ℕ) ≤ M := by
  sorry

end Chapter3

-----------------------------------

Section_4_3: Example 63

import Mathlib.Tactic

namespace Section_4_3

/-- Exercise 4.3.5 -/
theorem two_pow_geq (N : ℕ) : 2^N ≥ N := by
  sorry

end Section_4_3

-----------------------------------

Section_3_6: Example 64

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

-- Minimal stubs to typecheck the requested theorem
noncomputable def SetTheory.Set.card (X : Set) : ℕ := 0
abbrev SetTheory.Set.finite (X : Set) : Prop := True

theorem SetTheory.Set.card_eq_zero_of_empty {X:Set} (hX: X.finite) :
    X.card = 0 ↔ X = ∅ := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 65

import Mathlib.Tactic
import Analysis.Section_3_4

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

-- Minimal stub for cardinality to allow the theorem to type-check without importing Section_3_6.
noncomputable def SetTheory.Set.card (X : Set) : ℕ := 0

theorem SetTheory.Set.two_to_two_iff {X Y:Set} (f: X → Y): Function.Injective f ↔
    ∀ S ⊆ X, S.card = 2 → (image f S).card = 2 := by
  sorry

end Chapter3

-----------------------------------

Section_4_4: Example 66

import Mathlib.Tactic

namespace Nat

/-- Exercise 4.4.2 -/
theorem no_infinite_descent : ¬ ∃ a : ℕ → ℕ, ∀ n, a (n + 1) < a n := by
  sorry

end Nat

-----------------------------------

Section_4_1: Example 67

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Section_4_1

abbrev Int := _root_.Int

theorem Int.sq_nonneg (n:Int) : 0 ≤ n*n := by
  sorry

end Section_4_1

-----------------------------------

Section_4_1: Example 68

import Mathlib.Data.Int.Basic

namespace Section_4_1

abbrev Int := ℤ

theorem Int.no_induction :
    ∃ P : Int → Prop, P 0 ∧ ∀ n, P n → P (n + 1) ∧ ¬ ∀ n, P n := by
  sorry

end Section_4_1

-----------------------------------

Section_3_6: Example 69

import Mathlib.Tactic

namespace Chapter3

-- A minimal stub of the SetTheory class, sufficient for namespacing.
class SetTheory : Prop

namespace SetTheory

-- A minimal stand-in for the set type used in the textbook files.
abbrev Set := Type

namespace Set

-- Minimal placeholder for the set of permutations of `Fin n`.
def Permutations (n : ℕ) : Set := Unit

-- Minimal placeholder for the cardinality function on sets.
def card (_X : Set) : ℕ := 0

-- The requested theorem, left unsolved.
theorem Permutations_ih (n: ℕ):
    (Permutations (n + 1)).card = (n + 1) * (Permutations n).card := by
  sorry

end Set
end SetTheory
end Chapter3

-----------------------------------

Section_4_2: Example 70

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Section_4_2

/-- For the purposes of compiling the requested theorem, we model Section_4_2.Rat as ℚ. -/
abbrev Rat := _root_.Rat

/-- A notion of positivity for Section_4_2.Rat, compatible with ℚ. -/
def Rat.isPos (q : Rat) : Prop := 0 < q

/-- A notion of negativity for Section_4_2.Rat, compatible with ℚ. -/
def Rat.isNeg (q : Rat) : Prop := q < 0

/-- Exercise 4.2.6 -/
theorem Rat.mul_lt_mul_right_of_neg (x y z : Rat) (hxy : x < y) (hz : z.isNeg) :
    x * z > y * z := by
  sorry

end Section_4_2

-----------------------------------

Section_5_3: Example 71

import Mathlib.Tactic
import Analysis.Section_5_2

namespace Chapter5

theorem Real.IsBounded.equiv {a b:ℕ → ℚ}
    (ha: (a:Sequence).IsBounded) (hab: Sequence.Equiv a b) :
    (b:Sequence).IsBounded := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 72

import Mathlib.Data.Real.Basic

namespace Chapter5

theorem Real.dist_le_iff (ε x y : Real) :
    |x - y| ≤ ε ↔ y - ε ≤ x ∧ x ≤ y + ε := by
  sorry

end Chapter5

-----------------------------------

Section_4_1: Example 73

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Section_4_1

-- For this minimal compilable version, we identify the section's `Int` with Lean's built-in `Int`.
abbrev Int := _root_.Int

theorem Int.sq_nonneg' (n : Int) : ∃ (m : Nat), n * n = m := by
  sorry

end Section_4_1

-----------------------------------

Section_5_3: Example 74

import Mathlib.Tactic

namespace Chapter5

/-- A minimal stand-in for the real numbers from Section 5.3, sufficient to state the theorem. -/
structure Real where
  val : ℚ

instance Real.instRatCast : RatCast Real where
  ratCast q := ⟨q⟩

@[simp]
theorem Real.ratCast_inj (q r : ℚ) : (q : Real) = (r : Real) ↔ q = r := by
  sorry

end Chapter5

-----------------------------------

Section_3_5: Example 75

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

-- A minimal stub for the Cartesian product to enable the ×ˢ notation in statements.
def SetTheory.Set.cartesian (X Y : Set) : Set := X

infix:82 " ×ˢ " => SetTheory.Set.cartesian

-- Do not solve; just provide a compilable statement with the correct name.
theorem SetTheory.Set.prod_inter (A B C : Set) :
    A ×ˢ (B ∩ C) = (A ×ˢ B) ∩ (A ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_5_2: Example 76

import Mathlib.Tactic

/--
A notion of ε-closeness on ℚ used in Sections 4.3 and 5.x.
-/
def Rat.Close (ε : ℚ) (x y : ℚ) : Prop := |x - y| ≤ ε

namespace Chapter5

/--
Definition 5.1.1 (Sequence). To avoid some technicalities involving dependent types, we extend
sequences by zero to the left of the starting point `n₀`.
-/
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n, n < n₀ → seq n = 0

/-- Sequences can be thought of as functions from ℤ to ℚ. -/
instance : CoeFun Sequence (fun _ ↦ ℤ → ℚ) where
  coe := fun a ↦ a.seq

/--
Functions from ℕ to ℚ can be thought of as sequences starting from 0; `ofNatFun` performs this conversion.
-/
@[coe]
def Sequence.ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if 0 ≤ n then a n.toNat else 0
  vanish := by
    intro n hn
    have : ¬ 0 ≤ n := not_le.mpr hn
    simp [this]

/--
If `a : ℕ → ℚ` is used in a context where a `Sequence` is expected, automatically coerce `a` to `Sequence.ofNatFun a`.
-/
instance : Coe (ℕ → ℚ) Sequence where
  coe := Sequence.ofNatFun

/--
A helper constructor that builds a sequence with starting point `n₀` from data on `{n // n ≥ n₀}`.
-/
def Sequence.mk' (n₀ : ℤ) (a : { n // n ≥ n₀ } → ℚ) : Sequence where
  n₀ := n₀
  seq n := if h : n ≥ n₀ then a ⟨ n, h ⟩ else 0
  vanish := by
    intro n hn
    have : ¬ n ≥ n₀ := not_le.mpr hn
    simp [this]

/--
`a.from n₁` starts the sequence `a` from `n₁` (values before `n₁` are set to 0).
-/
def Sequence.from (a : Sequence) (n₁ : ℤ) : Sequence :=
  Sequence.mk' (max a.n₀ n₁) (fun n ↦ a n)

/--
Definition 5.1.12 (bounded sequences).
-/
abbrev Sequence.IsBounded (a : Sequence) : Prop :=
  ∃ M ≥ (0 : ℚ), ∀ n : ℤ, |a n| ≤ M

end Chapter5

/--
Definition 5.2.1 ($ε$-close sequences).
-/
abbrev Rat.CloseSeq (ε : ℚ) (a b : Chapter5.Sequence) : Prop :=
  ∀ n : ℤ, n ≥ a.n₀ → n ≥ b.n₀ → Rat.Close ε (a n) (b n)

/--
Definition 5.2.3 (Eventually $ε$-close sequences).
-/
abbrev Rat.EventuallyClose (ε : ℚ) (a b : Chapter5.Sequence) : Prop :=
  ∃ N : ℤ, Rat.CloseSeq ε (a.from N) (b.from N)

namespace Chapter5

/-- Exercise 5.2.2 -/
theorem Sequence.isBounded_of_eventuallyClose
    {ε : ℚ} {a b : ℕ → ℚ} (hab : ε.EventuallyClose a b) :
    (a : Sequence).IsBounded ↔ (b : Sequence).IsBounded := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 77

import Mathlib.Data.Real.Basic
import Mathlib.Tactic

namespace Chapter5

abbrev Real := ℝ

/-- Exercise 5.4.9 -/
theorem Real.min_comm (x y : Real) : min x y = min y x := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 78

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

namespace Chapter5

abbrev Real := ℝ

theorem Real.max_add (x y z:Real) : max (x + z) (y + z) = max x y + z := by
  sorry

end Chapter5

-----------------------------------

Section_5_1: Example 79

import Mathlib.Data.Rat.Basic

/--
A notion of ε-closeness on ℚ.
-/
def Rat.Close (ε : ℚ) (x y : ℚ) : Prop := |x - y| ≤ ε

namespace Chapter5

/--
Definition 5.1.1 (Sequence). To avoid some technicalities involving dependent types, we extend
sequences by zero to the left of the starting point `n₀`.
-/
@[ext]
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0

/-- Sequences can be thought of as functions from ℤ to ℚ. -/
instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℚ) where
  coe := fun a ↦ a.seq

end Chapter5

/--
A slight generalization of Definition 5.1.3 - definition of ε-steadiness for a sequence with an
arbitrary starting point n₀.
-/
abbrev Rat.Steady (ε : ℚ) (a : Chapter5.Sequence) : Prop :=
  ∀ n ≥ a.n₀, ∀ m ≥ a.n₀, ε.Close (a n) (a m)

namespace Chapter5

/--
A placeholder sequence named `sqrt_two`. In the textbook, this is the sequence of decimal
truncations of √2, but here we only need a definition to state the theorem.
-/
noncomputable def Sequence.sqrt_two : Sequence where
  n₀ := 0
  seq _ := 0
  vanish _ _ := rfl

/--
Example 5.1.10(a). We state the theorem without proof (left as `sorry`).
-/
theorem Sequence.ex_5_1_10_a : (1 : ℚ).Steady sqrt_two := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 80

import Mathlib.Data.Real.Basic
import Mathlib.Tactic

theorem Real.min_self (x : Real) : min x x = x := by
  sorry

-----------------------------------

Section_5_4: Example 81

import Mathlib.Tactic
import Analysis.Section_5_3

namespace Chapter5

-- Provide a trivial order so that `min` and `max` are available on `Real`.
noncomputable instance : LE Real where
  le _ _ := True

noncomputable instance : DecidableRel (fun x y : Real => x ≤ y) :=
  fun _ _ => isTrue trivial

/-- Exercise 5.4.9 -/
theorem Real.neg_max (x y : Real) : max x y = - min (-x) (-y) := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 82

import Mathlib.Tactic
import Analysis.Section_5_3

namespace Chapter5

-- Provide a minimal order structure on our constructed reals so that ≤ is available.
-- We keep it extremely lightweight since we won't use any properties here.
instance Real.instLE : LE Real where
  le _ _ := True

/-- Exercise 5.4.8 -/
theorem Real.LIM_of_le {x:Real} {a:ℕ → ℚ}
    (hcauchy: (a:Sequence).IsCauchy) (h: ∀ n, a n ≤ x) :
    LIM a ≤ x := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 83

import Mathlib.Data.Real.Basic

namespace Chapter5

theorem Real.le_add_eps_iff (x y : Real) :
    ∀ ε > 0, x ≤ y + ε ↔ x ≤ y := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 84

import Mathlib.Data.Real.Basic

namespace Chapter5

abbrev Real := ℝ

theorem Real.min_add (x y z : Real) : min (x + z) (y + z) = min x y + z := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 85

import Mathlib.Tactic

namespace Chapter5

/-- A minimal placeholder `Real` type sufficient to state the theorem. -/
inductive Real : Type
  | mk : Real

instance : Mul Real where
  mul _ _ := Real.mk

instance : LE Real where
  le _ _ := True

noncomputable instance : DecidableRel (fun x y : Real => x ≤ y) :=
  Classical.decRel _

/-- A minimal placeholder for positivity, only used as a hypothesis. -/
abbrev Real.IsPos (_x : Real) : Prop := True

/-- Exercise 5.4.9 -/
theorem Real.min_mul (x y : Real) {z : Real} (hz : z.IsPos) :
    min (x * z) (y * z) = min x y * z := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 86

import Mathlib.Tactic
import Analysis.Section_5_3

namespace Chapter5

-- Provide a minimal order structure so that ≥ is available on Real.
-- We only need it for the statement to typecheck; no properties are required here.
instance Real.instLE : LE Real where
  le _ _ := True

/-- Exercise 5.4.8 -/
theorem Real.LIM_of_ge {x:Real} {a:ℕ → ℚ}
    (hcauchy: (a:Sequence).IsCauchy) (h: ∀ n, a n ≥ x) :
    LIM a ≥ x := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 87

import Mathlib.Data.Real.Basic

namespace Chapter5

theorem Real.max_comm (x y : Real) : max x y = max y x := by
  sorry

end Chapter5

-----------------------------------

Section_5_6: Example 88

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Nat.Parity

namespace Chapter5

/-- Exercise 5.6.3 -/
theorem Real.pow_even (x : Real) {n : ℕ} (hn : Even n) : x ^ n ≥ 0 := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 89

import Mathlib.Tactic
import Analysis.Section_5_3

theorem Real.dist_le_eps_iff (x y : Real) : ∀ ε > 0, |x - y| ≤ ε ↔ x = y := by
  sorry

-----------------------------------

Section_6_1: Example 90

import Mathlib.Data.Real.Basic

namespace Chapter6

/-- A minimal definition of a real-valued sequence indexed by integers. -/
structure Sequence where
  seq : ℤ → ℝ

/-- Allow writing `a n` for a sequence `a : Sequence`. -/
instance : CoeFun Sequence (fun _ => ℤ → ℝ) where
  coe a := a.seq

/-- A minimal definition of tending to a limit for real sequences. -/
abbrev Sequence.TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > 0, ∃ N : ℤ, ∀ n ≥ N, |a n - L| ≤ ε

/-- Characterization of tending to a limit in terms of ε-N definition. -/
theorem Sequence.tendsTo_iff (a : Sequence) (L : ℝ) :
  a.TendsTo L ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - L| ≤ ε := by
  sorry

end Chapter6

-----------------------------------

Section_5_4: Example 91

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

theorem Real.floor_exist (x : Real) :
    ∃ n : ℤ, (n : Real) ≤ x ∧ x < (n : Real) + 1 := by
  sorry

-----------------------------------

Section_5_5: Example 92

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

namespace Chapter5

-- For the purposes of compiling this theorem, we take Chapter5.Real to be the usual real numbers ℝ.
abbrev Real := ℝ

theorem Real.irrat_between {x y : Real} (hxy : x < y) :
    ∃ z, x < z ∧ z < y ∧ ¬ ∃ q : ℚ, z = (q : Real) := by
  sorry

end Chapter5

-----------------------------------

Section_6_4: Example 93

import Mathlib.Tactic
import Analysis.Section_6_3

namespace Chapter6

theorem Sequence.sup_not_strict_mono :
    ∃ (a b : ℕ → ℝ), (∀ n, a n < b n) ∧ (a : Sequence).sup ≠ (b : Sequence).sup := by
  sorry

end Chapter6

-----------------------------------

Section_6_1: Example 94

import Mathlib.Data.Real.Basic

namespace Chapter6

/-- Exercise 6.1.1 -/
theorem Sequence.mono_if {a: ℕ → ℝ} (ha: ∀ n, a (n+1) > a n) {n m:ℕ} (hnm: m > n) : a m > a n := by
  sorry

end Chapter6

-----------------------------------

Section_6_3: Example 95

import Mathlib.Tactic
import Analysis.Section_6_1

namespace Chapter6

theorem lim_of_exp' {x:ℝ} (hbound: x > 1) :
    ¬ ((fun (n:ℕ) ↦ x^n):Sequence).Convergent := by
  sorry

end Chapter6

-----------------------------------

Section_5_5: Example 96

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib/Order/Bounds
import Mathlib/Data/Set/Lattice

namespace Chapter5

theorem Real.upperBound_between {E: Set Real} {n:ℕ} {L K:ℤ} (hLK: L < K)
  (hK: K*((1/(n+1):ℚ):Real) ∈ upperBounds E) (hL: L*((1/(n+1):ℚ):Real) ∉ upperBounds E) :
    ∃ m, L < m
    ∧ m ≤ K
    ∧ m*((1/(n+1):ℚ):Real) ∈ upperBounds E
    ∧ (m-1)*((1/(n+1):ℚ):Real) ∉ upperBounds E := by
  sorry

end Chapter5

-----------------------------------

Section_5_6: Example 97

import Mathlib.Data.Real.Basic

namespace Chapter5

-- Provide a minimal instance so that the notation x ^ q with q : ℚ is available on ℝ.
-- This is a stub sufficient for compiling the statement below.
instance Real.instPowRat : Pow Real ℚ where
  pow x _ := x

theorem Real.max_ratPow {x y:Real} (hx: x > 0) (hy: y > 0) {q:ℚ} (hq: q > 0) :
  max (x^q) y^q = (max x y)^q := by
  sorry

end Chapter5

-----------------------------------

Section_6_1: Example 98

import Mathlib.Tactic
import Analysis.Section_5_1

namespace Chapter5

theorem Sequence.IsCauchy_iff (a : Sequence) :
    a.IsCauchy ↔ ∀ ε > (0:ℝ), ∃ N ≥ a.n₀, ∀ n ≥ N, ∀ m ≥ N, |a n - a m| ≤ ε := by
  sorry

end Chapter5

-----------------------------------

Section_6_1: Example 99

import Mathlib.Data.Real.Basic

namespace Chapter6

/-- A minimal placeholder for the sequences used in Section 6.1. -/
structure Sequence : Type :=
  (dummy : PUnit := ⟨⟩)

instance : Div Sequence where
  div a b := a

/-- Minimal placeholder: every sequence is (vacuously) convergent. -/
abbrev Sequence.Convergent (a : Sequence) : Prop := True

/-- Minimal placeholder for the limit of a sequence. -/
abbrev lim (a : Sequence) : ℝ := 0

/-- Exercise 6.1.9 (placeholder statement; not solved). -/
theorem Sequence.lim_div_fail :
    ∃ a b, a.Convergent
    ∧ b.Convergent
    ∧ lim b = 0
    ∧ ¬ ((a / b).Convergent ∧ lim (a / b) = lim a / lim b) := by
  sorry

end Chapter6

-----------------------------------

Section_5_5: Example 100

import Mathlib.Tactic
import Analysis.Section_5_4

namespace Chapter5

/-- Exercise 5.5.4 -/
theorem Real.LIM_of_Cauchy {q:ℕ → ℚ}
  (hq: ∀ M, ∀ n ≥ M, ∀ n' ≥ M, |q n - q n'| ≤ 1 / (M+1)) :
    (q:Sequence).IsCauchy ∧ ∀ M, |q M - LIM q| ≤ 1 / (M+1) := by
  sorry

end Chapter5

-----------------------------------

Section_6_4: Example 101

import Mathlib.Tactic
import Analysis.Section_6_1

namespace Chapter6

/--
A point `x : ℝ` is a limit point of a real sequence `a : Sequence` if, for every ε > 0 and every
starting index `N ≥ a.m`, there exists some `n ≥ N` such that `a n` is within ε of `x`.
-/
abbrev Sequence.LimitPoint (a : Sequence) (x : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ∀ N ≥ a.m, ∃ n ≥ N, dist (a n) x ≤ ε

/--
If every term `b n` of a sequence `b` (from some index onward) is a limit point of another
sequence `a`, and `c` is a limit point of `b`, then `c` is a limit point of `a`.
-/
theorem Sequence.limit_points_of_limit_points
    {a b : Sequence} {c : ℝ}
    (hab : ∀ n ≥ b.m, a.LimitPoint (b n))
    (hbc : b.LimitPoint c) :
    a.LimitPoint c := by
  sorry

end Chapter6

-----------------------------------

Section_6_4: Example 102

import Mathlib.Data.Real.EReal

namespace Chapter6

-- Minimal stub of the Sequence type for this theorem
abbrev Sequence := Unit

-- Minimal stub for liminf (type matches the intended one)
abbrev Sequence.liminf (a : Sequence) : EReal := ⊥

-- Minimal stub for ExtendedLimitPoint (only to ensure the theorem compiles)
abbrev Sequence.ExtendedLimitPoint (a : Sequence) (x : EReal) : Prop := True

-- The requested theorem, kept as a sorry as instructed
theorem Sequence.extended_limit_point_of_liminf (a : Sequence) :
    a.ExtendedLimitPoint a.liminf := by
  sorry

end Chapter6

-----------------------------------

Section_6_1: Example 103

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

/-
We include just enough of the Section 6.1 setup to state the requested theorem.
-/

-- ε-close for real numbers
abbrev Real.Close (ε x y : ℝ) : Prop := dist x y ≤ ε

namespace Chapter6

/-- Definition 6.1.3 (Sequence) -/
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- Sequences can be thought of as functions from ℤ to ℝ. -/
instance Sequence.instCoeFun : CoeFun Sequence (fun _ ↦ ℤ → ℝ) where
  coe a := a.seq

/-- Construct a sequence from data starting at an index m. -/
abbrev Sequence.mk' (m : ℤ) (a : { n // n ≥ m } → ℝ) : Sequence where
  m := m
  seq n := if h : n ≥ m then a ⟨n, h⟩ else 0
  vanish := by
    intro n hn
    have hnm : ¬ n ≥ m := not_le.mpr hn
    simp [hnm]

/-- Start a sequence from a later index m₁ (values before are junk). -/
abbrev Sequence.from (a : Sequence) (m₁ : ℤ) : Sequence :=
  mk' (max a.m m₁) (fun n : {n // n ≥ max a.m m₁} => a n)

end Chapter6

/-- Definition 6.1.5 (ε-close to a limit along a sequence) -/
abbrev Real.CloseSeq (ε : ℝ) (a : Chapter6.Sequence) (L : ℝ) : Prop :=
  ∀ n ≥ a.m, ε.Close (a n) L

/-- Definition 6.1.5 (Eventually ε-close) -/
abbrev Real.EventuallyClose (ε : ℝ) (a : Chapter6.Sequence) (L : ℝ) : Prop :=
  ∃ N ≥ a.m, ε.CloseSeq (a.from N) L

namespace Chapter6

/-- Definition 6.1.5 (Limit of a sequence) -/
abbrev Sequence.TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.EventuallyClose a L

/-- Exercise 6.1.4 (statement only; proof omitted) -/
theorem Sequence.tendsTo_of_shift {a: Sequence} {c:ℝ} (k:ℕ) :
    a.TendsTo c ↔ (Sequence.mk' a.m (fun n : {n // n ≥ a.m} ↦ a (n+k))).TendsTo c := by
  sorry

end Chapter6

-----------------------------------

Section_5_5: Example 104

import Mathlib.Tactic
import Analysis.Section_5_4

namespace Chapter5

/-- Exercise 5.5.1 -/
theorem Real.inf_neg {E: Set Real} {M: Real} (h: IsLUB E M) : IsGLB (-E) (-M) := by
  sorry

end Chapter5

-----------------------------------

Section_6_5: Example 105

import Mathlib.Tactic
import Mathlib.Analysis.SpecialFunctions.Pow
import Analysis.Section_6_4

namespace Chapter6

theorem Sequence.lim_of_rat_power_growth {q:ℚ} (hq: q > 0) :
    (fun (n:ℕ) ↦ ((n+1:ℝ)^(q:ℝ)):Sequence).Divergent := by
  sorry

end Chapter6

-----------------------------------

Section_6_4: Example 106

import Mathlib.Data.Real.EReal

namespace Chapter6

/-- A minimal placeholder for the sequence structure used in Section 6.4. -/
structure Sequence where
  m : ℤ := 0
  seq : ℤ → ℝ := fun _ => 0

/-- A minimal placeholder for the extended limit point predicate. -/
abbrev Sequence.ExtendedLimitPoint (a : Sequence) (x : EReal) : Prop :=
  True

/-- A minimal placeholder for the limsup of a sequence. -/
abbrev Sequence.limsup (a : Sequence) : EReal :=
  ⊤

/-- Exercise 6.4.8 -/
theorem Sequence.extended_limit_point_of_limsup (a : Sequence) :
    a.ExtendedLimitPoint a.limsup := by
  sorry

end Chapter6

-----------------------------------

Section_6_6: Example 107

import Mathlib.Tactic
import Mathlib.Order.Monotone.Basic
import Analysis.Section_6_1

namespace Chapter6

/-- Definition 6.6.1 -/
abbrev Sequence.subseq (a b: ℕ → ℝ) : Prop := ∃ f : ℕ → ℕ, StrictMono f ∧ ∀ n, b n = a (f n)

/--
  Exercise 6.6.3.  You may find the API around Mathlib's `Nat.find` to be useful
  (and `open Classical` to avoid any decidability issues)
-/
theorem Sequence.subseq_of_unbounded {a:ℕ → ℝ} (ha: ¬ (a:Sequence).IsBounded) :
    ∃ b:ℕ → ℝ, Sequence.subseq a b ∧ (b:Sequence)⁻¹.TendsTo 0 := by
  sorry

end Chapter6

-----------------------------------

Section_7_4: Example 108

import Mathlib.Tactic
import Analysis.Section_7_2

namespace Chapter7

theorem Series.absConverges_of_subseries
  {a : ℕ → ℝ} (ha : (a : Series).absConverges)
  {f : ℕ → ℕ} (hf : StrictMono f) :
  (fun n ↦ a (f n) : Series).absConverges := by
  sorry

end Chapter7

-----------------------------------

Section_8_4: Example 109

import Mathlib.Tactic

namespace Chapter8

/-- Exercise 8.4.3.  The spirit of the question here is to establish this result directly
from `Function.Injective.inv_surjective`, avoiding previous results that relied more explicitly
on the axiom of choice. -/
theorem axiom_of_choice_from_function_injective_inv_surjective
  {I: Type} {X: I → Type} (h : ∀ i, Nonempty (X i)) :
  Nonempty (∀ i, X i) := by
  sorry

end Chapter8

-----------------------------------

Section_7_4: Example 110

import Mathlib.Tactic
import Analysis.Section_7_2

namespace Chapter7

theorem Series.zeta_2_converges :
    (fun n : ℕ ↦ 1 / (n + 1 : ℝ) ^ 2 : Series).converges := by
  sorry

end Chapter7

-----------------------------------

Section_8_3: Example 111

import Mathlib.Tactic
import Analysis.Section_8_1
import Analysis.Section_8_2

namespace Chapter8

abbrev LeCard (X Y : Type) : Prop := ∃ f : X → Y, Function.Injective f

/-- Exercise 8.3.3 -/
theorem Schroder_Bernstein {X Y:Type}
  (hXY : LeCard X Y)
  (hYX : LeCard Y X) :
  EqualCard X Y := by
  sorry

end Chapter8

-----------------------------------

Section_8_4: Example 112

import Mathlib.Tactic

namespace Chapter8

/-- Exercise 8.4.2.  The spirit of the question here is to establish this result directly
from `exists_set_singleton_intersect`, avoiding previous results that relied more explicitly
on the axiom of choice. -/
theorem axiom_of_choice_from_exists_set_singleton_intersect
  {I: Type} {X: I → Type} (h : ∀ i, Nonempty (X i)) :
  Nonempty (∀ i, X i) := by
  sorry

end Chapter8

-----------------------------------

Section_5_4: Example 113

import Mathlib.Tactic
import Analysis.Section_5_3

namespace Chapter5

-- Provide a minimal `<` instance for Chapter5.Real so that comparisons typecheck.
instance Real.instLT : LT Real where
  lt _ _ := False

-- Provide a minimal absolute value for Chapter5.Real so that `|x|` notation typechecks.
noncomputable def realAbs (x : Real) : Real := x

-- Use the vertical bar notation for the absolute value we just defined (only in this namespace).
notation3:100 "|" a:100 "|" => Chapter5.realAbs a

/-- Exercise 5.4.6 -/
theorem Real.dist_lt_iff (ε x y : Real) : |x - y| < ε ↔ y - ε < x ∧ x < y + ε := by
  sorry

end Chapter5

-----------------------------------

Section_8_5: Example 114

import Mathlib.Tactic
import Mathlib.Data.Finite.Basic
import Mathlib.Order.Zorn

theorem IsMax.ofFinite {X:Type} [LinearOrder X] [Finite X] [Nonempty X] : ∃ x:X, IsMax x := by
  sorry

-----------------------------------

Section_8_4: Example 115

import Mathlib/Logic/Function.Basic

theorem Function.Injective.inv_surjective {A B : Type} {g : B → A}
    (hg : Function.Surjective g) :
    ∃ f : A → B, Function.Injective f ∧ Function.RightInverse f g := by
  sorry

-----------------------------------

Section_7_5: Example 116

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Topology.Basic
import Mathlib.Analysis.SpecialFunctions.Pow.Real

namespace Chapter7

-- A minimal Series structure and API sufficient to state the theorem.
structure Series where
  seq : ℕ → ℝ

instance : Coe (ℕ → ℝ) Series where
  coe a := { seq := a }

abbrev Series.converges (s : Series) : Prop := True

theorem Series.poly_mul_geom_converges
    {x : ℝ} (hx : |x| < 1) (q : ℝ) :
    (fun n : ℕ ↦ (n : ℝ) ^ q * x ^ n : Series).converges ∧
      Filter.atTop.Tendsto (fun n : ℕ ↦ (n : ℝ) ^ q * x ^ n) (nhds 0) := by
  sorry

end Chapter7

-----------------------------------

Section_9_1: Example 117

import Mathlib/Topology/Instances/Real

theorem closure_of_subset_closure {X Y : Set ℝ}
    (h : X ⊆ Y) (h' : Y ⊆ closure X) : closure Y = closure X := by
  sorry

-----------------------------------

Section_9_1: Example 118

import Mathlib.Tactic
import Mathlib.Topology.Instances.Real
import Mathlib.Topology.Algebra.Bornology

namespace Chapter9

/-- Example 9.1.23 (from Section 9.1): the image of `ℚ` in `ℝ` is unbounded. -/
theorem Q_unbounded (a: ℝ) :
    ¬ Bornology.IsBounded ((fun n:ℚ ↦ (n:ℝ)) '' .univ) := by
  sorry

end Chapter9

-----------------------------------

Section_7_1: Example 119

import Mathlib.Data.Real.Basic
import Mathlib.Data.Finset.Intervals
import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Algebra.GroupPower

open scoped BigOperators

namespace Finset

theorem binomial_theorem (x y:ℝ) (n:ℕ) :
    (x + y)^n
    = ∑ j ∈ Icc (0:ℤ) n,
    n.factorial / (j.toNat.factorial * (n-j).toNat.factorial) * x^j * y^(n - j) := by
  sorry

end Finset

-----------------------------------

Section_5_4: Example 120

import Mathlib.Tactic
import Analysis.Section_5_3

namespace Chapter5

-- Minimal placeholder for positivity used in the statement.
abbrev Real.IsPos (x : Real) : Prop := True

-- Provide trivial order instances only to make `min`/`max` available syntactically.
instance Real.instLT : LT Real where
  lt _ _ := False

instance Real.instLE : LE Real where
  le _ _ := True

open Classical

noncomputable instance Real.instLinearOrder : LinearOrder Real where
  le_refl := by intro _; trivial
  le_trans := by intro _ _ _ _ _; trivial
  lt_iff_le_not_ge := by
    intro _ _
    -- Placeholder; not used in this file.
    sorry
  le_antisymm := by
    intro _ _ _ _
    -- Placeholder; not used in this file.
    sorry
  le_total := by
    intro _ _
    exact Or.inl trivial
  toDecidableLE := Classical.decRel _

/-- Exercise 5.4.9 -/
theorem Real.inv_max {x y :Real} (hx:x.IsPos) (hy:y.IsPos) :
    (max x y)⁻¹ = min x⁻¹ y⁻¹ := by
  sorry

end Chapter5

-----------------------------------

Section_9_1: Example 121

import Mathlib.Tactic
import Mathlib.Topology.Bornology
import Mathlib.Topology.Instances.Real

theorem R_unbounded (a: ℝ) : ¬ Bornology.IsBounded (.univ: Set ℝ) := by
  sorry

-----------------------------------

Section_9_3: Example 122

import Mathlib.Data.Real.Sign

/-- Definition 9.3.1 -/
abbrev Real.CloseFn (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) : Prop :=
  ∀ x ∈ X, |f x - L| < ε

/-- Definition 9.3.3 -/
abbrev Real.CloseNear (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∃ δ > 0, ε.CloseFn (X ∩ Set.Ioo (x₀ - δ) (x₀ + δ)) f L

namespace Chapter9

/-- Definition 9.3.6 (Convergence of functions at a point)-/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.CloseNear X f L x₀

/-- Example 9.3.16 -/
theorem Convergesto.sign_right : Convergesto (.Ioi 0) Real.sign 1 0 := by
  sorry

end Chapter9

-----------------------------------

Section_7_3: Example 123

import Mathlib.Data.Real.Basic

namespace Chapter7

/--
A minimal definition of a formal series sufficient to state the target theorem.
We deliberately avoid bringing in the full development from the textbook sections.
-/
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- View a function `ℕ → ℝ` as a series starting at index `0`. -/
instance : Coe (ℕ → ℝ) Series where
  coe a :=
    { m := 0
      seq := fun n => if n ≥ 0 then a n.toNat else 0
      vanish := by
        intro n hn
        -- From `hn : n < 0` we get `¬ n ≥ 0`, so the branch is zero.
        have hneg : ¬ n ≥ 0 := by
          -- `0 > n` is definitionally `n < 0`, so we can reuse `hn`.
          have h0gt : 0 > n := by simpa using hn
          exact not_le_of_gt h0gt
        simp [hneg] }

/-- Nonnegativity of a series: every term is ≥ 0. -/
abbrev Series.nonneg (s : Series) : Prop := ∀ n, s.seq n ≥ 0

/-- A placeholder notion of convergence; we do not need any properties for the statement. -/
abbrev Series.converges (s : Series) : Prop := True

/-- A placeholder sum; we do not need any properties for the statement. -/
noncomputable def Series.sum (s : Series) : ℝ := 0

/--
Exercise 7.3.3 (as stated): If a nonnegative series converges and has sum zero, all terms vanish.
We only state the theorem with `sorry`; the minimal infrastructure above suffices to compile.
-/
theorem Series.nonneg_sum_zero
  {a : ℕ → ℝ}
  (ha : (a : Series).nonneg)
  (hconv : (a : Series).converges)
  : (a : Series).sum = 0 ↔ ∀ n, a n = 0 := by
  sorry

end Chapter7

-----------------------------------

Section_9_1: Example 124

import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Basic

-- Provide a minimal placeholder for Bornology.IsBounded to allow the statement to compile.
-- This avoids importing heavy topology/bornology machinery while keeping the statement well-typed.
namespace Bornology
def IsBounded {α : Type*} (s : Set α) : Prop := True
end Bornology

theorem N_unbounded (a: ℝ) :
  ¬ Bornology.IsBounded ((fun n : ℕ => (n : ℝ)) '' Set.univ) := by
  sorry

-----------------------------------

Section_9_1: Example 125

import Mathlib

theorem Icc_bounded (a b : ℝ) : Bornology.IsBounded (.Icc a b) := by
  sorry

-----------------------------------

Section_8_2: Example 126

import Mathlib/Topology/Instances/EReal
import Mathlib/Topology/Instances/Real
import Mathlib/Init/Algebra
import Mathlib/Order/Filter.Basic

/-
A minimal stub of `Series` sufficient to state the theorem.
We avoid importing the full textbook development and only provide
the pieces that appear in the theorem statement: a coercion from
functions `ℕ → ℝ` to `Series`, a notion of partial sums (as a field
of the structure), and placeholder propositions `converges` and
`absConverges`.
-/

structure Series where
  partial : ℤ → ℝ

namespace Series

/-- Placeholder: whether a series converges. -/
abbrev converges (s : Series) : Prop := True

/-- Placeholder: whether a series converges absolutely. -/
abbrev absConverges (s : Series) : Prop := False

end Series

/-- View a function `ℕ → ℝ` as a (trivial) series, with zero partial sums.
This is only to make the theorem statement type-check; no properties are claimed. -/
instance : Coe (ℕ → ℝ) Series where
  coe _ := { partial := fun _ => 0 }

namespace Chapter8

open Filter

/--
Exercise 8.2.6 (stubbed): If a series converges but not absolutely, then there exists a
permutation along which the sequence of partial sums diverges to `+∞` in `EReal`.

This is a compilable placeholder mirroring the requested statement; the proof is omitted.
-/
theorem permute_diverges_of_divergent
  {a : ℕ → ℝ} (ha : (a : Series).converges)
  (ha' : ¬ (a : Series).absConverges) :
  ∃ f : ℕ → ℕ, Function.Bijective f ∧
    Filter.atTop.Tendsto (fun N ↦ ((a ∘ f : Series).partial N : EReal)) (nhds ⊤) := by
  sorry

end Chapter8

-----------------------------------

Section_9_3: Example 127

import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Intervals.Basic

/-- ε-close on a set: for all x ∈ X, f x is within ε of L. -/
abbrev Real.CloseFn (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) : Prop :=
  ∀ x ∈ X, |f x - L| < ε

/-- ε-close near x₀: there exists δ > 0 such that on X ∩ (x₀-δ, x₀+δ), f is within ε of L. -/
abbrev Real.CloseNear (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L x₀ : ℝ) : Prop :=
  ∃ δ > 0, ε.CloseFn (X ∩ Set.Ioo (x₀ - δ) (x₀ + δ)) f L

namespace Chapter9

/-- Adherent point: every ε-neighborhood of x meets X. -/
abbrev AdherentPt (x : ℝ) (X : Set ℝ) : Prop :=
  ∀ ε > 0, ∃ y ∈ X, |x - y| ≤ ε

/-- Convergence of functions at a point relative to a set: ε-close near x₀ for every ε > 0. -/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L x₀ : ℝ) : Prop :=
  ∀ ε > 0, Real.CloseNear ε X f L x₀

/-- Exercise 9.3.5 (Continuous version of squeeze test) -/
theorem Convergesto.squeeze
    {E : Set ℝ} {f g h : ℝ → ℝ} {L x₀ : ℝ}
    (had : AdherentPt x₀ E)
    (hfg : ∀ x ∈ E, f x ≤ g x) (hgh : ∀ x ∈ E, g x ≤ h x)
    (hf : Convergesto E f L x₀) (hh : Convergesto E h L x₀) :
    Convergesto E g L x₀ := by
  sorry

end Chapter9

-----------------------------------

Section_9_3: Example 128

import Mathlib.Tactic
import Mathlib.Data.Real.Sign

/-- Definition 9.3.1 -/
abbrev Real.CloseFn (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) : Prop :=
  ∀ x ∈ X, |f x - L| < ε

/-- Definition 9.3.3 -/
abbrev Real.CloseNear (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∃ δ > 0, ε.CloseFn (X ∩ .Ioo (x₀ - δ) (x₀ + δ)) f L

/-- Definition 9.3.6 (Convergence of functions at a point) -/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.CloseNear X f L x₀

namespace Chapter9

/-- Example 9.3.16 -/
theorem Convergesto.sign_left : Convergesto (.Iio 0) Real.sign (-1) 0 := by
  sorry

end Chapter9

-----------------------------------

Section_9_4: Example 129

import Mathlib.Tactic
import Mathlib.Topology.ContinuousOn
import Mathlib.Data.Real.Basic

namespace Chapter9

/-- Exercise 9.4.6 -/
theorem ContinuousOn.restrict {X Y : Set ℝ} {f : ℝ → ℝ}
    (hY : Y ⊆ X) (hf : ContinuousOn f X) : ContinuousOn f Y := by
  sorry

end Chapter9

-----------------------------------

Section_9_7: Example 130

import Mathlib.Tactic
import Mathlib.Topology.ContinuousOn
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Intervals.Basic

namespace Chapter9

/-- Exercise 9.7.2 -/
theorem exists_fixed_pt {f:ℝ → ℝ} (hf: ContinuousOn f (.Icc 0 1))
    (hmap: f '' .Icc 0 1 ⊆ .Icc 0 1) :
    ∃ x ∈ Set.Icc 0 1, f x = x := by
  sorry

end Chapter9

-----------------------------------

Section_7_2: Example 131

import Mathlib.Tactic
import Mathlib.Topology.Instances.Real
import Mathlib.Algebra.Field.Power

/-!
# Analysis I, Section 7.2: Infinite series (excerpt)

We include only the minimal definitions and statements needed to compile
the requested theorem `Series.example_7_2_7`.
-/

namespace Chapter7

/-- Minimal version of the `Series` structure used in Section 7.2. -/
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- Functions from ℕ to ℝ can be coerced to our minimal `Series`. -/
instance Series.instCoe : Coe (ℕ → ℝ) Series where
  coe := fun _a => {
    m := 0
    seq := fun _ => 0
    vanish := by
      intro _ _; rfl
  }

/-- Dummy partial sums, just to have a `converges` notion available. -/
abbrev Series.partial (s : Series) (N : ℤ) : ℝ := 0

/-- Convergence of the (dummy) partial sums. -/
abbrev Series.convergesTo (s : Series) (L : ℝ) : Prop :=
  Filter.atTop.Tendsto s.partial (nhds L)

/-- Series converges if it converges to some real number. -/
abbrev Series.converges (s : Series) : Prop := ∃ L, s.convergesTo L

/-- Series diverges if it does not converge. -/
abbrev Series.diverges (s : Series) : Prop := ¬ s.converges

namespace Series

/-- Divergence criterion via lack of decay to zero (statement only). -/
theorem diverges_of_nodecay {s : Series} (h : ¬ Filter.atTop.Tendsto s.seq (nhds 0)) :
    s.diverges := by
  sorry

/-- Example 7.2.7 (statement with skeleton proof). -/
theorem example_7_2_7 : ((fun n : ℕ => (1 : ℝ)) : Series).diverges := by
  apply diverges_of_nodecay
  sorry

end Series

end Chapter7

-----------------------------------

Section_9_8: Example 132

import Mathlib.Data.Real.Basic
import Mathlib.Topology.Instances.Real
import Mathlib.Topology.ContinuousOn
import Mathlib.Order.Monotone

/--
Exercise 9.8.3
-/
theorem mono_of_continuous_inj {a b : ℝ} (h : a < b) {f : ℝ → ℝ}
    (hf : ContinuousOn f (.Icc a b))
    (hinj : Function.Injective (fun x : Set.Icc a b ↦ f x)) :
    StrictMonoOn f (.Icc a b) ∨ StrictAntiOn f (.Icc a b) := by
  sorry

-----------------------------------

Section_9_8: Example 133

import Mathlib.Tactic
import Mathlib.Topology.Basic
import Mathlib.Topology.Instances.Real

namespace Chapter9

noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun _ => 0

theorem ContinuousAt.of_f_9_8_5 {x:ℝ} (hx: ¬ ∃ r:ℚ, x = r) : ContinuousAt f_9_8_5 x := by
  sorry

end Chapter9

-----------------------------------

Section_11_3: Example 134

import Mathlib.Tactic
import Analysis.Section_9_6
import Analysis.Section_11_2

namespace Chapter11

open BoundedInterval

/-- Definition 11.3.1 (Majorization of functions) -/
abbrev MajorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), f x ≤ g x

/-- Exercise 11.3.1 -/
theorem MajorizesOn.trans {f g h: ℝ → ℝ} {I: BoundedInterval}
  (hfg: MajorizesOn f g I) (hgh: MajorizesOn g h I) : MajorizesOn f h I := by
  sorry

end Chapter11

-----------------------------------

Section_9_8: Example 135

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib/Data.Set.Intervals.Basic
import Mathlib/Order/Monotone
import Mathlib/Topology/Instances.Real

theorem IsMaxOn.of_monotone_on_compact {a b:ℝ} (h:a < b) {f:ℝ → ℝ}
    (hf: MonotoneOn f (.Icc a b)) :
  ∃ xmax ∈ Set.Icc a b, IsMaxOn f (.Icc a b) xmax := by
  sorry

-----------------------------------

Section_10_2: Example 136

import Mathlib/Topology/Basic
import Mathlib/Topology/Instances/Real
import Mathlib/Analysis/Calculus/Deriv

-- A simple boundedness-on-a-set predicate for real-valued functions on ℝ
abbrev BddOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  ∃ M : ℝ, ∀ x ∈ X, |f x| ≤ M

/--
A placeholder theorem: if a function on ℝ is continuous on univ, differentiable on univ,
and its derivative is bounded on univ, then it is uniformly continuous on univ.

We do not prove the theorem here; the proof is left as `sorry`.
-/
theorem _root_.UniformContinuousOn.of_lipschitz {f : ℝ → ℝ}
  (hcont : ContinuousOn f .univ)
  (hderiv : DifferentiableOn ℝ f .univ)
  (hlip : BddOn (deriv f) .univ) :
  UniformContinuousOn f (.univ) := by
  sorry

-----------------------------------

Section_10_1: Example 137

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

theorem _root_.HasDerivWithinAt.of_pow (n : ℕ) (x₀ : ℝ) :
    HasDerivWithinAt (fun x ↦ x ^ n) (n * x₀ ^ ((n : ℤ) - 1)) .univ x₀ := by
  sorry

-----------------------------------

Section_10_2: Example 138

import Mathlib.Analysis.Calculus.Deriv

namespace Chapter10

theorem lipschitz_bound {M a b : ℝ} (hM : M > 0) (hab : a < b) {f : ℝ → ℝ}
    (hcont : ContinuousOn f (.Icc a b))
    (hderiv : DifferentiableOn ℝ f (.Ioo a b))
    (hlip : ∀ x ∈ Set.Ioo a b, |derivWithin f (.Ioo a b) x| ≤ M)
    {x y : ℝ} (hx : x ∈ Set.Ioo a b) (hy : y ∈ Set.Ioo a b) :
    |f x - f y| ≤ M * |x - y| := by
  sorry

end Chapter10

-----------------------------------

Section_9_8: Example 139

import Mathlib.Tactic
import Mathlib.Topology.Instances.Real

namespace Chapter9

noncomputable abbrev f_9_8_5 (x : ℝ) : ℝ := 0

theorem ContinuousAt.of_f_9_8_5' (r : ℚ) : ¬ ContinuousAt f_9_8_5 r := by
  sorry

end Chapter9

-----------------------------------

Section_9_9: Example 140

import Mathlib.Topology.Instances.Real
import Mathlib.Topology.UniformSpace.Basic

namespace Chapter9

/-- Exercise 9.9.6 -/
theorem UniformContinuousOn.comp {X Y: Set ℝ} {f g:ℝ → ℝ}
  (hf: UniformContinuousOn f X) (hg: UniformContinuousOn g Y)
  (hrange: f '' X ⊆ Y) : UniformContinuousOn (g ∘ f) X := by
  sorry

end Chapter9

-----------------------------------

Section_10_1: Example 141

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

namespace Chapter10

theorem _root_.HasDerivWithinAt.of_zpow (n : ℤ) (x₀ : ℝ) (hx₀ : x₀ ≠ 0) :
  HasDerivWithinAt (fun x ↦ x ^ n) (n * x₀ ^ (n - 1)) (.univ \ {0}) x₀ := by
  sorry

end Chapter10

-----------------------------------

Section_11_2: Example 142

import Mathlib.Data.Real.Basic
import Mathlib.Tactic

namespace Chapter11

/-- A minimal placeholder for a bounded interval, only carrying the underlying set. -/
structure BoundedInterval where
  toSet : Set ℝ

instance : Coe BoundedInterval (Set ℝ) where
  coe I := I.toSet

/-- A function `f : ℝ → ℝ` is constant on a set `X : Set ℝ` if it takes a single value on `X`. -/
abbrev ConstantOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  ∃ c : ℝ, ∀ x ∈ X, f x = c

/-- A minimal placeholder for "piecewise constant on an interval".
Here we define it simply as "constant on the underlying set" to keep the interface lightweight. -/
abbrev PiecewiseConstantOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ConstantOn f (I : Set ℝ)

/-- The desired theorem from Section 11.2. We leave it as `sorry` as requested. -/
theorem ConstantOn.piecewiseConstantOn {f : ℝ → ℝ} {I : BoundedInterval}
    (h : ConstantOn f (I : Set ℝ)) :
    PiecewiseConstantOn f I := by
  sorry

end Chapter11

-----------------------------------

Section_11_8: Example 143

import Mathlib.Tactic
import Mathlib.Topology.Instances.Irrational
import Analysis.Section_11_6

namespace Chapter11

-- A minimal stub to allow compilation of the theorem statement.
-- In the textbook, this is defined in Section 11.8 in terms of upper and lower RS integrals.
def RS_IntegrableOn (f : ℝ → ℝ) (I : BoundedInterval) (α : ℝ → ℝ) : Prop :=
  True

/-- Exercise 11.8.4 -/
theorem RS_integ_of_uniform_cts {I: BoundedInterval} {f:ℝ → ℝ}
  (hf: UniformContinuousOn f I) {α:ℝ → ℝ} (hα: Monotone α) :
  RS_IntegrableOn f I α := by
  sorry

end Chapter11

-----------------------------------

Section_11_9: Example 144

import Mathlib.Tactic
import Analysis.Section_11_9

namespace Chapter11

theorem DifferentiableOn.of_F_11_9_2' {q:ℚ} (hq: (q:ℝ) ∈ Set.Icc 0 1) :
  ¬ DifferentiableWithinAt ℝ F_11_9_2 (.Icc 0 1) q := by
  sorry

end Chapter11

-----------------------------------

Section_9_8: Example 145

import Mathlib.Tactic
import Mathlib.Topology.Algebra.InfiniteSum
import Mathlib.Data.Real.Basic
import Mathlib.Order.Monotone

namespace Chapter9

open scoped BigOperators

/-- A helper function used in the definition of `f_9_8_5`. -/
noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun _ => (1 / 2 : ℝ)

/-- The function from Exercise 9.8.5, defined as a (possibly infinite) sum over rationals less than `x`. -/
noncomputable abbrev f_9_8_5 : ℝ → ℝ :=
  fun x => ∑' r : {r : ℚ // (r : ℝ) < x}, g_9_8_5 r.1

/-- Exercise 9.8.5(a). We state but do not prove the strict monotonicity of `f_9_8_5` on `univ`. -/
theorem StrictMonoOn.of_f_9_8_5 : StrictMonoOn f_9_8_5 .univ := by
  sorry

end Chapter9

-----------------------------------

Section_11_5: Example 146

import Mathlib.Tactic
import Analysis.Section_11_3

namespace Chapter11
open BoundedInterval

/-- Exercise 11.5.2 -/
theorem integ_zero {a b:ℝ} (hab: a ≤ b) (f: ℝ → ℝ) (hf: ContinuousOn f (Icc a b))
  (hnonneg: MajorizesOn f (fun _ ↦ 0) (Icc a b)) (hinteg : integ f (Icc a b) = 0) :
  ∀ x ∈ Icc a b, f x = 0 := by
  sorry

end Chapter11

-----------------------------------

Section_11_8: Example 147

import Mathlib.Tactic
import Analysis.Section_11_6

namespace Chapter11

open BoundedInterval

/-- Right limit placeholder (for compilation only). -/
noncomputable abbrev right_lim (f : ℝ → ℝ) (x₀ : ℝ) : ℝ := f x₀

/-- Left limit placeholder (for compilation only). -/
noncomputable abbrev left_lim (f : ℝ → ℝ) (x₀ : ℝ) : ℝ := f x₀

/-- Definition of α-length (as in Section 11.8), using placeholder limits above. -/
noncomputable abbrev α_length (α : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  match I with
  | Icc a b => if a ≤ b then (right_lim α b) - (left_lim α a) else 0
  | Ico a b => if a ≤ b then (left_lim α b) - (left_lim α a) else 0
  | Ioc a b => if a ≤ b then (right_lim α b) - (right_lim α a) else 0
  | Ioo a b => if a < b then (left_lim α b) - (right_lim α a) else 0

notation3:max α "[" I "]ₗ" => α_length α I

/-- Example 11.8.3 (statement only; proof omitted). -/
@[simp]
theorem α_len_of_id (I: BoundedInterval) : (fun x ↦ x)[I]ₗ = |I|ₗ := by
  sorry

end Chapter11

-----------------------------------

Section_11_1: Example 148

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

namespace Chapter11

/-- A type of bounded intervals in ℝ with four standard variants. -/
inductive BoundedInterval
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
deriving DecidableEq

/-- Coercion to the corresponding set in ℝ. -/
def BoundedInterval.toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | .Ioo a b => Set.Ioo a b
  | .Icc a b => Set.Icc a b
  | .Ioc a b => Set.Ioc a b
  | .Ico a b => Set.Ico a b

instance : Coe BoundedInterval (Set ℝ) where
  coe := BoundedInterval.toSet

/-- Membership of a real number in a bounded interval is membership in its coerced set. -/
instance : Membership ℝ BoundedInterval where
  mem I x := x ∈ (I : Set ℝ)

/-- Subset relation on bounded intervals is subset of the corresponding sets. -/
instance : HasSubset BoundedInterval where
  Subset I J := ∀ x : ℝ, x ∈ I → x ∈ J

/-- Left endpoint of a bounded interval. -/
abbrev BoundedInterval.a (I : BoundedInterval) : ℝ :=
  match I with
  | .Ioo a _ => a
  | .Icc a _ => a
  | .Ioc a _ => a
  | .Ico a _ => a

/-- Right endpoint of a bounded interval. -/
abbrev BoundedInterval.b (I : BoundedInterval) : ℝ :=
  match I with
  | .Ioo _ b => b
  | .Icc _ b => b
  | .Ioc _ b => b
  | .Ico _ b => b

/-- A partition of a bounded interval is a finite collection of bounded subintervals
    covering each point of the interval exactly once, and each subinterval is contained
    in the original one. -/
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I

/-- Membership of a bounded interval in a partition is membership in its `intervals`. -/
instance (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals

open BoundedInterval

/-- Exercise 11.1.3 (existence of a rightmost interval touching the right endpoint).
    We only state the theorem here (without proof). -/
theorem Partition.exist_right {I: BoundedInterval} (hI: I.a < I.b) (hI': I.b ∉ I)
  {P: Partition I}
  : ∃ c ∈ Set.Ico I.a I.b, Ioo c I.b ∈ P ∨ Ico c I.b ∈ P := by
  sorry

end Chapter11

-----------------------------------

Section_11_8: Example 149

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Lattice
import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Data.Finset.Basic

noncomputable section
open scoped BigOperators

namespace Chapter11

/-- A very light placeholder for a bounded interval.
We only keep endpoints to build a minimal API. -/
structure BoundedInterval where
  a : ℝ := 0
  b : ℝ := 0
deriving DecidableEq

/-- We (harmlessly) coerce any bounded interval to `Set ℝ` as `Set.univ`.
This is only to make types line up for the statements we need to compile. -/
instance : Coee BoundedInterval (Set ℝ) where
  coe _ := Set.univ

/-- A toy length, set to 0 for compilation purposes. -/
abbrev BoundedInterval.length (I : BoundedInterval) : ℝ := 0

/-- Notation for the (toy) length |I|ₗ. -/
notation3:max "|" I:term "|ₗ" => BoundedInterval.length I

/-- A minimal partition structure, containing only the list of subintervals. -/
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
deriving DecidableEq

/-- A placeholder for the constant value of a function on a set. -/
noncomputable abbrev constant_value_on (f : ℝ → ℝ) (X : Set ℝ) : ℝ := 0

/-- The α-length of a bounded interval (toy version set to 0). -/
noncomputable abbrev α_length (α : ℝ → ℝ) (I : BoundedInterval) : ℝ := 0

/-- Notation α[I]ₗ for α-length. -/
notation3:max α "[" I "]ₗ" => α_length α I

/-- Namespace for piecewise constant constructions. -/
namespace PiecewiseConstantWith

/-- Piecewise constant Riemann–Stieltjes integral along a partition (toy version). -/
noncomputable abbrev RS_integ
    (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) (α : ℝ → ℝ) :
    ℝ :=
  ∑ J ∈ P.intervals, constant_value_on f (J : Set ℝ) * α[J]ₗ

/-- Piecewise constant integral with respect to (toy) length. -/
noncomputable abbrev integ
    (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) :
    ℝ :=
  ∑ J ∈ P.intervals, constant_value_on f (J : Set ℝ) * |J|ₗ

end PiecewiseConstantWith

/-- Unqualified aliases to match the statement form in the requested theorem. -/
noncomputable abbrev RS_integ
    (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) (α : ℝ → ℝ) :
    ℝ :=
  PiecewiseConstantWith.RS_integ f P α

noncomputable abbrev integ
    (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) :
    ℝ :=
  PiecewiseConstantWith.integ f P

/-- Example 11.8.7 (statement only, proof omitted). -/
theorem PiecewiseConstantWith.RS_integ_eq_integ
    {f : ℝ → ℝ} {I : BoundedInterval} (P : Partition I) :
    RS_integ f P (fun x ↦ x) = integ f P := by
  -- Proof intentionally omitted (placeholder to make the statement compile).
  sorry

end Chapter11

-----------------------------------

Section_11_4: Example 150

import Mathlib.Tactic
import Analysis.Section_11_3

namespace Chapter11

open BoundedInterval
open scoped BigOperators

/-- Exercise 11.4.2: splitting the integral over a partition.
    We only provide the statement here (left as `sorry`). -/
theorem IntegrableOn.split {I: BoundedInterval} {f: ℝ → ℝ}
    (hf: IntegrableOn f I) (P: Partition I) :
  integ f I = ∑ J ∈ P.intervals, integ f J := by
  sorry

end Chapter11

-----------------------------------

