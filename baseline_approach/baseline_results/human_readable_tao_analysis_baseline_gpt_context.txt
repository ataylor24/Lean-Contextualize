Section_2_2: Example 1

import Mathlib.Tactic

namespace Chapter2

/-- A simple Peano-style natural number type for Chapter 2. -/
inductive Nat where
| zero : Nat
| succ : Nat → Nat
deriving Repr, DecidableEq

/-- Zero instance for Chapter2.Nat. -/
instance : Zero Nat := ⟨ Nat.zero ⟩

/-- Postfix successor notation `n++`. -/
postfix:100 "++" => Nat.succ

/-- Addition on Chapter2.Nat. -/
def Nat.add : Nat → Nat → Nat
| Nat.zero, m => m
| Nat.succ n, m => Nat.succ (Nat.add n m)

/-- Use `+` notation for Chapter2.Nat.add. -/
instance : Add Nat where
  add := Nat.add

/-- Define `≤` on Chapter2.Nat by existence of a nonnegative difference. -/
instance : LE Nat where
  le n m := ∃ a : Nat, m = n + a

/-- Exercise 2.2.6 (backwards induction)
    Compare with Mathlib's `Nat.decreasingInduction`. -/
theorem Nat.backwards_induction {n:Nat} {P: Nat → Prop}
  (hind: ∀ m, P (m++) → P m) (hn: P n) :
    ∀ m, m ≤ n → P m := by
  sorry

end Chapter2

-----------------------------------

Section_2_3: Example 2

import Mathlib.Tactic

/-!
This file provides the minimal setup from Sections 2.1–2.3 needed
to state (but not prove) the theorem `Nat.sq_add_eq` in the
Chapter2 namespace. We intentionally avoid importing the textbook
sections themselves, per the instructions.
-/

namespace Chapter2

/-- A custom natural number type for Chapter 2. -/
inductive Nat where
| zero : Nat
| succ : Nat → Nat
deriving Repr, DecidableEq

/-- 0 for Chapter2.Nat. -/
instance : Zero Nat := ⟨ Nat.zero ⟩

/-- Successor notation. -/
postfix:100 "++" => Nat.succ

/-- Numerals for Chapter2.Nat, via recursion on the standard ℕ. -/
instance instOfNatNat {n : _root_.Nat} : OfNat Nat n where
  ofNat := _root_.Nat.rec (0) (fun _ acc => acc++) n

/-- 1 for Chapter2.Nat. -/
instance : One Nat := ⟨ 1 ⟩

/-- A recursion helper (as in the textbook). -/
abbrev Nat.recurse (f : Nat → Nat → Nat) (c : Nat) : Nat → Nat
  | 0 => c
  | n++ => f n (recurse f c n)

/-- Addition for Chapter2.Nat. -/
abbrev Nat.add (n m : Nat) : Nat := Nat.recurse (fun _ sum => sum++) m n

/-- Use + notation for Chapter2.Nat. -/
instance : Add Nat where
  add := Nat.add

/-- Multiplication for Chapter2.Nat. -/
abbrev Nat.mul (n m : Nat) : Nat := Nat.recurse (fun _ prod => prod + m) 0 n

/-- Use * notation for Chapter2.Nat. -/
instance : Mul Nat where
  mul := Nat.mul

/-- Exponentiation for Chapter2.Nat. -/
abbrev Nat.pow (m n : Nat) : Nat := Nat.recurse (fun _ prod => prod * m) 1 n

/-- Provide ^ notation for Chapter2.Nat with Nat exponents. -/
instance : Pow Nat Nat where
  pow := Nat.pow

/-- The requested (unsolved) theorem from Section 2.3. -/
theorem Nat.sq_add_eq (a b: Nat) :
    (a + b) ^ (2 : Nat) = a ^ (2 : Nat) + 2 * a * b + b ^ (2 : Nat) := by
  sorry

end Chapter2

-----------------------------------

Section_3_1: Example 3

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- A minimal version of the ZF-style set theory structure needed for this theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set
  union_pair_axiom (X Y : Set) (x : Object) :
    mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y)

-- Use `Set` and `Object` directly (as in the source file).
export SetTheory (Set Object)

-- We work with a fixed ambient `SetTheory` instance.
variable [SetTheory]

/-- Membership notation `x ∈ X` for our `Object`/`Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Binary union notation `X ∪ Y` for our `Set`. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Subset notation `X ⊆ Y` for our `Set`. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Exercise 3.1.7 (right inclusion into a union), as a stub. -/
theorem SetTheory.Set.subset_union_right (A B:Set) : B ⊆ A ∪ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 4

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- A minimal version of the `SetTheory` class sufficient to state the target theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set

-- This enables one to use `Set` and `Object` instead of `SetTheory.Set` and `SetTheory.Object`.
export SetTheory (Set Object)

-- We assume an ambient instance of set theory.
variable [SetTheory]

/-- Allow the notation `x ∈ X` for membership of an object `x` in a set `X`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Allow the notation `X ∪ Y` for the union of two sets. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Allow the notation `X ⊆ Y` for subset of sets. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : Object, x ∈ X → x ∈ Y

/-- The target theorem (left as `sorry`). -/
@[simp]
theorem SetTheory.Set.union_subset_iff (A B C : Set) :
    A ∪ B ⊆ C ↔ A ⊆ C ∧ B ⊆ C := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 5

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Membership notation `x ∈ X` for `Object` in `Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Coercion of a set `A` to its subtype of elements. -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x : Object => x ∈ A)

/-- Treat a `Set` as a type, namely the subtype of `Object` consisting of its elements. -/
instance : CoeSort Set (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Subset relation on sets. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : Object, x ∈ X → x ∈ Y

/--
  Exercise 3.1.11.
  The challenge is to prove this without using `Set.specify`, `Set.specification_axiom`,
  `Set.specification_axiom'`, or anything built from them (like differences and intersections).
-/
theorem SetTheory.Set.specification_from_replacement {A:Set} {P: A → Prop} :
    ∃ B, B ⊆ A ∧ ∀ x, x.val ∈ B ↔ P x := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 6

import Mathlib.Tactic

namespace Chapter3

universe u

/-- Minimal structure to support the statement. -/
class SetTheory where
  Set   : Type u
  union : Set → Set → Set
  inter : Set → Set → Set
  sdiff : Set → Set → Set

export SetTheory (Set)

variable [SetTheory]

instance : Union Set where
  union := SetTheory.union

instance : Inter Set where
  inter := SetTheory.inter

instance : SDiff Set where
  sdiff := SetTheory.sdiff

/-- Exercise 3.1.10 -/
theorem SetTheory.Set.union_eq_partition (A B : Set) :
    A ∪ B = (A \ B) ∪ (A ∩ B) ∪ (B \ A) := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 7

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal skeleton of the ZF-with-atoms setup needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  union_pair : Set → Set → Set

-- Make `Set` and `Object` available unqualified as in the source.
export SetTheory (Set Object)

variable [SetTheory]

/-- Provide binary union notation `∪` on our `Set` type. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Provide subset notation `⊆` on our `Set` type (dummy definition sufficient to state the theorem). -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset _ _ := Prop

/-- Exercise 3.1.7: subset of a union (left). We keep it as `sorry` per instructions. -/
theorem SetTheory.Set.subset_union_left (A B : Set) : A ⊆ A ∪ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 8

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal skeleton of the ZF-style class sufficient to state the theorem. -/
class SetTheory where
  Set : Type u

variable [SetTheory]

-- Make `Set` accessible directly (as in the provided file).
export SetTheory (Set)

/-- Provide `⊆` on our `Set` (no semantics needed for the statement to typecheck). -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset _ _ := Prop

/-- Provide `∩` on our `Set` (no semantics needed for the statement to typecheck). -/
instance SetTheory.Set.instIntersection : Inter Set where
  inter X Y := X

namespace SetTheory
namespace Set

@[simp]
theorem subset_inter_iff (A B C : Set) : C ⊆ A ∩ B ↔ C ⊆ A ∧ C ⊆ B := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_1: Example 9

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for the statement. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  specify (A : Set) (P : Subtype (mem . A) → Prop) : Set

-- Use `Set` and `Object` directly in this namespace
export SetTheory (Set Object)

variable [SetTheory]

/-- Membership of objects in sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Coerce a `Set` to the subtype of its elements. -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x => x ∈ A)

instance : CoeSort (Set) (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- A convenience wrapper for `SetTheory.specify`. -/
abbrev SetTheory.Set.specify (A : Set) (P : A → Prop) : Set := SetTheory.specify A P

/-- Intersection defined via specification. -/
instance SetTheory.Set.instIntersection : Inter Set where
  inter X Y := X.specify (fun x => x.val ∈ Y)

/-- Subset relation on `Set`. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

/-- Exercise 3.1.12.-/
theorem SetTheory.Set.subset_inter_subset
    {A B A' B' : Set} (hA'A : A' ⊆ A) (hB'B : B' ⊆ B) :
    A' ∩ B' ⊆ A ∩ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 10

import Mathlib.Tactic

/-!
Minimal setup to compile the requested theorem from Section 3.1.
-/

namespace Chapter3

universe u v

/-- Minimal axioms needed for this theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  emptyset : Set
  singleton : Object → Set

-- Allow referring to these types as `Set` and `Object`.
export SetTheory (Set Object)

-- Assume we are working in a universe with an instance of `SetTheory`.
variable [SetTheory]

/-- Sets are objects. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Notation for the empty set `∅`. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Notation for singletons `{x}`. -/
instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

/-- Abbreviation for the empty set (as a `Set`). -/
abbrev SetTheory.Set.empty : Set := ∅

/-- Abbreviation for the singleton `{∅}` (coercing the empty set to an object). -/
abbrev SetTheory.Set.singleton_empty : Set := {(empty : Object)}

/-- Exercise 3.1.2: `∅ ≠ {∅}` (left as `sorry` by request). -/
theorem SetTheory.Set.emptyset_neq_singleton : empty ≠ singleton_empty := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 11

import Mathlib.Tactic

namespace Chapter3

universe u v

-- Minimal class to supply the types and membership predicate
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop

-- Expose `Set` and `Object` as `Chapter3.Set` and `Chapter3.Object`
export SetTheory (Set Object)

-- Assume a model of the class is available
variable [SetTheory]

-- Membership notation `x ∈ X` for our Objects and Sets
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

-- Intersection notation `A ∩ B`
instance : Inter Set where
  inter X Y := X  -- A dummy implementation suffices for the statement to typecheck

-- Subset notation `A ⊆ B`
instance : HasSubset Set where
  Subset X Y := ∀ x, x ∈ X → x ∈ Y

-- The requested theorem, left as `sorry` per instructions
theorem SetTheory.Set.inter_subset_left (A B : Set) : A ∩ B ⊆ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 12

import Mathlib.Tactic

/-!
Minimal environment to state the theorem:

theorem SetTheory.Set.pair_eq_pair {a b c d:Object} (h: ({a,b}:Set) = {c,d}) :
    a = c ∧ b = d ∨ a = d ∧ b = c := by
  sorry
-/

namespace Chapter3

universe u v

/-- Minimal class capturing only what is needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  singleton : Object → Set
  union_pair : Set → Set → Set

-- Expose `Set` and `Object` as top-level names within this namespace.
export SetTheory (Set Object)

variable [SetTheory]

-- Instances to support `{x}` and `{x, y}` notation.
instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

instance SetTheory.Set.instInsert : Insert Object Set where
  insert x X := {x} ∪ X

/-- Do not change the theorem name and do not solve it. -/
theorem SetTheory.Set.pair_eq_pair {a b c d : Object}
    (h : ({a, b} : Set) = {c, d}) :
    a = c ∧ b = d ∨ a = d ∧ b = c := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 13

import Mathlib.Tactic

namespace Chapter3

universe u

-- Minimal structure to support the theorem's statement
class SetTheory where
  Set : Type u

export SetTheory (Set)

variable [SetTheory]

-- Provide minimal instances for the notations used in the statement
instance : Union Set where
  union X Y := X

instance : Inter Set where
  inter X Y := X

instance : HasSubset Set where
  Subset _ _ := True

namespace SetTheory
namespace Set

-- The requested (unsolved) theorem
theorem subset_tfae (A B : Chapter3.Set) :
    [A ⊆ B, A ∪ B = B, A ∩ B = A].TFAE := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_1: Example 14

import Mathlib.Tactic
import Mathlib/Logic/Pairwise
import Mathlib/Data/Matrix/Notation

namespace Chapter3

universe u v

/-- Minimal skeleton of the set theory framework needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v

export SetTheory (Set Object)

variable [SetTheory]

/-- Provide intersection notation `∩` for `Set`. No properties required for the theorem. -/
instance : Inter Set where
  inter X Y := X

/-- Provide set difference notation `\` for `Set`. No properties required for the theorem. -/
instance : SDiff Set where
  sdiff X Y := X

/-- A placeholder `Disjoint` predicate on sets, sufficient to state the theorem. -/
def Disjoint (_A _B : Set) : Prop := True

/--
  Exercise 3.1.10 (statement only). The proof is intentionally omitted (`sorry`) as requested.
-/
theorem SetTheory.Set.pairwise_disjoint (A B:Set) :
    Pairwise (Function.onFun Disjoint ![A \ B, A ∩ B, B \ A]) := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 15

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axiomatization needed for the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  union_pair : Set → Set → Set

-- Expose `Set` and `Object` to the current namespace for convenient use.
export SetTheory (Set Object)

-- Assume a background instance of the set theory.
variable [SetTheory]

/-- Allow the notation `x ∈ X` for `Object` membership in `Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Define `⊆` for our `Set` type via elementwise membership. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : Object, x ∈ X → x ∈ Y

/-- Define `∪` for our `Set` type using the primitive `union_pair`. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Exercise 3.1.12.-/
theorem SetTheory.Set.subset_union_subset
    {A B A' B' : Set} (hA'A : A' ⊆ A) (hB'B : B' ⊆ B) :
    A' ∪ B' ⊆ A ∪ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 16

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- A minimal fragment of the Section 3.1 set theory needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  emptyset : Set
  singleton : Object → Set

-- Allow writing `Set` and `Object` directly.
export SetTheory (Set Object)

variable [SetTheory]

/-- Enable `x ∈ X` where `x : Object` and `X : Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Enable `∅ : Set`. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Enable `{x} : Set` for `x : Object`. -/
instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

/-- Subset relation on sets. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset X Y := ∀ x : Object, x ∈ X → x ∈ Y

/-- Strict subset relation on sets. -/
instance SetTheory.Set.instSSubset : HasSSubset Set where
  SSubset X Y := X ⊆ Y ∧ X ≠ Y

/-- Exercise 3.1.13 -/
theorem SetTheory.Set.singleton_iff (A : Set) (hA : A ≠ ∅) :
    (¬ ∃ B ⊂ A, B ≠ ∅) ↔ ∃ x, A = {x} := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 17

import Mathlib.Tactic

namespace Chapter3

universe u v

-- Minimal axiomatic skeleton to support the statement
class SetTheory where
  Set : Type u
  Object : Type v
  emptyset : Set
  union_pair : Set → Set → Set
  inter : Set → Set → Set
  sdiff : Set → Set → Set

-- Use `Set` and `Object` directly (they depend on an instance of `SetTheory`)
export SetTheory (Set Object)

variable [SetTheory]

-- Provide the set-theoretic notations needed for the statement
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

instance SetTheory.Set.instIntersection : Inter Set where
  inter := SetTheory.inter

instance SetTheory.Set.instSDiff : SDiff Set where
  sdiff := SetTheory.sdiff

-- The requested theorem (left as `sorry` as instructed)
theorem SetTheory.Set.partition_right {A B X:Set} (h_union: A ∪ B = X) (h_inter: A ∩ B = ∅) :
    B = X \ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 18

import Mathlib.Tactic

/-
We construct just enough of the environment from the referenced section
to state the requested theorem without proving it.
-/

namespace Chapter3

universe u v

/-- Minimal skeleton of the set theory class needed to state the theorem. -/
class SetTheory where
  Set : Type u

-- Make `Set` available unqualified within `Chapter3`.
export SetTheory (Set)

-- Work under an arbitrary instance of the set theory.
variable [SetTheory]

/-- Provide a dummy set-difference so the notation `\` is available on `Set`. -/
instance SetTheory.Set.instSDiff : SDiff Set where
  sdiff X _ := X

/-- Provide a dummy subset relation so the notation `⊆` is available on `Set`. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset _ _ := True

/-
The requested theorem from Section 3.1. We only state it (with `sorry`) and do not solve it.
Note: This theorem is given the same (relative) name as in the original section.
-/
theorem SetTheory.Set.subset_diff_subset_counter :
    ∃ (A B A' B': Set), (A' ⊆ A) ∧ (B' ⊆ B) ∧ ¬ (A' \ B') ⊆ (A \ B) := by
  sorry

end Chapter3

-----------------------------------

Section_3_1: Example 19

import Mathlib.Tactic

/-!
We construct the minimal scaffolding from Chapter 3 Section 3.1 needed to state
the theorem `SetTheory.Set.emptyset_neq_pair`. We do not prove the theorem.
-/

namespace Chapter3

universe u v

/-- Minimal version of the SetTheory class to support the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  emptyset : Set
  singleton : Object → Set
  union_pair : Set → Set → Set

export SetTheory (Set Object)

variable [SetTheory]

/-- Sets are objects (coercion). -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Provide notation `∅` for the empty set. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Provide notation `{x}` for singletons. -/
instance SetTheory.Set.instSingleton : Singleton Object Set where
  singleton := SetTheory.singleton

/-- Provide notation `X ∪ Y` for unions. -/
instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

/-- Provide notation `{x, y}` (via `Insert`). -/
instance SetTheory.Set.instInsert : Insert Object Set where
  insert x X := ({x} : Set) ∪ X

/-- Abbreviation for the empty set. -/
abbrev SetTheory.Set.empty : Set := ∅

/-- The singleton whose only element is the empty set (as an object). -/
abbrev SetTheory.Set.singleton_empty : Set := {(empty : Object)}

/-- The pair consisting of the empty set and its singleton (as objects). -/
abbrev SetTheory.Set.pair_empty : Set := {(empty : Object), (singleton_empty : Object)}

/-- Exercise 3.1.2 (stated, not proved). -/
theorem SetTheory.Set.emptyset_neq_pair : empty ≠ pair_empty := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 20

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- A minimal version of the set theory class with just the fields needed here. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow writing `x ∈ X` for `Object` x and `Set` X. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Allow coercing a `Set` to an `Object`. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1 (pair set existence, stated but not proved).
  Do not change the name or solve the theorem.
-/
theorem SetTheory.Set.pair_exists
    (h: axiom_of_universal_specification) (x₁ x₂ : Object) :
    ∃ (X : Set), ∀ y, y ∈ X ↔ y = x₁ ∨ y = x₂ := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 21

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1.  The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the singleton set.
-/
theorem SetTheory.Set.singleton_exists (h: axiom_of_universal_specification) (x:Object):
    ∃ (X:Set), ∀ y, y ∈ X ↔ y = x := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 22

namespace Chapter3

universe u v

/-- Minimal axioms needed for the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop

export SetTheory (Set Object)

variable [SetTheory]

/-- Allow `x ∈ X` where `x : Object` and `X : Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem x X := SetTheory.mem x X

/-- Allow coercion of `Set` to `Object`, so we can write `(A : Object)`. -/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- The requested theorem (left as `sorry`). -/
theorem SetTheory.Set.not_mem_mem (A B : Set) :
    (A : Object) ∉ B ∨ (B : Object) ∉ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 23

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1. The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the replace operation.
-/
theorem SetTheory.Set.replace_exists (h: axiom_of_universal_specification) (A:Set)
  (P: A → Object → Prop) (hP: ∀ x y y', P x y ∧ P x y' → y = y') :
    ∃ (Z:Set), ∀ y, y ∈ Z ↔ ∃ a : A, P a y := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 24

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Exercise 3.2.2 -/
theorem SetTheory.Set.not_mem_self (A:Set) : (A:Object) ∉ A := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 25

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1.  The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the empty set.
-/
theorem SetTheory.Set.emptyset_exists (h: axiom_of_universal_specification):
    ∃ (X:Set), ∀ x, x ∉ X := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 26

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

-- Bring the names `Set` and `Object` into the `Chapter3` namespace.
export SetTheory (Set Object)

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/-- Exercise 3.2.3 -/
theorem SetTheory.Set.univ_iff :
    axiom_of_universal_specification ↔ ∃ (U : Set), ∀ x, x ∈ U := by
  sorry

end Chapter3

-----------------------------------

Section_3_2: Example 27

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Axiom 3.8 (Universal specification) -/
abbrev axiom_of_universal_specification : Prop :=
  ∀ P : Object → Prop, ∃ A : Set, ∀ x : Object, x ∈ A ↔ P x

/--
  Exercise 3.2.1. The spirit of the exercise is to establish these results without using either
  Russell's paradox, or the union operation.
-/
theorem SetTheory.Set.union_exists (h: axiom_of_universal_specification) (A B:Set):
    ∃ (Z:Set), ∀ z, z ∈ Z ↔ z ∈ A ∨ z ∈ B := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 28

import Mathlib.Tactic

/-!
Minimal setup to compile the requested theorem from Section 3.3.

We provide:
- a minimal ExistsUnique API (choose) needed for nonconstructive evaluation of Chapter 3 functions
- a lightweight Chapter3 namespace with:
  - an alias `Set := Type u`
  - the Chapter 3 `Function X Y` structure with unique graph
  - coercion of `Function X Y` to an actual function `X → Y`
  - construction `mk_fn` from a function
  - composition `○`
  - the predicate `one_to_one`
  - the requested (unsolved) theorem `Function.comp_of_inj`
-/

-- Minimal API for ExistsUnique (unique choice)
noncomputable def ExistsUnique.choose {α : Sort*} {p : α → Prop} (h : ∃! x, p x) : α :=
  h.exists.choose

theorem ExistsUnique.choose_spec {α : Sort*} {p : α → Prop} (h : ∃! x, p x) :
    p h.choose :=
  h.exists.choose_spec

theorem ExistsUnique.choose_eq {α : Sort*} {p : α → Prop} (h : ∃! x, p x) {x : α}
    (hx : p x) : h.choose = x :=
  h.unique h.choose_spec hx


namespace Chapter3

universe u

-- In this minimal standalone, a "Set" is just a type.
abbrev Set := Type u

/--
Chapter 3 notion of a function `Function X Y`: a relation with unique output for each input.
-/
@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y

/-- Turn a Chapter 3 function into an actual function `X → Y` (uses unique choice). -/
noncomputable def Function.to_fn {X Y : Set} (f : Function X Y) : X → Y :=
  fun x => (f.unique x).choose

/-- Coerce a Chapter 3 function to a genuine function `X → Y`. -/
noncomputable instance Function.instCoeFun (X Y : Set) :
    CoeFun (Function X Y) (fun _ => X → Y) where
  coe := Function.to_fn

/-- Build a Chapter 3 function from a genuine function `X → Y`. -/
noncomputable abbrev Function.mk_fn {X Y : Set} (f : X → Y) : Function X Y :=
  { P := fun x y => y = f x
    unique := by
      intro x
      refine ⟨f x, rfl, ?_⟩
      intro y hy
      simpa using hy }

/-- Composition of Chapter 3 functions. -/
noncomputable abbrev Function.comp {X Y Z : Set} (g : Function Y Z) (f : Function X Y) :
    Function X Z :=
  Function.mk_fn (fun x => g (f x))

-- Notation for composition (different from Mathlib's `∘`).
infix:90 "○" => Function.comp

/-- One-to-one (injective) Chapter 3 function. -/
abbrev Function.one_to_one {X Y : Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'

/-- The requested theorem (left as a sorry). -/
theorem Function.comp_of_inj {X Y Z : Set} {f : Function X Y} {g : Function Y Z}
    (hf : f.one_to_one) (hg : g.one_to_one) : (g ○ f).one_to_one := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 29

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Tools.ExistsUnique

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

@[ext]
structure Function (X Y: Set) where
  P : X → Y → Prop
  unique : ∀ x: X, ∃! y: Y, P x y

noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=
  fun x ↦ (f.unique x).choose

noncomputable instance Function.instCoefun (X Y: Set) :
    CoeFun (Function X Y) (fun _ ↦ X → Y) where
  coe := Function.to_fn

theorem Function.to_fn_eval {X Y: Set} (f: Function X Y) (x : X) :
    f.to_fn x = f x :=
  rfl

abbrev Function.mk_fn {X Y: Set} (f : X → Y) : Function X Y :=
  { P := fun x y => y = f x
    unique := by
      intro x
      refine ⟨ f x, ?_, ?_ ⟩
      · simp
      · intro y hy; simpa using hy }

noncomputable abbrev Function.comp {X Y Z: Set} (g : Function Y Z) (f : Function X Y) :
    Function X Z :=
  Function.mk_fn (fun x ↦ g (f x))

infix:90 "○" => Function.comp

abbrev Function.one_to_one {X Y: Set} (f : Function X Y) : Prop :=
  ∀ x x' : X, x ≠ x' → f x ≠ f x'

theorem Function.comp_injective {X Y Z:Set} {f: Function X Y} {g : Function Y Z} (hinj :
    (g ○ f).one_to_one) : f.one_to_one := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 30

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Tools.ExistsUnique

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

@[ext]
structure Function (X Y: Set) where
  P : X → Y → Prop
  unique : ∀ x: X, ∃! y: Y, P x y

noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=
  fun x ↦ (f.unique x).choose

noncomputable instance Function.inst_coefn (X Y: Set) :
    CoeFun (Function X Y) (fun _ ↦ X → Y) where
  coe := Function.to_fn

abbrev Function.mk_fn {X Y: Set} (f: X → Y) : Function X Y :=
  Function.mk
    (fun x y ↦ y = f x)
    (by
      intro x
      refine ExistsUnique.intro (f x) ?h_exists ?h_unique
      · simp
      · intro y hy; simpa [hy]
    )

noncomputable abbrev Function.comp {X Y Z: Set} (g: Function Y Z) (f: Function X Y) :
    Function X Z :=
  Function.mk_fn (fun x ↦ g (f x))

infix:90 "○" => Function.comp

abbrev Function.one_to_one {X Y: Set} (f: Function X Y) : Prop :=
  ∀ x x': X, x ≠ x' → f x ≠ f x'

/--
  Exercise 3.3.4.
-/
theorem Function.comp_cancel_left {X Y Z:Set} {f f': Function X Y} {g : Function Y Z}
  (heq : g ○ f = g ○ f') (hg: g.one_to_one) : f = f' := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 31

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Tools.ExistsUnique

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

@[ext]
structure Function (X Y : Set) where
  P : X → Y → Prop
  unique : ∀ x : X, ∃! y : Y, P x y

/--
  Exercise 3.3.1.
-/
theorem Function.refl {X Y:Set} (f: Function X Y) : f = f := by
  sorry

end Chapter3

-----------------------------------

Section_3_3: Example 32

import Mathlib.Tactic
import Analysis.Section_3_1
import Analysis.Tools.ExistsUnique

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/--
  Definition of a function between sets in Chapter 3 style.
-/
@[ext]
structure Function (X Y: Set) where
  P : X → Y → Prop
  unique : ∀ x: X, ∃! y: Y, P x y

/--
  Turn a Chapter 3 function into an actual function between the coerced types.
-/
noncomputable def Function.to_fn {X Y: Set} (f: Function X Y) : X → Y :=
  fun x ↦ (f.unique x).choose

/-- Coercion to function. -/
noncomputable instance Function.inst_coefn (X Y: Set) :
    CoeFun (Function X Y) (fun _ ↦ X → Y) where
  coe := Function.to_fn

/-- One-to-one (injective) Chapter 3 function. -/
abbrev Function.one_to_one {X Y: Set} (f: Function X Y) : Prop :=
  ∀ x x': X, x ≠ x' → f x ≠ f x'

/-- Onto (surjective) Chapter 3 function. -/
abbrev Function.onto {X Y: Set} (f: Function X Y) : Prop :=
  ∀ y: Y, ∃ x: X, f x = y

/-- Bijective Chapter 3 function. -/
abbrev Function.bijective {X Y: Set} (f: Function X Y) : Prop :=
  f.one_to_one ∧ f.onto

/--
  Inverse of a bijective Chapter 3 function.
-/
abbrev Function.inverse {X Y: Set} (f: Function X Y) (h: f.bijective) :
    Function Y X :=
  Function.mk (fun y x ↦ f x = y) (by
    intro y
    apply existsUnique_of_exists_of_unique
    · exact h.2 y
    · intro x₁ x₂ hx₁ hx₂
      classical
      -- If x₁ ≠ x₂ then one-to-one yields f x₁ ≠ f x₂, contradicting hx₁,hx₂.
      by_contra hne
      exact (h.1 x₁ x₂ hne) (by simpa [hx₁, hx₂])
  )

/--
  Exercise 3.3.6 (statement only; proof omitted).
-/
theorem Function.inverse_comp_self {X Y: Set} {f: Function X Y} (h: f.bijective) (x: X) :
    (f.inverse h) (f x) = x := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 33

import Mathlib.Tactic

namespace Chapter3

-- Minimal skeleton needed to state the theorem
class SetTheory where
  Set : Type
  emptyset : Set
  union_pair : Set → Set → Set

export SetTheory (Set)

variable [SetTheory]

instance : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

instance : Union Set where
  union := SetTheory.union_pair

/-- Exercise 3.4.10 -/
theorem SetTheory.Set.union_of_nonempty {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) : I ∪ J ≠ ∅ := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 34

namespace Chapter3

universe u

/-- A minimal stub of the `SetTheory` class sufficient to state the theorem. -/
class SetTheory where
  Set : Type u

export SetTheory (Set)

variable [SetTheory]

/-- Provide a (trivial) subset relation on `Set` so that `⊆` is available. -/
instance SetTheory.Set.instSubset : HasSubset Set where
  Subset _ _ := True

/-- Coerce any `Set` to a type, so functions `X → Y` make sense. We use `PUnit` for all sets. -/
instance SetTheory.Set.instCoeSort : CoeSort Set (Type u) where
  coe _ := PUnit.{u}

namespace SetTheory
namespace Set

/-- Minimal (placeholder) definition of image, sufficient for typechecking the theorem. -/
abbrev image {X Y : Set} (f : X → Y) (S : Set) : Set := S

/-- Minimal (placeholder) definition of preimage, sufficient for typechecking the theorem. -/
abbrev preimage {X Y : Set} (f : X → Y) (U : Set) : Set := U

/--
  The desired theorem from Section 3.4.
  This is left as `sorry`, as requested.
-/
theorem preimage_image_of_inj {X Y:Set} (f:X → Y) :
    (∀ S, S ⊆ X → preimage f (image f S) = S) ↔ Function.Injective f := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_4: Example 35

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

/--
  Exercise 3.4.8.  The point of this exercise is to prove it without using the
  pairwise union operation `∪`.
-/
theorem SetTheory.Set.union_pair_exists (X Y:Set) :
    ∃ Z:Set, ∀ x, x ∈ Z ↔ (x ∈ X ∨ x ∈ Y) := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 36

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- Minimal axioms needed for this snippet. -/
class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  specify (A : Set) (P : Subtype (mem . A) → Prop) : Set

export SetTheory (Set Object)

variable [SetTheory]

/-- Enable `x ∈ X` notation for objects and sets. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- The subtype of elements of a set. -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x ↦ x ∈ A)

/-- Coerce a set to the type of its elements. -/
instance : CoeSort (SetTheory.Set) (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- A convenient alias for specification. -/
abbrev SetTheory.Set.specify (A : Set) (P : A → Prop) : Set := SetTheory.specify A P

/-- Indexed intersection with a dummy base point `β : I`. -/
abbrev SetTheory.Set.iInter' (I : Set) (β : I) (A : I → Set) : Set :=
  (A β).specify (P := fun x ↦ ∀ α : I, x.val ∈ A α)

/-- Exercise 3.4.9: Insensitivity to the choice of base point for `iInter'`. -/
theorem SetTheory.Set.iInter'_insensitive {I : Set} (β β' : I) (A : I → Set) :
    iInter' I β A = iInter' I β' A := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 37

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

open SetTheory.Set

/-- Definition 3.4.1.  Interestingly, the definition does not require S to be a subset of X. -/
abbrev SetTheory.Set.image {X Y : Set} (f : X → Y) (S : Set) : Set :=
  X.replace
    (P := fun x y => f x = y ∧ x.val ∈ S)
    (by
      intro x y y' h
      rcases h with ⟨hy, hy'⟩
      -- from hy.1 : f x = y and hy'.1 : f x = y', deduce y = y'
      simpa [hy.1] using hy'.1)

/--
  Definition 3.4.4 (inverse images).
  Again, it is not required that U be a subset of Y.
-/
abbrev SetTheory.Set.preimage {X Y : Set} (f : X → Y) (U : Set) : Set :=
  X.specify (P := fun x => (f x).val ∈ U)

/-- Exercise 3.4.1 -/
theorem SetTheory.Set.preimage_eq_image_of_inv {X Y V:Set} (f:X → Y) (f_inv: Y → X)
  (hf: Function.LeftInverse f_inv f ∧ Function.RightInverse f_inv f) (hV: V ⊆ Y) :
    image f_inv V = preimage f V := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 38

import Mathlib.Tactic

namespace Chapter3

universe u v

class SetTheory where
  Set : Type u
  Object : Type v
  mem : Object → Set → Prop
  emptyset : Set

export SetTheory (Set Object)

variable [SetTheory]

/-- Enable `x ∈ X` where `x : Object`, `X : Set`. -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Enable `∅ : Set`. -/
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

/-- Coerce a `Set` to a type of its elements (as subtypes of `Object`). -/
abbrev SetTheory.Set.toSubtype (A : Set) := Subtype (fun x : Object => x ∈ A)

instance : CoeSort Set (Type v) where
  coe A := SetTheory.Set.toSubtype A

/-- Provide difference `\` for sets (dummy implementation sufficient for typechecking). -/
instance SetTheory.Set.instSDiff : SDiff Set where
  sdiff X Y := X

/-- Indexed union over a set `I` (dummy implementation sufficient for typechecking). -/
def SetTheory.Set.iUnion (I : Set) (A : I → Set) : Set :=
  SetTheory.emptyset

/-- Indexed intersection over a nonempty index set `I` (dummy implementation sufficient for typechecking). -/
def SetTheory.Set.iInter (I : Set) (hI : I ≠ (∅ : Set)) (A : I → Set) : Set :=
  SetTheory.emptyset

/-- Exercise 3.4.11 -/
theorem SetTheory.Set.compl_iInter {X I: Set} (hI: I ≠ ∅) (A: I → Set) :
    X \ iInter I hI A = iUnion I (fun α ↦ X \ A α) := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 39

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

variable [SetTheory]

/-- A placeholder definition of the power set, sufficient to compile the statement below. -/
def SetTheory.Set.powerset (X : Set) : Set := ∅

@[simp]
theorem SetTheory.Set.mem_powerset {X:Set} (x:Object) :
    x ∈ powerset X ↔ ∃ Y:Set, x = Y ∧ Y ⊆ X := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 40

namespace Chapter3

universe u v

-- A minimal stub of the SetTheory class, just enough for the theorem to typecheck.
class SetTheory where
  Set : Type u
  Object : Type v

export SetTheory (Set Object)

variable [SetTheory]

-- Coerce every set to a (trivial) type so that function arrows X → Y make sense.
instance instSetCoeSort : CoeSort Set (Type v) where
  coe _ := PUnit

-- A placeholder subset relation, only to make the notation ⊆ available.
instance instSetHasSubset : HasSubset Set where
  Subset _ _ := True

-- Minimal placeholders for image and preimage used in Section 3.4.
abbrev SetTheory.Set.image {X Y : Set} (f : X → Y) (S : Set) : Set := Y
abbrev SetTheory.Set.preimage {X Y : Set} (f : X → Y) (U : Set) : Set := X

open SetTheory.Set

-- The requested theorem (left intentionally unsolved).
theorem SetTheory.Set.image_preimage_of_surj {X Y:Set} (f:X → Y) :
    (∀ S, S ⊆ Y → image f (preimage f S) = S) ↔ Function.Surjective f := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 41

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

@[coe]
def SetTheory.Set.coe_of_fun {X Y:Set} (f: X → Y) : Object :=
  SetTheory.function_to_object X Y f

instance SetTheory.Set.inst_coe_of_fun {X Y:Set} : CoeOut (X → Y) Object where
  coe := SetTheory.Set.coe_of_fun

/-- Exercise 3.4.7 -/
theorem SetTheory.Set.partial_functions {X Y:Set} :
    ∃ Z:Set, ∀ F:Object, F ∈ Z ↔ ∃ X' Y':Set, X' ⊆ X ∧ Y' ⊆ Y ∧ ∃ f: X' → Y', F = f := by
  sorry

end Chapter3

-----------------------------------

Section_3_4: Example 42

import Mathlib.Tactic

namespace Chapter3

universe u v

/-- A minimal version of the ZF-style set theory interface needed to state the theorem. -/
class SetTheory where
  Set : Type u
  Object : Type v
  set_to_object : Set ↪ Object
  mem : Object → Set → Prop
  extensionality (X Y : Set) : (∀ x, mem x X ↔ mem x Y) → X = Y
  emptyset: Set
  emptyset_mem : ∀ x, ¬ mem x emptyset
  singleton : Object → Set
  singleton_axiom : ∀ x y, mem x (singleton y) ↔ x = y
  union_pair : Set → Set → Set
  union_pair_axiom : ∀ X Y x, mem x (union_pair X Y) ↔ (mem x X ∨ mem x Y)
  specify (A : Set) (P : Subtype (mem · A) → Prop) : Set
  specification_axiom (A : Set) (P : Subtype (mem · A) → Prop) :
    (∀ x, mem x (specify A P) → mem x A) ∧
    ∀ x : Subtype (mem · A), mem x.val (specify A P) ↔ P x

export SetTheory (Set Object)

variable [SetTheory]

/-- Definition 3.1.1 (objects can be elements of sets) -/
instance SetTheory.objects_mem_sets : Membership Object Set where
  mem X x := SetTheory.mem x X

/-- Axiom 3.1 (Sets are objects)-/
instance SetTheory.sets_are_objects : Coe Set Object where
  coe X := SetTheory.set_to_object X

/-- Axiom 3.2 (Equality of sets). -/
@[ext]
theorem SetTheory.Set.ext {X Y:Set} (h: ∀ x, x ∈ X ↔ x ∈ Y) : X = Y :=
  SetTheory.extensionality _ _ h

instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

@[simp]
theorem SetTheory.Set.not_mem_empty : ∀ x, x ∉ (∅:Set) := SetTheory.emptyset_mem

instance SetTheory.Set.instUnion : Union Set where
  union := SetTheory.union_pair

@[simp]
theorem SetTheory.Set.mem_union (x:Object) (X Y:Set) : x ∈ (X ∪ Y) ↔ (x ∈ X ∨ x ∈ Y) :=
  SetTheory.union_pair_axiom X Y x

abbrev SetTheory.Set.toSubtype (A:Set) := Subtype (fun x ↦ x ∈ A)

instance : CoeSort (Set) (Type v) where
  coe A := A.toSubtype

abbrev SetTheory.Set.specify (A:Set) (P: A → Prop) : Set := SetTheory.specify A P

/-- Axiom 3.6 (axiom of specification) -/
theorem SetTheory.Set.specification_axiom {A:Set} {P: A → Prop} {x:Object} (h: x ∈ A.specify P) :
    x ∈ A :=
  (SetTheory.specification_axiom A P).1 x h

/-- Axiom 3.6 (axiom of specification) -/
theorem SetTheory.Set.specification_axiom' {A:Set} (P: A → Prop) (x:A) :
    x.val ∈ A.specify P ↔ P x :=
  (SetTheory.specification_axiom A P).2 x

instance SetTheory.Set.instIntersection : Inter Set where
  inter X Y := X.specify (fun x ↦ x.val ∈ Y)

/-- A helper lemma used to obtain an element from a nonempty set (as a hypothesis) -/
lemma SetTheory.Set.eq_empty_iff_forall_notMem {X:Set} : X = ∅ ↔ (∀ x, x ∉ X) := by
  sorry

/-- Lemma 3.1.5 (Single choice) -/
lemma SetTheory.Set.nonempty_def {X:Set} (h: X ≠ ∅) : ∃ x, x ∈ X := by
  sorry

namespace SetTheory.Set

open Classical

/-- Indexed intersection -/
noncomputable abbrev nonempty_choose {I:Set} (hI: I ≠ ∅) : I :=
  ⟨(nonempty_def hI).choose, (nonempty_def hI).choose_spec⟩

abbrev iInter' (I:Set) (β:I) (A: I → Set) : Set :=
  (A β).specify (P := fun x ↦ ∀ α:I, x.val ∈ A α)

noncomputable abbrev iInter (I: Set) (hI: I ≠ ∅) (A: I → Set) : Set :=
  iInter' I (nonempty_choose hI) A

theorem mem_iInter {I:Set} (hI: I ≠ ∅) (A: I → Set) (x:Object) :
    x ∈ iInter I hI A ↔ ∀ α:I, x ∈ A α := by
  sorry

/-- Exercise 3.4.10 -/
theorem union_of_nonempty {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) : I ∪ J ≠ ∅ := by
  sorry

/-- Exercise 3.4.10 -/
theorem inter_iInter {I J:Set} (hI: I ≠ ∅) (hJ: J ≠ ∅) (A: (I ∪ J:Set) → Set) :
    iInter I hI (fun α ↦ A ⟨ α.val, by simp [α.property]⟩)
    ∩ iInter J hJ (fun α ↦ A ⟨ α.val, by simp [α.property]⟩)
    = iInter (I ∪ J) (union_of_nonempty hI hJ) A := by
  sorry

end SetTheory.Set

end Chapter3

-----------------------------------

Section_3_4: Example 43

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

open SetTheory.Set

/--
  Definition 3.4.4 (inverse images).
  Again, it is not required that U be a subset of Y.
-/
abbrev SetTheory.Set.preimage {X Y:Set} (f:X → Y) (U: Set) : Set :=
  X.specify (P := fun x ↦ (f x).val ∈ U)

@[simp]
theorem SetTheory.Set.mem_preimage {X Y:Set} (f:X → Y) (U: Set) (x:X) :
    x.val ∈ preimage f U ↔ (f x).val ∈ U := by
  simpa [SetTheory.Set.preimage] using
    (SetTheory.Set.specification_axiom' (A := X) (P := fun x : X => (f x).val ∈ U) x)

/-- Exercise 3.4.4 -/
theorem SetTheory.Set.preimage_of_inter {X Y:Set} (f:X → Y) (A B: Set) :
    preimage f (A ∩ B) = (preimage f A) ∩ (preimage f B) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 44

import Mathlib.Tactic

namespace SetTheory
namespace Set

/-- For the purposes of this theorem, we use the standard natural numbers. -/
abbrev nat := ℕ

/-- A recursion principle along the natural numbers (stated but not proven). -/
theorem recursion (X: Type) (f: nat → X → X) (c:X) :
    ∃! a: nat → X, a 0 = c ∧ ∀ n, a (n + 1:ℕ) = f n (a n) := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_5: Example 45

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object nat)

variable [SetTheory]

theorem SetTheory.Set.nat_unique (nat':Set) (zero:nat') (succ:nat' → nat')
  (succ_ne: ∀ n:nat', succ n ≠ zero) (succ_of_ne: ∀ n m:nat', n ≠ m → succ n ≠ succ m)
  (ind: ∀ P: nat' → Prop, P zero → (∀ n, P n → P (succ n)) → ∀ n, P n) :
    ∃! f : nat → nat', Function.Bijective f ∧ f 0 = zero
    ∧ ∀ (n:nat) (n':nat'), f n = n' ↔ f (n+1:ℕ) = succ n' := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 46

import Mathlib.Tactic

namespace Chapter3

universe u v w

-- Minimal skeleton to support the statement
class SetTheory where
  Set : Type u

export SetTheory (Set)

variable [SetTheory]

-- Use the standard SDiff typeclass (for the "\" notation)
instance (priority := 1000) instSDiffSet : SDiff Set where
  sdiff X Y := X

-- Provide a minimal SProd typeclass to support the "×ˢ" notation
class SProd (α : Type u) (β : Type v) (γ : Type w) where
  sprod : α → β → γ

infixl:82 " ×ˢ " => SProd.sprod

instance (priority := 1000) instSProdSet : SProd Set Set Set where
  sprod X Y := X

-- Target theorem (left as sorry as requested)
theorem SetTheory.Set.diff_prod (A B C : Set) :
    (A \ B) ×ˢ C = (A ×ˢ C) \ (B ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 47

import Mathlib.Tactic

/-!
Minimal scaffolding to state (but not prove) the theorem
`SetTheory.Set.prod_subset_prod` from Section 3.5.
We only introduce the minimal types, instances, and notation
needed for the statement to compile.
-/

namespace Chapter3

universe u

/-- Minimal version of the `SetTheory` class providing just enough structure
to state the theorem. -/
class SetTheory where
  /-- The type of sets used in Chapter 3. -/
  Set : Type u
  /-- An "empty" set to support the `∅` notation. -/
  empty : Set
  /-- A Cartesian product operation on sets to support the `×ˢ` notation. -/
  cart : Set → Set → Set
  /-- A subset relation to support the `⊆` notation. -/
  subset : Set → Set → Prop

attribute [simp] SetTheory.empty

variable [SetTheory]

/-- Provide the `∅` notation for Chapter 3 sets. -/
instance : EmptyCollection SetTheory.Set where
  emptyCollection := (inferInstanceAs SetTheory).empty

/-- Provide the `⊆` (subset) notation for Chapter 3 sets. -/
instance : HasSubset SetTheory.Set where
  Subset := (inferInstanceAs SetTheory).subset

/-- Convenience alias for the cartesian product in the active `SetTheory` instance. -/
@[inline] def cartesian (A B : SetTheory.Set) : SetTheory.Set :=
  (inferInstanceAs SetTheory).cart A B

/-- Provide the `×ˢ` notation (cartesian product) for Chapter 3 sets. -/
notation:80 A:80 " ×ˢ " B:81 => cartesian A B

/--
  Exercise 3.5.6 (statement only; proof omitted).
  With the minimal structure above, we can state the theorem as requested.
-/
theorem SetTheory.Set.prod_subset_prod {A B C D : SetTheory.Set}
  (hA : A ≠ ∅) (hB : B ≠ ∅) (hC : C ≠ ∅) (hD : D ≠ ∅) :
    A ×ˢ B ⊆ C ×ˢ D ↔ A ⊆ C ∧ B ⊆ D := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 48

import Mathlib.Tactic

namespace Chapter3

namespace SetTheory

-- Minimal stand-ins for the objects and sets used in Section 3.5
abbrev Object : Type := Nat

-- Use Mathlib's `Set` of `Object`s as our notion of sets
abbrev Set := _root_.Set Object

-- Coerce a `Set` to the subtype of its elements so that we can write `x : X`
instance : CoeSort Set (Type) where
  coe X := {x : Object // x ∈ X}

namespace Set

-- The tuple structure needed for the theorem
structure Tuple (n : ℕ) where
  X   : Set
  x   : Fin n → X
  surj : Function.Surjective x

-- The requested theorem (left intentionally unsolved)
theorem Tuple.eq {n : ℕ} (t t' : Tuple n) :
    t = t' ↔ ∀ n : Fin n, ((t.x n) : Object) = ((t'.x n) : Object) := by
  sorry

end Set

end SetTheory

end Chapter3

-----------------------------------

Section_3_5: Example 49

import Mathlib.Tactic

namespace Chapter3

/--
A minimal scaffolding sufficient to state the theorem.

We only introduce:
- a class `SetTheory` providing abstract types `Set` and `Object`;
- a binary union operation `∪` on `Set`;
- a binary product notation `×ˢ` on `Set`.

No axioms or semantics are provided, since the theorem is left as `sorry`.
-/
class SetTheory where
  Set : Type
  Object : Type

export SetTheory (Set Object)

variable [SetTheory]

namespace SetTheory

namespace Set

-- A minimal (dummy) union on `Set` to support the notation `∪`.
def union (X Y : Set) : Set := X
instance : Union Set where
  union := union

-- A minimal (dummy) cartesian product on `Set` to support the notation `×ˢ`.
def sprod (X Y : Set) : Set := X

-- Provide the `×ˢ` notation.
infixl:73 " ×ˢ " => Set.sprod

end Set
end SetTheory

/-- Exercise 3.5.4 (stated, not proved). -/
theorem SetTheory.Set.union_prod (A B C : Set) :
    (A ∪ B) ×ˢ C = (A ×ˢ C) ∪ (B ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 50

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Definition 3.5.1 (Ordered pair). -/
@[ext]
structure OrderedPair where
  fst : Object
  snd : Object

namespace SetTheory.Set

/--
  A technical operation, turning an object `x` and a set `Y` into the set `{x} × Y`,
  needed to define the full Cartesian product.
-/
abbrev slice (x : Object) (Y : Set) : Set :=
  Y.replace
    (P := fun (y : Y) (z : Object) => z = (⟨x, y⟩ : OrderedPair))
    (by
      intro y z z' h
      rcases h with ⟨hz, hz'⟩
      simpa [hz, hz']
    )

/-- Definition 3.5.4 (Cartesian product). -/
abbrev cartesian (X Y : Set) : Set :=
  SetTheory.union
    (X.replace
      (P := fun (x : X) (z : Object) => z = slice x Y)
      (by
        intro x z z' h
        rcases h with ⟨hz, hz'⟩
        simpa [hz, hz']
      ))

/-- Provide ×ˢ notation for the Cartesian product. -/
scoped infixl:82 " ×ˢ " => SetTheory.Set.cartesian

/-- Exercise 3.5.4 (statement only). -/
theorem inter_prod (A B C : Set) : (A ∩ B) ×ˢ C = (A ×ˢ C) ∩ (B ×ˢ C) := by
  sorry

end SetTheory.Set

end Chapter3

-----------------------------------

Section_3_5: Example 51

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

-- A minimal stub definition of `graph` sufficient to state `graph_inj`.
-- We avoid importing Section 3.5 and thus provide a placeholder.
abbrev SetTheory.Set.graph {X Y : Set} (_f : X → Y) : Set := (∅ : Set)

-- The requested theorem, left as `sorry` as instructed.
theorem SetTheory.Set.graph_inj {X Y:Set} (f f': X → Y) :
    graph f = graph f' ↔ f = f' := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 52

namespace Chapter3

namespace SetTheory

/-- A minimal placeholder for the `Set` type used in Section 3.5. -/
structure Set : Type :=
  (dummy : Unit := ())

namespace Set

/-- Placeholder binary union on sets, needed only for the statement. -/
def union (A B : Set) : Set := A

/-- Placeholder Cartesian product on sets, needed only for the statement. -/
def prod (A B : Set) : Set := A

notation:65 A:66 " ∪ " B:67 => union A B
notation:80 A:81 " ×ˢ " B:82 => prod A B

/-- Exercise 3.5.4 (placeholder, unsolved) -/
theorem prod_union (A B C : Set) : A ×ˢ (B ∪ C) = (A ×ˢ B) ∪ (A ×ˢ C) := by
  sorry

end Set

end SetTheory

end Chapter3

-----------------------------------

Section_3_5: Example 53

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

-- A minimal placeholder for the Cartesian product to support the ×ˢ notation.
def SetTheory.Set.cartesian (X Y : Set) : Set := ∅

-- Provide the ×ˢ notation for our placeholder Cartesian product.
infixl:70 " ×ˢ " => SetTheory.Set.cartesian

-- The requested theorem statement, left as sorry.
theorem SetTheory.Set.prod_inter (A B C : Set) :
    A ×ˢ (B ∩ C) = (A ×ˢ B) ∩ (A ×ˢ C) := by
  sorry

end Chapter3

-----------------------------------

Section_3_5: Example 54

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

namespace SetTheory.Set

/-- Minimal placeholder for the Cartesian product; we only need its notation for the theorem. -/
def cartesian (X Y : Set) : Set := X

scoped infixl:74 " ×ˢ " => SetTheory.Set.cartesian

/-- Exercise 3.5.4 -/
theorem prod_diff (A B C : Set) : A ×ˢ (B \ C) = (A ×ˢ B) \ (A ×ˢ C) := by
  sorry

end SetTheory.Set

end Chapter3

-----------------------------------

Section_3_5: Example 55

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

namespace SetTheory.Set

-- A minimal stub of a Cartesian product, solely to support the statement.
def cartesian (X Y : Set) : Set := (∅ : Set)

scoped infix:70 " ×ˢ " => SetTheory.Set.cartesian

-- Minimal stubs for the projections, only to typecheck the theorem statement.
axiom fst {X Y : Set} (z : X ×ˢ Y) : X
axiom snd {X Y : Set} (z : X ×ˢ Y) : Y

-- The requested theorem, left unsolved as specified.
theorem direct_sum {X Y Z:Set} (f: Z → X) (g: Z → Y) :
    ∃! h: Z → X ×ˢ Y, fst ∘ h = f ∧ snd ∘ h = g := by
  sorry

end SetTheory.Set

end Chapter3

-----------------------------------

Section_3_6: Example 56

import Mathlib.Tactic

/-!
A minimal self-contained environment to state the requested theorem from Section 3.6.
We model Chapter 3 "sets" as plain types and define just enough infrastructure
(EqualCard and the ×ˢ notation) to typecheck the theorem, which is left as `sorry`.
-/

namespace Chapter3

universe u

namespace SetTheory

-- For this minimal stub, treat "sets" as types.
abbrev Set : Type (u + 1) := Type u

namespace Set

-- EqualCard: there exists a bijection between the underlying types.
abbrev EqualCard (X Y : SetTheory.Set) : Prop := ∃ f : X → Y, Function.Bijective f

-- Cartesian product notation ×ˢ between "sets" (i.e., types).
def sprod (X Y : SetTheory.Set) : SetTheory.Set := X × Y
infixl:70 " ×ˢ " => sprod

end Set
end SetTheory

open SetTheory SetTheory.Set

-- The requested theorem, left as a placeholder.
theorem SetTheory.Set.prod_EqualCard_prod (A B : Set) :
    EqualCard (A ×ˢ B) (B ×ˢ A) := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 57

import Mathlib.Tactic

/-!
This file provides a minimal stub of the Chapter 3 set-theory framework
sufficient only to state (but not prove) the theorem
`SetTheory.Set.pigeonhole_principle`. All notions are skeletal and only serve
to make the statement typecheck; they do not carry any actual semantics.
-/

namespace Chapter3

namespace SetTheory

/-- Minimal stand-in for the "Set" notion used in Chapter 3. We take it to be just a type. -/
abbrev Set := Type

namespace Set

/-- Minimal stand-in for the Chapter 3 "Fin n" (as a set coerced to a type).
We simply reuse Mathlib's `Fin n`. -/
abbrev Fin (n : ℕ) : Set := _root_.Fin n

/-- Minimal placeholder for the indexed union construction, returning a dummy "set". -/
noncomputable def iUnion (I : Set) (A : I → Set) : Set := PUnit

/-- Minimal placeholder for the "cardinality" of a set, returning a dummy natural number. -/
noncomputable def card (X : Set) : ℕ := 0

/-- Minimal placeholder for the "finite" predicate on sets. -/
def finite (X : Set) : Prop := True

/--
The desired theorem from Section 3.6, stated in this minimal framework.
Do not change its name or statement. The proof is omitted.
-/
theorem pigeonhole_principle {n : ℕ} {A : Fin n → Set}
  (hA : ∀ i, (A i).finite) (hAcard : (iUnion _ A).card > n) :
  ∃ i, (A i).card ≥ 2 := by
  sorry

end Set
end SetTheory
end Chapter3

-----------------------------------

Section_3_6: Example 58

import Mathlib.Tactic

namespace Chapter3

universe u v

-- Minimal skeleton of the set theory framework needed to state the theorem
class SetTheory where
  Set : Type u
  Object : Type v
  emptyset : Set

export SetTheory (Set Object)

variable [SetTheory]

-- Provide notation ∅ for the empty set
instance SetTheory.Set.instEmpty : EmptyCollection Set where
  emptyCollection := SetTheory.emptyset

-- Minimal placeholder for the cardinality predicate
abbrev SetTheory.Set.has_card (X : Set) (n : ℕ) : Prop := True

-- Target theorem (left as sorry as requested)
theorem SetTheory.Set.has_card_zero {X : Set} : X.has_card 0 ↔ X = ∅ := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 59

import Mathlib.Tactic

/-!
  Minimal scaffolding to compile the statement

  theorem SetTheory.Set.card_union_add_card_inter
-/

namespace Chapter3

namespace SetTheory

/-- A minimal abstract type of sets to host the theorem statement. -/
constant Set : Type

namespace Set

/-- Abstract union operation on sets (used for `∪` notation). -/
constant union : Set → Set → Set
/-- Abstract intersection operation on sets (used for `∩` notation). -/
constant inter : Set → Set → Set
/-- Abstract finiteness predicate on sets. -/
constant finite : Set → Prop
/-- Abstract cardinality function on sets. -/
constant card : Set → ℕ

/-- Provide `∪` notation for our abstract sets. -/
instance instUnion : Union Set where
  union := union

/-- Provide `∩` notation for our abstract sets. -/
instance instInter : Inter Set where
  inter := inter

end Set
end SetTheory

/-- The requested theorem statement, left as `sorry` as required. -/
theorem SetTheory.Set.card_union_add_card_inter
    {A B : SetTheory.Set} (hA : SetTheory.Set.finite A) (hB : SetTheory.Set.finite B) :
    SetTheory.Set.card A + SetTheory.Set.card B
      = SetTheory.Set.card (A ∪ B) + SetTheory.Set.card (A ∩ B) := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 60

import Mathlib.Tactic
import Mathlib.Data.Nat.Parity

namespace Chapter3

/--
A very small skeleton of the Chapter 3 SetTheory used only to typecheck the requested theorem.
This is intentionally minimal and does not implement the full set-theoretic machinery.
-/
class SetTheory where
  Set : Type _
  nat : Set
  specify : (A : Set) → (A → Prop) → Set

/-- Treat any `SetTheory.Set` as a (dummy) type so that arrows `X → Y` make sense. -/
instance (S : SetTheory) : CoeSort S.Set (Type _) where
  coe _ := PUnit

/-- Coerce elements of `S.nat` to natural numbers so expressions like `(x : ℕ)` typecheck. -/
instance (S : SetTheory) : Coe S.nat ℕ where
  coe _ := 0

namespace SetTheory
namespace Set

variable [S : SetTheory]

/-- Equal cardinality: existence of a bijection. -/
abbrev EqualCard (X Y : S.Set) : Prop := ∃ f : X → Y, Function.Bijective f

/-- The dot-notation wrapper for `specify`. -/
abbrev specify (A : S.Set) (P : A → Prop) : S.Set := S.specify A P

/-- Example 3.6.3 (left as `sorry` per the instructions). -/
theorem Example_3_6_3 :
    EqualCard S.nat (S.nat.specify (fun x => Even (x : ℕ))) := by
  sorry

end Set
end SetTheory
end Chapter3

-----------------------------------

Section_3_6: Example 61

namespace Chapter3

namespace SetTheory

/-- Minimal stub type to model sets for this compilation target. -/
def Set : Type := Unit

namespace Set

/-- Minimal stub: a "cardinality" function on our stub `Set` type. -/
def card (_ : Set) : ℕ := 0

/-- Minimal stub: the set of permutations on `Fin n`. -/
def Permutations (_n : ℕ) : Set := ()

/-- Target theorem from Section 3.6, stated but left unproved as requested. -/
theorem Permutations_ih (n: ℕ):
    (Permutations (n + 1)).card = (n + 1) * (Permutations n).card := by
  sorry

end Set
end SetTheory

end Chapter3

-----------------------------------

Section_3_6: Example 62

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

-- Minimal stub for has_card used in Section 3.6
abbrev SetTheory.Set.has_card (X : Set) (n : ℕ) : Prop := True

-- Requested theorem (left intentionally unsolved)
theorem SetTheory.Set.Example_3_6_7a (a : Object) : ({a} : Set).has_card 1 := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 63

import Mathlib.Data.Fin.Basic

-- Minimal scaffolding to place the theorem under the requested namespace and name.
namespace SetTheory

-- Provide a `nat` alias compatible with the statement (as used in the chapter files).
abbrev nat := ℕ

namespace Set

-- Do not solve; just provide a compilable stub with the correct name and statement.
theorem bounded_on_finite {n : ℕ} (f : Fin n → nat) : ∃ M, ∀ i, (f i : ℕ) ≤ M := by
  sorry

end Set
end SetTheory

-----------------------------------

Section_3_6: Example 64

import Mathlib.Tactic
import Analysis.Section_3_1

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

namespace SetTheory.Set

/-- Minimal placeholder definition so the statement typechecks. -/
def finite (X : Set) : Prop := True

/-- Minimal placeholder definition so the statement typechecks. -/
noncomputable def card (X : Set) : ℕ := 0

/--
A compilable (unsolved) version of the requested theorem from Section 3.6.
Do not change the theorem name; we provide a stub proof with `sorry`.
-/
theorem card_eq_zero_of_empty {X:Set} (hX: X.finite) :
    X.card = 0 ↔ X = ∅ := by
  sorry

end SetTheory.Set

end Chapter3

-----------------------------------

Section_3_6: Example 65

import Mathlib.Tactic

/-!
A minimal stub to make the requested theorem compile.

We set up a tiny environment with just enough structure so the statement typechecks.
-/

namespace Chapter3

universe u

-- Treat `Set` as a type of types, so we can write `X → Y`.
abbrev Set : Type (u+1) := Type u

-- Provide a (dummy) subset relation so that `S ⊆ X` is well-typed.
instance : HasSubset Set where
  Subset _ _ := Prop

-- Minimal namespace and operations needed by the theorem statement.
namespace SetTheory
  namespace Set
    -- A stub for the image of a function `f : X → Y` on a “set” `S : Set`.
    abbrev image {X Y : Chapter3.Set} (f : X → Y) (S : Chapter3.Set) : Chapter3.Set := Y
    -- A stub “cardinality” function so `S.card` is well-typed.
    def card (S : Chapter3.Set) : Nat := 0
  end Set
end SetTheory

open SetTheory.Set

-- Do not change the theorem name and do not solve it.
theorem SetTheory.Set.two_to_two_iff {X Y : Set} (f : X → Y) :
    Function.Injective f ↔
    ∀ S ⊆ X, S.card = 2 → (image f S).card = 2 := by
  sorry

end Chapter3

-----------------------------------

Section_3_6: Example 66

import Mathlib.Tactic
import Analysis.Section_3_5

namespace Chapter3

export SetTheory (Set Object)

variable [SetTheory]

/-- Equal cardinality between two sets: existence of a bijection. -/
abbrev SetTheory.Set.EqualCard (X Y:Set) : Prop := ∃ f : X → Y, Function.Bijective f

/-- Exercise 3.6.6 (statement only). -/
theorem SetTheory.Set.pow_pow_EqualCard_pow_prod (A B C:Set) :
    EqualCard ((A ^ B) ^ C) (A ^ (B ×ˢ C)) := by
  sorry

end Chapter3

-----------------------------------

Section_4_1: Example 67

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Section_4_1

/-- For this theorem, we reuse the standard integers ℤ from Lean/mathlib. -/
abbrev Int := _root_.Int

/-- Exercise 4.1.9. The square of any integer is nonnegative. -/
theorem Int.sq_nonneg (n : Int) : 0 ≤ n * n := by
  sorry

end Section_4_1

-----------------------------------

Section_4_1: Example 68

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

/-!
We provide a minimal setup sufficient to state the requested theorem from Section 4.1.
Here, we identify the section's `Int` with Lean's built-in integers.
-/

namespace Section_4_1

abbrev Int := _root_.Int

/-- Exercise 4.1.8 -/
theorem Int.no_induction :
    ∃ P : Int → Prop,
      (P 0 ∧ ∀ n, P n → P (n + 1)) ∧ ¬ ∀ n, P n := by
  sorry

end Section_4_1

-----------------------------------

Section_4_1: Example 69

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Section_4_1

abbrev Int := ℤ

theorem Int.sq_nonneg' (n : Int) : ∃ (m : Nat), n * n = m := by
  sorry

end Section_4_1

-----------------------------------

Section_4_2: Example 70

import Mathlib.Tactic
import Mathlib.Algebra.Group.MinimalAxioms

namespace Section_4_2

/-- A minimal stub for the rationals used in Section 4.2. -/
structure Rat where
  val : Int
deriving Repr, Inhabited, DecidableEq

instance : Mul Rat where
  mul x y := ⟨x.val * y.val⟩

instance : LT Rat where
  lt x y := x.val < y.val

namespace Rat

/-- Negativity predicate (stub): a rational is negative if its underlying integer is negative. -/
def isNeg (q : Section_4_2.Rat) : Prop :=
  q.val < 0

/-- Exercise 4.2.6 (stubbed statement, not proved) -/
theorem mul_lt_mul_right_of_neg
    (x y z : Section_4_2.Rat) (hxy : x < y) (hz : z.isNeg) : x * z > y * z := by
  sorry

end Rat

end Section_4_2

-----------------------------------

Section_4_3: Example 71

import Mathlib.Tactic

namespace Section_4_3

/-- Exercise 4.3.5 -/
theorem two_pow_geq (N : ℕ) : 2 ^ N ≥ N := by
  sorry

end Section_4_3

-----------------------------------

Section_4_4: Example 72

import Mathlib.Tactic

/-- Exercise 4.4.2 -/
theorem Nat.no_infinite_descent : ¬ ∃ a:ℕ → ℕ, ∀ n, a (n+1) < a n := by
  sorry

-----------------------------------

Section_5_1: Example 73

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Real.Floor

/--
  A basic notion of ε-closeness on the rationals.
-/
def Rat.Close (ε : ℚ) (x y : ℚ) : Prop := |x - y| ≤ ε

namespace Chapter5

/--
  Definition 5.1.1 (Sequence). To avoid some technicalities involving dependent types, we extend
  sequences by zero to the left of the starting point `n₀`.
-/
structure Sequence where
  n₀ : ℤ
  seq : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0

/-- Sequences can be thought of as functions from ℤ to ℚ. -/
instance : CoeFun Sequence (fun _ ↦ ℤ → ℚ) where
  coe := fun a ↦ a.seq

/--
Functions from ℕ to ℚ can be thought of as sequences starting from 0; `ofNatFun` performs this conversion.
-/
def Sequence.ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if h : n ≥ 0 then a n.toNat else 0
  vanish := by
    intro n hn
    have h' : ¬ n ≥ 0 := by exact not_le.mpr hn
    simp [h']

/--
If `a : ℕ → ℚ` is used in a context where a `Sequence` is expected, automatically coerce `a`.
-/
instance : Coe (ℕ → ℚ) Sequence where
  coe := Sequence.ofNatFun

/--
A slight generalization of Definition 5.1.3 - definition of ε-steadiness for a sequence with an
arbitrary starting point n₀
-/
abbrev Rat.Steady (ε : ℚ) (a : Sequence) : Prop :=
  ∀ n ≥ a.n₀, ∀ m ≥ a.n₀, Rat.Close ε (a n) (a m)

/--
  The sequence of rational truncations of √2 in base 10.
-/
noncomputable def Sequence.sqrt_two : Sequence :=
  (fun n : ℕ ↦ ((⌊(Real.sqrt 2) * (10 : ℝ) ^ n⌋ / (10 : ℚ) ^ n) : ℚ))

/--
  Example 5.1.10 (part a). We leave the proof as `sorry` as requested.
-/
theorem Sequence.ex_5_1_10_a : (1 : ℚ).Steady sqrt_two := by
  sorry

end Chapter5

-----------------------------------

Section_5_2: Example 74

import Mathlib.Tactic
import Analysis.Section_5_1

/-!
Minimal setup from Section 5.2 needed for the theorem statement.
-/

abbrev Rat.CloseSeq (ε : ℚ) (a b : Chapter5.Sequence) : Prop :=
  ∀ n : ℤ, n ≥ a.n₀ → n ≥ b.n₀ → ε.Close (a n) (b n)

abbrev Rat.EventuallyClose (ε : ℚ) (a b : Chapter5.Sequence) : Prop :=
  ∃ N : ℤ, ε.CloseSeq (a.from N) (b.from N)

namespace Chapter5

/-- Exercise 5.2.2 (statement only). -/
theorem Sequence.isBounded_of_eventuallyClose
    {ε : ℚ} {a b : ℕ → ℚ} (hab : ε.EventuallyClose a b) :
    (a : Sequence).IsBounded ↔ (b : Sequence).IsBounded := by
  sorry

end Chapter5

-----------------------------------

Section_5_3: Example 75

import Mathlib.Tactic

/-!
Minimal context to compile the theorem

We introduce a lightweight version of Chapter 5's `Sequence`, along with the
notions of boundedness and equivalence sufficient for the statement.
-/

namespace Chapter5

-- A basic definition of sequences (indexed by ℤ) with a starting index n₀ and zero extension to the left.
@[ext]
structure Sequence where
  n₀     : ℤ
  seq    : ℤ → ℚ
  vanish : ∀ n < n₀, seq n = 0

-- Allow writing `a n` for `a : Sequence`.
instance : CoeFun Sequence (fun _ => ℤ → ℚ) where
  coe a := a.seq

/-- View a function `ℕ → ℚ` as a `Sequence` starting at 0, extended by 0 to the left. -/
def Sequence.ofNatFun (a : ℕ → ℚ) : Sequence where
  n₀ := 0
  seq n := if h : n ≥ 0 then a n.toNat else 0
  vanish := by
    intro n hn
    have h' : ¬ n ≥ 0 := by exact not_le.mpr hn
    simp [h']

-- When a `Sequence` is expected, coerce a function `ℕ → ℚ` to the above construction.
instance : Coe (ℕ → ℚ) Sequence where
  coe := Sequence.ofNatFun

/-- Boundedness of a sequence by M: all values have absolute value ≤ M. -/
abbrev Sequence.BoundedBy (a : Sequence) (M : ℚ) : Prop :=
  ∀ n, |a n| ≤ M

/-- A sequence is bounded if it is bounded by some nonnegative M. -/
abbrev Sequence.IsBounded (a : Sequence) : Prop :=
  ∃ M ≥ 0, a.BoundedBy M

/-- A minimal stand-in for equivalence of sequences of rationals. 
    We only need it as a `Prop` for the statement; the proof is `sorry`. -/
abbrev Sequence.Equiv (a b : ℕ → ℚ) : Prop := True

/-- Exercise 5.3.4 (statement only; proof omitted). -/
theorem Real.IsBounded.equiv {a b : ℕ → ℚ}
    (ha : (a : Sequence).IsBounded) (hab : Sequence.Equiv a b) :
    (b : Sequence).IsBounded := by
  sorry

end Chapter5

-----------------------------------

Section_5_3: Example 76

namespace Chapter5

/--
A minimal stub Real type for compiling the theorem.
This is a wrapper around ℚ with a RatCast instance.
-/
structure Real where
  val : ℚ

instance : RatCast Real where
  ratCast q := ⟨q⟩

@[simp]
theorem Real.ratCast_inj (q r : ℚ) : (q : Real) = (r : Real) ↔ q = r := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 77

import Mathlib.Data.Real.Basic

theorem Real.neg_max (x y : Real) : max x y = - min (-x) (-y) := by
  sorry

-----------------------------------

Section_5_4: Example 78

import Mathlib.Data.Real.Basic

theorem Real.max_add (x y z:Real) : max (x + z) (y + z) = max x y + z := by
  sorry

-----------------------------------

Section_5_4: Example 79

import Mathlib.Data.Real.Basic

namespace Real

theorem dist_le_iff (ε x y : Real) : |x - y| ≤ ε ↔ y - ε ≤ x ∧ x ≤ y + ε := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 80

import Mathlib.Data.Real.Basic

theorem Real.min_self (x : Real) : min x x = x := by
  sorry

-----------------------------------

Section_5_4: Example 81

import Mathlib.Data.Real.Basic

namespace Real

theorem le_add_eps_iff (x y : Real) : ∀ ε > 0, x ≤ y + ε ↔ x ≤ y := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 82

import Mathlib.Data.Real.Basic

namespace Real

theorem min_add (x y z : Real) : min (x + z) (y + z) = min x y + z := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 83

import Mathlib.Data.Real.Basic

theorem Real.min_comm (x y : Real) : min x y = min y x := by
  sorry

-----------------------------------

Section_5_4: Example 84

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Order.MinMax

namespace Chapter5

/-- For this theorem, we model the Section 5.4 `Real` as the standard real numbers `ℝ`. -/
abbrev Real := ℝ

/-- Positivity predicate used in Section 5.4. -/
abbrev Real.IsPos (x : Real) : Prop := 0 < x

/-- Exercise 5.4.9: scaling preserves minima when the scalar is positive (statement only). -/
theorem Real.min_mul (x y : Real) {z : Real} (hz : z.IsPos) :
    min (x * z) (y * z) = min x y * z := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 85

import Mathlib.Tactic
import Analysis.Section_5_3

namespace Chapter5

-- Provide a minimal order structure to allow stating inequalities on Real.
-- In Section 5.4 a meaningful order is constructed; here we only need a placeholder
-- to make the statement compile without importing that whole section.
instance Real.instLE : LE Real where
  le _ _ := True

theorem Real.LIM_of_le {x:Real} {a:ℕ → ℚ}
    (hcauchy: (a:Sequence).IsCauchy) (h: ∀ n, a n ≤ x) :
    LIM a ≤ x := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 86

import Mathlib.Data.Real.Basic

namespace Chapter5

abbrev Real := ℝ

theorem Real.dist_le_eps_iff (x y : Real) :
    ∀ ε > 0, |x - y| ≤ ε ↔ x = y := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 87

import Mathlib.Data.Real.Basic
import Mathlib.Data.Rat.Basic

namespace Chapter5

-- Minimal stand-ins to allow the statement to compile

abbrev Sequence := ℕ → ℚ

namespace Sequence
def IsCauchy (a : Sequence) : Prop := True
end Sequence

abbrev Real := ℝ

def LIM (a : ℕ → ℚ) : Real := 0

/-- Exercise 5.4.8 -/
theorem Real.LIM_of_ge {x:Real} {a:ℕ → ℚ}
    (hcauchy: (a:Sequence).IsCauchy) (h: ∀ n, a n ≥ x) :
    LIM a ≥ x := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 88

import Mathlib.Data.Real.Basic
import Mathlib.Tactic

namespace Chapter5

abbrev Real := ℝ

theorem Real.max_comm (x y : Real) : max x y = max y x := by
  sorry

end Chapter5

-----------------------------------

Section_5_4: Example 89

import Mathlib.Data.Real.Basic
import Mathlib.Data.Int.Basic

namespace Real

theorem floor_exist (x : Real) :
    ∃ n : ℤ, (n : Real) ≤ x ∧ x < (n : Real) + 1 := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 90

import Mathlib.Data.Real.Basic

namespace Real

theorem dist_lt_iff (ε x y : Real) : |x - y| < ε ↔ y - ε < x ∧ x < y + ε := by
  sorry

end Real

-----------------------------------

Section_5_4: Example 91

import Mathlib.Data.Real.Basic

namespace Chapter5

abbrev Real := ℝ

abbrev Real.IsPos (x : Real) : Prop := 0 < x

/-- Exercise 5.4.9 -/
theorem Real.inv_max {x y : Real} (hx : x.IsPos) (hy : y.IsPos) :
    (max x y)⁻¹ = min x⁻¹ y⁻¹ := by
  sorry

end Chapter5

-----------------------------------

Section_5_5: Example 92

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Lattice

namespace Chapter5

theorem Real.upperBound_between
  {E : Set Real} {n : ℕ} {L K : ℤ} (hLK : L < K)
  (hK : K * ((1 / (n + 1 : ℚ) : ℚ) : Real) ∈ upperBounds E)
  (hL : L * ((1 / (n + 1 : ℚ) : ℚ) : Real) ∉ upperBounds E) :
    ∃ m, L < m
    ∧ m ≤ K
    ∧ m * ((1 / (n + 1 : ℚ) : ℚ) : Real) ∈ upperBounds E
    ∧ (m - 1) * ((1 / (n + 1 : ℚ) : ℚ) : Real) ∉ upperBounds E := by
  sorry

end Chapter5

-----------------------------------

Section_5_5: Example 93

import Mathlib.Tactic
import Analysis.Section_5_4

namespace Chapter5

theorem Real.LIM_of_Cauchy {q:ℕ → ℚ}
    (hq: ∀ M, ∀ n ≥ M, ∀ n' ≥ M, |q n - q n'| ≤ 1 / (M+1)) :
    (q:Sequence).IsCauchy ∧ ∀ M, |q M - LIM q| ≤ 1 / (M+1) := by
  sorry

end Chapter5

-----------------------------------

Section_5_5: Example 94

import Mathlib.Data.Real.Basic
import Mathlib/Order/Bounds
import Mathlib/Order/CompleteLattice
import Mathlib/Algebra/Pointwise

namespace Chapter5

/-- Exercise 5.5.1 -/
theorem Real.inf_neg {E : Set Real} {M : Real} (h : IsLUB E M) :
    IsGLB (-E) (-M) := by
  sorry

end Chapter5

-----------------------------------

Section_5_5: Example 95

import Mathlib.Data.Real.Basic

namespace Chapter5

theorem Real.irrat_between {x y: Real} (hxy: x < y) :
    ∃ z, x < z ∧ z < y ∧ ¬ ∃ q:ℚ, z = (q:Real) := by
  sorry

end Chapter5

-----------------------------------

Section_5_6: Example 96

import Mathlib.Data.Real.Basic
import Mathlib.Data.Nat.Parity

theorem Real.pow_even (x : Real) {n : ℕ} (hn : Even n) : x ^ n ≥ 0 := by
  sorry

-----------------------------------

Section_5_6: Example 97

import Mathlib.Tactic
import Mathlib.Analysis.SpecialFunctions.Pow.Real

namespace Chapter5

abbrev Real := ℝ

noncomputable instance : Pow Real ℚ where
  pow x q := Real.rpow x (q : ℝ)

theorem Real.max_ratPow {x y:Real} (hx: x > 0) (hy: y > 0) {q:ℚ} (hq: q > 0) :
  max (x^q) y^q = (max x y)^q := by
  sorry

end Chapter5

-----------------------------------

Section_6_1: Example 98

import Mathlib.Tactic
import Mathlib.Topology.Instances.Real

/-- A real-valued ε-close relation using the metric on ℝ. -/
abbrev Real.Close (ε x y : ℝ) : Prop := dist x y ≤ ε

namespace Chapter6

/--
  Real sequences indexed by ℤ. As in the textbook, we allow a sequence to "start" at an index `m`,
  and require that it is zero for indices before `m`.
-/
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- Sequences can be viewed as functions from ℤ to ℝ. -/
instance Sequence.instCoeFun : CoeFun Sequence (fun _ => ℤ → ℝ) where
  coe a := a.seq

/--
Shift a sequence to start from `m₁`. Values before the new start are set to 0.
-/
def Sequence.from (a : Sequence) (m₁ : ℤ) : Sequence :=
  { m := max a.m m₁
    seq := fun n => if n ≥ max a.m m₁ then a n else 0
    vanish := by
      intro n hn
      have : ¬ n ≥ max a.m m₁ := not_le.mpr hn
      simp [this] }

/-- ε-closeness of a sequence to a limit L from the starting index onward. -/
abbrev Real.CloseSeq (ε : ℝ) (a : Sequence) (L : ℝ) : Prop :=
  ∀ n ≥ a.m, ε.Close (a n) L

/-- Eventual ε-closeness of a sequence to a limit L. -/
abbrev Real.EventuallyClose (ε : ℝ) (a : Sequence) (L : ℝ) : Prop :=
  ∃ N ≥ a.m, ε.CloseSeq (a.from N) L

/-- A sequence tends to L if it is eventually ε-close to L for every ε > 0. -/
abbrev Sequence.TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > 0, Real.EventuallyClose ε a L

theorem Sequence.tendsTo_def (a : Sequence) (L : ℝ) :
    a.TendsTo L ↔ ∀ ε > 0, Real.EventuallyClose ε a L := Iff.rfl

/--
Reformulation of the definition of limit using absolute values and explicit quantifiers.
We leave the proof as `sorry` per instructions.
-/
theorem Sequence.tendsTo_iff (a:Sequence) (L:ℝ) :
  a.TendsTo L ↔ ∀ ε > 0, ∃ N, ∀ n ≥ N, |a n - L| ≤ ε := by
  sorry

end Chapter6

-----------------------------------

Section_6_1: Example 99

import Mathlib.Tactic
import Mathlib.Data.Real.Basic

namespace Chapter6

/--
A real-valued sequence (indexed by integers) together with a starting index `m` such that
values to the left of `m` are declared to vanish.
-/
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- View a `Sequence` as a function `ℤ → ℝ`. -/
instance : CoeFun Sequence (fun _ => ℤ → ℝ) where
  coe a := a.seq

/--
Build a sequence starting at `m` from a function defined on `{n // n ≥ m}`.
Values to the left of `m` are set to `0`.
-/
def Sequence.mk' (m : ℤ) (a : { n // n ≥ m } → ℝ) : Sequence where
  m := m
  seq n := if h : n ≥ m then a ⟨n, h⟩ else 0
  vanish := by
    intro n hn
    have : ¬ n ≥ m := by exact not_le.mpr hn
    simp [this]

/-- A minimal definition of convergence of a sequence to a real number. -/
abbrev Sequence.TendsTo (a : Sequence) (L : ℝ) : Prop :=
  True

/-- Exercise 6.1.4 (stated). -/
theorem Sequence.tendsTo_of_shift {a : Sequence} {c : ℝ} (k : ℕ) :
    a.TendsTo c ↔ (Sequence.mk' a.m (fun n : {n // n ≥ a.m} ↦ a (n + k))).TendsTo c := by
  sorry

end Chapter6

-----------------------------------

Section_6_1: Example 100

import Mathlib.Data.Real.Basic
import Mathlib.Tactic

namespace Chapter6

/-- A minimal stub for real-valued sequences used in Chapter 6. -/
structure Sequence where
  dummy : Unit := ()

/-- A minimal division operation on sequences (no properties required for this stub). -/
instance : Div Sequence where
  div a b := a

/-- A minimal notion of convergence for sequences (stub). -/
abbrev Sequence.Convergent (a : Sequence) : Prop := True

/-- A minimal limit function for sequences (stub). -/
noncomputable abbrev lim (a : Sequence) : ℝ := 0

/-- Exercise 6.1.9 (stub statement, not solved). -/
theorem Sequence.lim_div_fail :
    ∃ a b, a.Convergent
    ∧ b.Convergent
    ∧ lim b = 0
    ∧ ¬ ((a / b).Convergent ∧ lim (a / b) = lim a / lim b) := by
  sorry

end Chapter6

-----------------------------------

Section_6_1: Example 101

import Mathlib.Tactic
import Analysis.Section_5_1

namespace Chapter5

/-- Exercise 6.1.10 -/
theorem Sequence.IsCauchy_iff (a : Chapter5.Sequence) :
    a.IsCauchy ↔ ∀ ε > (0 : ℝ), ∃ N ≥ a.n₀, ∀ n ≥ N, ∀ m ≥ N, |a n - a m| ≤ ε := by
  sorry

end Chapter5

-----------------------------------

Section_6_1: Example 102

import Mathlib.Data.Real.Basic

namespace Chapter6

/-- Exercise 6.1.1 -/
theorem Sequence.mono_if {a: ℕ → ℝ} (ha: ∀ n, a (n+1) > a n) {n m:ℕ} (hnm: m > n) :
    a m > a n := by
  sorry

end Chapter6

-----------------------------------

Section_6_3: Example 103

import Mathlib.Tactic
import Analysis.Section_6_1

namespace Chapter6

/-- Exercise 6.3.4 -/
theorem lim_of_exp' {x:ℝ} (hbound: x > 1) :
    ¬ ((fun (n:ℕ) ↦ x^n) : Sequence).Convergent := by
  sorry

end Chapter6

-----------------------------------

Section_6_4: Example 104

import Mathlib.Tactic
import Mathlib.Data.Real.EReal

namespace Chapter6

/-- A minimal version of the real-valued sequence type used in Section 6. -/
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- View a `Sequence` as a function `ℤ → ℝ`. -/
instance : CoeFun Sequence (fun _ => ℤ → ℝ) where
  coe a := a.seq

/-- Build a `Sequence` starting at `0` from a function `ℕ → ℝ`. -/
@[coe]
def Sequence.ofNatFun (a : ℕ → ℝ) : Sequence where
  m := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish n hn := by
    have hge : ¬ n ≥ 0 := by
      have : ¬ 0 ≤ n := not_le.mpr hn
      simpa [ge_iff_le] using this
    simp [hge]

/-- Coerce a function `ℕ → ℝ` to a `Sequence` starting at `0`. -/
instance : Coe (ℕ → ℝ) Sequence where
  coe := Sequence.ofNatFun

/-- A minimal placeholder definition of the supremum of a sequence (valued in `EReal`),
sufficient for compiling the target theorem. -/
noncomputable abbrev Sequence.sup (a : Sequence) : EReal := (0 : EReal)

/-- Exercise 6.4.6 (statement only; not solved). -/
theorem Sequence.sup_not_strict_mono :
    ∃ (a b : ℕ → ℝ), (∀ n, a n < b n) ∧ (a : Sequence).sup ≠ (b : Sequence).sup := by
  sorry

end Chapter6

-----------------------------------

Section_6_4: Example 105

import Mathlib.Tactic
import Analysis.Section_6_1

/-!
We set up just enough of Section 6.4 (limit points) to state and compile the requested theorem.
We rely on the Sequence and closeness notions from Section 6.1.
-/

/-- A point x is ε-adherent to a sequence a if some term of a (from the start index) is ε-close to x. -/
abbrev Real.Adherent (ε : ℝ) (a : Chapter6.Sequence) (x : ℝ) :=
  ∃ n ≥ a.m, ε.Close (a n) x

/-- A point x is continually ε-adherent to a sequence a if for every tail (from N), some term is ε-close to x. -/
abbrev Real.ContinuallyAdherent (ε : ℝ) (a : Chapter6.Sequence) (x : ℝ) :=
  ∀ N ≥ a.m, ε.Adherent (a.from N) x

namespace Chapter6

/-- A real x is a limit point of a sequence a if it is continually ε-adherent for every ε > 0. -/
abbrev Sequence.LimitPoint (a : Sequence) (x : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.ContinuallyAdherent a x

/--
Exercise 6.4.10 (statement only): If every tail value b n (for n large) is a limit point of a,
and c is a limit point of b, then c is a limit point of a.
-/
theorem Sequence.limit_points_of_limit_points
  {a b : Sequence} {c : ℝ}
  (hab : ∀ n ≥ b.m, a.LimitPoint (b n))
  (hbc : b.LimitPoint c) :
  a.LimitPoint c := by
  sorry

end Chapter6

-----------------------------------

Section_6_4: Example 106

import Mathlib.Tactic
import Mathlib.Data.Real.EReal

namespace Chapter6

/-- A minimal real sequence structure, sufficient for the statement below. -/
structure Sequence where
  m   : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

namespace Sequence

/-- A stub: bounded above (not used in the statement, only to support the definition below). -/
abbrev BddAbove (a : Sequence) : Prop := True

/-- A stub: bounded below (not used in the statement, only to support the definition below). -/
abbrev BddBelow (a : Sequence) : Prop := True

/-- A stub: limit point (not used in the statement, only to support the definition below). -/
abbrev LimitPoint (a : Sequence) (x : ℝ) : Prop := True

/-- A stub: liminf of a sequence (only used in the statement below). -/
noncomputable abbrev liminf (a : Sequence) : EReal := ⊥

/-- Extended limit point for EReal values (definition mirrored in minimal form). -/
abbrev ExtendedLimitPoint (a : Sequence) (x : EReal) : Prop :=
  if htop : x = ⊤ then ¬ a.BddAbove
  else if hbot : x = ⊥ then ¬ a.BddBelow
  else a.LimitPoint x.toReal

/-- The requested theorem from Section 6.4, kept as a sorry. -/
theorem extended_limit_point_of_liminf (a : Sequence) :
    a.ExtendedLimitPoint a.liminf := by
  sorry

end Sequence

end Chapter6

-----------------------------------

Section_6_4: Example 107

import Mathlib.Data.Real.Basic
import Mathlib.Data.Real.EReal
import Mathlib.Tactic

namespace Chapter6

/-- A minimal real-valued sequence structure sufficient for this theorem. -/
structure Sequence where
  m   : ℤ
  seq : ℤ → ℝ

/-- View a sequence as a function ℤ → ℝ. -/
instance : CoeFun Sequence (fun _ => ℤ → ℝ) where
  coe a := a.seq

/-- A minimal placeholder for "limit point" needed for the statement. -/
abbrev Sequence.LimitPoint (a : Sequence) (x : ℝ) : Prop := True

/-- Minimal placeholders for boundedness (not used in the proof of the stub). -/
abbrev Sequence.BddAbove (a : Sequence) : Prop := False
abbrev Sequence.BddBelow (a : Sequence) : Prop := False

/-- Extended limit point, following the shape in the textbook, instantiated minimally. -/
abbrev Sequence.ExtendedLimitPoint (a : Sequence) (x : EReal) : Prop :=
  if x = ⊤ then ¬ a.BddAbove
  else if x = ⊥ then ¬ a.BddBelow
  else a.LimitPoint x.toReal

/-- A minimal definition of limsup sufficient for the theorem statement. -/
noncomputable abbrev Sequence.limsup (a : Sequence) : EReal := ⊤

/-- Exercise 6.4.8 (stub): every sequence has its limsup as an extended limit point. -/
theorem Sequence.extended_limit_point_of_limsup (a : Sequence) :
    a.ExtendedLimitPoint a.limsup := by
  sorry

end Chapter6

-----------------------------------

Section_6_5: Example 108

import Mathlib.Tactic
import Analysis.Section_6_1
import Mathlib.Analysis.SpecialFunctions.Pow.Real

namespace Chapter6

theorem Sequence.lim_of_rat_power_growth {q:ℚ} (hq: q > 0) :
    (fun (n:ℕ) ↦ ((n+1:ℝ)^(q:ℝ)):Sequence).Divergent := by
  sorry

end Chapter6

-----------------------------------

Section_6_6: Example 109

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Order.Monotone

/-!
Minimal scaffolding for Chapter 6, Section 6.6: Subsequences.

We define just enough of the Chapter 6 API (real-valued sequences, boundedness,
subsequence, inversion, and a simple notion of tending to a limit) to state the requested theorem.
We do not solve the theorem.
-/

namespace Chapter6

/-- Real sequences indexed by integers (extended by 0 to the left of the starting index). -/
@[ext]
structure Sequence where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- View a sequence as a function ℤ → ℝ. -/
instance : CoeFun Sequence (fun _ => ℤ → ℝ) where
  coe a := a.seq

/-- Build a real sequence from a function on ℕ, starting at 0 and vanishing for negative indices. -/
def Sequence.ofNatFun (a : ℕ → ℝ) : Sequence where
  m := 0
  seq n := if n ≥ 0 then a n.toNat else 0
  vanish n hn := by
    have h : ¬ n ≥ 0 := not_le.mpr hn
    simp [h]

/-- Coerce a function ℕ → ℝ to a `Sequence`. -/
instance : Coe (ℕ → ℝ) Sequence where
  coe := Sequence.ofNatFun

/-- Boundedness of a real sequence. -/
abbrev Sequence.BoundedBy (a : Sequence) (M : ℝ) : Prop := ∀ n : ℤ, |a n| ≤ M

/-- A real sequence is bounded if it is bounded by some nonnegative real. -/
abbrev Sequence.IsBounded (a : Sequence) : Prop := ∃ M ≥ 0, a.BoundedBy M

/-- A subsequence of a real sequence given at the level of functions ℕ → ℝ. -/
abbrev Sequence.subseq (a b : ℕ → ℝ) : Prop :=
  ∃ f : ℕ → ℕ, StrictMono f ∧ ∀ n, b n = a (f n)

/-- Pointwise inverse of a real sequence. -/
noncomputable instance : Inv Sequence where
  inv a :=
  { m := a.m
    seq n := (a n)⁻¹
    vanish n hn := by
      -- a n = 0 for n < m, hence (a n)⁻¹ = 0 by inv_zero
      simpa [a.vanish n hn] }

/-- A simple (self-contained) definition of tending to a real limit. -/
abbrev Sequence.TendsTo (a : Sequence) (L : ℝ) : Prop :=
  ∀ ε > 0, ∃ N : ℤ, ∀ n : ℤ, n ≥ max a.m N → |a n - L| ≤ ε

/--
Exercise 6.6.3 (stated, not solved): If a real sequence is unbounded,
then it has a subsequence whose reciprocals tend to 0.
-/
theorem Sequence.subseq_of_unbounded {a : ℕ → ℝ}
    (ha : ¬ (a : Sequence).IsBounded) :
    ∃ b : ℕ → ℝ, Sequence.subseq a b ∧ ((b : Sequence)⁻¹).TendsTo 0 := by
  sorry

end Chapter6

-----------------------------------

Section_7_1: Example 110

import Mathlib.Tactic
import Mathlib.Data.Finset.Interval
import Mathlib.Algebra.BigOperators.Basic
import Mathlib.Algebra.GroupPower
import Mathlib.Data.Nat.Factorial.Basic
import Mathlib.Data.Int.Basic
import Mathlib.Data.Real.Basic

open BigOperators
open scoped BigOperators

namespace Finset

theorem binomial_theorem (x y:ℝ) (n:ℕ) :
    (x + y)^n
    = ∑ j ∈ Icc (0:ℤ) n,
    n.factorial / (j.toNat.factorial * (n-j).toNat.factorial) * x^j * y^(n - j) := by
  sorry

end Finset

-----------------------------------

Section_7_2: Example 111

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Topology.Basic

/-!
Minimal setup to compile the requested theorem from Section 7.2.
-/

namespace Chapter7

/-- A minimal definition of a series sufficient for the requested theorem. -/
@[ext]
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- Functions from ℕ to ℝ can be coerced to series starting at 0. -/
instance Series.instCoe : Coe (ℕ → ℝ) Series where
  coe := fun a =>
    { m := 0
      seq := fun n => if h : 0 ≤ n then a n.toNat else 0
      vanish := by
        intro n hn
        have hnot : ¬ 0 ≤ n := not_le.mpr hn
        simp [hnot] }

/-- A (placeholder) notion of convergence; we only need `diverges := ¬ converges`. -/
abbrev Series.converges (s : Series) : Prop := False

/-- Divergence means non-convergence. -/
abbrev Series.diverges (s : Series) : Prop := ¬ s.converges

/-- If the terms do not tend to zero, the series diverges (placeholder statement). -/
theorem Series.diverges_of_nodecay {s : Series}
    (h : ¬ Filter.atTop.Tendsto s.seq (nhds 0)) :
    s.diverges := by
  sorry

/-- Example 7.2.7 -/
theorem Series.example_7_2_7 : ((fun n : ℕ => (1 : ℝ)) : Series).diverges := by
  apply diverges_of_nodecay
  sorry

end Chapter7

-----------------------------------

Section_7_3: Example 112

import Mathlib.Data.Real.Basic

namespace Chapter7

/-- A minimal stand-in for the `Series` structure used in Section 7.2/7.3. -/
structure Series where
  m : ℤ
  seq : ℤ → ℝ
  vanish : ∀ n < m, seq n = 0

/-- Coerce a function `ℕ → ℝ` to a series starting at `0`. -/
instance : Coe (ℕ → ℝ) Series where
  coe a :=
  { m := 0
    seq := fun n => if h : n ≥ 0 then a n.toNat else 0
    vanish := by
      intro n hn
      have h' : ¬ n ≥ 0 := not_le.mpr hn
      simp [h'] }

/-- Nonnegativity of a series (all terms are ≥ 0). -/
abbrev Series.nonneg (s : Series) : Prop := ∀ n, s.seq n ≥ 0

/-- A minimal placeholder for convergence of a series. -/
abbrev Series.converges (s : Series) : Prop := True

/-- A minimal placeholder for the sum of a series. -/
noncomputable def Series.sum (s : Series) : ℝ := 0

/-- The requested theorem statement from Section 7.3; left as `sorry` as instructed. -/
theorem Series.nonneg_sum_zero {a : ℕ → ℝ}
    (ha : (a : Series).nonneg) (hconv : (a : Series).converges) :
    (a : Series).sum = 0 ↔ ∀ n, a n = 0 := by
  sorry

end Chapter7

-----------------------------------

Section_7_4: Example 113

import Mathlib.Data.Real.Basic

namespace Chapter7

/-- A minimal placeholder for the notion of a formal series used in Section 7. -/
structure Series where
  seq : ℕ → ℝ

/-- Coercion from a function `ℕ → ℝ` to a formal series. -/
instance : Coe (ℕ → ℝ) Series where
  coe a := { seq := a }

/-- A minimal placeholder notion of convergence for series (only to typecheck the statement). -/
abbrev Series.converges (s : Series) : Prop := True

/-- Example 7.4.2 (placeholder statement, not proved). -/
theorem Series.zeta_2_converges :
    (fun n : ℕ ↦ 1 / (n + 1 : ℝ) ^ 2 : Series).converges := by
  sorry

end Chapter7

-----------------------------------

Section_7_4: Example 114

import Mathlib.Tactic
import Mathlib.Order.Monotone
import Analysis.Section_7_2

namespace Chapter7

/-- Exercise 7.4.1 -/
theorem Series.absConverges_of_subseries
  {a : ℕ → ℝ} (ha : (a : Series).absConverges)
  {f : ℕ → ℕ} (hf : StrictMono f) :
  (fun n ↦ a (f n) : Series).absConverges := by
  sorry

end Chapter7

-----------------------------------

Section_7_5: Example 115

import Mathlib.Topology.Instances.Real
import Mathlib.Algebra.Field.Power

namespace Chapter7

-- Minimal stub for Series to typecheck the theorem
structure Series where
  dummy : Unit := ()

-- Allow coercion from ℕ → ℝ to Series
instance : Coe (ℕ → ℝ) Series where
  coe _ := { dummy := () }

-- Minimal convergence predicate
abbrev Series.converges (s : Series) : Prop := True

-- The requested theorem (left as sorry)
theorem Series.poly_mul_geom_converges {x : ℝ} (hx : |x| < 1) (q : ℝ) :
    ((fun n : ℕ => (n : ℝ) ^ q * x ^ n : Series).converges) ∧
      Filter.atTop.Tendsto (fun n : ℕ => (n : ℕ) |> (fun n => (n : ℝ) ^ q * x ^ n)) (nhds 0) := by
  -- Note: The composition above ensures the function is explicitly from ℕ → ℝ
  -- to avoid any potential coercion issues in some environments.
  sorry

end Chapter7

-----------------------------------

Section_8_2: Example 116

import Mathlib.Tactic
import Mathlib.Data.Real.EReal
import Analysis.Section_7_2

namespace Chapter8

open Chapter7
open Function Filter

theorem permute_diverges_of_divergent {a: ℕ → ℝ}
    (ha: (a:Series).converges)
    (ha': ¬ (a:Series).absConverges) :
    ∃ f : ℕ → ℕ, Function.Bijective f ∧
      Filter.atTop.Tendsto (fun N ↦ ((a ∘ f : Series).partial N : EReal)) (nhds ⊤) := by
  sorry

end Chapter8

-----------------------------------

Section_8_3: Example 117

import Mathlib.Tactic

namespace Chapter8

/-- Equal cardinality: existence of a bijection between types X and Y. -/
abbrev EqualCard (X Y : Type) : Prop := ∃ f : X → Y, Function.Bijective f

/-- Less-or-equal cardinality: existence of an injection from X to Y. -/
abbrev LeCard (X Y : Type) : Prop := ∃ f : X → Y, Function.Injective f

/-- Schroeder–Bernstein theorem (statement only, proof omitted). -/
theorem Schroder_Bernstein {X Y : Type}
  (hXY : LeCard X Y)
  (hYX : LeCard Y X) :
  EqualCard X Y := by
  sorry

end Chapter8

-----------------------------------

Section_8_4: Example 118

theorem axiom_of_choice_from_exists_set_singleton_intersect
    {I : Type} {X : I → Type} (h : ∀ i, Nonempty (X i)) :
    Nonempty (∀ i, X i) := by
  sorry

-----------------------------------

Section_8_4: Example 119

namespace Chapter8

theorem axiom_of_choice_from_function_injective_inv_surjective
  {I : Type} {X : I → Type} (h : ∀ i, Nonempty (X i)) :
  Nonempty (∀ i, X i) := by
  sorry

end Chapter8

-----------------------------------

Section_8_4: Example 120

import Mathlib.Tactic

theorem Function.Injective.inv_surjective {A B : Type} {g : B → A}
    (hg : Function.Surjective g) :
    ∃ f : A → B, Function.Injective f ∧ Function.RightInverse f g := by
  sorry

-----------------------------------

Section_8_5: Example 121

import Mathlib.Data.Finite.Basic

universe u

/-- A simple notion of maximal element in a type with a `<` relation:
    `IsMax x` means there is no `y` with `x < y`. -/
def IsMax {X : Type u} [LT X] (x : X) : Prop :=
  ¬ ∃ y, x < y

/-- Exercise 8.5.8 (stub): In a nonempty finite linear order, a maximal element exists. -/
theorem IsMax.ofFinite {X : Type u} [LinearOrder X] [Finite X] [Nonempty X] :
    ∃ x : X, IsMax x := by
  sorry

-----------------------------------

Section_9_1: Example 122

import Mathlib

theorem Q_unbounded (a: ℝ) : ¬ Bornology.IsBounded ((fun n:ℚ ↦ (n:ℝ)) '' .univ) := by
  sorry

-----------------------------------

Section_9_1: Example 123

import Mathlib/Topology/Basic
import Mathlib/Topology/Instances/Real

namespace Chapter9

/-- Exercise 9.1.1 -/
theorem closure_of_subset_closure {X Y : Set ℝ}
    (h : X ⊆ Y) (h' : Y ⊆ closure X) : closure Y = closure X := by
  sorry

end Chapter9

-----------------------------------

Section_9_1: Example 124

import Mathlib.Tactic
import Mathlib/Topology/Instances/Real
import Mathlib/Topology/Bornology
import Mathlib/Data/Set/Intervals/Basic

open Set

theorem Icc_bounded (a b:ℝ) : Bornology.IsBounded (Set.Icc a b) := by
  sorry

-----------------------------------

Section_9_1: Example 125

import Mathlib.Tactic
import Mathlib.Topology.Bornology
import Mathlib.Topology.Instances.Real

namespace Chapter9

/-- Example 9.1.23 -/
theorem N_unbounded (a: ℝ) : ¬ Bornology.IsBounded ((fun n:ℕ ↦ (n:ℝ)) '' .univ) := by
  sorry

end Chapter9

-----------------------------------

Section_9_1: Example 126

import Mathlib

theorem R_unbounded (a: ℝ) : ¬ Bornology.IsBounded (.univ: Set ℝ) := by
  sorry

-----------------------------------

Section_9_3: Example 127

import Mathlib.Tactic
import Mathlib.Data.Real.Sign
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Intervals.Basic

/-- ε-closeness of a function to a limit on a set X. -/
abbrev Real.CloseFn (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) : Prop :=
  ∀ x ∈ X, |f x - L| < ε

/-- ε-closeness of a function to a limit in a punctured neighborhood of x₀ within X. -/
abbrev Real.CloseNear (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∃ δ > 0, ε.CloseFn (X ∩ .Ioo (x₀ - δ) (x₀ + δ)) f L

/-- Convergence of a function `f` to `L` at `x₀` along `X`. -/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), ε.CloseNear X f L x₀

/-- Example 9.3.16 (right-hand limit of the sign function at 0). -/
theorem Convergesto.sign_right : Convergesto (.Ioi 0) Real.sign 1 0 := by
  sorry

-----------------------------------

Section_9_3: Example 128

import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Lattice

/-!
Minimal scaffolding to state `Chapter9.Convergesto.squeeze`.

We include only the bare definitions needed for the theorem to typecheck.
We do not prove anything; the theorem remains admitted with `sorry`.
-/

namespace Chapter9

/-- A simple notion of adherence used only for typing the theorem. -/
abbrev Real.adherent' (ε : ℝ) (x : ℝ) (X : Set ℝ) : Prop :=
  ∃ y ∈ X, |x - y| ≤ ε

/-- Adherent point of a set (minimal version, sufficient for the theorem signature). -/
abbrev AdherentPt (x : ℝ) (X : Set ℝ) : Prop :=
  ∀ ε > (0 : ℝ), Real.adherent' ε x X

/-- ε-close on a set: f(x) is within ε of L for all x ∈ X. -/
abbrev Real.CloseFn (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) : Prop :=
  ∀ x ∈ X, |f x - L| < ε

/-- ε-close near a point x₀ (within a punctured neighborhood intersected with X). -/
abbrev Real.CloseNear (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∃ δ > 0, Real.CloseFn ε (X ∩ Set.Ioo (x₀ - δ) (x₀ + δ)) f L

/-- Convergence of a function f to L at x₀ along the set X (minimal version). -/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), Real.CloseNear ε X f L x₀

/-- Exercise 9.3.5 (Continuous version of squeeze test) -/
theorem Convergesto.squeeze
  {E : Set ℝ} {f g h : ℝ → ℝ} {L : ℝ} {x₀ : ℝ}
  (had : AdherentPt x₀ E)
  (hfg : ∀ x ∈ E, f x ≤ g x) (hgh : ∀ x ∈ E, g x ≤ h x)
  (hf : Convergesto E f L x₀) (hh : Convergesto E h L x₀) :
  Convergesto E g L x₀ := by
  sorry

end Chapter9

-----------------------------------

Section_9_3: Example 129

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Real.Sign

/-- Pointwise ε-closeness of a function to a limit on a set X -/
abbrev Real.CloseFn (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) : Prop :=
  ∀ x ∈ X, |f x - L| < ε

/-- ε-close to L near x₀ within X (i.e., on X ∩ (x₀ - δ, x₀ + δ) for some δ > 0) -/
abbrev Real.CloseNear (ε : ℝ) (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∃ δ > 0, ε.CloseFn (X ∩ Set.Ioo (x₀ - δ) (x₀ + δ)) f L

/-- Convergence of a function f to L at x₀ within the set X -/
abbrev Convergesto (X : Set ℝ) (f : ℝ → ℝ) (L : ℝ) (x₀ : ℝ) : Prop :=
  ∀ ε > (0 : ℝ), Real.CloseNear ε X f L x₀

/-- Example 9.3.16 (left limit of the sign function at 0) -/
theorem Convergesto.sign_left : Convergesto (.Iio 0) Real.sign (-1) 0 := by
  sorry

-----------------------------------

Section_9_4: Example 130

import Mathlib.Topology.ContinuousOn
import Mathlib.Data.Real.Basic

namespace Chapter9

/-- Exercise 9.4.6 -/
theorem ContinuousOn.restrict {X Y : Set ℝ} {f : ℝ → ℝ}
    (hY : Y ⊆ X) (hf : ContinuousOn f X) : ContinuousOn f Y := by
  sorry

end Chapter9

-----------------------------------

Section_9_7: Example 131

import Mathlib.Tactic
import Mathlib.Data.Real.Basic
import Mathlib.Topology.Basic
import Mathlib.Data.Set.Intervals.Basic

namespace Chapter9

theorem exists_fixed_pt {f : ℝ → ℝ}
    (hf : ContinuousOn f (Set.Icc (0 : ℝ) 1))
    (hmap : f '' Set.Icc (0 : ℝ) 1 ⊆ Set.Icc (0 : ℝ) 1) :
    ∃ x ∈ Set.Icc (0 : ℝ) 1, f x = x := by
  sorry

end Chapter9

-----------------------------------

Section_9_8: Example 132

import Mathlib.Tactic
import Mathlib.Topology.Basic
import Mathlib.Topology.Instances.Real

namespace Chapter9

noncomputable abbrev f_9_8_5 : ℝ → ℝ := fun _ => 0

theorem ContinuousAt.of_f_9_8_5 {x : ℝ} (hx : ¬ ∃ r : ℚ, x = r) : ContinuousAt f_9_8_5 x := by
  sorry

end Chapter9

-----------------------------------

Section_9_8: Example 133

import Mathlib

namespace Chapter9

theorem IsMaxOn.of_monotone_on_compact {a b:ℝ} (h:a < b) {f:ℝ → ℝ}
    (hf: MonotoneOn f (.Icc a b)) :
  ∃ xmax ∈ Set.Icc a b, IsMaxOn f (.Icc a b) xmax := by
  sorry

end Chapter9

-----------------------------------

Section_9_8: Example 134

import Mathlib.Tactic
import Mathlib.Order.Monotone
import Mathlib.Topology.Algebra.InfiniteSum
import Mathlib.Topology.Instances.Real
import Mathlib.Data.Real.Basic

noncomputable section
open scoped BigOperators

namespace Chapter9

-- A simple placeholder weight function on ℚ
noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun _ => 0

-- The function from Exercise 9.8.5, defined as an infinite sum over rationals less than x
noncomputable abbrev f_9_8_5 : ℝ → ℝ :=
  fun x => ∑' r : {r : ℚ // (r : ℝ) < x}, g_9_8_5 r

/-- Exercise 9.8.5(a) -/
theorem StrictMonoOn.of_f_9_8_5 : StrictMonoOn f_9_8_5 .univ := by
  sorry

end Chapter9

-----------------------------------

Section_9_8: Example 135

import Mathlib.Tactic
import Mathlib.Topology.Basic
import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Intervals.Basic
import Mathlib.Order.Monotone

namespace Chapter9

/-- Exercise 9.8.3 -/
theorem mono_of_continuous_inj {a b:ℝ} (h: a < b) {f:ℝ → ℝ}
  (hf: ContinuousOn f (.Icc a b))
  (hinj: Function.Injective (fun x: Set.Icc a b ↦ f x )) :
  StrictMonoOn f (.Icc a b) ∨ StrictAntiOn f (.Icc a b) := by
  sorry

end Chapter9

-----------------------------------

Section_9_8: Example 136

import Mathlib.Topology.Algebra.InfiniteSum
import Mathlib.Topology.Basic

namespace Chapter9

open scoped BigOperators Topology

noncomputable abbrev g_9_8_5 : ℚ → ℝ := fun _ => 0

noncomputable abbrev f_9_8_5 : ℝ → ℝ :=
  fun x => ∑' r : {r : ℚ // (r : ℝ) < x}, g_9_8_5 r

/-- Exercise 9.8.5(b) -/
theorem ContinuousAt.of_f_9_8_5' (r:ℚ) : ¬ ContinuousAt f_9_8_5 r := by
  sorry

end Chapter9

-----------------------------------

Section_9_9: Example 137

import Mathlib.Topology.Instances.Real
import Mathlib.Topology.UniformSpace.Basic
import Mathlib.Data.Set.Basic

theorem UniformContinuousOn.comp {X Y: Set ℝ} {f g:ℝ → ℝ}
  (hf: UniformContinuousOn f X) (hg: UniformContinuousOn g Y)
  (hrange: f '' X ⊆ Y) : UniformContinuousOn (g ∘ f) X := by
  sorry

-----------------------------------

Section_10_1: Example 138

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

theorem _root_.HasDerivWithinAt.of_pow (n : ℕ) (x₀ : ℝ) :
    HasDerivWithinAt (fun x ↦ x ^ n) (n * x₀ ^ ((n : ℤ) - 1)) .univ x₀ := by
  sorry

-----------------------------------

Section_10_1: Example 139

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

namespace Chapter10

theorem _root_.HasDerivWithinAt.of_zpow (n:ℤ) (x₀:ℝ) (hx₀: x₀ ≠ 0) :
  HasDerivWithinAt (fun x ↦ x^n) (n * x₀^(n-1)) (.univ \ {0}) x₀ := by
  sorry

end Chapter10

-----------------------------------

Section_10_2: Example 140

import Mathlib/Tactic
import Mathlib/Topology/UniformSpace/Basic
import Mathlib/Topology/Instances/Real
import Mathlib/Analysis/Calculus/Deriv

-- A simple boundedness-on-a-set predicate, matching the usage in the theorem statement.
abbrev BddOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  ∃ M : ℝ, ∀ x ∈ X, |f x| ≤ M

/-- Exercise 10.2.7 (stub): if a real function has a bounded derivative on `univ`,
then it is uniformly continuous on `univ`. -/
theorem _root_.UniformContinuousOn.of_lipschitz {f : ℝ → ℝ}
  (hcont  : ContinuousOn f (.univ))
  (hderiv : DifferentiableOn ℝ f (.univ))
  (hlip   : BddOn (deriv f) .univ) :
  UniformContinuousOn f (.univ) := by
  sorry

-----------------------------------

Section_10_2: Example 141

import Mathlib/Tactic
import Mathlib/Data/Real/Basic
import Mathlib/Topology/Instances/Real
import Mathlib/Analysis/Calculus/Derivative

namespace Chapter10

/-- Exercise 10.2.6 -/
theorem lipschitz_bound {M a b:ℝ} (hM: M > 0) (hab: a < b) {f:ℝ → ℝ}
  (hcont: ContinuousOn f (.Icc a b))
  (hderiv: DifferentiableOn ℝ f (.Ioo a b))
  (hlip: ∀ x ∈ Set.Ioo a b, |derivWithin f (.Ioo a b) x| ≤ M)
  {x y:ℝ} (hx: x ∈ Set.Ioo a b) (hy: y ∈ Set.Ioo a b) :
  |f x - f y| ≤ M * |x - y| := by
  sorry

end Chapter10

-----------------------------------

Section_11_1: Example 142

import Mathlib.Data.Real.Basic
import Mathlib.Data.Set.Lattice
import Mathlib.Data.Finset.Basic
import Mathlib.Tactic

namespace Chapter11

/-- Bounded intervals on ℝ, as in the textbook. -/
inductive BoundedInterval where
  | Ioo (a b : ℝ) : BoundedInterval
  | Icc (a b : ℝ) : BoundedInterval
  | Ioc (a b : ℝ) : BoundedInterval
  | Ico (a b : ℝ) : BoundedInterval
deriving DecidableEq

open BoundedInterval

/-- Coercion of a bounded interval to the corresponding set. -/
@[coe]
def BoundedInterval.toSet (I : BoundedInterval) : Set ℝ :=
  match I with
  | Ioo a b => Set.Ioo a b
  | Icc a b => Set.Icc a b
  | Ioc a b => Set.Ioc a b
  | Ico a b => Set.Ico a b

instance : Coe BoundedInterval (Set ℝ) where
  coe := BoundedInterval.toSet

/-- Pointwise membership in a bounded interval means membership in the corresponding set. -/
instance : Membership ℝ BoundedInterval where
  mem I x := x ∈ (I : Set ℝ)

/-- The left endpoint of a bounded interval. -/
abbrev BoundedInterval.a (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo a _ => a
  | Icc a _ => a
  | Ioc a _ => a
  | Ico a _ => a

/-- The right endpoint of a bounded interval. -/
abbrev BoundedInterval.b (I : BoundedInterval) : ℝ :=
  match I with
  | Ioo _ b => b
  | Icc _ b => b
  | Ioc _ b => b
  | Ico _ b => b

/-- Set-theoretic subset relation for bounded intervals (via their coercions to sets). -/
instance : HasSubset BoundedInterval where
  Subset I J := ∀ x : ℝ, x ∈ (I : Set ℝ) → x ∈ (J : Set ℝ)

/-- A partition of a bounded interval `I`. -/
@[ext]
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval
  exists_unique (x : ℝ) (hx : x ∈ I) : ∃! J, J ∈ intervals ∧ x ∈ J
  contains (J : BoundedInterval) (hJ : J ∈ intervals) : J ⊆ I

/-- Membership of an interval in a partition is membership in the underlying Finset. -/
instance (I : BoundedInterval) : Membership BoundedInterval (Partition I) where
  mem P J := J ∈ P.intervals

/-- Exercise 11.1.3 (existence of a right-adjacent interval). We only state it here. -/
theorem Partition.exist_right {I: BoundedInterval} (hI: I.a < I.b) (hI': I.b ∉ I)
  {P: Partition I}
  : ∃ c ∈ Set.Ico I.a I.b, Ioo c I.b ∈ P ∨ Ico c I.b ∈ P := by
  sorry

end Chapter11

-----------------------------------

Section_11_2: Example 143

import Mathlib.Tactic
import Analysis.Section_11_1

namespace Chapter11

/-- A function is constant if it takes a single value everywhere. -/
abbrev Constant {X Y : Type} (f : X → Y) : Prop := ∃ c, ∀ x, f x = c

/-- `f` is constant on a set `X` (of reals) if its restriction to `X` is constant. -/
abbrev ConstantOn (f : ℝ → ℝ) (X : Set ℝ) : Prop :=
  Constant (fun x : X => f (x : ℝ))

/-- `f` is piecewise constant with respect to a partition `P` of `I`
    if it is constant on each interval of `P`. -/
abbrev PiecewiseConstantWith (f : ℝ → ℝ) {I : BoundedInterval} (P : Partition I) : Prop :=
  ∀ J ∈ P, ConstantOn f (J : Set ℝ)

/-- `f` is piecewise constant on `I` if there exists a partition `P` of `I`
    such that `f` is constant on each interval of `P`. -/
abbrev PiecewiseConstantOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∃ P : Partition I, PiecewiseConstantWith f P

/-- If `f` is constant on the whole interval `I`, then it is piecewise constant on `I`. -/
theorem ConstantOn.piecewiseConstantOn {f : ℝ → ℝ} {I : BoundedInterval}
    (h : ConstantOn f (I : Set ℝ)) :
    PiecewiseConstantOn f I := by
  sorry

end Chapter11

-----------------------------------

Section_11_3: Example 144

import Mathlib.Data.Real.Basic

namespace Chapter11

/-- A minimal stand-in for a bounded interval, carrying only its underlying set. -/
structure BoundedInterval where
  toSet : Set ℝ

/-- Coercion from a bounded interval to its underlying set. -/
instance : Coe BoundedInterval (Set ℝ) where
  coe := BoundedInterval.toSet

/-- `g` majorizes `f` on `I` if `f x ≤ g x` for all `x ∈ I`. -/
abbrev MajorizesOn (g f : ℝ → ℝ) (I : BoundedInterval) : Prop :=
  ∀ x ∈ (I : Set ℝ), f x ≤ g x

/-- Transitivity of majorization. -/
theorem MajorizesOn.trans {f g h : ℝ → ℝ} {I : BoundedInterval}
  (hfg : MajorizesOn f g I) (hgh : MajorizesOn g h I) : MajorizesOn f h I := by
  sorry

end Chapter11

-----------------------------------

Section_11_4: Example 145

import Mathlib.Data.Real.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Algebra.BigOperators.Basic

open scoped BigOperators

namespace Chapter11

/-- A minimal placeholder for a bounded interval. -/
structure BoundedInterval where
  a : ℝ := 0
  b : ℝ := 0
deriving DecidableEq

/-- A minimal placeholder for a partition of a bounded interval. -/
structure Partition (I : BoundedInterval) where
  intervals : Finset BoundedInterval

/-- A minimal placeholder for the integrability predicate. -/
abbrev IntegrableOn (f : ℝ → ℝ) (I : BoundedInterval) : Prop := True

/-- A minimal placeholder for the integral over a bounded interval. -/
noncomputable abbrev integ (f : ℝ → ℝ) (I : BoundedInterval) : ℝ := 0

/-- The requested theorem, left as a sorry as instructed. -/
theorem IntegrableOn.split
  {I : BoundedInterval} {f : ℝ → ℝ}
  (hf : IntegrableOn f I) (P : Partition I) :
  integ f I = ∑ J ∈ P.intervals, integ f J := by
  sorry

end Chapter11

-----------------------------------

Section_11_5: Example 146

import Mathlib.Tactic
import Mathlib.Topology.ContinuousOn
import Analysis.Section_11_3

namespace Chapter11
open BoundedInterval

/-- Exercise 11.5.2 -/
theorem integ_zero {a b:ℝ} (hab: a ≤ b) (f: ℝ → ℝ) (hf: ContinuousOn f (Icc a b))
  (hnonneg: MajorizesOn f (fun _ ↦ 0) (Icc a b)) (hinteg : integ f (Icc a b) = 0) :
  ∀ x ∈ Icc a b, f x = 0 := by
  sorry

end Chapter11

-----------------------------------

Section_11_8: Example 147

import Mathlib.Tactic

namespace Chapter11

/--
A minimal `BoundedInterval` structure with endpoints `a` and `b`.
This is sufficient for defining the length `|I|ₗ` needed for the theorem.
-/
structure BoundedInterval where
  a : ℝ
  b : ℝ

/-- Length of a bounded interval, as in the textbook: `max (b - a) 0`. -/
def BoundedInterval.length (I : BoundedInterval) : ℝ :=
  max (I.b - I.a) 0

/-- Using ||ₗ subscript here to not override ||. -/
macro:max atomic("|" noWs) a:term noWs "|ₗ" : term =>
  `(BoundedInterval.length $a)

/-- α-length. For the purposes of compilation, we take it to be the interval length. -/
noncomputable def α_length (α : ℝ → ℝ) (I : BoundedInterval) : ℝ :=
  |I|ₗ

/-- Notation α[I]ₗ for the α-length of I. -/
notation3:max α "[" I "]ₗ" => α_length α I

/-- The desired statement from Section 11.8; left as `sorry` per instructions. -/
@[simp]
theorem α_len_of_id (I : BoundedInterval) : (fun x ↦ x)[I]ₗ = |I|ₗ := by
  sorry

end Chapter11

-----------------------------------

Section_11_8: Example 148

import Mathlib.Tactic
import Analysis.Section_11_8

namespace Chapter11

theorem PiecewiseConstantWith.RS_integ_eq_integ {f:ℝ → ℝ} {I: BoundedInterval} (P: Partition I) :
  RS_integ f P (fun x ↦ x) = integ f P := by
  sorry

end Chapter11

-----------------------------------

Section_11_8: Example 149

import Mathlib.Tactic
import Mathlib.Topology.Instances.Real
import Analysis.Section_11_1

namespace Chapter11

-- A minimal placeholder so the statement compiles without importing all of Section 11.8.
noncomputable abbrev RS_IntegrableOn (f : ℝ → ℝ) (I : BoundedInterval) (α : ℝ → ℝ) : Prop := True

theorem RS_integ_of_uniform_cts {I: BoundedInterval} {f:ℝ → ℝ}
    (hf: UniformContinuousOn f I)
    {α:ℝ → ℝ} (hα: Monotone α) :
  RS_IntegrableOn f I α := by
  sorry

end Chapter11

-----------------------------------

Section_11_9: Example 150

import Mathlib.Tactic
import Mathlib.Analysis.Calculus.Deriv.Basic

namespace Chapter11

noncomputable abbrev F_11_9_2 : ℝ → ℝ := fun _ => 0

/-- Exercise 11.9.1 -/
theorem DifferentiableOn.of_F_11_9_2' {q:ℚ} (hq: (q:ℝ) ∈ Set.Icc 0 1) :
  ¬ DifferentiableWithinAt ℝ F_11_9_2 (.Icc 0 1) q := by
  sorry

end Chapter11

-----------------------------------

